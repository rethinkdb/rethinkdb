// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rdb_protocol/ql2.proto

#ifndef PROTOBUF_rdb_5fprotocol_2fql2_2eproto__INCLUDED
#define PROTOBUF_rdb_5fprotocol_2fql2_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

class VersionDummy;
class Query;
class Query_AssocPair;
class Frame;
class Backtrace;
class Response;
class Datum;
class Datum_AssocPair;
class Term;
class Term_AssocPair;

enum VersionDummy_Version {
  VersionDummy_Version_V0_1 = 1063369270,
  VersionDummy_Version_V0_2 = 1915781601,
  VersionDummy_Version_V0_3 = 1601562686,
  VersionDummy_Version_V0_4 = 1074539808
};
bool VersionDummy_Version_IsValid(int value);
const VersionDummy_Version VersionDummy_Version_Version_MIN = VersionDummy_Version_V0_1;
const VersionDummy_Version VersionDummy_Version_Version_MAX = VersionDummy_Version_V0_2;
const int VersionDummy_Version_Version_ARRAYSIZE = VersionDummy_Version_Version_MAX + 1;

const ::google::protobuf::EnumDescriptor* VersionDummy_Version_descriptor();
inline const ::std::string& VersionDummy_Version_Name(VersionDummy_Version value) {
  return ::google::protobuf::internal::NameOfEnum(
    VersionDummy_Version_descriptor(), value);
}
inline bool VersionDummy_Version_Parse(
    const ::std::string& name, VersionDummy_Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VersionDummy_Version>(
    VersionDummy_Version_descriptor(), name, value);
}
enum VersionDummy_Protocol {
  VersionDummy_Protocol_PROTOBUF = 656407617,
  VersionDummy_Protocol_JSON = 2120839367
};
bool VersionDummy_Protocol_IsValid(int value);
const VersionDummy_Protocol VersionDummy_Protocol_Protocol_MIN = VersionDummy_Protocol_PROTOBUF;
const VersionDummy_Protocol VersionDummy_Protocol_Protocol_MAX = VersionDummy_Protocol_JSON;
const int VersionDummy_Protocol_Protocol_ARRAYSIZE = VersionDummy_Protocol_Protocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* VersionDummy_Protocol_descriptor();
inline const ::std::string& VersionDummy_Protocol_Name(VersionDummy_Protocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    VersionDummy_Protocol_descriptor(), value);
}
inline bool VersionDummy_Protocol_Parse(
    const ::std::string& name, VersionDummy_Protocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VersionDummy_Protocol>(
    VersionDummy_Protocol_descriptor(), name, value);
}
enum Query_QueryType {
  Query_QueryType_START = 1,
  Query_QueryType_CONTINUE = 2,
  Query_QueryType_STOP = 3,
  Query_QueryType_NOREPLY_WAIT = 4,
  Query_QueryType_SERVER_INFO = 5
};
bool Query_QueryType_IsValid(int value);
const Query_QueryType Query_QueryType_QueryType_MIN = Query_QueryType_START;
const Query_QueryType Query_QueryType_QueryType_MAX = Query_QueryType_SERVER_INFO;
const int Query_QueryType_QueryType_ARRAYSIZE = Query_QueryType_QueryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Query_QueryType_descriptor();
inline const ::std::string& Query_QueryType_Name(Query_QueryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Query_QueryType_descriptor(), value);
}
inline bool Query_QueryType_Parse(
    const ::std::string& name, Query_QueryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Query_QueryType>(
    Query_QueryType_descriptor(), name, value);
}
enum Frame_FrameType {
  Frame_FrameType_POS = 1,
  Frame_FrameType_OPT = 2
};
bool Frame_FrameType_IsValid(int value);
const Frame_FrameType Frame_FrameType_FrameType_MIN = Frame_FrameType_POS;
const Frame_FrameType Frame_FrameType_FrameType_MAX = Frame_FrameType_OPT;
const int Frame_FrameType_FrameType_ARRAYSIZE = Frame_FrameType_FrameType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Frame_FrameType_descriptor();
inline const ::std::string& Frame_FrameType_Name(Frame_FrameType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Frame_FrameType_descriptor(), value);
}
inline bool Frame_FrameType_Parse(
    const ::std::string& name, Frame_FrameType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Frame_FrameType>(
    Frame_FrameType_descriptor(), name, value);
}
enum Response_ResponseType {
  Response_ResponseType_SUCCESS_ATOM = 1,
  Response_ResponseType_SUCCESS_SEQUENCE = 2,
  Response_ResponseType_SUCCESS_PARTIAL = 3,
  Response_ResponseType_WAIT_COMPLETE = 4,
  Response_ResponseType_SERVER_INFO = 5,
  Response_ResponseType_CLIENT_ERROR = 16,
  Response_ResponseType_COMPILE_ERROR = 17,
  Response_ResponseType_RUNTIME_ERROR = 18
};
bool Response_ResponseType_IsValid(int value);
const Response_ResponseType Response_ResponseType_ResponseType_MIN = Response_ResponseType_SUCCESS_ATOM;
const Response_ResponseType Response_ResponseType_ResponseType_MAX = Response_ResponseType_RUNTIME_ERROR;
const int Response_ResponseType_ResponseType_ARRAYSIZE = Response_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_ResponseType_descriptor();
inline const ::std::string& Response_ResponseType_Name(Response_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_ResponseType_descriptor(), value);
}
inline bool Response_ResponseType_Parse(
    const ::std::string& name, Response_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_ResponseType>(
    Response_ResponseType_descriptor(), name, value);
}
enum Response_ErrorType {
  Response_ErrorType_INTERNAL = 1000000,
  Response_ErrorType_RESOURCE_LIMIT = 2000000,
  Response_ErrorType_QUERY_LOGIC = 3000000,
  Response_ErrorType_NON_EXISTENCE = 3100000,
  Response_ErrorType_OP_FAILED = 4100000,
  Response_ErrorType_OP_INDETERMINATE = 4200000,
  Response_ErrorType_USER = 5000000
};
bool Response_ErrorType_IsValid(int value);
const Response_ErrorType Response_ErrorType_ErrorType_MIN = Response_ErrorType_INTERNAL;
const Response_ErrorType Response_ErrorType_ErrorType_MAX = Response_ErrorType_USER;
const int Response_ErrorType_ErrorType_ARRAYSIZE = Response_ErrorType_ErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_ErrorType_descriptor();
inline const ::std::string& Response_ErrorType_Name(Response_ErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_ErrorType_descriptor(), value);
}
inline bool Response_ErrorType_Parse(
    const ::std::string& name, Response_ErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_ErrorType>(
    Response_ErrorType_descriptor(), name, value);
}
enum Response_ResponseNote {
  Response_ResponseNote_SEQUENCE_FEED = 1,
  Response_ResponseNote_ATOM_FEED = 2,
  Response_ResponseNote_ORDER_BY_LIMIT_FEED = 3,
  Response_ResponseNote_UNIONED_FEED = 4,
  Response_ResponseNote_INCLUDES_STATES = 5
};
bool Response_ResponseNote_IsValid(int value);
const Response_ResponseNote Response_ResponseNote_ResponseNote_MIN = Response_ResponseNote_SEQUENCE_FEED;
const Response_ResponseNote Response_ResponseNote_ResponseNote_MAX = Response_ResponseNote_INCLUDES_STATES;
const int Response_ResponseNote_ResponseNote_ARRAYSIZE = Response_ResponseNote_ResponseNote_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_ResponseNote_descriptor();
inline const ::std::string& Response_ResponseNote_Name(Response_ResponseNote value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_ResponseNote_descriptor(), value);
}
inline bool Response_ResponseNote_Parse(
    const ::std::string& name, Response_ResponseNote* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_ResponseNote>(
    Response_ResponseNote_descriptor(), name, value);
}
enum Datum_DatumType {
  Datum_DatumType_R_NULL = 1,
  Datum_DatumType_R_BOOL = 2,
  Datum_DatumType_R_NUM = 3,
  Datum_DatumType_R_STR = 4,
  Datum_DatumType_R_ARRAY = 5,
  Datum_DatumType_R_OBJECT = 6,
  Datum_DatumType_R_JSON = 7
};
bool Datum_DatumType_IsValid(int value);
const Datum_DatumType Datum_DatumType_DatumType_MIN = Datum_DatumType_R_NULL;
const Datum_DatumType Datum_DatumType_DatumType_MAX = Datum_DatumType_R_JSON;
const int Datum_DatumType_DatumType_ARRAYSIZE = Datum_DatumType_DatumType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Datum_DatumType_descriptor();
inline const ::std::string& Datum_DatumType_Name(Datum_DatumType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Datum_DatumType_descriptor(), value);
}
inline bool Datum_DatumType_Parse(
    const ::std::string& name, Datum_DatumType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Datum_DatumType>(
    Datum_DatumType_descriptor(), name, value);
}
enum Term_TermType {
  Term_TermType_DATUM = 1,
  Term_TermType_MAKE_ARRAY = 2,
  Term_TermType_MAKE_OBJ = 3,
  Term_TermType_VAR = 10,
  Term_TermType_JAVASCRIPT = 11,
  Term_TermType_UUID = 169,
  Term_TermType_HTTP = 153,
  Term_TermType_ERROR = 12,
  Term_TermType_IMPLICIT_VAR = 13,
  Term_TermType_DB = 14,
  Term_TermType_TABLE = 15,
  Term_TermType_GET = 16,
  Term_TermType_GET_ALL = 78,
  Term_TermType_EQ = 17,
  Term_TermType_NE = 18,
  Term_TermType_LT = 19,
  Term_TermType_LE = 20,
  Term_TermType_GT = 21,
  Term_TermType_GE = 22,
  Term_TermType_NOT = 23,
  Term_TermType_ADD = 24,
  Term_TermType_SUB = 25,
  Term_TermType_MUL = 26,
  Term_TermType_DIV = 27,
  Term_TermType_MOD = 28,
  Term_TermType_FLOOR = 183,
  Term_TermType_CEIL = 184,
  Term_TermType_ROUND = 185,
  Term_TermType_APPEND = 29,
  Term_TermType_PREPEND = 80,
  Term_TermType_DIFFERENCE = 95,
  Term_TermType_SET_INSERT = 88,
  Term_TermType_SET_INTERSECTION = 89,
  Term_TermType_SET_UNION = 90,
  Term_TermType_SET_DIFFERENCE = 91,
  Term_TermType_SLICE = 30,
  Term_TermType_SKIP = 70,
  Term_TermType_LIMIT = 71,
  Term_TermType_OFFSETS_OF = 87,
  Term_TermType_CONTAINS = 93,
  Term_TermType_GET_FIELD = 31,
  Term_TermType_KEYS = 94,
  Term_TermType_VALUES = 186,
  Term_TermType_OBJECT = 143,
  Term_TermType_HAS_FIELDS = 32,
  Term_TermType_WITH_FIELDS = 96,
  Term_TermType_PLUCK = 33,
  Term_TermType_WITHOUT = 34,
  Term_TermType_MERGE = 35,
  Term_TermType_BETWEEN_DEPRECATED = 36,
  Term_TermType_BETWEEN = 182,
  Term_TermType_REDUCE = 37,
  Term_TermType_MAP = 38,
  Term_TermType_FILTER = 39,
  Term_TermType_CONCAT_MAP = 40,
  Term_TermType_ORDER_BY = 41,
  Term_TermType_DISTINCT = 42,
  Term_TermType_COUNT = 43,
  Term_TermType_IS_EMPTY = 86,
  Term_TermType_UNION = 44,
  Term_TermType_NTH = 45,
  Term_TermType_BRACKET = 170,
  Term_TermType_INNER_JOIN = 48,
  Term_TermType_OUTER_JOIN = 49,
  Term_TermType_EQ_JOIN = 50,
  Term_TermType_ZIP = 72,
  Term_TermType_RANGE = 173,
  Term_TermType_INSERT_AT = 82,
  Term_TermType_DELETE_AT = 83,
  Term_TermType_CHANGE_AT = 84,
  Term_TermType_SPLICE_AT = 85,
  Term_TermType_COERCE_TO = 51,
  Term_TermType_TYPE_OF = 52,
  Term_TermType_UPDATE = 53,
  Term_TermType_DELETE = 54,
  Term_TermType_REPLACE = 55,
  Term_TermType_INSERT = 56,
  Term_TermType_DB_CREATE = 57,
  Term_TermType_DB_DROP = 58,
  Term_TermType_DB_LIST = 59,
  Term_TermType_TABLE_CREATE = 60,
  Term_TermType_TABLE_DROP = 61,
  Term_TermType_TABLE_LIST = 62,
  Term_TermType_CONFIG = 174,
  Term_TermType_STATUS = 175,
  Term_TermType_WAIT = 177,
  Term_TermType_RECONFIGURE = 176,
  Term_TermType_REBALANCE = 179,
  Term_TermType_SYNC = 138,
  Term_TermType_INDEX_CREATE = 75,
  Term_TermType_INDEX_DROP = 76,
  Term_TermType_INDEX_LIST = 77,
  Term_TermType_INDEX_STATUS = 139,
  Term_TermType_INDEX_WAIT = 140,
  Term_TermType_INDEX_RENAME = 156,
  Term_TermType_FUNCALL = 64,
  Term_TermType_BRANCH = 65,
  Term_TermType_OR = 66,
  Term_TermType_AND = 67,
  Term_TermType_FOR_EACH = 68,
  Term_TermType_FUNC = 69,
  Term_TermType_ASC = 73,
  Term_TermType_DESC = 74,
  Term_TermType_INFO = 79,
  Term_TermType_MATCH = 97,
  Term_TermType_UPCASE = 141,
  Term_TermType_DOWNCASE = 142,
  Term_TermType_SAMPLE = 81,
  Term_TermType_DEFAULT = 92,
  Term_TermType_JSON = 98,
  Term_TermType_TO_JSON_STRING = 172,
  Term_TermType_ISO8601 = 99,
  Term_TermType_TO_ISO8601 = 100,
  Term_TermType_EPOCH_TIME = 101,
  Term_TermType_TO_EPOCH_TIME = 102,
  Term_TermType_NOW = 103,
  Term_TermType_IN_TIMEZONE = 104,
  Term_TermType_DURING = 105,
  Term_TermType_DATE = 106,
  Term_TermType_TIME_OF_DAY = 126,
  Term_TermType_TIMEZONE = 127,
  Term_TermType_YEAR = 128,
  Term_TermType_MONTH = 129,
  Term_TermType_DAY = 130,
  Term_TermType_DAY_OF_WEEK = 131,
  Term_TermType_DAY_OF_YEAR = 132,
  Term_TermType_HOURS = 133,
  Term_TermType_MINUTES = 134,
  Term_TermType_SECONDS = 135,
  Term_TermType_TIME = 136,
  Term_TermType_MONDAY = 107,
  Term_TermType_TUESDAY = 108,
  Term_TermType_WEDNESDAY = 109,
  Term_TermType_THURSDAY = 110,
  Term_TermType_FRIDAY = 111,
  Term_TermType_SATURDAY = 112,
  Term_TermType_SUNDAY = 113,
  Term_TermType_JANUARY = 114,
  Term_TermType_FEBRUARY = 115,
  Term_TermType_MARCH = 116,
  Term_TermType_APRIL = 117,
  Term_TermType_MAY = 118,
  Term_TermType_JUNE = 119,
  Term_TermType_JULY = 120,
  Term_TermType_AUGUST = 121,
  Term_TermType_SEPTEMBER = 122,
  Term_TermType_OCTOBER = 123,
  Term_TermType_NOVEMBER = 124,
  Term_TermType_DECEMBER = 125,
  Term_TermType_LITERAL = 137,
  Term_TermType_GROUP = 144,
  Term_TermType_SUM = 145,
  Term_TermType_AVG = 146,
  Term_TermType_MIN = 147,
  Term_TermType_MAX = 148,
  Term_TermType_SPLIT = 149,
  Term_TermType_UNGROUP = 150,
  Term_TermType_RANDOM = 151,
  Term_TermType_CHANGES = 152,
  Term_TermType_ARGS = 154,
  Term_TermType_BINARY = 155,
  Term_TermType_GEOJSON = 157,
  Term_TermType_TO_GEOJSON = 158,
  Term_TermType_POINT = 159,
  Term_TermType_LINE = 160,
  Term_TermType_POLYGON = 161,
  Term_TermType_DISTANCE = 162,
  Term_TermType_INTERSECTS = 163,
  Term_TermType_INCLUDES = 164,
  Term_TermType_CIRCLE = 165,
  Term_TermType_GET_INTERSECTING = 166,
  Term_TermType_FILL = 167,
  Term_TermType_GET_NEAREST = 168,
  Term_TermType_POLYGON_SUB = 171,
  Term_TermType_MINVAL = 180,
  Term_TermType_MAXVAL = 181
};
bool Term_TermType_IsValid(int value);
const Term_TermType Term_TermType_TermType_MIN = Term_TermType_DATUM;
const Term_TermType Term_TermType_TermType_MAX = Term_TermType_VALUES;
const int Term_TermType_TermType_ARRAYSIZE = Term_TermType_TermType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Term_TermType_descriptor();
inline const ::std::string& Term_TermType_Name(Term_TermType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Term_TermType_descriptor(), value);
}
inline bool Term_TermType_Parse(
    const ::std::string& name, Term_TermType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Term_TermType>(
    Term_TermType_descriptor(), name, value);
}
// ===================================================================

class VersionDummy : public ::google::protobuf::Message {
 public:
  VersionDummy();
  virtual ~VersionDummy();

  VersionDummy(const VersionDummy& from);

  inline VersionDummy& operator=(const VersionDummy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionDummy& default_instance();

  void Swap(VersionDummy* other);

  // implements Message ----------------------------------------------

  VersionDummy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VersionDummy& from);
  void MergeFrom(const VersionDummy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VersionDummy_Version Version;
  static const Version V0_1 = VersionDummy_Version_V0_1;
  static const Version V0_2 = VersionDummy_Version_V0_2;
  static const Version V0_3 = VersionDummy_Version_V0_3;
  static const Version V0_4 = VersionDummy_Version_V0_4;
  static inline bool Version_IsValid(int value) {
    return VersionDummy_Version_IsValid(value);
  }
  static const Version Version_MIN =
    VersionDummy_Version_Version_MIN;
  static const Version Version_MAX =
    VersionDummy_Version_Version_MAX;
  static const int Version_ARRAYSIZE =
    VersionDummy_Version_Version_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Version_descriptor() {
    return VersionDummy_Version_descriptor();
  }
  static inline const ::std::string& Version_Name(Version value) {
    return VersionDummy_Version_Name(value);
  }
  static inline bool Version_Parse(const ::std::string& name,
      Version* value) {
    return VersionDummy_Version_Parse(name, value);
  }

  typedef VersionDummy_Protocol Protocol;
  static const Protocol PROTOBUF = VersionDummy_Protocol_PROTOBUF;
  static const Protocol JSON = VersionDummy_Protocol_JSON;
  static inline bool Protocol_IsValid(int value) {
    return VersionDummy_Protocol_IsValid(value);
  }
  static const Protocol Protocol_MIN =
    VersionDummy_Protocol_Protocol_MIN;
  static const Protocol Protocol_MAX =
    VersionDummy_Protocol_Protocol_MAX;
  static const int Protocol_ARRAYSIZE =
    VersionDummy_Protocol_Protocol_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Protocol_descriptor() {
    return VersionDummy_Protocol_descriptor();
  }
  static inline const ::std::string& Protocol_Name(Protocol value) {
    return VersionDummy_Protocol_Name(value);
  }
  static inline bool Protocol_Parse(const ::std::string& name,
      Protocol* value) {
    return VersionDummy_Protocol_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:VersionDummy)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static VersionDummy* default_instance_;
};
// -------------------------------------------------------------------

class Query_AssocPair : public ::google::protobuf::Message {
 public:
  Query_AssocPair();
  virtual ~Query_AssocPair();

  Query_AssocPair(const Query_AssocPair& from);

  inline Query_AssocPair& operator=(const Query_AssocPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Query_AssocPair& default_instance();

  void Swap(Query_AssocPair* other);

  // implements Message ----------------------------------------------

  Query_AssocPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Query_AssocPair& from);
  void MergeFrom(const Query_AssocPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional .Term val = 2;
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 2;
  inline const ::Term& val() const;
  inline ::Term* mutable_val();
  inline ::Term* release_val();
  inline void set_allocated_val(::Term* val);

  // @@protoc_insertion_point(class_scope:Query.AssocPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_val();
  inline void clear_has_val();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::Term* val_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Query_AssocPair* default_instance_;
};
// -------------------------------------------------------------------

class Query : public ::google::protobuf::Message {
 public:
  Query();
  virtual ~Query();

  Query(const Query& from);

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Query& default_instance();

  void Swap(Query* other);

  // implements Message ----------------------------------------------

  Query* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Query_AssocPair AssocPair;

  typedef Query_QueryType QueryType;
  static const QueryType START = Query_QueryType_START;
  static const QueryType CONTINUE = Query_QueryType_CONTINUE;
  static const QueryType STOP = Query_QueryType_STOP;
  static const QueryType NOREPLY_WAIT = Query_QueryType_NOREPLY_WAIT;
  static const QueryType SERVER_INFO = Query_QueryType_SERVER_INFO;
  static inline bool QueryType_IsValid(int value) {
    return Query_QueryType_IsValid(value);
  }
  static const QueryType QueryType_MIN =
    Query_QueryType_QueryType_MIN;
  static const QueryType QueryType_MAX =
    Query_QueryType_QueryType_MAX;
  static const int QueryType_ARRAYSIZE =
    Query_QueryType_QueryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  QueryType_descriptor() {
    return Query_QueryType_descriptor();
  }
  static inline const ::std::string& QueryType_Name(QueryType value) {
    return Query_QueryType_Name(value);
  }
  static inline bool QueryType_Parse(const ::std::string& name,
      QueryType* value) {
    return Query_QueryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Query.QueryType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Query_QueryType type() const;
  inline void set_type(::Query_QueryType value);

  // optional .Term query = 2;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 2;
  inline const ::Term& query() const;
  inline ::Term* mutable_query();
  inline ::Term* release_query();
  inline void set_allocated_query(::Term* query);

  // optional int64 token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline ::google::protobuf::int64 token() const;
  inline void set_token(::google::protobuf::int64 value);

  // optional bool OBSOLETE_noreply = 4 [default = false];
  inline bool has_obsolete_noreply() const;
  inline void clear_obsolete_noreply();
  static const int kOBSOLETENoreplyFieldNumber = 4;
  inline bool obsolete_noreply() const;
  inline void set_obsolete_noreply(bool value);

  // optional bool accepts_r_json = 5 [default = false];
  inline bool has_accepts_r_json() const;
  inline void clear_accepts_r_json();
  static const int kAcceptsRJsonFieldNumber = 5;
  inline bool accepts_r_json() const;
  inline void set_accepts_r_json(bool value);

  // repeated .Query.AssocPair global_optargs = 6;
  inline int global_optargs_size() const;
  inline void clear_global_optargs();
  static const int kGlobalOptargsFieldNumber = 6;
  inline const ::Query_AssocPair& global_optargs(int index) const;
  inline ::Query_AssocPair* mutable_global_optargs(int index);
  inline ::Query_AssocPair* add_global_optargs();
  inline const ::google::protobuf::RepeatedPtrField< ::Query_AssocPair >&
      global_optargs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Query_AssocPair >*
      mutable_global_optargs();

  // @@protoc_insertion_point(class_scope:Query)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_obsolete_noreply();
  inline void clear_has_obsolete_noreply();
  inline void set_has_accepts_r_json();
  inline void clear_has_accepts_r_json();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Term* query_;
  ::google::protobuf::int64 token_;
  int type_;
  bool obsolete_noreply_;
  bool accepts_r_json_;
  ::google::protobuf::RepeatedPtrField< ::Query_AssocPair > global_optargs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Query* default_instance_;
};
// -------------------------------------------------------------------

class Frame : public ::google::protobuf::Message {
 public:
  Frame();
  virtual ~Frame();

  Frame(const Frame& from);

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Frame& default_instance();

  void Swap(Frame* other);

  // implements Message ----------------------------------------------

  Frame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Frame_FrameType FrameType;
  static const FrameType POS = Frame_FrameType_POS;
  static const FrameType OPT = Frame_FrameType_OPT;
  static inline bool FrameType_IsValid(int value) {
    return Frame_FrameType_IsValid(value);
  }
  static const FrameType FrameType_MIN =
    Frame_FrameType_FrameType_MIN;
  static const FrameType FrameType_MAX =
    Frame_FrameType_FrameType_MAX;
  static const int FrameType_ARRAYSIZE =
    Frame_FrameType_FrameType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FrameType_descriptor() {
    return Frame_FrameType_descriptor();
  }
  static inline const ::std::string& FrameType_Name(FrameType value) {
    return Frame_FrameType_Name(value);
  }
  static inline bool FrameType_Parse(const ::std::string& name,
      FrameType* value) {
    return Frame_FrameType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Frame.FrameType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Frame_FrameType type() const;
  inline void set_type(::Frame_FrameType value);

  // optional int64 pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline ::google::protobuf::int64 pos() const;
  inline void set_pos(::google::protobuf::int64 value);

  // optional string opt = 3;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 3;
  inline const ::std::string& opt() const;
  inline void set_opt(const ::std::string& value);
  inline void set_opt(const char* value);
  inline void set_opt(const char* value, size_t size);
  inline ::std::string* mutable_opt();
  inline ::std::string* release_opt();
  inline void set_allocated_opt(::std::string* opt);

  // @@protoc_insertion_point(class_scope:Frame)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 pos_;
  ::std::string* opt_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Frame* default_instance_;
};
// -------------------------------------------------------------------

class Backtrace : public ::google::protobuf::Message {
 public:
  Backtrace();
  virtual ~Backtrace();

  Backtrace(const Backtrace& from);

  inline Backtrace& operator=(const Backtrace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Backtrace& default_instance();

  void Swap(Backtrace* other);

  // implements Message ----------------------------------------------

  Backtrace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Backtrace& from);
  void MergeFrom(const Backtrace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Frame frames = 1;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 1;
  inline const ::Frame& frames(int index) const;
  inline ::Frame* mutable_frames(int index);
  inline ::Frame* add_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::Frame >&
      frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Frame >*
      mutable_frames();

  // @@protoc_insertion_point(class_scope:Backtrace)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Frame > frames_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Backtrace* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_ResponseType ResponseType;
  static const ResponseType SUCCESS_ATOM = Response_ResponseType_SUCCESS_ATOM;
  static const ResponseType SUCCESS_SEQUENCE = Response_ResponseType_SUCCESS_SEQUENCE;
  static const ResponseType SUCCESS_PARTIAL = Response_ResponseType_SUCCESS_PARTIAL;
  static const ResponseType WAIT_COMPLETE = Response_ResponseType_WAIT_COMPLETE;
  static const ResponseType SERVER_INFO = Response_ResponseType_SERVER_INFO;
  static const ResponseType CLIENT_ERROR = Response_ResponseType_CLIENT_ERROR;
  static const ResponseType COMPILE_ERROR = Response_ResponseType_COMPILE_ERROR;
  static const ResponseType RUNTIME_ERROR = Response_ResponseType_RUNTIME_ERROR;
  static inline bool ResponseType_IsValid(int value) {
    return Response_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    Response_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    Response_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    Response_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return Response_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return Response_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return Response_ResponseType_Parse(name, value);
  }

  typedef Response_ErrorType ErrorType;
  static const ErrorType INTERNAL = Response_ErrorType_INTERNAL;
  static const ErrorType RESOURCE_LIMIT = Response_ErrorType_RESOURCE_LIMIT;
  static const ErrorType QUERY_LOGIC = Response_ErrorType_QUERY_LOGIC;
  static const ErrorType NON_EXISTENCE = Response_ErrorType_NON_EXISTENCE;
  static const ErrorType OP_FAILED = Response_ErrorType_OP_FAILED;
  static const ErrorType OP_INDETERMINATE = Response_ErrorType_OP_INDETERMINATE;
  static const ErrorType USER = Response_ErrorType_USER;
  static inline bool ErrorType_IsValid(int value) {
    return Response_ErrorType_IsValid(value);
  }
  static const ErrorType ErrorType_MIN =
    Response_ErrorType_ErrorType_MIN;
  static const ErrorType ErrorType_MAX =
    Response_ErrorType_ErrorType_MAX;
  static const int ErrorType_ARRAYSIZE =
    Response_ErrorType_ErrorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorType_descriptor() {
    return Response_ErrorType_descriptor();
  }
  static inline const ::std::string& ErrorType_Name(ErrorType value) {
    return Response_ErrorType_Name(value);
  }
  static inline bool ErrorType_Parse(const ::std::string& name,
      ErrorType* value) {
    return Response_ErrorType_Parse(name, value);
  }

  typedef Response_ResponseNote ResponseNote;
  static const ResponseNote SEQUENCE_FEED = Response_ResponseNote_SEQUENCE_FEED;
  static const ResponseNote ATOM_FEED = Response_ResponseNote_ATOM_FEED;
  static const ResponseNote ORDER_BY_LIMIT_FEED = Response_ResponseNote_ORDER_BY_LIMIT_FEED;
  static const ResponseNote UNIONED_FEED = Response_ResponseNote_UNIONED_FEED;
  static const ResponseNote INCLUDES_STATES = Response_ResponseNote_INCLUDES_STATES;
  static inline bool ResponseNote_IsValid(int value) {
    return Response_ResponseNote_IsValid(value);
  }
  static const ResponseNote ResponseNote_MIN =
    Response_ResponseNote_ResponseNote_MIN;
  static const ResponseNote ResponseNote_MAX =
    Response_ResponseNote_ResponseNote_MAX;
  static const int ResponseNote_ARRAYSIZE =
    Response_ResponseNote_ResponseNote_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseNote_descriptor() {
    return Response_ResponseNote_descriptor();
  }
  static inline const ::std::string& ResponseNote_Name(ResponseNote value) {
    return Response_ResponseNote_Name(value);
  }
  static inline bool ResponseNote_Parse(const ::std::string& name,
      ResponseNote* value) {
    return Response_ResponseNote_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Response.ResponseType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Response_ResponseType type() const;
  inline void set_type(::Response_ResponseType value);

  // optional .Response.ErrorType error_type = 7;
  inline bool has_error_type() const;
  inline void clear_error_type();
  static const int kErrorTypeFieldNumber = 7;
  inline ::Response_ErrorType error_type() const;
  inline void set_error_type(::Response_ErrorType value);

  // repeated .Response.ResponseNote notes = 6;
  inline int notes_size() const;
  inline void clear_notes();
  static const int kNotesFieldNumber = 6;
  inline ::Response_ResponseNote notes(int index) const;
  inline void set_notes(int index, ::Response_ResponseNote value);
  inline void add_notes(::Response_ResponseNote value);
  inline const ::google::protobuf::RepeatedField<int>& notes() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_notes();

  // optional int64 token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline ::google::protobuf::int64 token() const;
  inline void set_token(::google::protobuf::int64 value);

  // repeated .Datum response = 3;
  inline int response_size() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 3;
  inline const ::Datum& response(int index) const;
  inline ::Datum* mutable_response(int index);
  inline ::Datum* add_response();
  inline const ::google::protobuf::RepeatedPtrField< ::Datum >&
      response() const;
  inline ::google::protobuf::RepeatedPtrField< ::Datum >*
      mutable_response();

  // optional .Backtrace backtrace = 4;
  inline bool has_backtrace() const;
  inline void clear_backtrace();
  static const int kBacktraceFieldNumber = 4;
  inline const ::Backtrace& backtrace() const;
  inline ::Backtrace* mutable_backtrace();
  inline ::Backtrace* release_backtrace();
  inline void set_allocated_backtrace(::Backtrace* backtrace);

  // optional .Datum profile = 5;
  inline bool has_profile() const;
  inline void clear_profile();
  static const int kProfileFieldNumber = 5;
  inline const ::Datum& profile() const;
  inline ::Datum* mutable_profile();
  inline ::Datum* release_profile();
  inline void set_allocated_profile(::Datum* profile);

  // @@protoc_insertion_point(class_scope:Response)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_error_type();
  inline void clear_has_error_type();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_backtrace();
  inline void clear_has_backtrace();
  inline void set_has_profile();
  inline void clear_has_profile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  int error_type_;
  ::google::protobuf::RepeatedField<int> notes_;
  ::google::protobuf::int64 token_;
  ::google::protobuf::RepeatedPtrField< ::Datum > response_;
  ::Backtrace* backtrace_;
  ::Datum* profile_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Datum_AssocPair : public ::google::protobuf::Message {
 public:
  Datum_AssocPair();
  virtual ~Datum_AssocPair();

  Datum_AssocPair(const Datum_AssocPair& from);

  inline Datum_AssocPair& operator=(const Datum_AssocPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Datum_AssocPair& default_instance();

  void Swap(Datum_AssocPair* other);

  // implements Message ----------------------------------------------

  Datum_AssocPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Datum_AssocPair& from);
  void MergeFrom(const Datum_AssocPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional .Datum val = 2;
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 2;
  inline const ::Datum& val() const;
  inline ::Datum* mutable_val();
  inline ::Datum* release_val();
  inline void set_allocated_val(::Datum* val);

  // @@protoc_insertion_point(class_scope:Datum.AssocPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_val();
  inline void clear_has_val();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::Datum* val_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Datum_AssocPair* default_instance_;
};
// -------------------------------------------------------------------

class Datum : public ::google::protobuf::Message {
 public:
  Datum();
  virtual ~Datum();

  Datum(const Datum& from);

  inline Datum& operator=(const Datum& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Datum& default_instance();

  void Swap(Datum* other);

  // implements Message ----------------------------------------------

  Datum* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Datum& from);
  void MergeFrom(const Datum& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Datum_AssocPair AssocPair;

  typedef Datum_DatumType DatumType;
  static const DatumType R_NULL = Datum_DatumType_R_NULL;
  static const DatumType R_BOOL = Datum_DatumType_R_BOOL;
  static const DatumType R_NUM = Datum_DatumType_R_NUM;
  static const DatumType R_STR = Datum_DatumType_R_STR;
  static const DatumType R_ARRAY = Datum_DatumType_R_ARRAY;
  static const DatumType R_OBJECT = Datum_DatumType_R_OBJECT;
  static const DatumType R_JSON = Datum_DatumType_R_JSON;
  static inline bool DatumType_IsValid(int value) {
    return Datum_DatumType_IsValid(value);
  }
  static const DatumType DatumType_MIN =
    Datum_DatumType_DatumType_MIN;
  static const DatumType DatumType_MAX =
    Datum_DatumType_DatumType_MAX;
  static const int DatumType_ARRAYSIZE =
    Datum_DatumType_DatumType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DatumType_descriptor() {
    return Datum_DatumType_descriptor();
  }
  static inline const ::std::string& DatumType_Name(DatumType value) {
    return Datum_DatumType_Name(value);
  }
  static inline bool DatumType_Parse(const ::std::string& name,
      DatumType* value) {
    return Datum_DatumType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Datum.DatumType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Datum_DatumType type() const;
  inline void set_type(::Datum_DatumType value);

  // optional bool r_bool = 2;
  inline bool has_r_bool() const;
  inline void clear_r_bool();
  static const int kRBoolFieldNumber = 2;
  inline bool r_bool() const;
  inline void set_r_bool(bool value);

  // optional double r_num = 3;
  inline bool has_r_num() const;
  inline void clear_r_num();
  static const int kRNumFieldNumber = 3;
  inline double r_num() const;
  inline void set_r_num(double value);

  // optional string r_str = 4;
  inline bool has_r_str() const;
  inline void clear_r_str();
  static const int kRStrFieldNumber = 4;
  inline const ::std::string& r_str() const;
  inline void set_r_str(const ::std::string& value);
  inline void set_r_str(const char* value);
  inline void set_r_str(const char* value, size_t size);
  inline ::std::string* mutable_r_str();
  inline ::std::string* release_r_str();
  inline void set_allocated_r_str(::std::string* r_str);

  // repeated .Datum r_array = 5;
  inline int r_array_size() const;
  inline void clear_r_array();
  static const int kRArrayFieldNumber = 5;
  inline const ::Datum& r_array(int index) const;
  inline ::Datum* mutable_r_array(int index);
  inline ::Datum* add_r_array();
  inline const ::google::protobuf::RepeatedPtrField< ::Datum >&
      r_array() const;
  inline ::google::protobuf::RepeatedPtrField< ::Datum >*
      mutable_r_array();

  // repeated .Datum.AssocPair r_object = 6;
  inline int r_object_size() const;
  inline void clear_r_object();
  static const int kRObjectFieldNumber = 6;
  inline const ::Datum_AssocPair& r_object(int index) const;
  inline ::Datum_AssocPair* mutable_r_object(int index);
  inline ::Datum_AssocPair* add_r_object();
  inline const ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair >&
      r_object() const;
  inline ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair >*
      mutable_r_object();

  // @@protoc_insertion_point(class_scope:Datum)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_r_bool();
  inline void clear_has_r_bool();
  inline void set_has_r_num();
  inline void clear_has_r_num();
  inline void set_has_r_str();
  inline void clear_has_r_str();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  bool r_bool_;
  double r_num_;
  ::std::string* r_str_;
  ::google::protobuf::RepeatedPtrField< ::Datum > r_array_;
  ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair > r_object_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Datum* default_instance_;
};
// -------------------------------------------------------------------

class Term_AssocPair : public ::google::protobuf::Message {
 public:
  Term_AssocPair();
  virtual ~Term_AssocPair();

  Term_AssocPair(const Term_AssocPair& from);

  inline Term_AssocPair& operator=(const Term_AssocPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Term_AssocPair& default_instance();

  void Swap(Term_AssocPair* other);

  // implements Message ----------------------------------------------

  Term_AssocPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Term_AssocPair& from);
  void MergeFrom(const Term_AssocPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional .Term val = 2;
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 2;
  inline const ::Term& val() const;
  inline ::Term* mutable_val();
  inline ::Term* release_val();
  inline void set_allocated_val(::Term* val);

  // @@protoc_insertion_point(class_scope:Term.AssocPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_val();
  inline void clear_has_val();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::Term* val_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Term_AssocPair* default_instance_;
};
// -------------------------------------------------------------------

class Term : public ::google::protobuf::Message {
 public:
  Term();
  virtual ~Term();

  Term(const Term& from);

  inline Term& operator=(const Term& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Term& default_instance();

  void Swap(Term* other);

  // implements Message ----------------------------------------------

  Term* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Term& from);
  void MergeFrom(const Term& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Term_AssocPair AssocPair;

  typedef Term_TermType TermType;
  static const TermType DATUM = Term_TermType_DATUM;
  static const TermType MAKE_ARRAY = Term_TermType_MAKE_ARRAY;
  static const TermType MAKE_OBJ = Term_TermType_MAKE_OBJ;
  static const TermType VAR = Term_TermType_VAR;
  static const TermType JAVASCRIPT = Term_TermType_JAVASCRIPT;
  static const TermType UUID = Term_TermType_UUID;
  static const TermType HTTP = Term_TermType_HTTP;
  static const TermType ERROR = Term_TermType_ERROR;
  static const TermType IMPLICIT_VAR = Term_TermType_IMPLICIT_VAR;
  static const TermType DB = Term_TermType_DB;
  static const TermType TABLE = Term_TermType_TABLE;
  static const TermType GET = Term_TermType_GET;
  static const TermType GET_ALL = Term_TermType_GET_ALL;
  static const TermType EQ = Term_TermType_EQ;
  static const TermType NE = Term_TermType_NE;
  static const TermType LT = Term_TermType_LT;
  static const TermType LE = Term_TermType_LE;
  static const TermType GT = Term_TermType_GT;
  static const TermType GE = Term_TermType_GE;
  static const TermType NOT = Term_TermType_NOT;
  static const TermType ADD = Term_TermType_ADD;
  static const TermType SUB = Term_TermType_SUB;
  static const TermType MUL = Term_TermType_MUL;
  static const TermType DIV = Term_TermType_DIV;
  static const TermType MOD = Term_TermType_MOD;
  static const TermType FLOOR = Term_TermType_FLOOR;
  static const TermType CEIL = Term_TermType_CEIL;
  static const TermType ROUND = Term_TermType_ROUND;
  static const TermType APPEND = Term_TermType_APPEND;
  static const TermType PREPEND = Term_TermType_PREPEND;
  static const TermType DIFFERENCE = Term_TermType_DIFFERENCE;
  static const TermType SET_INSERT = Term_TermType_SET_INSERT;
  static const TermType SET_INTERSECTION = Term_TermType_SET_INTERSECTION;
  static const TermType SET_UNION = Term_TermType_SET_UNION;
  static const TermType SET_DIFFERENCE = Term_TermType_SET_DIFFERENCE;
  static const TermType SLICE = Term_TermType_SLICE;
  static const TermType SKIP = Term_TermType_SKIP;
  static const TermType LIMIT = Term_TermType_LIMIT;
  static const TermType OFFSETS_OF = Term_TermType_OFFSETS_OF;
  static const TermType CONTAINS = Term_TermType_CONTAINS;
  static const TermType GET_FIELD = Term_TermType_GET_FIELD;
  static const TermType KEYS = Term_TermType_KEYS;
  static const TermType VALUES = Term_TermType_VALUES;
  static const TermType OBJECT = Term_TermType_OBJECT;
  static const TermType HAS_FIELDS = Term_TermType_HAS_FIELDS;
  static const TermType WITH_FIELDS = Term_TermType_WITH_FIELDS;
  static const TermType PLUCK = Term_TermType_PLUCK;
  static const TermType WITHOUT = Term_TermType_WITHOUT;
  static const TermType MERGE = Term_TermType_MERGE;
  static const TermType BETWEEN_DEPRECATED = Term_TermType_BETWEEN_DEPRECATED;
  static const TermType BETWEEN = Term_TermType_BETWEEN;
  static const TermType REDUCE = Term_TermType_REDUCE;
  static const TermType MAP = Term_TermType_MAP;
  static const TermType FILTER = Term_TermType_FILTER;
  static const TermType CONCAT_MAP = Term_TermType_CONCAT_MAP;
  static const TermType ORDER_BY = Term_TermType_ORDER_BY;
  static const TermType DISTINCT = Term_TermType_DISTINCT;
  static const TermType COUNT = Term_TermType_COUNT;
  static const TermType IS_EMPTY = Term_TermType_IS_EMPTY;
  static const TermType UNION = Term_TermType_UNION;
  static const TermType NTH = Term_TermType_NTH;
  static const TermType BRACKET = Term_TermType_BRACKET;
  static const TermType INNER_JOIN = Term_TermType_INNER_JOIN;
  static const TermType OUTER_JOIN = Term_TermType_OUTER_JOIN;
  static const TermType EQ_JOIN = Term_TermType_EQ_JOIN;
  static const TermType ZIP = Term_TermType_ZIP;
  static const TermType RANGE = Term_TermType_RANGE;
  static const TermType INSERT_AT = Term_TermType_INSERT_AT;
  static const TermType DELETE_AT = Term_TermType_DELETE_AT;
  static const TermType CHANGE_AT = Term_TermType_CHANGE_AT;
  static const TermType SPLICE_AT = Term_TermType_SPLICE_AT;
  static const TermType COERCE_TO = Term_TermType_COERCE_TO;
  static const TermType TYPE_OF = Term_TermType_TYPE_OF;
  static const TermType UPDATE = Term_TermType_UPDATE;
  static const TermType DELETE = Term_TermType_DELETE;
  static const TermType REPLACE = Term_TermType_REPLACE;
  static const TermType INSERT = Term_TermType_INSERT;
  static const TermType DB_CREATE = Term_TermType_DB_CREATE;
  static const TermType DB_DROP = Term_TermType_DB_DROP;
  static const TermType DB_LIST = Term_TermType_DB_LIST;
  static const TermType TABLE_CREATE = Term_TermType_TABLE_CREATE;
  static const TermType TABLE_DROP = Term_TermType_TABLE_DROP;
  static const TermType TABLE_LIST = Term_TermType_TABLE_LIST;
  static const TermType CONFIG = Term_TermType_CONFIG;
  static const TermType STATUS = Term_TermType_STATUS;
  static const TermType WAIT = Term_TermType_WAIT;
  static const TermType RECONFIGURE = Term_TermType_RECONFIGURE;
  static const TermType REBALANCE = Term_TermType_REBALANCE;
  static const TermType SYNC = Term_TermType_SYNC;
  static const TermType INDEX_CREATE = Term_TermType_INDEX_CREATE;
  static const TermType INDEX_DROP = Term_TermType_INDEX_DROP;
  static const TermType INDEX_LIST = Term_TermType_INDEX_LIST;
  static const TermType INDEX_STATUS = Term_TermType_INDEX_STATUS;
  static const TermType INDEX_WAIT = Term_TermType_INDEX_WAIT;
  static const TermType INDEX_RENAME = Term_TermType_INDEX_RENAME;
  static const TermType FUNCALL = Term_TermType_FUNCALL;
  static const TermType BRANCH = Term_TermType_BRANCH;
  static const TermType OR = Term_TermType_OR;
  static const TermType AND = Term_TermType_AND;
  static const TermType FOR_EACH = Term_TermType_FOR_EACH;
  static const TermType FUNC = Term_TermType_FUNC;
  static const TermType ASC = Term_TermType_ASC;
  static const TermType DESC = Term_TermType_DESC;
  static const TermType INFO = Term_TermType_INFO;
  static const TermType MATCH = Term_TermType_MATCH;
  static const TermType UPCASE = Term_TermType_UPCASE;
  static const TermType DOWNCASE = Term_TermType_DOWNCASE;
  static const TermType SAMPLE = Term_TermType_SAMPLE;
  static const TermType DEFAULT = Term_TermType_DEFAULT;
  static const TermType JSON = Term_TermType_JSON;
  static const TermType TO_JSON_STRING = Term_TermType_TO_JSON_STRING;
  static const TermType ISO8601 = Term_TermType_ISO8601;
  static const TermType TO_ISO8601 = Term_TermType_TO_ISO8601;
  static const TermType EPOCH_TIME = Term_TermType_EPOCH_TIME;
  static const TermType TO_EPOCH_TIME = Term_TermType_TO_EPOCH_TIME;
  static const TermType NOW = Term_TermType_NOW;
  static const TermType IN_TIMEZONE = Term_TermType_IN_TIMEZONE;
  static const TermType DURING = Term_TermType_DURING;
  static const TermType DATE = Term_TermType_DATE;
  static const TermType TIME_OF_DAY = Term_TermType_TIME_OF_DAY;
  static const TermType TIMEZONE = Term_TermType_TIMEZONE;
  static const TermType YEAR = Term_TermType_YEAR;
  static const TermType MONTH = Term_TermType_MONTH;
  static const TermType DAY = Term_TermType_DAY;
  static const TermType DAY_OF_WEEK = Term_TermType_DAY_OF_WEEK;
  static const TermType DAY_OF_YEAR = Term_TermType_DAY_OF_YEAR;
  static const TermType HOURS = Term_TermType_HOURS;
  static const TermType MINUTES = Term_TermType_MINUTES;
  static const TermType SECONDS = Term_TermType_SECONDS;
  static const TermType TIME = Term_TermType_TIME;
  static const TermType MONDAY = Term_TermType_MONDAY;
  static const TermType TUESDAY = Term_TermType_TUESDAY;
  static const TermType WEDNESDAY = Term_TermType_WEDNESDAY;
  static const TermType THURSDAY = Term_TermType_THURSDAY;
  static const TermType FRIDAY = Term_TermType_FRIDAY;
  static const TermType SATURDAY = Term_TermType_SATURDAY;
  static const TermType SUNDAY = Term_TermType_SUNDAY;
  static const TermType JANUARY = Term_TermType_JANUARY;
  static const TermType FEBRUARY = Term_TermType_FEBRUARY;
  static const TermType MARCH = Term_TermType_MARCH;
  static const TermType APRIL = Term_TermType_APRIL;
  static const TermType MAY = Term_TermType_MAY;
  static const TermType JUNE = Term_TermType_JUNE;
  static const TermType JULY = Term_TermType_JULY;
  static const TermType AUGUST = Term_TermType_AUGUST;
  static const TermType SEPTEMBER = Term_TermType_SEPTEMBER;
  static const TermType OCTOBER = Term_TermType_OCTOBER;
  static const TermType NOVEMBER = Term_TermType_NOVEMBER;
  static const TermType DECEMBER = Term_TermType_DECEMBER;
  static const TermType LITERAL = Term_TermType_LITERAL;
  static const TermType GROUP = Term_TermType_GROUP;
  static const TermType SUM = Term_TermType_SUM;
  static const TermType AVG = Term_TermType_AVG;
  static const TermType MIN = Term_TermType_MIN;
  static const TermType MAX = Term_TermType_MAX;
  static const TermType SPLIT = Term_TermType_SPLIT;
  static const TermType UNGROUP = Term_TermType_UNGROUP;
  static const TermType RANDOM = Term_TermType_RANDOM;
  static const TermType CHANGES = Term_TermType_CHANGES;
  static const TermType ARGS = Term_TermType_ARGS;
  static const TermType BINARY = Term_TermType_BINARY;
  static const TermType GEOJSON = Term_TermType_GEOJSON;
  static const TermType TO_GEOJSON = Term_TermType_TO_GEOJSON;
  static const TermType POINT = Term_TermType_POINT;
  static const TermType LINE = Term_TermType_LINE;
  static const TermType POLYGON = Term_TermType_POLYGON;
  static const TermType DISTANCE = Term_TermType_DISTANCE;
  static const TermType INTERSECTS = Term_TermType_INTERSECTS;
  static const TermType INCLUDES = Term_TermType_INCLUDES;
  static const TermType CIRCLE = Term_TermType_CIRCLE;
  static const TermType GET_INTERSECTING = Term_TermType_GET_INTERSECTING;
  static const TermType FILL = Term_TermType_FILL;
  static const TermType GET_NEAREST = Term_TermType_GET_NEAREST;
  static const TermType POLYGON_SUB = Term_TermType_POLYGON_SUB;
  static const TermType MINVAL = Term_TermType_MINVAL;
  static const TermType MAXVAL = Term_TermType_MAXVAL;
  static inline bool TermType_IsValid(int value) {
    return Term_TermType_IsValid(value);
  }
  static const TermType TermType_MIN =
    Term_TermType_TermType_MIN;
  static const TermType TermType_MAX =
    Term_TermType_TermType_MAX;
  static const int TermType_ARRAYSIZE =
    Term_TermType_TermType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TermType_descriptor() {
    return Term_TermType_descriptor();
  }
  static inline const ::std::string& TermType_Name(TermType value) {
    return Term_TermType_Name(value);
  }
  static inline bool TermType_Parse(const ::std::string& name,
      TermType* value) {
    return Term_TermType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Term.TermType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Term_TermType type() const;
  inline void set_type(::Term_TermType value);

  // optional .Datum datum = 2;
  inline bool has_datum() const;
  inline void clear_datum();
  static const int kDatumFieldNumber = 2;
  inline const ::Datum& datum() const;
  inline ::Datum* mutable_datum();
  inline ::Datum* release_datum();
  inline void set_allocated_datum(::Datum* datum);

  // repeated .Term args = 3;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 3;
  inline const ::Term& args(int index) const;
  inline ::Term* mutable_args(int index);
  inline ::Term* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::Term >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::Term >*
      mutable_args();

  // repeated .Term.AssocPair optargs = 4;
  inline int optargs_size() const;
  inline void clear_optargs();
  static const int kOptargsFieldNumber = 4;
  inline const ::Term_AssocPair& optargs(int index) const;
  inline ::Term_AssocPair* mutable_optargs(int index);
  inline ::Term_AssocPair* add_optargs();
  inline const ::google::protobuf::RepeatedPtrField< ::Term_AssocPair >&
      optargs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Term_AssocPair >*
      mutable_optargs();

  // @@protoc_insertion_point(class_scope:Term)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_datum();
  inline void clear_has_datum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Datum* datum_;
  ::google::protobuf::RepeatedPtrField< ::Term > args_;
  ::google::protobuf::RepeatedPtrField< ::Term_AssocPair > optargs_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto();
  friend void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto();

  void InitAsDefaultInstance();
  static Term* default_instance_;
};
// ===================================================================


// ===================================================================

// VersionDummy

// -------------------------------------------------------------------

// Query_AssocPair

// optional string key = 1;
inline bool Query_AssocPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Query_AssocPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Query_AssocPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Query_AssocPair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Query_AssocPair::key() const {
  return *key_;
}
inline void Query_AssocPair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Query_AssocPair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Query_AssocPair::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query_AssocPair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Query_AssocPair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Query_AssocPair::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Term val = 2;
inline bool Query_AssocPair::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Query_AssocPair::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Query_AssocPair::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Query_AssocPair::clear_val() {
  if (val_ != NULL) val_->::Term::Clear();
  clear_has_val();
}
inline const ::Term& Query_AssocPair::val() const {
  return val_ != NULL ? *val_ : *default_instance_->val_;
}
inline ::Term* Query_AssocPair::mutable_val() {
  set_has_val();
  if (val_ == NULL) val_ = new ::Term;
  return val_;
}
inline ::Term* Query_AssocPair::release_val() {
  clear_has_val();
  ::Term* temp = val_;
  val_ = NULL;
  return temp;
}
inline void Query_AssocPair::set_allocated_val(::Term* val) {
  delete val_;
  val_ = val;
  if (val) {
    set_has_val();
  } else {
    clear_has_val();
  }
}

// -------------------------------------------------------------------

// Query

// optional .Query.QueryType type = 1;
inline bool Query::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Query::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Query::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Query::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Query_QueryType Query::type() const {
  return static_cast< ::Query_QueryType >(type_);
}
inline void Query::set_type(::Query_QueryType value) {
  assert(::Query_QueryType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Term query = 2;
inline bool Query::has_query() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Query::set_has_query() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Query::clear_has_query() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Query::clear_query() {
  if (query_ != NULL) query_->::Term::Clear();
  clear_has_query();
}
inline const ::Term& Query::query() const {
  return query_ != NULL ? *query_ : *default_instance_->query_;
}
inline ::Term* Query::mutable_query() {
  set_has_query();
  if (query_ == NULL) query_ = new ::Term;
  return query_;
}
inline ::Term* Query::release_query() {
  clear_has_query();
  ::Term* temp = query_;
  query_ = NULL;
  return temp;
}
inline void Query::set_allocated_query(::Term* query) {
  delete query_;
  query_ = query;
  if (query) {
    set_has_query();
  } else {
    clear_has_query();
  }
}

// optional int64 token = 3;
inline bool Query::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Query::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Query::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Query::clear_token() {
  token_ = GOOGLE_LONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::int64 Query::token() const {
  return token_;
}
inline void Query::set_token(::google::protobuf::int64 value) {
  set_has_token();
  token_ = value;
}

// optional bool OBSOLETE_noreply = 4 [default = false];
inline bool Query::has_obsolete_noreply() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Query::set_has_obsolete_noreply() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Query::clear_has_obsolete_noreply() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Query::clear_obsolete_noreply() {
  obsolete_noreply_ = false;
  clear_has_obsolete_noreply();
}
inline bool Query::obsolete_noreply() const {
  return obsolete_noreply_;
}
inline void Query::set_obsolete_noreply(bool value) {
  set_has_obsolete_noreply();
  obsolete_noreply_ = value;
}

// optional bool accepts_r_json = 5 [default = false];
inline bool Query::has_accepts_r_json() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Query::set_has_accepts_r_json() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Query::clear_has_accepts_r_json() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Query::clear_accepts_r_json() {
  accepts_r_json_ = false;
  clear_has_accepts_r_json();
}
inline bool Query::accepts_r_json() const {
  return accepts_r_json_;
}
inline void Query::set_accepts_r_json(bool value) {
  set_has_accepts_r_json();
  accepts_r_json_ = value;
}

// repeated .Query.AssocPair global_optargs = 6;
inline int Query::global_optargs_size() const {
  return global_optargs_.size();
}
inline void Query::clear_global_optargs() {
  global_optargs_.Clear();
}
inline const ::Query_AssocPair& Query::global_optargs(int index) const {
  return global_optargs_.Get(index);
}
inline ::Query_AssocPair* Query::mutable_global_optargs(int index) {
  return global_optargs_.Mutable(index);
}
inline ::Query_AssocPair* Query::add_global_optargs() {
  return global_optargs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Query_AssocPair >&
Query::global_optargs() const {
  return global_optargs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Query_AssocPair >*
Query::mutable_global_optargs() {
  return &global_optargs_;
}

// -------------------------------------------------------------------

// Frame

// optional .Frame.FrameType type = 1;
inline bool Frame::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Frame_FrameType Frame::type() const {
  return static_cast< ::Frame_FrameType >(type_);
}
inline void Frame::set_type(::Frame_FrameType value) {
  assert(::Frame_FrameType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int64 pos = 2;
inline bool Frame::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame::clear_pos() {
  pos_ = GOOGLE_LONGLONG(0);
  clear_has_pos();
}
inline ::google::protobuf::int64 Frame::pos() const {
  return pos_;
}
inline void Frame::set_pos(::google::protobuf::int64 value) {
  set_has_pos();
  pos_ = value;
}

// optional string opt = 3;
inline bool Frame::has_opt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Frame::set_has_opt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Frame::clear_has_opt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Frame::clear_opt() {
  if (opt_ != &::google::protobuf::internal::kEmptyString) {
    opt_->clear();
  }
  clear_has_opt();
}
inline const ::std::string& Frame::opt() const {
  return *opt_;
}
inline void Frame::set_opt(const ::std::string& value) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(value);
}
inline void Frame::set_opt(const char* value) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(value);
}
inline void Frame::set_opt(const char* value, size_t size) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Frame::mutable_opt() {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  return opt_;
}
inline ::std::string* Frame::release_opt() {
  clear_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opt_;
    opt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Frame::set_allocated_opt(::std::string* opt) {
  if (opt_ != &::google::protobuf::internal::kEmptyString) {
    delete opt_;
  }
  if (opt) {
    set_has_opt();
    opt_ = opt;
  } else {
    clear_has_opt();
    opt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Backtrace

// repeated .Frame frames = 1;
inline int Backtrace::frames_size() const {
  return frames_.size();
}
inline void Backtrace::clear_frames() {
  frames_.Clear();
}
inline const ::Frame& Backtrace::frames(int index) const {
  return frames_.Get(index);
}
inline ::Frame* Backtrace::mutable_frames(int index) {
  return frames_.Mutable(index);
}
inline ::Frame* Backtrace::add_frames() {
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Frame >&
Backtrace::frames() const {
  return frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Frame >*
Backtrace::mutable_frames() {
  return &frames_;
}

// -------------------------------------------------------------------

// Response

// optional .Response.ResponseType type = 1;
inline bool Response::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Response_ResponseType Response::type() const {
  return static_cast< ::Response_ResponseType >(type_);
}
inline void Response::set_type(::Response_ResponseType value) {
  assert(::Response_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Response.ErrorType error_type = 7;
inline bool Response::has_error_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_error_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_error_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_error_type() {
  error_type_ = 1000000;
  clear_has_error_type();
}
inline ::Response_ErrorType Response::error_type() const {
  return static_cast< ::Response_ErrorType >(error_type_);
}
inline void Response::set_error_type(::Response_ErrorType value) {
  assert(::Response_ErrorType_IsValid(value));
  set_has_error_type();
  error_type_ = value;
}

// repeated .Response.ResponseNote notes = 6;
inline int Response::notes_size() const {
  return notes_.size();
}
inline void Response::clear_notes() {
  notes_.Clear();
}
inline ::Response_ResponseNote Response::notes(int index) const {
  return static_cast< ::Response_ResponseNote >(notes_.Get(index));
}
inline void Response::set_notes(int index, ::Response_ResponseNote value) {
  assert(::Response_ResponseNote_IsValid(value));
  notes_.Set(index, value);
}
inline void Response::add_notes(::Response_ResponseNote value) {
  assert(::Response_ResponseNote_IsValid(value));
  notes_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
Response::notes() const {
  return notes_;
}
inline ::google::protobuf::RepeatedField<int>*
Response::mutable_notes() {
  return &notes_;
}

// optional int64 token = 2;
inline bool Response::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_token() {
  token_ = GOOGLE_LONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::int64 Response::token() const {
  return token_;
}
inline void Response::set_token(::google::protobuf::int64 value) {
  set_has_token();
  token_ = value;
}

// repeated .Datum response = 3;
inline int Response::response_size() const {
  return response_.size();
}
inline void Response::clear_response() {
  response_.Clear();
}
inline const ::Datum& Response::response(int index) const {
  return response_.Get(index);
}
inline ::Datum* Response::mutable_response(int index) {
  return response_.Mutable(index);
}
inline ::Datum* Response::add_response() {
  return response_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Datum >&
Response::response() const {
  return response_;
}
inline ::google::protobuf::RepeatedPtrField< ::Datum >*
Response::mutable_response() {
  return &response_;
}

// optional .Backtrace backtrace = 4;
inline bool Response::has_backtrace() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_backtrace() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_backtrace() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_backtrace() {
  if (backtrace_ != NULL) backtrace_->::Backtrace::Clear();
  clear_has_backtrace();
}
inline const ::Backtrace& Response::backtrace() const {
  return backtrace_ != NULL ? *backtrace_ : *default_instance_->backtrace_;
}
inline ::Backtrace* Response::mutable_backtrace() {
  set_has_backtrace();
  if (backtrace_ == NULL) backtrace_ = new ::Backtrace;
  return backtrace_;
}
inline ::Backtrace* Response::release_backtrace() {
  clear_has_backtrace();
  ::Backtrace* temp = backtrace_;
  backtrace_ = NULL;
  return temp;
}
inline void Response::set_allocated_backtrace(::Backtrace* backtrace) {
  delete backtrace_;
  backtrace_ = backtrace;
  if (backtrace) {
    set_has_backtrace();
  } else {
    clear_has_backtrace();
  }
}

// optional .Datum profile = 5;
inline bool Response::has_profile() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_profile() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_profile() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_profile() {
  if (profile_ != NULL) profile_->::Datum::Clear();
  clear_has_profile();
}
inline const ::Datum& Response::profile() const {
  return profile_ != NULL ? *profile_ : *default_instance_->profile_;
}
inline ::Datum* Response::mutable_profile() {
  set_has_profile();
  if (profile_ == NULL) profile_ = new ::Datum;
  return profile_;
}
inline ::Datum* Response::release_profile() {
  clear_has_profile();
  ::Datum* temp = profile_;
  profile_ = NULL;
  return temp;
}
inline void Response::set_allocated_profile(::Datum* profile) {
  delete profile_;
  profile_ = profile;
  if (profile) {
    set_has_profile();
  } else {
    clear_has_profile();
  }
}

// -------------------------------------------------------------------

// Datum_AssocPair

// optional string key = 1;
inline bool Datum_AssocPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Datum_AssocPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Datum_AssocPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Datum_AssocPair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Datum_AssocPair::key() const {
  return *key_;
}
inline void Datum_AssocPair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Datum_AssocPair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Datum_AssocPair::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Datum_AssocPair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Datum_AssocPair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Datum_AssocPair::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Datum val = 2;
inline bool Datum_AssocPair::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Datum_AssocPair::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Datum_AssocPair::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Datum_AssocPair::clear_val() {
  if (val_ != NULL) val_->::Datum::Clear();
  clear_has_val();
}
inline const ::Datum& Datum_AssocPair::val() const {
  return val_ != NULL ? *val_ : *default_instance_->val_;
}
inline ::Datum* Datum_AssocPair::mutable_val() {
  set_has_val();
  if (val_ == NULL) val_ = new ::Datum;
  return val_;
}
inline ::Datum* Datum_AssocPair::release_val() {
  clear_has_val();
  ::Datum* temp = val_;
  val_ = NULL;
  return temp;
}
inline void Datum_AssocPair::set_allocated_val(::Datum* val) {
  delete val_;
  val_ = val;
  if (val) {
    set_has_val();
  } else {
    clear_has_val();
  }
}

// -------------------------------------------------------------------

// Datum

// optional .Datum.DatumType type = 1;
inline bool Datum::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Datum::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Datum::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Datum::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Datum_DatumType Datum::type() const {
  return static_cast< ::Datum_DatumType >(type_);
}
inline void Datum::set_type(::Datum_DatumType value) {
  assert(::Datum_DatumType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bool r_bool = 2;
inline bool Datum::has_r_bool() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Datum::set_has_r_bool() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Datum::clear_has_r_bool() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Datum::clear_r_bool() {
  r_bool_ = false;
  clear_has_r_bool();
}
inline bool Datum::r_bool() const {
  return r_bool_;
}
inline void Datum::set_r_bool(bool value) {
  set_has_r_bool();
  r_bool_ = value;
}

// optional double r_num = 3;
inline bool Datum::has_r_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Datum::set_has_r_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Datum::clear_has_r_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Datum::clear_r_num() {
  r_num_ = 0;
  clear_has_r_num();
}
inline double Datum::r_num() const {
  return r_num_;
}
inline void Datum::set_r_num(double value) {
  set_has_r_num();
  r_num_ = value;
}

// optional string r_str = 4;
inline bool Datum::has_r_str() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Datum::set_has_r_str() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Datum::clear_has_r_str() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Datum::clear_r_str() {
  if (r_str_ != &::google::protobuf::internal::kEmptyString) {
    r_str_->clear();
  }
  clear_has_r_str();
}
inline const ::std::string& Datum::r_str() const {
  return *r_str_;
}
inline void Datum::set_r_str(const ::std::string& value) {
  set_has_r_str();
  if (r_str_ == &::google::protobuf::internal::kEmptyString) {
    r_str_ = new ::std::string;
  }
  r_str_->assign(value);
}
inline void Datum::set_r_str(const char* value) {
  set_has_r_str();
  if (r_str_ == &::google::protobuf::internal::kEmptyString) {
    r_str_ = new ::std::string;
  }
  r_str_->assign(value);
}
inline void Datum::set_r_str(const char* value, size_t size) {
  set_has_r_str();
  if (r_str_ == &::google::protobuf::internal::kEmptyString) {
    r_str_ = new ::std::string;
  }
  r_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Datum::mutable_r_str() {
  set_has_r_str();
  if (r_str_ == &::google::protobuf::internal::kEmptyString) {
    r_str_ = new ::std::string;
  }
  return r_str_;
}
inline ::std::string* Datum::release_r_str() {
  clear_has_r_str();
  if (r_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = r_str_;
    r_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Datum::set_allocated_r_str(::std::string* r_str) {
  if (r_str_ != &::google::protobuf::internal::kEmptyString) {
    delete r_str_;
  }
  if (r_str) {
    set_has_r_str();
    r_str_ = r_str;
  } else {
    clear_has_r_str();
    r_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Datum r_array = 5;
inline int Datum::r_array_size() const {
  return r_array_.size();
}
inline void Datum::clear_r_array() {
  r_array_.Clear();
}
inline const ::Datum& Datum::r_array(int index) const {
  return r_array_.Get(index);
}
inline ::Datum* Datum::mutable_r_array(int index) {
  return r_array_.Mutable(index);
}
inline ::Datum* Datum::add_r_array() {
  return r_array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Datum >&
Datum::r_array() const {
  return r_array_;
}
inline ::google::protobuf::RepeatedPtrField< ::Datum >*
Datum::mutable_r_array() {
  return &r_array_;
}

// repeated .Datum.AssocPair r_object = 6;
inline int Datum::r_object_size() const {
  return r_object_.size();
}
inline void Datum::clear_r_object() {
  r_object_.Clear();
}
inline const ::Datum_AssocPair& Datum::r_object(int index) const {
  return r_object_.Get(index);
}
inline ::Datum_AssocPair* Datum::mutable_r_object(int index) {
  return r_object_.Mutable(index);
}
inline ::Datum_AssocPair* Datum::add_r_object() {
  return r_object_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair >&
Datum::r_object() const {
  return r_object_;
}
inline ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair >*
Datum::mutable_r_object() {
  return &r_object_;
}

// -------------------------------------------------------------------

// Term_AssocPair

// optional string key = 1;
inline bool Term_AssocPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Term_AssocPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Term_AssocPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Term_AssocPair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Term_AssocPair::key() const {
  return *key_;
}
inline void Term_AssocPair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Term_AssocPair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Term_AssocPair::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Term_AssocPair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Term_AssocPair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Term_AssocPair::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Term val = 2;
inline bool Term_AssocPair::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Term_AssocPair::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Term_AssocPair::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Term_AssocPair::clear_val() {
  if (val_ != NULL) val_->::Term::Clear();
  clear_has_val();
}
inline const ::Term& Term_AssocPair::val() const {
  return val_ != NULL ? *val_ : *default_instance_->val_;
}
inline ::Term* Term_AssocPair::mutable_val() {
  set_has_val();
  if (val_ == NULL) val_ = new ::Term;
  return val_;
}
inline ::Term* Term_AssocPair::release_val() {
  clear_has_val();
  ::Term* temp = val_;
  val_ = NULL;
  return temp;
}
inline void Term_AssocPair::set_allocated_val(::Term* val) {
  delete val_;
  val_ = val;
  if (val) {
    set_has_val();
  } else {
    clear_has_val();
  }
}

// -------------------------------------------------------------------

// Term

// optional .Term.TermType type = 1;
inline bool Term::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Term::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Term::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Term::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Term_TermType Term::type() const {
  return static_cast< ::Term_TermType >(type_);
}
inline void Term::set_type(::Term_TermType value) {
  assert(::Term_TermType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Datum datum = 2;
inline bool Term::has_datum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Term::set_has_datum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Term::clear_has_datum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Term::clear_datum() {
  if (datum_ != NULL) datum_->::Datum::Clear();
  clear_has_datum();
}
inline const ::Datum& Term::datum() const {
  return datum_ != NULL ? *datum_ : *default_instance_->datum_;
}
inline ::Datum* Term::mutable_datum() {
  set_has_datum();
  if (datum_ == NULL) datum_ = new ::Datum;
  return datum_;
}
inline ::Datum* Term::release_datum() {
  clear_has_datum();
  ::Datum* temp = datum_;
  datum_ = NULL;
  return temp;
}
inline void Term::set_allocated_datum(::Datum* datum) {
  delete datum_;
  datum_ = datum;
  if (datum) {
    set_has_datum();
  } else {
    clear_has_datum();
  }
}

// repeated .Term args = 3;
inline int Term::args_size() const {
  return args_.size();
}
inline void Term::clear_args() {
  args_.Clear();
}
inline const ::Term& Term::args(int index) const {
  return args_.Get(index);
}
inline ::Term* Term::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::Term* Term::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Term >&
Term::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::Term >*
Term::mutable_args() {
  return &args_;
}

// repeated .Term.AssocPair optargs = 4;
inline int Term::optargs_size() const {
  return optargs_.size();
}
inline void Term::clear_optargs() {
  optargs_.Clear();
}
inline const ::Term_AssocPair& Term::optargs(int index) const {
  return optargs_.Get(index);
}
inline ::Term_AssocPair* Term::mutable_optargs(int index) {
  return optargs_.Mutable(index);
}
inline ::Term_AssocPair* Term::add_optargs() {
  return optargs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Term_AssocPair >&
Term::optargs() const {
  return optargs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Term_AssocPair >*
Term::mutable_optargs() {
  return &optargs_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VersionDummy_Version>() {
  return ::VersionDummy_Version_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VersionDummy_Protocol>() {
  return ::VersionDummy_Protocol_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Query_QueryType>() {
  return ::Query_QueryType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Frame_FrameType>() {
  return ::Frame_FrameType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Response_ResponseType>() {
  return ::Response_ResponseType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Response_ErrorType>() {
  return ::Response_ErrorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Response_ResponseNote>() {
  return ::Response_ResponseNote_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Datum_DatumType>() {
  return ::Datum_DatumType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Term_TermType>() {
  return ::Term_TermType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rdb_5fprotocol_2fql2_2eproto__INCLUDED
