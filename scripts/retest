#!/usr/bin/python
# -*- mode: Python; -*-

import sys
import os
import os.path
from subprocess import call
from xml.dom.minidom import parse
import hashlib

test_function_prefix = 'test_'

visited_tests = []
performed_tests = []
performed_tests_count = 0

# Utility functions
def source_name(file_name):
    return '.%s.cc' % os.path.splitext(file_name)[0]

def exec_name(file_name):
    return '.%s.exec' % os.path.splitext(file_name)[0]

def conf_name(file_name):
    return '.%s.conf' % os.path.splitext(file_name)[0]

def test_cmp(x, y):
    return x[1]['line'] - y[1]['line']

def gen_fn_hash(source, node):
    begin = int(node.getAttribute('line'))
    if(node.getAttribute('endline') != ''):
        end = int(node.getAttribute('endline'))
    else:
        end = begin
    m = hashlib.md5()
    with open(source, 'r') as src:
        i = 1
        for line in src:
            if i > end:
                break
            if i >= begin and i <= end:
                m.update(line)
            i += 1
    return m.hexdigest()

# Inspect the test file source code and automatically generate a file
# that can run unit tests dynamically.
def gen_main_file(test_file, dom):
    config = { 'test_list' : [], 'tests' : {} }
    for node in dom.getElementsByTagName("Function"):
        fn_name = node.getAttribute('name')
        if fn_name.startswith(test_function_prefix):
            config['tests'][fn_name] = { 'known_state' : None,
                                         'hash' : gen_fn_hash(test_file, node),
                                         'line' : int(node.getAttribute('line'))}
    # Generate a sorted test list
    test_list = sorted(config['tests'].items(), test_cmp)
    for (fn, test) in test_list:
        config['test_list'].append(fn)
        del config['tests'][fn]['line']
    # Generate the source file
    with open(source_name(test_file), 'w') as gen:
        with open(test_file, 'r') as test_file:
            for line in test_file:
                gen.write(line)
        gen.write('\n/*** GENERATED CODE ***/\n\n')
        gen.write('#include <string.h>\n\n')
        gen.write('int main(int argc, char *argv[]) {\n')
        gen.write('    if(argc != 2) {\n')
        gen.write('        return -1;\n')
        gen.write('    }\n\n')
        for test in config['test_list']:
            gen.write('    if(strcmp(argv[1], "%s") == 0) {\n'
                      % test[len(test_function_prefix):])
            gen.write('        %s();\n' % test)
            gen.write('    }\n')
        gen.write('    return 0;\n')
        gen.write('}\n')
    return config

def gen_conf_file(test_file, conf):
    with open(conf_name(test_file), 'w') as gen:
        gen.write(str(conf))

def load_config(conf_file):
    with open(conf_file, 'r') as old_conf_file:
        conf = eval(old_conf_file.readline())
    return conf

def compare_configs(new_conf, conf_file):
    if not os.path.exists(conf_file):
        return new_conf
    # Read the old config file
    old_conf = load_config(conf_file)
    # Go through old config and see if anything changed
    for test in old_conf['test_list']:
        if not test in new_conf['tests']:
            del old_conf['tests'][test]
            continue
        if old_conf['tests'][test]['hash'] != new_conf['tests'][test]['hash']:
            old_conf['tests'][test]['known_state'] = None
            old_conf['tests'][test]['hash'] = new_conf['tests'][test]['hash']
    # Go through new config and see if we need to add anything
    for test in new_conf['test_list']:
        if not test in old_conf['tests']:
            old_conf['tests'][test] = new_conf['tests'][test]
    old_conf['test_list'] = new_conf['test_list']
    return old_conf

def print_test_status(test, res):
    global performed_tests_count
    if res:
        res = 'P'
    else:
        res = 'F'
    print '%s [%s]' % (test, res)
    performed_tests_count += 1

def print_results():
    print("Ran %d of %d, %d failed"
          % (len(performed_tests),
             len(visited_tests),
             len(filter(lambda x: x[1] != True, performed_tests))))

def run_tests(exec_file, conf):
    global visited_tests, performed_tests
    for test in conf['test_list']:
        visited_tests.append(test)
        if conf['tests'][test]['known_state'] != True:
            ret = call(['./%s' % exec_file, test[len(test_function_prefix):]])
            print_test_status(test, ret == 0)
            performed_tests.append((test, (ret == 0)))
            conf['tests'][test]['known_state'] = (ret == 0)
    return conf

def process_test_file(file):
    xml_file = '%s.xml' % file
    source_file = source_name(file)
    exec_file = exec_name(file)
    conf_file = conf_name(file)
    # Check the times
    if(not (os.path.exists(exec_file) and
            os.path.exists(conf_file) and
            os.path.getmtime(exec_file) >= os.path.getmtime(file) and
            os.path.getmtime(conf_file) >= os.path.getmtime(file))):
        # Remove generated files
        call(['rm', '-f', xml_file])
        call(['rm', '-f', source_file])
        call(['rm', '-f', exec_file])
        # Generate XML out of the file
        ret = call(['gccxml', '-fxml=%s' % xml_file, file])
        if not (ret == 0):
            return
        # Load the XML
        dom = parse(xml_file)
        call(['rm', '-f', xml_file])
        # Generate executable
        conf = gen_main_file(file, dom)
        # Compile
        call(['g++', '-o', exec_file, source_file])
        call(['rm', '-f', source_file])
        # Compare configuration files
        conf = compare_configs(conf, conf_file)
    else:
        conf = load_config(conf_file)
    # Remove old config file
    call(['rm', '-f', conf_file])
    # Run the test
    conf = run_tests(exec_file, conf)
    # Generate new configuration file
    gen_conf_file(file, conf)

def recursive_retest(dir):
    for root, dirs, files in os.walk(os.path.abspath(dir)):
        for file in files:
            if os.path.splitext(file)[1] == '.cc' and file[0] != '.':
                os.chdir(os.path.abspath(root))
                process_test_file(file)
    # Results!
    print_results()

def recursive_clean():
    for root, dirs, files in os.walk(os.path.abspath('.')):
        for file in files:
            if os.path.splitext(file)[1] == '.cc' and file[0] != '.':
                os.chdir(os.path.abspath(root))
                call(['rm', '-f', '%s.xml' % file])
                call(['rm', '-f', source_name(file)])
                call(['rm', '-f', exec_name(file)])
                call(['rm', '-f', conf_name(file)])

def main(argv):
    if(len(argv) > 2):
        print("Usage: %s [clean | file.cc | dir]" % argv[0])
        sys.exit()
    if(len(argv) == 2):
        if(argv[1] == 'clean'):
            recursive_clean()
        else:
            if os.path.splitext(argv[1])[1] == '.cc':
                if(os.path.split(argv[1])[0] != ''):
                    os.chdir(os.path.split(argv[1])[0])
                process_test_file(os.path.split(argv[1])[1])
                print_results()
            else:
                recursive_retest(argv[1])
        return
    recursive_retest(os.curdir)

if __name__ == '__main__':
    sys.exit(main(sys.argv))
