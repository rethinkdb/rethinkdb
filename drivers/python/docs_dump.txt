Help on package rethinkdb:

NAME
    rethinkdb - r -> r

FILE
    /home/ssd1/atnnn/code/rethinkdb/drivers/python/rethinkdb/__init__.py

DESCRIPTION
    The top-level ReQL namespace.
    
    *Example* Setup your top-level namespace.
    
        import rethinkdb as r

PACKAGE CONTENTS
    _backup
    _dump
    _export
    _import
    _index_rebuild
    _negative_zero_check
    _restore
    ast
    docs
    errors
    net
    net_tornado
    ql2_pb2
    query
    repl
    version

SUBMODULES
    module

CLASSES
    __builtin__.object
        r
        r
    exceptions.Exception(exceptions.BaseException)
        rethinkdb.errors.RqlError
            rethinkdb.errors.RqlDriverError
            rethinkdb.errors.RqlTimeoutError
    rethinkdb.errors.RqlQueryError(rethinkdb.errors.RqlError)
        rethinkdb.errors.RqlClientError
        rethinkdb.errors.RqlCompileError
        rethinkdb.errors.RqlCursorEmpty
        rethinkdb.errors.RqlRuntimeError
    
    class RqlClientError(RqlQueryError)
     |  Method resolution order:
     |      RqlClientError
     |      RqlQueryError
     |      RqlError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods inherited from RqlQueryError:
     |  
     |  __init__(self, message, term, frames)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from RqlError:
     |  
     |  __repr__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RqlError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class RqlCompileError(RqlQueryError)
     |  Method resolution order:
     |      RqlCompileError
     |      RqlQueryError
     |      RqlError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods inherited from RqlQueryError:
     |  
     |  __init__(self, message, term, frames)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from RqlError:
     |  
     |  __repr__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RqlError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class RqlCursorEmpty(RqlQueryError)
     |  Method resolution order:
     |      RqlCursorEmpty
     |      RqlQueryError
     |      RqlError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, term)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from RqlQueryError:
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from RqlError:
     |  
     |  __repr__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RqlError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class RqlDriverError(RqlError)
     |  Method resolution order:
     |      RqlDriverError
     |      RqlError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods inherited from RqlError:
     |  
     |  __init__(self, message)
     |  
     |  __repr__(self)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RqlError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class RqlError(exceptions.Exception)
     |  Method resolution order:
     |      RqlError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, message)
     |  
     |  __repr__(self)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class RqlRuntimeError(RqlQueryError)
     |  Method resolution order:
     |      RqlRuntimeError
     |      RqlQueryError
     |      RqlError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from RqlQueryError:
     |  
     |  __init__(self, message, term, frames)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from RqlError:
     |  
     |  __repr__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RqlError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class RqlTimeoutError(RqlError)
     |  Method resolution order:
     |      RqlTimeoutError
     |      RqlError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from RqlError:
     |  
     |  __repr__(self)
     |  
     |  __str__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RqlError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class r(__builtin__.object)
     |  # The builtins here defends against re-importing something obscuring `object`.
     |  
     |  Static methods defined here:
     |  
     |  class Connection(__builtin__.object)
     |   |  Methods defined here:
     |   |  
     |   |  __enter__(self)
     |   |  
     |   |  __exit__(self, type, value, traceback)
     |   |  
     |   |  __init__(self, conn_type, host, port, db, auth_key, timeout, **kwargs)
     |   |  
     |   |  check_open(self)
     |   |  
     |   |  close(self, noreply_wait=True)
     |   |      conn.close(noreply_wait=True)
     |   |      
     |   |      Close an open connection.
     |   |      
     |   |      Closing a connection normally waits until all outstanding requests have finished and then frees any open resources associated with the connection. By passing `False` to the `noreply_wait` optional argument, the connection will be closed immediately, possibly aborting any outstanding noreply writes.
     |   |      
     |   |      A noreply query is executed by passing the `noreply` option to the [run](http://rethinkdb.com/api/python/run/) command, indicating that `run()` should not wait for the query to complete before returning. You may also explicitly wait for a noreply query to complete by using the [noreply_wait](http://rethinkdb.com/api/python/noreply_wait) command.
     |   |      
     |   |      *Example* Close an open connection, waiting for noreply writes to finish.
     |   |      
     |   |          conn.close()
     |   |      
     |   |      *Example* Close an open connection immediately.
     |   |      
     |   |          conn.close(noreply_wait=False)
     |   |  
     |   |  is_open(self)
     |   |  
     |   |  noreply_wait(self)
     |   |      conn.noreply_wait()
     |   |      
     |   |      `noreply_wait` ensures that previous queries with the `noreply` flag have been processed
     |   |      by the server. Note that this guarantee only applies to queries run on the given connection.
     |   |      
     |   |      *Example* We have previously run queries with the `noreply` argument set to `True`. Now
     |   |      wait until the server has processed them.
     |   |      
     |   |          conn.noreply_wait()
     |   |  
     |   |  reconnect(self, noreply_wait=True, timeout=None)
     |   |      conn.reconnect(noreply_wait=True)
     |   |      
     |   |      Close and reopen a connection.
     |   |      
     |   |      Closing a connection normally waits until all outstanding requests have finished and then frees any open resources associated with the connection. By passing `False` to the `noreply_wait` optional argument, the connection will be closed immediately, possibly aborting any outstanding noreply writes.
     |   |      
     |   |      A noreply query is executed by passing the `noreply` option to the [run](http://rethinkdb.com/api/python/run/) command, indicating that `run()` should not wait for the query to complete before returning. You may also explicitly wait for a noreply query to complete by using the [noreply_wait](http://rethinkdb.com/api/python/noreply_wait) command.
     |   |      
     |   |      *Example* Cancel outstanding requests/queries that are no longer needed.
     |   |      
     |   |          conn.reconnect(noreply_wait=False)
     |   |  
     |   |  repl(self)
     |   |      conn.repl()
     |   |      
     |   |      Set the default connection to make REPL use easier. Allows calling
     |   |      `.run()` on queries without specifying a connection.
     |   |      
     |   |      __Note:__ Avoid using `repl` in application code. RethinkDB connection objects are not thread-safe, and calls to `connect` from multiple threads may change the global connection object used by `repl`. Applications should specify connections explicitly.
     |   |      
     |   |      *Example* Set the default connection for the REPL, then call
     |   |      `run()` without specifying the connection.
     |   |      
     |   |          r.connect(db='marvel').repl()
     |   |          r.table('heroes').run()
     |   |  
     |   |  use(self, db)
     |   |      conn.use(db_name)
     |   |      
     |   |      Change the default database on this connection.
     |   |      
     |   |      *Example* Change the default database so that we don't need to
     |   |      specify the database when referencing a table.
     |   |      
     |   |          conn.use('marvel')
     |   |          r.table('heroes').run(conn) # refers to r.db('marvel').table('heroes')
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors defined here:
     |   |  
     |   |  __dict__
     |   |      dictionary for instance variables (if defined)
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |  
     |  class Cursor(__builtin__.object)
     |   |  # This class encapsulates all shared behavior between cursor implementations.
     |   |  # It provides iteration over the cursor using `iter`, as well as incremental
     |   |  # iteration using `next`.
     |   |  #
     |   |  # query - the original query that resulted in the cursor, used for:
     |   |  #     query.term - the term to be used for pretty-printing backtraces
     |   |  #     query.token - the token to use for subsequent CONTINUE and STOP requests
     |   |  #     query.global_optargs - dictate how to format results
     |   |  # items - The current list of items obtained from the server, this is
     |   |  #     added to in `_extend`, which is called by the ConnectionInstance when a
     |   |  #     new response arrives for this cursor.
     |   |  # outstanding_requests - The number of requests that are currently awaiting
     |   |  #     a response from the server.  This will typically be 0 or 1 unless the
     |   |  #     cursor is exhausted, but this can be higher if `close` is called.
     |   |  # threshold - a CONTINUE request will be sent when the length of `items` goes
     |   |  #     below this number.
     |   |  # error - indicates the current state of the cursor:
     |   |  #     None - there is more data available from the server and no errors have
     |   |  #         occurred yet
     |   |  #     Exception - an error has occurred in the cursor and should be raised
     |   |  #         to the user once all results in `items` have been returned.  This
     |   |  #         will be a RqlCursorEmpty exception if the cursor completed successfully.
     |   |  #
     |   |  # A class that derives from this should implement the following functions:
     |   |  #     def _get_next(self, timeout):
     |   |  #         where `timeout` is the maximum amount of time (in seconds) to wait for the
     |   |  #         next result in the cursor before raising a RqlTimeoutError.
     |   |  #     def _empty_error(self):
     |   |  #         which returns the appropriate error to be raised when the cursor is empty
     |   |  
     |   |  Methods defined here:
     |   |  
     |   |  __init__(self, conn_instance, query)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  close(self)
     |   |      cursor.close()
     |   |      
     |   |      Close a cursor. Closing a cursor cancels the corresponding query and frees the memory
     |   |      associated with the open request.
     |   |      
     |   |      *Example* Close a cursor.
     |   |      
     |   |          cursor.close()
     |   |  
     |   |  next(self, wait=True)
     |   |      cursor.next([wait=True])
     |   |      
     |   |      Get the next element in the cursor.
     |   |      
     |   |      The optional `wait` argument specifies whether to wait for the next available element and how long to wait:
     |   |      
     |   |      * `True`: Wait indefinitely (the default).
     |   |      * `False`: Do not wait at all. If data is immediately available, it will be returned; if it is not available, a `RqlDriverError` will be raised.
     |   |      * number: Wait up the specified number of seconds for data to be available before raising `RqlDriverError`.
     |   |      
     |   |      The behavior of `next` will be identical with `False`, `None` or the number `0`.
     |   |      
     |   |      Calling `next` the first time on a cursor provides the first element of the cursor. If the data set is exhausted (e.g., you have retrieved all the documents in a table), a `StopIteration` error will be raised when `next` is called.
     |   |      
     |   |      *Example* Retrieve the next element.
     |   |      
     |   |          cursor = r.table('superheroes').run(conn)
     |   |          doc = cursor.next()
     |   |      
     |   |      *Example* Retrieve the next element on a [changefeed](http://rethinkdb.com/docs/changefeeds/python), waiting up to five seconds.
     |   |      
     |   |          cursor = r.table('superheroes').changes().run(conn)
     |   |          doc = cursor.next(wait=5)
     |   |      
     |   |      __Note:__ RethinkDB sequences can be iterated through via the Python [Iterable][it] interface. The canonical way to retrieve all the results is to use a [for...in](../each/) loop or [list()](../to_array/).
     |   |      
     |   |      [it]: https://docs.python.org/3.4/library/stdtypes.html#iterator-types
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors defined here:
     |   |  
     |   |  __dict__
     |   |      dictionary for instance variables (if defined)
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |  
     |  class RqlClientError(RqlQueryError)
     |   |  Method resolution order:
     |   |      RqlClientError
     |   |      RqlQueryError
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods inherited from RqlQueryError:
     |   |  
     |   |  __init__(self, message, term, frames)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlError:
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from RqlError:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  class RqlCompileError(RqlQueryError)
     |   |  Method resolution order:
     |   |      RqlCompileError
     |   |      RqlQueryError
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods inherited from RqlQueryError:
     |   |  
     |   |  __init__(self, message, term, frames)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlError:
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from RqlError:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  class RqlCursorEmpty(RqlQueryError)
     |   |  Method resolution order:
     |   |      RqlCursorEmpty
     |   |      RqlQueryError
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods defined here:
     |   |  
     |   |  __init__(self, term)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlQueryError:
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlError:
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from RqlError:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  class RqlDriverError(RqlError)
     |   |  Method resolution order:
     |   |      RqlDriverError
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods inherited from RqlError:
     |   |  
     |   |  __init__(self, message)
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from RqlError:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  class RqlError(exceptions.Exception)
     |   |  Method resolution order:
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods defined here:
     |   |  
     |   |  __init__(self, message)
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors defined here:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  class RqlQuery(__builtin__.object)
     |   |  Methods defined here:
     |   |  
     |   |  __add__(self, other)
     |   |      number + number -> number
     |   |      string + string -> string
     |   |      array + array -> array
     |   |      time + number -> time
     |   |      
     |   |      Sum two numbers, concatenate two strings, or concatenate 2 arrays.
     |   |      
     |   |      *Example* It's as easy as 2 + 2 = 4.
     |   |      
     |   |          > (r.expr(2) + 2).run(conn)
     |   |          
     |   |          4
     |   |      
     |   |      *Example* Strings can be concatenated too.
     |   |      
     |   |          > (r.expr("foo") + "bar").run(conn)
     |   |          
     |   |          "foobar"
     |   |      
     |   |      *Example* Arrays can be concatenated too.
     |   |      
     |   |          > (r.expr(["foo", "bar"]) + ["buzz"]).run(conn)
     |   |          
     |   |          ['foo', 'bar', 'buzz']
     |   |      
     |   |      *Example* Create a date one year from now.
     |   |      
     |   |          r.now() + 365*24*60*60
     |   |      
     |   |      *Example* Use [args](http://rethinkdb.com/api/python/args) with `add` to sum multiple values.
     |   |      
     |   |          > r.add(r.args([10, 20, 30])).run(conn)
     |   |          
     |   |          60
     |   |      
     |   |      *Example* Concatenate an array of strings with `args`.
     |   |      
     |   |          > r.add(r.args(['foo', 'bar', 'buzz'])).run(conn)
     |   |          
     |   |          "foobarbuzz"
     |   |  
     |   |  __and__(self, other)
     |   |      bool & bool -> bool
     |   |      r.and_(bool, bool) -> bool
     |   |      bool.and_(bool) -> bool
     |   |      
     |   |      Compute the logical "and" of two or more values. The `and_` command can be used as an infix operator after its first argument (`r.expr(True).and_(False)`) or given all of its arguments as parameters (`r.and_(True, False)`). The standard Python and operator, `&`, may also be used with ReQL.
     |   |      
     |   |      *Example* Return whether both `a` and `b` evaluate to true.
     |   |      
     |   |          > a = True
     |   |          > b = False
     |   |          > (r.expr(a) & b).run(conn)
     |   |          
     |   |          False
     |   |      *Example* Return whether all of `x`, `y` and `z` evaluate to true.
     |   |      
     |   |          > x = True
     |   |          > y = True
     |   |          > z = True
     |   |          > r.and_(x, y, z).run(conn)
     |   |          
     |   |          True
     |   |  
     |   |  __div__(self, other)
     |   |      number / number -> number
     |   |      
     |   |      Divide two numbers.
     |   |      
     |   |      *Example* It's as easy as 2 / 2 = 1.
     |   |      
     |   |          (r.expr(2) / 2).run(conn)
     |   |  
     |   |  __eq__(self, other)
     |   |      value == value -> bool
     |   |      value.eq(value) -> bool
     |   |      
     |   |      Test if two values are equal.
     |   |      
     |   |      *Example* Does 2 equal 2?
     |   |      
     |   |          (r.expr(2) == 2).run(conn)
     |   |          r.expr(2).eq(2).run(conn)
     |   |  
     |   |  __ge__(self, other)
     |   |      value >= value -> bool
     |   |      value.ge(value) -> bool
     |   |      
     |   |      Test if the first value is greater than or equal to other.
     |   |      
     |   |      *Example* Is 2 greater than or equal to 2?
     |   |      
     |   |          (r.expr(2) >= 2).run(conn)
     |   |          r.expr(2).ge(2).run(conn)
     |   |  
     |   |  __getitem__(self, index)
     |   |      sequence[attr] -> sequence
     |   |      singleSelection[attr] -> value
     |   |      object[attr] -> value
     |   |      array[index] -> value
     |   |      
     |   |      Get a single field from an object. If called on a sequence, gets that field from every object in the sequence, skipping objects that lack it.
     |   |      
     |   |      *Example* What was Iron Man's first appearance in a comic?
     |   |      
     |   |          r.table('marvel').get('IronMan')['firstAppearance'].run(conn)
     |   |      
     |   |      The `[]` command also accepts integer arguments as array offsets, like the [nth](http://rethinkdb.com/api/python/nth) command.
     |   |      
     |   |      *Example* Get the fourth element in a sequence. (The first element is position `0`, so the fourth element is position `3`.)
     |   |      
     |   |          r.expr([10, 20, 30, 40, 50])[3]
     |   |          
     |   |          40
     |   |  
     |   |  __gt__(self, other)
     |   |      value > value -> bool
     |   |      value.gt(value) -> bool
     |   |      
     |   |      Test if the first value is greater than other.
     |   |      
     |   |      *Example* Is 2 greater than 2?
     |   |      
     |   |          (r.expr(2) > 2).run(conn)
     |   |          r.expr(2).gt(2).run(conn)
     |   |  
     |   |  __init__(self, *args, **optargs)
     |   |      # Instantiate this AST node with the given pos and opt args
     |   |  
     |   |  __invert__(self)
     |   |      bool.not_() -> bool
     |   |      not_(bool) -> bool
     |   |      (~bool) -> bool
     |   |      
     |   |      Compute the logical inverse (not) of an expression.
     |   |      
     |   |      `not_` can be called either via method chaining, immediately after an expression that evaluates as a boolean value, or by passing the expression as a parameter to `not_`.  All values that are not `False` or `None` will be converted to `True`.
     |   |      
     |   |      You may also use `~` as a shorthand operator.
     |   |      
     |   |      *Example* Not true is false.
     |   |      
     |   |          r.not_(True).run(conn)
     |   |          r.expr(True).not_().run(conn)
     |   |          (~r.expr(True)).run(conn)
     |   |      
     |   |      These evaluate to `false`.
     |   |      
     |   |      Note that when using `~` the expression is wrapped in parentheses. Without this, Python will evaluate `r.expr(True)` *first* rather than using the ReQL operator and return an incorrect value. (`~True` evaluates to &minus;2 in Python.)
     |   |      
     |   |      *Example* Return all the users that do not have a "flag" field.
     |   |      
     |   |          r.table('users').filter(
     |   |              lambda users: (~users.has_fields('flag'))
     |   |          ).run(conn)
     |   |      
     |   |      *Example* As above, but prefix-style.
     |   |      
     |   |          r.table('users').filter(
     |   |              lambda users: r.not_(users.has_fields('flag'))
     |   |          ).run(conn)
     |   |  
     |   |  __iter__(*args, **kwargs)
     |   |  
     |   |  __le__(self, other)
     |   |      value <= value -> bool
     |   |      value.le(value) -> bool
     |   |      
     |   |      Test if the first value is less than or equal to other.
     |   |      
     |   |      *Example* Is 2 less than or equal to 2?
     |   |      
     |   |          (r.expr(2) <= 2).run(conn)
     |   |          r.expr(2).le(2).run(conn)
     |   |  
     |   |  __lt__(self, other)
     |   |      value < value -> bool
     |   |      value.lt(value) -> bool
     |   |      
     |   |      Test if the first value is less than other.
     |   |      
     |   |      *Example* Is 2 less than 2?
     |   |      
     |   |          (r.expr(2) < 2).run(conn)
     |   |          r.expr(2).lt(2).run(conn)
     |   |  
     |   |  __mod__(self, other)
     |   |      number % number -> number
     |   |      
     |   |      Find the remainder when dividing two numbers.
     |   |      
     |   |      *Example* It's as easy as 2 % 2 = 0.
     |   |      
     |   |          (r.expr(2) % 2).run(conn)
     |   |      
     |   |      `
     |   |  
     |   |  __mul__(self, other)
     |   |      number * number -> number
     |   |      array * number -> array
     |   |      
     |   |      Multiply two numbers, or make a periodic array.
     |   |      
     |   |      *Example* It's as easy as 2 * 2 = 4.
     |   |      
     |   |          (r.expr(2) * 2).run(conn)
     |   |      
     |   |      *Example* Arrays can be multiplied by numbers as well.
     |   |      
     |   |          (r.expr(["This", "is", "the", "song", "that", "never", "ends."]) * 100).run(conn)
     |   |  
     |   |  __ne__(self, other)
     |   |      value != value -> bool
     |   |      value.ne(value) -> bool
     |   |      
     |   |      Test if two values are not equal.
     |   |      
     |   |      *Example* Does 2 not equal 2?
     |   |      
     |   |          (r.expr(2) != 2).run(conn)
     |   |          r.expr(2).ne(2).run(conn)
     |   |  
     |   |  __or__(self, other)
     |   |      bool | bool -> bool
     |   |      bool.or_(bool[, bool, ...]) -> bool
     |   |      r.or_(bool, bool) -> bool
     |   |      
     |   |      Compute the logical "or" of two or more values. The `or_` command can be used as an infix operator after its first argument (`r.expr(True).or_(False)`) or given all of its arguments as parameters (`r.or_(True, False)`). The standard Python or operator, `|`, may also be used with ReQL.
     |   |      
     |   |      *Example* Return whether either `a` or `b` evaluate to true.
     |   |      
     |   |          > a = True
     |   |          > b = False
     |   |          > (r.expr(a) | b).run(conn)
     |   |          
     |   |          True
     |   |      
     |   |      *Example* Return whether any of `x`, `y` or `z` evaluate to true.
     |   |      
     |   |          > x = False
     |   |          > y = False
     |   |          > z = False
     |   |          > r.or_(x, y, z).run(conn)
     |   |          
     |   |          False
     |   |      
     |   |      __Note:__ When using `or` inside a `filter` predicate to test the values of fields that may not exist on the documents being tested, you should use the `default` command with those fields so they explicitly return `False`.
     |   |      
     |   |          r.table('posts').filter(lambda post:
     |   |              post['category'].default('foo').eq('article').or(
     |   |                  post['genre'].default('foo').eq('mystery'))
     |   |          ).run(conn)
     |   |  
     |   |  __radd__(self, other)
     |   |  
     |   |  __rand__(self, other)
     |   |  
     |   |  __rdiv__(self, other)
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  __rmod__(self, other)
     |   |  
     |   |  __rmul__(self, other)
     |   |  
     |   |  __ror__(self, other)
     |   |  
     |   |  __rsub__(self, other)
     |   |  
     |   |  __rtruediv__(self, other)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  __sub__(self, other)
     |   |      number - number -> number
     |   |      time - time -> number
     |   |      time - number -> time
     |   |      
     |   |      Subtract two numbers.
     |   |      
     |   |      *Example* It's as easy as 2 - 2 = 0.
     |   |      
     |   |          (r.expr(2) - 2).run(conn)
     |   |      
     |   |      *Example* Create a date one year ago today.
     |   |      
     |   |          r.now() - 365*24*60*60
     |   |      
     |   |      *Example* Retrieve how many seconds elapsed between today and date
     |   |      
     |   |          r.now() - date
     |   |  
     |   |  __truediv__(self, other)
     |   |  
     |   |  add(self, *args)
     |   |  
     |   |  and_(self, *args)
     |   |  
     |   |  append(self, *args)
     |   |      array.append(value) -> array
     |   |      
     |   |      Append a value to an array.
     |   |      
     |   |      *Example* Retrieve Iron Man's equipment list with the addition of some new boots.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].append('newBoots').run(conn)
     |   |  
     |   |  avg(self, *args)
     |   |      sequence.avg([field_or_function]) -> number
     |   |      
     |   |      Averages all the elements of a sequence.  If called with a field name,
     |   |      averages all the values of that field in the sequence, skipping
     |   |      elements of the sequence that lack that field.  If called with a
     |   |      function, calls that function on every element of the sequence and
     |   |      averages the results, skipping elements of the sequence where that
     |   |      function returns `None` or a non-existence error.
     |   |      
     |   |      Produces a non-existence error when called on an empty sequence.  You
     |   |      can handle this case with `default`.
     |   |      
     |   |      *Example* What's the average of 3, 5, and 7?
     |   |      
     |   |          r.expr([3, 5, 7]).avg().run(conn)
     |   |      
     |   |      *Example* What's the average number of points scored in a game?
     |   |      
     |   |          r.table('games').avg('points').run(conn)
     |   |      
     |   |      *Example* What's the average number of points scored in a game,
     |   |      counting bonus points?
     |   |      
     |   |          r.table('games').avg(lambda game:
     |   |              game['points'] + game['bonus_points']
     |   |          ).run(conn)
     |   |      
     |   |      *Example* What's the average number of points scored in a game?
     |   |      (But return `None` instead of raising an error if there are no games where
     |   |      points have been scored.)
     |   |      
     |   |          r.table('games').avg('points').default(None).run(conn)
     |   |  
     |   |  between(self, *args, **kwargs)
     |   |      table.between(lower_key, upper_key[, index='id', left_bound='closed', right_bound='open'])
     |   |          -> selection
     |   |      
     |   |      Get all documents between two keys. Accepts three optional arguments: `index`, `left_bound`, and `right_bound`. If `index` is set to the name of a secondary index, `between` will return all documents where that index's value is in the specified range (it uses the primary key by default). `left_bound` or `right_bound` may be set to `open` or `closed` to indicate whether or not to include that endpoint of the range (by default, `left_bound` is closed and `right_bound` is open).
     |   |      
     |   |      You may also use the special constants `r.minval` and `r.maxval` for boundaries, which represent "less than any index key" and "more than any index key" respectively. For instance, if you use `r.minval` as the lower key, then `between` will return all documents whose primary keys (or indexes) are less than the specified upper key.
     |   |      
     |   |      Note that compound indexes are sorted using [lexicographical order][lo]. Take the following range as an example:
     |   |      
     |   |              [[1, "c"] ... [5, "e"]]
     |   |      
     |   |      This range includes all compound keys:
     |   |      
     |   |      * whose first item is 1 and second item is equal or greater than "c";
     |   |      * whose first item is between 1 and 5, *regardless of the value of the second item*;
     |   |      * whose first item is 5 and second item is less than or equal to "e".
     |   |      
     |   |      [lo]: https://en.wikipedia.org/wiki/Lexicographical_order
     |   |      
     |   |      *Example* Find all users with primary key >= 10 and < 20 (a normal half-open interval).
     |   |      
     |   |          r.table('marvel').between(10, 20).run(conn)
     |   |      
     |   |      *Example* Find all users with primary key >= 10 and <= 20 (an interval closed on both sides).
     |   |      
     |   |          r.table('marvel').between(10, 20, right_bound='closed').run(conn)
     |   |      
     |   |      *Example* Find all users with primary key < 20.
     |   |      
     |   |          r.table('marvel').between(r.minval, 20).run(conn)
     |   |      
     |   |      *Example* Find all users with primary key > 10.
     |   |      
     |   |          r.table('marvel').between(10, r.maxval, left_bound='open').run(conn)
     |   |      
     |   |      *Example* Between can be used on secondary indexes too. Just pass an optional index argument giving the secondary index to query.
     |   |      
     |   |          r.table('dc').between('dark_knight', 'man_of_steel', index='code_name').run(conn)
     |   |      
     |   |      *Example* Get all users whose full name is between "John Smith" and "Wade Welles."
     |   |      
     |   |          r.table("users").between(["Smith", "John"], ["Welles", "Wade"],
     |   |              index="full_name").run(conn)
     |   |      
     |   |      *Example* Subscribe to a [changefeed](http://rethinkdb.com/docs/changefeeds/javascript) of teams ranked in the top 10.
     |   |      
     |   |          changes = r.table("teams").between(1, 11, index="rank").changes().run(conn)
     |   |      
     |   |      __Note:__ Between works with secondary indexes on date fields, but will not work with unindexed date fields. To test whether a date value is between two other dates, use the [during](http://rethinkdb.com/api/python/during) command, not `between`.
     |   |      
     |   |      Secondary indexes can be used in extremely powerful ways with `between` and other commands; read the full article on [secondary indexes](http://rethinkdb.com/docs/secondary-indexes) for examples using boolean operations, `contains` and more.
     |   |      
     |   |      __Note:__ RethinkDB uses byte-wise ordering for `between` and does not support Unicode collations; non-ASCII characters will be sorted by UTF-8 codepoint.
     |   |  
     |   |  build(self)
     |   |      # Compile this query to a json-serializable object
     |   |  
     |   |  change_at(self, *args)
     |   |      array.change_at(index, value) -> array
     |   |      
     |   |      Change a value in an array at a given index. Returns the modified array.
     |   |      
     |   |      *Example* Bruce Banner hulks out.
     |   |      
     |   |          r.expr(["Iron Man", "Bruce", "Spider-Man"]).change_at(1, "Hulk").run(conn)
     |   |  
     |   |  changes(self, *args, **kwargs)
     |   |      table.changes(squash=True, include_states=False) -> stream
     |   |      singleSelection.changes(squash=True, include_states=False) -> stream
     |   |      
     |   |      Return an infinite stream of objects representing changes to a query.
     |   |      
     |   |      The `squash` optional argument controls how `changes` batches change notifications:
     |   |      
     |   |      * `True`: When multiple changes to the same document occur before a batch of notifications is sent, the changes are "squashed" into one change. The client receives a notification that will bring it fully up to date with the server. This is the default.
     |   |      * `False`: All changes will be sent to the client verbatim.
     |   |      * `n`: A numeric value (floating point). Similar to `True`, but the server will wait `n` seconds to respond in order to squash as many changes together as possible, reducing network traffic.
     |   |      
     |   |      If the `include_states` optional argument is `True`, the changefeed stream will include special status documents consisting of the field `state` and a string indicating a change in the feed's state. These documents can occur at any point in the feed between the notification documents described below. There are currently two states:
     |   |      
     |   |      * `{"state": "initializing"}` indicates the following documents represent initial values on the feed rather than changes. This will be the first document of a feed that returns initial values.
     |   |      * `{"state": "ready"}` indicates the following documents represent changes. This will be the first document of a feed that does *not* return initial values; otherwise, it will indicate the initial values have all been sent.
     |   |      
     |   |      If `include_states` is `False` (the default), the status documents will not be sent on the feed.
     |   |      
     |   |      If the table becomes unavailable, the changefeed will be disconnected, and a runtime exception will be thrown by the driver.
     |   |      
     |   |      Changefeed notifications take the form of a two-field object:
     |   |      
     |   |          {
     |   |              "old_val": <document before change>,
     |   |              "new_val": <document after change>
     |   |          }
     |   |      
     |   |      The first notification object in the changefeed stream will contain the query's initial value in `new_val` and have no `old_val` field. When a document is deleted, `new_val` will be `None`; when a document is inserted, `old_val` will be `None`.
     |   |      
     |   |      Certain document transformation commands can be chained before changefeeds. For more information, read the [discussion of changefeeds](http://rethinkdb.com/docs/changefeeds/python/) in the "Query language" documentation.
     |   |      
     |   |      The server will buffer up to 100,000 elements. If the buffer limit is hit, early changes will be discarded, and the client will receive an object of the form `{"error": "Changefeed cache over array size limit, skipped X elements."}` where `X` is the number of elements skipped.
     |   |      
     |   |      Commands that operate on streams (such as `filter` or `map`) can usually be chained after `changes`.  However, since the stream produced by `changes` has no ending, commands that need to consume the entire stream before returning (such as `reduce` or `count`) cannot.
     |   |      
     |   |      It's a good idea to open changefeeds on their own connection. If you don't, other queries run on the same connection will experience unpredictable latency spikes while the connection blocks on more changes.
     |   |      
     |   |      *Example* Subscribe to the changes on a table.
     |   |      
     |   |      Start monitoring the changefeed in one client:
     |   |      
     |   |          for change in r.table('games').changes().run(conn):
     |   |            print change
     |   |      
     |   |      As these queries are performed in a second client, the first client would receive and print the following objects:
     |   |      
     |   |          > r.table('games').insert({'id': 1}).run(conn)
     |   |          {'old_val': None, 'new_val': {'id': 1}}
     |   |          
     |   |          > r.table('games').get(1).update({'player1': 'Bob'}).run(conn)
     |   |          {'old_val': {'id': 1}, 'new_val': {'id': 1, 'player1': 'Bob'}}
     |   |          
     |   |          > r.table('games').get(1).replace({'id': 1, 'player1': 'Bob', 'player2': 'Alice'}).run(conn)
     |   |          {'old_val': {'id': 1, 'player1': 'Bob'},
     |   |           'new_val': {'id': 1, 'player1': 'Bob', 'player2': 'Alice'}}
     |   |          
     |   |          > r.table('games').get(1).delete().run(conn)
     |   |          {'old_val': {'id': 1, 'player1': 'Bob', 'player2': 'Alice'}, 'new_val': None}
     |   |          
     |   |          > r.table_drop('games').run(conn)
     |   |          RqlRuntimeError: Changefeed aborted (table unavailable)
     |   |      
     |   |      *Example* Return all the changes that increase a player's score.
     |   |      
     |   |          r.table('test').changes().filter(
     |   |            r.row['new_val']['score'] > r.row['old_val']['score']
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Return all the changes to Bob's score.
     |   |      
     |   |          # Note that this will have to look at and discard all the changes to
     |   |          # rows besides Bob's.  This is currently no way to filter with an index
     |   |          # on changefeeds.
     |   |          r.table('test').changes().filter(r.row['new_val']['name'].eq('Bob')).run(conn)
     |   |      
     |   |      *Example* Return all the inserts on a table.
     |   |      
     |   |          r.table('test').changes().filter(r.row['old_val'].eq(None)).run(conn)
     |   |      
     |   |      *Example* Return all the changes to game 1.
     |   |      
     |   |          r.table('games').get(1).changes().run(conn)
     |   |      
     |   |      *Example* Return all the changes to the top 10 games. This assumes the presence of a `score` secondary index on the `games` table.
     |   |      
     |   |          r.table('games').order_by(index=r.desc('score')).limit(10).run(conn)
     |   |  
     |   |  coerce_to(self, *args)
     |   |      sequence.coerce_to('array') -> array
     |   |      value.coerce_to('string') -> string
     |   |      string.coerce_to('number') -> number
     |   |      array.coerce_to('object') -> object
     |   |      object.coerce_to('array') -> array
     |   |      binary.coerce_to('string') -> string
     |   |      string.coerce_to('binary') -> binary
     |   |      
     |   |      Convert a value of one type into another.
     |   |      
     |   |      * a sequence, selection or object can be coerced to an array
     |   |      * an array of key-value pairs can be coerced to an object
     |   |      * a string can be coerced to a number
     |   |      * any datum (single value) can be coerced to a string
     |   |      * a binary object can be coerced to a string and vice-versa
     |   |      
     |   |      *Example* Coerce a stream to an array to store its output in a field. (A stream cannot be stored in a field directly.)
     |   |      
     |   |          r.table('posts').map(lambda post: post.merge(
     |   |              { 'comments': r.table('comments').get_all(post['id'], index='post_id').coerce_to('array') }
     |   |          )).run(conn)
     |   |      
     |   |      *Example* Coerce an array of pairs into an object.
     |   |      
     |   |          r.expr([['name', 'Ironman'], ['victories', 2000]]).coerce_to('object').run(conn)
     |   |      
     |   |      __Note:__ To coerce a list of key-value pairs like `['name', 'Ironman', 'victories', 2000]` to an object, use the [object](http://rethinkdb.com/api/python/object) command.
     |   |      
     |   |      *Example* Coerce a number to a string.
     |   |      
     |   |          r.expr(1).coerce_to('string').run(conn)
     |   |  
     |   |  concat_map(self, *args)
     |   |      stream.concat_map(mapping_function) -> stream
     |   |      array.concat_map(mapping_function) -> array
     |   |      
     |   |      Concatenate one or more elements into a single sequence using a mapping function.
     |   |      
     |   |      `concat_map` works in a similar fashion to `map`, applying the given function to each element in a sequence, but it will always return a single sequence. If the mapping function returns a sequence, `map` would produce a sequence of sequences:
     |   |      
     |   |          r.expr([1, 2, 3]).map(lambda x: [x, x.mul(2)]).run(conn)
     |   |      
     |   |      Result:
     |   |      
     |   |          [[1, 2], [2, 4], [3, 6]]
     |   |      
     |   |      Whereas `concat_map` with the same mapping function would merge those sequences into one:
     |   |      
     |   |          r.expr([1, 2, 3]).concat_map(lambda x: [x, x.mul(2)]).run(conn)
     |   |      
     |   |      Result:
     |   |      
     |   |          [1, 2, 2, 4, 3, 6]
     |   |      
     |   |      The return value, array or stream, will be the same type as the input.
     |   |      
     |   |      *Example* Construct a sequence of all monsters defeated by Marvel heroes. The field "defeatedMonsters" is an array of one or more monster names.
     |   |      
     |   |          r.table('marvel').concat_map(lambda hero: hero['defeatedMonsters']).run(conn)
     |   |      
     |   |      *Example* Simulate an [eq_join](http://rethinkdb.com/api/python/eq_join/) using `concat_map`. (This is how ReQL joins are implemented internally.)
     |   |      
     |   |          r.table('posts').concat_map(
     |   |              lambda post: r.table('comments').get_all(
     |   |                  post['id'], index='post_id'
     |   |              ).map(
     |   |                  lambda comment: { 'left': post, 'right': comment}
     |   |              )
     |   |          ).run(conn)
     |   |  
     |   |  contains(self, *args)
     |   |      sequence.contains(value1[, value2...]) -> bool
     |   |      sequence.contains(predicate1[, predicate2...]) -> bool
     |   |      
     |   |      When called with values, returns `True` if a sequence contains all the
     |   |      specified values.  When called with predicate functions, returns `True`
     |   |      if for each predicate there exists at least one element of the stream
     |   |      where that predicate returns `True`.
     |   |      
     |   |      *Example* Has Iron Man ever fought Superman?
     |   |      
     |   |          r.table('marvel').get('ironman')['opponents'].contains('superman').run(conn)
     |   |      
     |   |      *Example* Has Iron Man ever defeated Superman in battle?
     |   |      
     |   |          r.table('marvel').get('ironman')['battles'].contains(lambda battle:
     |   |              (battle['winner'] == 'ironman') & (battle['loser'] == 'superman')
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Use `contains` with a predicate function to simulate an `or`. Return the Marvel superheroes who live in Detroit, Chicago or Hoboken.
     |   |      
     |   |          r.table('marvel').filter(
     |   |              lambda hero: r.expr(['Detroit', 'Chicago', 'Hoboken']).contains(hero['city'])
     |   |          ).run(conn)
     |   |  
     |   |  count(self, *args)
     |   |      sequence.count([value_or_predicate]) -> number
     |   |      binary.count() -> number
     |   |      
     |   |      Counts the number of elements in a sequence.  If called with a value,
     |   |      counts the number of times that value occurs in the sequence.  If
     |   |      called with a predicate function, counts the number of elements in the
     |   |      sequence where that function returns `True`.
     |   |      
     |   |      If `count` is called on a [binary](http://rethinkdb.com/api/python/binary) object, it will return the size of the object in bytes.
     |   |      
     |   |      *Example* Count the number of users.
     |   |      
     |   |          r.table('users').count().run(conn)
     |   |      
     |   |      *Example* Count the number of 18 year old users.
     |   |      
     |   |          r.table('users')['age'].count(18).run(conn)
     |   |      
     |   |      *Example* Count the number of users over 18.
     |   |      
     |   |          r.table('users')['age'].count(lambda age: age > 18).run(conn)
     |   |      
     |   |          r.table('users').count(lambda user: user['age'] > 18).run(conn)
     |   |  
     |   |  date(self, *args)
     |   |      time.date() -> time
     |   |      
     |   |      Return a new time object only based on the day, month and year (ie. the same day at 00:00).
     |   |      
     |   |      *Example* Retrieve all the users whose birthday is today
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user["birthdate"].date() == r.now().date()
     |   |          ).run(conn)
     |   |  
     |   |  day(self, *args)
     |   |      time.day() -> number
     |   |      
     |   |      Return the day of a time object as a number between 1 and 31.
     |   |      
     |   |      *Example* Return the users born on the 24th of any month.
     |   |      
     |   |          r.table("users").filter(
     |   |              r.row["birthdate"].day() == 24
     |   |          )
     |   |  
     |   |  day_of_week(self, *args)
     |   |      time.day_of_week() -> number
     |   |      
     |   |      Return the day of week of a time object as a number between 1 and 7 (following ISO 8601 standard). For your convenience, the terms r.monday, r.tuesday etc. are defined and map to the appropriate integer.
     |   |      
     |   |      *Example* Return today's day of week.
     |   |      
     |   |          r.now().day_of_week().run(conn)
     |   |      
     |   |      *Example* Retrieve all the users who were born on a Tuesday.
     |   |      
     |   |          r.table("users").filter( lambda user:
     |   |              user["birthdate"].day_of_week().eq(r.tuesday)
     |   |          )
     |   |  
     |   |  day_of_year(self, *args)
     |   |      time.day_of_year() -> number
     |   |      
     |   |      Return the day of the year of a time object as a number between 1 and 366 (following ISO 8601 standard).
     |   |      
     |   |      *Example* Retrieve all the users who were born the first day of a year.
     |   |      
     |   |          r.table("users").filter(
     |   |              r.row["birthdate"].day_of_year() == 1
     |   |          ).run(conn)
     |   |  
     |   |  default(self, *args)
     |   |      value.default(default_value) -> any
     |   |      sequence.default(default_value) -> any
     |   |      
     |   |      Handle non-existence errors. Tries to evaluate and return its first argument. If an
     |   |      error related to the absence of a value is thrown in the process, or if its first
     |   |      argument returns `None`, returns its second argument. (Alternatively, the second argument
     |   |      may be a function which will be called with either the text of the non-existence error
     |   |      or `None`.)
     |   |      
     |   |      *Example* Suppose we want to retrieve the titles and authors of the table `posts`.
     |   |      In the case where the author field is missing or `None`, we want to retrieve the string
     |   |      `Anonymous`.
     |   |      
     |   |          r.table("posts").map(lambda post:
     |   |              {
     |   |                  "title": post["title"],
     |   |                  "author": post["author"].default("Anonymous")
     |   |              }
     |   |          ).run(conn)
     |   |      
     |   |      We can rewrite the previous query with `r.branch` too.
     |   |      
     |   |          r.table("posts").map(lambda post:
     |   |              r.branch(
     |   |                  post.has_fields("author"),
     |   |                  {
     |   |                      "title": post["title"],
     |   |                      "author": post["author"]
     |   |                  },
     |   |                  {
     |   |                      "title": post["title"],
     |   |                      "author": "Anonymous" 
     |   |                  }
     |   |              )
     |   |          ).run(conn)
     |   |      
     |   |      *Example* The `default` command can be useful to filter documents too. Suppose
     |   |      we want to retrieve all our users who are not grown-ups or whose age is unknown
     |   |      (i.e the field `age` is missing or equals `None`). We can do it with this query:
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              (user["age"] < 18).default(True)
     |   |          ).run(conn)
     |   |      
     |   |      One more way to write the previous query is to set the age to be `-1` when the
     |   |      field is missing.
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user["age"].default(-1) < 18
     |   |          ).run(conn)
     |   |      
     |   |      One last way to do the same query is to use `has_fields`.
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user.has_fields("age").not_() | (user["age"] < 18)
     |   |          ).run(conn)
     |   |      
     |   |      The body of every `filter` is wrapped in an implicit `.default(False)`. You can overwrite
     |   |      the value `False` by passing an option in filter, so the previous query can also be
     |   |      written like this.
     |   |      
     |   |          r.table("users").filter(
     |   |              lambda user: (user["age"] < 18).default(True),
     |   |              default=True
     |   |          ).run(conn)
     |   |  
     |   |  delete(self, *args, **kwargs)
     |   |      table.delete([durability="hard", return_changes=False])
     |   |          -> object
     |   |      selection.delete([durability="hard", return_changes=False])
     |   |          -> object
     |   |      singleSelection.delete([durability="hard", return_changes=False])
     |   |          -> object
     |   |      
     |   |      Delete one or more documents from a table.
     |   |      
     |   |      The optional arguments are:
     |   |      
     |   |      - `durability`: possible values are `hard` and `soft`. This option will override the
     |   |      table or query's durability setting (set in [run](http://rethinkdb.com/api/python/run/)).  
     |   |      In soft durability mode RethinkDB will acknowledge the write immediately after
     |   |      receiving it, but before the write has been committed to disk.
     |   |      - `return_changes`: if set to `True`, return a `changes` array consisting of `old_val`/`new_val` objects describing the changes made.
     |   |      
     |   |      Delete returns an object that contains the following attributes:
     |   |      
     |   |      - `deleted`: the number of documents that were deleted.
     |   |      - `skipped`: the number of documents that were skipped.  
     |   |      For example, if you attempt to delete a batch of documents, and another concurrent query
     |   |      deletes some of those documents first, they will be counted as skipped.
     |   |      - `errors`: the number of errors encountered while performing the delete.
     |   |      - `first_error`: If errors were encountered, contains the text of the first error.
     |   |      - `inserted`, `replaced`, and `unchanged`: all 0 for a delete operation.
     |   |      - `changes`: if `return_changes` is set to `True`, this will be an array of objects, one for each objected affected by the `delete` operation. Each object will have two keys: `{"new_val": None, "old_val": <old value>}`.
     |   |      
     |   |      *Example* Delete a single document from the table `comments`.
     |   |      
     |   |          r.table("comments").get("7eab9e63-73f1-4f33-8ce4-95cbea626f59").delete().run(conn)
     |   |      
     |   |      *Example* Delete all documents from the table `comments`.
     |   |      
     |   |          r.table("comments").delete().run(conn)
     |   |      
     |   |      *Example* Delete all comments where the field `id_post` is `3`.
     |   |      
     |   |          r.table("comments").filter({"id_post": 3}).delete().run(conn)
     |   |      
     |   |      *Example* Delete a single document from the table `comments` and return its value.
     |   |      
     |   |          r.table("comments").get("7eab9e63-73f1-4f33-8ce4-95cbea626f59").delete(return_changes=True).run(conn)
     |   |      
     |   |      The result will look like:
     |   |      
     |   |          {
     |   |              "deleted": 1,
     |   |              "errors": 0,
     |   |              "inserted": 0,
     |   |              "changes": [
     |   |                  {
     |   |                      "new_val": None,
     |   |                      "old_val": {
     |   |                          "id": "7eab9e63-73f1-4f33-8ce4-95cbea626f59",
     |   |                          "author": "William",
     |   |                          "comment": "Great post",
     |   |                          "id_post": 3
     |   |                      }
     |   |                  }
     |   |              ],
     |   |              "replaced": 0,
     |   |              "skipped": 0,
     |   |              "unchanged": 0
     |   |          }
     |   |      
     |   |      *Example* Delete all documents from the table `comments` without waiting for the
     |   |      operation to be flushed to disk.
     |   |      
     |   |          r.table("comments").delete(durability="soft"}).run(conn)
     |   |  
     |   |  delete_at(self, *args)
     |   |      array.delete_at(index [,endIndex]) -> array
     |   |      
     |   |      Remove one or more elements from an array at a given index. Returns the modified array. (Note: `delete_at` operates on arrays, not documents; to delete documents, see the [delete](http://rethinkdb.com/api/python/delete) command.)
     |   |      
     |   |      If only `index` is specified, `delete_at` removes the element at that index. If both `index` and `end_index` are specified, `delete_at` removes the range of elements between `index` and `end_index`, inclusive of `index` but not inclusive of `end_index`.
     |   |      
     |   |      If `end_index` is specified, it must not be less than `index`. Both `index` and `end_index` must be within the array's bounds (i.e., if the array has 10 elements, an `index` or `end_index` of 10 or higher is invalid).
     |   |      
     |   |      By using a negative `index` you can delete from the end of the array. `-1` is the last element in the array, `-2` is the second-to-last element, and so on. You may specify a negative `end_index`, although just as with a positive value, this will not be inclusive. The range `(2,-1)` specifies the third element through the next-to-last element.
     |   |      
     |   |      *Example* Delete the second element of an array.
     |   |      
     |   |          > r.expr(['a','b','c','d','e','f']).delete_at(1).run(conn)
     |   |          
     |   |          ['a', 'c', 'd', 'e', 'f']
     |   |      
     |   |      *Example* Delete the second and third elements of an array.
     |   |      
     |   |          > r.expr(['a','b','c','d','e','f']).delete_at(1,3).run(conn)
     |   |          
     |   |          ['a', 'd', 'e', 'f']
     |   |      
     |   |      *Example* Delete the next-to-last element of an array.
     |   |      
     |   |          > r.expr(['a','b','c','d','e','f']).delete_at(-2).run(conn)
     |   |          
     |   |          ['a', 'b', 'c', 'd', 'f']
     |   |      
     |   |      *Example* Delete a comment on a post.
     |   |      
     |   |      Given a post document such as:
     |   |      
     |   |      {
     |   |          id: '4cf47834-b6f9-438f-9dec-74087e84eb63',
     |   |          title: 'Post title',
     |   |          author: 'Bob',
     |   |          comments: [
     |   |              { author: 'Agatha', text: 'Comment 1' },
     |   |              { author: 'Fred', text: 'Comment 2' }
     |   |          ]
     |   |      }
     |   |      
     |   |      The second comment can be deleted by using `update` and `delete_at` together.
     |   |      
     |   |          r.table('posts').get('4cf47834-b6f9-438f-9dec-74087e84eb63').update(
     |   |              lambda post: { 'comments': post['comments'].delete_at(1) }
     |   |          ).run(conn)
     |   |  
     |   |  difference(self, *args)
     |   |      array.difference(array) -> array
     |   |      
     |   |      Remove the elements of one array from another array.
     |   |      
     |   |      *Example* Retrieve Iron Man's equipment list without boots.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].difference(['Boots']).run(conn)
     |   |      
     |   |      *Example* Remove Iron Man's boots from his equipment.
     |   |      
     |   |          r.table('marvel').get('IronMan')[:equipment].update(lambda doc:
     |   |              {'equipment': doc['equipment'].difference(['Boots'])}
     |   |          ).run(conn)
     |   |  
     |   |  distance(self, *args, **kwargs)
     |   |      geometry.distance(geometry[, geo_system='WGS84', unit='m']) -> number
     |   |      
     |   |      Compute the distance between a point and another geometry object. At least one of the geometry objects specified must be a point.
     |   |      
     |   |      Optional arguments available with `distance` are:
     |   |      
     |   |      * `geo_system`: the reference ellipsoid to use for geographic coordinates. Possible values are `WGS84` (the default), a common standard for Earth's geometry, or `unit_sphere`, a perfect sphere of 1 meter radius.
     |   |      * `unit`: Unit to return the distance in. Possible values are `m` (meter, the default), `km` (kilometer), `mi` (international mile), `nm` (nautical mile), `ft` (international foot).
     |   |      
     |   |      If one of the objects is a polygon or a line, the point will be projected onto the line or polygon assuming a perfect sphere model before the distance is computed (using the model specified with `geo_system`). As a consequence, if the polygon or line is extremely large compared to Earth's radius and the distance is being computed with the default WGS84 model, the results of `distance` should be considered approximate due to the deviation between the ellipsoid and spherical models.
     |   |      
     |   |      *Example* Compute the distance between two points on the Earth in kilometers.
     |   |      
     |   |          > point1 = r.point(-122.423246,37.779388)
     |   |          > point2 = r.point(-117.220406,32.719464)
     |   |          > r.distance(point1, point2, unit='km').run(conn)
     |   |          
     |   |          734.1252496021841
     |   |  
     |   |  distinct(self, *args, **kwargs)
     |   |      sequence.distinct() -> array
     |   |      table.distinct() -> stream
     |   |      table.distinct(index=<indexname>) -> stream
     |   |      
     |   |      Removes duplicate elements from a sequence.
     |   |      
     |   |      The `distinct` command can be called on any sequence, a table, or called on a table with an index.
     |   |      
     |   |      *Example* Which unique villains have been vanquished by marvel heroes?
     |   |      
     |   |          r.table('marvel').concat_map(
     |   |              lambda hero: hero['villain_list']).distinct().run(conn)
     |   |      
     |   |      *Example* Topics in a table of messages have a secondary index on them, and more than one message can have the same topic. What are the unique topics in the table?
     |   |      
     |   |          r.table('messages').distinct(index='topics').run(conn)
     |   |      
     |   |      The above structure is functionally identical to:
     |   |      
     |   |          r.table('messages')['topics'].distinct().run(conn)
     |   |      
     |   |      However, the first form (passing the index as an argument to `distinct`) is faster, and won't run into array limit issues since it's returning a stream.
     |   |  
     |   |  div(self, *args)
     |   |  
     |   |  do(self, *args)
     |   |      any.do(function) -> any
     |   |      r.do([args]*, function) -> any
     |   |      any.do(expr) -> any
     |   |      r.do([args]*, expr) -> any
     |   |      
     |   |      Evaluate an expression and pass its values as arguments to a function or to an expression.
     |   |      
     |   |      The last argument to `do` (or, in some forms, the only argument) is an expression or an anonymous function which receives values from either the previous arguments or from prefixed commands chained before `do`. A common use, for example, would be to retrieve a document with `get` and pass it to a function via `do`. The type of `do`'s result is the type of the value returned from the function or last expression.
     |   |      
     |   |      Arguments passed to the `do` function must be basic data types, and cannot be streams or selections. (Read about [ReQL data types](http://rethinkdb.com/docs/data-types/).) While the arguments will all be evaluated before the function is executed, they may be evaluated in any order, so their values should not be dependent on one another.
     |   |      
     |   |      *Example* Compute a golfer's net score for a game.
     |   |      
     |   |          r.table('players').get('86be93eb-a112-48f5-a829-15b2cb49de1d').do(
     |   |              lambda player: player['gross_score'] - player['course_handicap']
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Return the name of the best scoring player in a two-player golf match.
     |   |      
     |   |          r.do(r.table('players').get(id1), r.table('players').get(id2),
     |   |              (lambda player1, player2:
     |   |                  r.branch(player1['gross_score'].lt(player2['gross_score']),
     |   |                  player1, player2))
     |   |          ).run(conn)
     |   |          
     |   |      
     |   |      Note that `branch`, the ReQL conditional command, must be used instead of `if`. See the `branch` [documentation](http://rethinkdb.com/api/python/branch) for more.
     |   |  
     |   |  downcase(self, *args)
     |   |      string.downcase() -> string
     |   |      
     |   |      Lowercases a string.
     |   |      
     |   |      *Example*
     |   |      
     |   |          > r.expr("Sentence about LaTeX.").downcase().run(conn)
     |   |          "sentence about latex."
     |   |      
     |   |      __Note:__ `upcase` and `downcase` only affect ASCII characters.
     |   |  
     |   |  during(self, *args, **kwargs)
     |   |      time.during(start_time, end_time[, left_bound="closed", right_bound="open"])
     |   |          -> bool
     |   |      
     |   |      Return whether a time is between two other times. By default, this is inclusive of the start time and exclusive of the end time. Set `left_bound` and `right_bound` to explicitly include (`closed`) or exclude (`open`) that endpoint of the range.
     |   |      
     |   |      *Example* Retrieve all the posts that were posted between December 1st, 2013 (inclusive) and December 10th, 2013 (exclusive).
     |   |      
     |   |          r.table("posts").filter(
     |   |              r.row['date'].during(r.time(2013, 12, 1, "Z"), r.time(2013, 12, 10, "Z"))
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Retrieve all the posts that were posted between December 1st, 2013 (exclusive) and December 10th, 2013 (inclusive).
     |   |      
     |   |          r.table("posts").filter(
     |   |              r.row['date'].during(r.time(2013, 12, 1, "Z"), r.time(2013, 12, 10, "Z"), left_bound="open", right_bound="closed")
     |   |          ).run(conn)
     |   |  
     |   |  eq(self, *args)
     |   |      value == value -> bool
     |   |      value.eq(value) -> bool
     |   |      
     |   |      Test if two values are equal.
     |   |      
     |   |      *Example* Does 2 equal 2?
     |   |      
     |   |          (r.expr(2) == 2).run(conn)
     |   |          r.expr(2).eq(2).run(conn)
     |   |  
     |   |  eq_join(self, *args, **kwargs)
     |   |      sequence.eq_join(left_field, right_table[, index='id']) -> sequence
     |   |      
     |   |      Join tables using a field on the left-hand sequence matching primary keys or secondary indexes on the right-hand table. `eq_join` is more efficient than other Re_qL join types, and operates much faster. Documents in the result set consist of pairs of left-hand and right-hand documents, matched when the field on the left-hand side exists and is non-null and an entry with that field's value exists in the specified index on the right-hand side.
     |   |      
     |   |      The result set of `eq_join` is a stream or array of objects. Each object in the returned set will be an object of the form `{ left: <left-document>, right: <right-document> }`, where the values of `left` and `right` will be the joined documents. Use the <code><a href="/api/python/zip/">zip</a></code> command to merge the `left` and `right` fields together.
     |   |      
     |   |      **Example:** Match players with the games they've played against one another.
     |   |      
     |   |      The players table contains these documents:
     |   |      
     |   |          [
     |   |              { 'id': 1, 'player': 'George', 'gameId': 1 },
     |   |              { 'id': 2, 'player': 'Agatha', 'gameId': 3 },
     |   |              { 'id': 3, 'player': 'Fred', 'gameId': 2 },
     |   |              { 'id': 4, 'player': 'Marie', 'gameId': 2 },
     |   |              { 'id': 5, 'player': 'Earnest', 'gameId': 1 },
     |   |              { 'id': 6, 'player': 'Beth', 'gameId': 3 }
     |   |          ]
     |   |      
     |   |      The games table contains these documents:
     |   |      
     |   |          [
     |   |              { 'id': 1, 'field': 'Little Delving' },
     |   |              { 'id': 2, 'field': 'Rushock Bog' },
     |   |              { 'id': 3, 'field': 'Bucklebury' }
     |   |          ]
     |   |      
     |   |      Join these tables using `game_id` on the player table and `id` on the games table:
     |   |      
     |   |          r.table('players').eq_join('game_id', r.table('games')).run(conn)
     |   |      
     |   |      This will return a result set such as the following:
     |   |      
     |   |          [
     |   |              {
     |   |                  "left" : { "gameId" : 3, "id" : 2, "player" : "Agatha" },
     |   |                  "right" : { "id" : 3, "field" : "Bucklebury" }
     |   |              },
     |   |              {
     |   |                  "left" : { "gameId" : 2, "id" : 3, "player" : "Fred" },
     |   |                  "right" : { "id" : 2, "field" : "Rushock Bog" }
     |   |              },
     |   |              ...
     |   |          ]
     |   |      
     |   |      What you likely want is the result of using `zip` with that. For clarity, we'll use `without` to drop the `id` field from the games table (it conflicts with the `id` field for the players and it's redundant anyway), and we'll order it by the games.
     |   |      
     |   |          r.table('players').eq_join('game_id', r.table('games')).without({'right': "id"}).zip().order_by('game_id').run(conn)
     |   |          
     |   |          [
     |   |              { "field": "Little Delving", "gameId": 1, "id": 5, "player": "Earnest" },
     |   |              { "field": "Little Delving", "gameId": 1, "id": 1, "player": "George" },
     |   |              { "field": "Rushock Bog", "gameId": 2, "id": 3, "player": "Fred" },
     |   |              { "field": "Rushock Bog", "gameId": 2, "id": 4, "player": "Marie" },
     |   |              { "field": "Bucklebury", "gameId": 3, "id": 6, "player": "Beth" },
     |   |              { "field": "Bucklebury", "gameId": 3, "id": 2, "player": "Agatha" }
     |   |          ]
     |   |      
     |   |      For more information, see [Table joins in Rethink_dB](http://rethinkdb.com/docs/table-joins/).
     |   |      
     |   |      **Example:** Use a secondary index on the right table rather than the primary key. If players have a secondary index on their cities, we can get a list of arenas with players in the same area.
     |   |      
     |   |          r.table('arenas').eq_join('city_id', r.table('arenas'), index='city_id').run(conn)
     |   |      
     |   |      **Example:** Use a nested key as the join field. Suppose the documents in the players table were structured like this:
     |   |      
     |   |          { 'id': 1, 'player': 'George', 'game': {'id': 1} },
     |   |          { 'id': 2, 'player': 'Agatha', 'game': {'id': 3} },
     |   |          ...
     |   |      
     |   |      Simply specify the field using the `row` command instead of a string.
     |   |      
     |   |          r.table('players').eq_join(r.row['game']['id'], r.table('games')).without({'right': 'id'}).zip().run(conn)
     |   |          
     |   |          [
     |   |              { "field": "Little Delving", "game": { "id": 1 }, "id": 5, "player": "Earnest" },
     |   |              { "field": "Little Delving", "game": { "id": 1 }, "id": 1, "player": "George" },
     |   |              ...
     |   |          ]
     |   |      
     |   |      **Example:** Use a function instead of a field to join on a more complicated expression. Suppose the players have lists of favorite games ranked in order in a field such as `"favorites": [3, 2, 1]`. Get a list of players and their top favorite:
     |   |      
     |   |          r.table('players3').eq_join(
     |   |              lambda player: player['favorites'].nth(0),
     |   |              r.table('games')
     |   |          ).without([{'left': ['favorites', 'game_id', 'id']}, {'right': 'id'}]).zip()
     |   |      
     |   |      Result:
     |   |      
     |   |          [
     |   |              { "field": "Rushock Bog", "name": "Fred" },
     |   |              { "field": "Little Delving", "name": "George" },
     |   |              ...
     |   |          ]
     |   |  
     |   |  fill(self, *args)
     |   |      line.fill() -> polygon
     |   |      
     |   |      Convert a Line object into a Polygon object. If the last point does not specify the same coordinates as the first point, `polygon` will close the polygon by connecting them.
     |   |      
     |   |      Longitude (&minus;180 to 180) and latitude (&minus;90 to 90) of vertices are plotted on a perfect sphere. See [Geospatial support](http://rethinkdb.com/docs/geo-support/) for more information on ReQL's coordinate system.
     |   |      
     |   |      If the last point does not specify the same coordinates as the first point, `polygon` will close the polygon by connecting them. You cannot directly construct a polygon with holes in it using `polygon`, but you can use [polygon_sub](http://rethinkdb.com/api/python/polygon_sub) to use a second polygon within the interior of the first to define a hole.
     |   |      
     |   |      *Example* Create a line object and then convert it to a polygon.
     |   |      
     |   |          r.table('geo').insert({
     |   |              'id': 201,
     |   |              'rectangle': r.line(
     |   |                  [-122.423246,37.779388],
     |   |                  [-122.423246,37.329898],
     |   |                  [-121.886420,37.329898],
     |   |                  [-121.886420,37.779388]
     |   |              )
     |   |          }).run(conn)
     |   |          
     |   |          r.table('geo').get(201).update({
     |   |              'rectangle': r.row('rectangle').fill()
     |   |          }).run(conn)
     |   |  
     |   |  filter(self, *args, **kwargs)
     |   |      selection.filter(predicate[, default=False]) -> selection
     |   |      stream.filter(predicate[, default=False]) -> stream
     |   |      array.filter(predicate[, default=False]) -> array
     |   |      
     |   |      Return all the elements in a sequence for which the given predicate is true. The return value of `filter` will be the same as the input (sequence, stream, or array). Documents can be filtered in a variety of ways&mdash;ranges, nested values, boolean conditions, and the results of anonymous functions.
     |   |      
     |   |      By default, `filter` will silently skip documents with missing fields: if the predicate tries to access a field that doesn't exist (for instance, the predicate `{'age': 30}` applied to a document with no `age` field), that document will not be returned in the result set, and no error will be generated. This behavior can be changed with the `default` optional argument.
     |   |      
     |   |      * If `default` is set to `True`, documents with missing fields will be returned rather than skipped.
     |   |      * If `default` is set to `r.error()`, an `RqlRuntimeError` will be thrown when a document with a missing field is tested.
     |   |      * If `default` is set to `False` (the default), documents with missing fields will be skipped.
     |   |      
     |   |      *Example* Get all users who are 30 years old.
     |   |      
     |   |          r.table('users').filter({'age': 30}).run(conn)
     |   |      
     |   |      The predicate `{'age': 30}` selects documents in the `users` table with an `age` field whose value is `30`. Documents with an `age` field set to any other value *or* with no `age` field present are skipped.
     |   |      
     |   |      While the `{'field': value}` style of predicate is useful for exact matches, a more general way to write a predicate is to use the [row](http://rethinkdb.com/api/python/row) command with a comparison operator such as [eq](http://rethinkdb.com/api/python/eq) (`==`) or [gt](http://rethinkdb.com/api/python/gt) (`>`), or to use a lambda function that returns `True` or `False`.
     |   |      
     |   |          r.table('users').filter(r.row["age"] == 30).run(conn)
     |   |      
     |   |      In this case, the predicate `r.row["age"] == 30` returns `True` if the field `age` is equal to 30. You can write this predicate as a lambda function instead:
     |   |      
     |   |          r.table('users').filter(lambda user:
     |   |              user["age"] == 30
     |   |          ).run(conn)
     |   |      
     |   |      Predicates to `filter` are evaluated on the server, and must use ReQL expressions. Some Python comparison operators are overloaded by the RethinkDB driver and will be translated to ReQL, such as `==`, `<`/`>` and `|`/`&` (note the single character form, rather than `||`/`&&`).
     |   |      
     |   |      Also, predicates must evaluate document fields. They cannot evaluate [secondary indexes](http://rethinkdb.com/docs/secondary-indexes/).
     |   |      
     |   |      *Example* Get all users who are more than 18 years old.
     |   |      
     |   |          r.table("users").filter(r.row["age"] > 18).run(conn)
     |   |      
     |   |      *Example* Get all users who are less than 18 years old and more than 13 years old.
     |   |      
     |   |          r.table("users").filter((r.row["age"] < 18) & (r.row["age"] > 13)).run(conn)
     |   |      
     |   |      *Example* Get all users who are more than 18 years old or have their parental consent.
     |   |      
     |   |          r.table("users").filter(
     |   |              (r.row["age"] >= 18) | (r.row["hasParentalConsent"])).run(conn)
     |   |      
     |   |      *Example* Retrieve all users who subscribed between January 1st, 2012
     |   |      (included) and January 1st, 2013 (excluded).
     |   |      
     |   |          r.table("users").filter(
     |   |              lambda user: user["subscription_date"].during(
     |   |                  r.time(2012, 1, 1, 'Z'), r.time(2013, 1, 1, 'Z'))
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Retrieve all users who have a gmail account (whose field `email` ends with `@gmail.com`).
     |   |      
     |   |          r.table("users").filter(
     |   |              lambda user: user["email"].match("@gmail.com$")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Filter based on the presence of a value in an array.
     |   |      
     |   |      Given this schema for the `users` table:
     |   |      
     |   |          {
     |   |              "name": <type 'str'>
     |   |              "places_visited": [<type 'str'>]
     |   |          }
     |   |      
     |   |      Retrieve all users whose field `places_visited` contains `France`.
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user["places_visited"].contains("France")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Filter based on nested fields.
     |   |      
     |   |      Given this schema for the `users` table:
     |   |      
     |   |          {
     |   |              "id": <type 'str'>
     |   |              "name": {
     |   |                  "first": <type 'str'>,
     |   |                  "middle": <type 'str'>,
     |   |                  "last": <type 'str'>
     |   |              }
     |   |          }
     |   |      
     |   |      Retrieve all users named "William Adama" (first name "William", last name
     |   |      "Adama"), with any middle name.
     |   |      
     |   |          r.table("users").filter({
     |   |              "name": {
     |   |                  "first": "William",
     |   |                  "last": "Adama"
     |   |              }
     |   |          }).run(conn)
     |   |      
     |   |      If you want an exact match for a field that is an object, you will have to use `r.literal`.
     |   |      
     |   |      Retrieve all users named "William Adama" (first name "William", last name
     |   |      "Adama"), and who do not have a middle name.
     |   |      
     |   |          r.table("users").filter(r.literal({
     |   |              "name": {
     |   |                  "first": "William",
     |   |                  "last": "Adama"
     |   |              }
     |   |          })).run(conn)
     |   |      
     |   |      You may rewrite these with lambda functions.
     |   |      
     |   |          r.table("users").filter(
     |   |              lambda user:
     |   |              (user["name"]["first"] == "William")
     |   |                  & (user["name"]["last"] == "Adama")
     |   |          ).run(conn)
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user["name"] == {
     |   |                  "first": "William",
     |   |                  "last": "Adama"
     |   |              }
     |   |          ).run(conn)
     |   |      
     |   |      By default, documents missing fields tested by the `filter` predicate are skipped. In the previous examples, users without an `age` field are not returned. By passing the optional `default` argument to `filter`, you can change this behavior.
     |   |      
     |   |      *Example* Get all users less than 18 years old or whose `age` field is missing.
     |   |      
     |   |          r.table("users").filter(r.row["age"] < 18, default=True).run(conn)
     |   |      
     |   |      *Example* Get all users more than 18 years old. Throw an error if a
     |   |      document is missing the field `age`.
     |   |      
     |   |          r.table("users").filter(r.row["age"] > 18, default=r.error()).run(conn)
     |   |      
     |   |      *Example* Get all users who have given their phone number (all the documents whose field `phone_number` exists and is not `None`).
     |   |      
     |   |          r.table('users').filter(
     |   |              lambda user: user.has_fields('phone_number')
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Get all users with an "editor" role or an "admin" privilege.
     |   |      
     |   |          r.table('users').filter(
     |   |              lambda user: (user['role'] == 'editor').default(False) |
     |   |                  (user['privilege'] == 'admin').default(False)
     |   |          ).run(conn)
     |   |      
     |   |      Instead of using the `default` optional argument to `filter`, we have to use default values on the fields within the `or` clause. Why? If the field on the left side of the `or` clause is missing from a document&mdash;in this case, if the user doesn't have a `role` field&mdash;the predicate will generate an error, and will return `False` (or the value the `default` argument is set to) without evaluating the right side of the `or`. By using `.default(False)` on the fields, each side of the `or` will evaluate to either the field's value or `False` if the field doesn't exist.
     |   |  
     |   |  for_each(self, *args)
     |   |      sequence.for_each(write_query) -> object
     |   |      
     |   |      Loop over a sequence, evaluating the given write query for each element.
     |   |      
     |   |      *Example* Now that our heroes have defeated their villains, we can safely remove them from the villain table.
     |   |      
     |   |          r.table('marvel').for_each(
     |   |              lambda hero: r.table('villains').get(hero['villainDefeated']).delete()
     |   |          ).run(conn)
     |   |  
     |   |  ge(self, *args)
     |   |      value >= value -> bool
     |   |      value.ge(value) -> bool
     |   |      
     |   |      Test if the first value is greater than or equal to other.
     |   |      
     |   |      *Example* Is 2 greater than or equal to 2?
     |   |      
     |   |          (r.expr(2) >= 2).run(conn)
     |   |          r.expr(2).ge(2).run(conn)
     |   |  
     |   |  get_field(self, *args)
     |   |      sequence.get_field(attr) -> sequence
     |   |      singleSelection.get_field(attr) -> value
     |   |      object.get_field(attr) -> value
     |   |      
     |   |      Get a single field from an object. If called on a sequence, gets that field from every
     |   |      object in the sequence, skipping objects that lack it.
     |   |      
     |   |      *Example* What was Iron Man's first appearance in a comic?
     |   |      
     |   |          r.table('marvel').get('IronMan').get_field('firstAppearance').run(conn)
     |   |  
     |   |  group(self, *args, **kwargs)
     |   |      sequence.group(field_or_function..., [index='index_name', multi=False]) -> grouped_stream
     |   |      
     |   |      Takes a stream and partitions it into multiple groups based on the
     |   |      fields or functions provided.
     |   |      
     |   |      With the `multi` flag single documents can be assigned to multiple groups, similar to the behavior of [multi-indexes](http://rethinkdb.com/docs/secondary-indexes/python). When `multi` is `True` and the grouping value is an array, documents will be placed in each group that corresponds to the elements of the array. If the array is empty the row will be ignored.
     |   |      
     |   |      *Example* Grouping games by player.
     |   |      
     |   |      Suppose that the table `games` has the following data:
     |   |      
     |   |          [
     |   |              {"id": 2, "player": "Bob", "points": 15, "type": "ranked"},
     |   |              {"id": 5, "player": "Alice", "points": 7, "type": "free"},
     |   |              {"id": 11, "player": "Bob", "points": 10, "type": "free"},
     |   |              {"id": 12, "player": "Alice", "points": 2, "type": "free"}
     |   |          ]
     |   |      
     |   |      Grouping games by player can be done with:
     |   |      
     |   |          > r.table('games').group('player').run(conn)
     |   |          
     |   |          {
     |   |              "Alice": [
     |   |                  {"id": 5, "player": "Alice", "points": 7, "type": "free"},
     |   |                  {"id": 12, "player": "Alice", "points": 2, "type": "free"}
     |   |              ],
     |   |              "Bob": [
     |   |                  {"id": 2, "player": "Bob", "points": 15, "type": "ranked"},
     |   |                  {"id": 11, "player": "Bob", "points": 10, "type": "free"}
     |   |              ]
     |   |          }
     |   |      
     |   |      Commands chained after `group` will be called on each of these grouped
     |   |      sub-streams, producing grouped data.
     |   |      
     |   |      *Example* What is each player's best game?
     |   |      
     |   |          > r.table('games').group('player').max('points').run(conn)
     |   |          
     |   |          {
     |   |              "Alice": {"id": 5, "player": "Alice", "points": 7, "type": "free"},
     |   |              "Bob": {"id": 2, "player": "Bob", "points": 15, "type": "ranked"}
     |   |          }
     |   |      
     |   |      Commands chained onto grouped data will operate on each grouped datum,
     |   |      producing more grouped data.
     |   |      
     |   |      *Example* What is the maximum number of points scored by each player?
     |   |      
     |   |          > r.table('games').group('player').max('points')['points'].run(conn)
     |   |          
     |   |          {
     |   |              "Alice": 7,
     |   |              "Bob": 15
     |   |          }
     |   |      
     |   |      You can also group by more than one field.
     |   |      
     |   |      *Example* What is the maximum number of points scored by each
     |   |      player for each game type?
     |   |      
     |   |          > r.table('games').group('player', 'type').max('points')['points'].run(conn)
     |   |          
     |   |          {
     |   |              ("Alice", "free"): 7,
     |   |              ("Bob", "free"): 10,
     |   |              ("Bob", "ranked"): 15
     |   |          }
     |   |      
     |   |      You can also group by a function.
     |   |      
     |   |      *Example* What is the maximum number of points scored by each
     |   |      player for each game type?
     |   |      
     |   |          > r.table('games')
     |   |              .group(lambda game:
     |   |                  game.pluck('player', 'type')
     |   |              ).max('points')['points'].run(conn)
     |   |          
     |   |          {
     |   |              frozenset([('player', 'Alice'), ('type', 'free')]): 7,
     |   |              frozenset([('player', 'Bob'), ('type', 'free')]): 10,
     |   |              frozenset([('player', 'Bob'), ('type', 'ranked')]): 15,
     |   |          }
     |   |      
     |   |      Using a function, you can also group by date on a ReQL [date field](http://rethinkdb.com/docs/dates-and-times/javascript/).
     |   |      
     |   |      *Example* How many matches have been played this year by month?
     |   |      
     |   |          > r.table('matches').group(
     |   |                lambda match: [match['date'].year(), match['date'].month()]
     |   |            ).count().run(conn)
     |   |          
     |   |          {
     |   |              (2014, 2): 2,
     |   |              (2014, 3): 2,
     |   |              (2014, 4): 1,
     |   |              (2014, 5): 3
     |   |          }
     |   |      
     |   |      You can also group by an index.
     |   |      
     |   |      *Example* What is the maximum number of points scored by game type?
     |   |      
     |   |          > r.table('games').group(index='type').max('points')['points'].run(conn)
     |   |          
     |   |          {
     |   |              "free": 10,
     |   |              "ranked": 15
     |   |          }
     |   |      
     |   |      Suppose that the table `games2` has the following data:
     |   |      
     |   |          [
     |   |              { 'id': 1, 'matches': {'a': [1, 2, 3], 'b': [4, 5, 6]} },
     |   |              { 'id': 2, 'matches': {'b': [100], 'c': [7, 8, 9]} },
     |   |              { 'id': 3, 'matches': {'a': [10, 20], 'c': [70, 80]} }
     |   |          ]
     |   |      
     |   |      Using the `multi` option we can group data by match A, B or C.
     |   |      
     |   |          > r.table('games2').group(r.row['matches'].keys(), multi=True).run(conn)
     |   |          
     |   |          [
     |   |              {
     |   |                  'group': 'a',
     |   |                  'reduction': [ <id 1>, <id 3> ]
     |   |              },
     |   |              {
     |   |                  'group': 'b',
     |   |                  'reduction': [ <id 1>, <id 2> ]
     |   |              },
     |   |              {
     |   |                  'group': 'c',
     |   |                  'reduction': [ <id 2>, <id 3> ]
     |   |              }
     |   |          ]
     |   |      
     |   |      (The full result set is abbreviated in the figure; `<id 1>, <id 2>` and `<id 3>` would be the entire documents matching those keys.)
     |   |      
     |   |      *Example* Use [map](http://rethinkdb.com/api/python/map) and [sum](http://rethinkdb.com/api/python/sum) to get the total points scored for each match.
     |   |      
     |   |          r.table('games2').group(r.row['matches'].keys(), multi=True).ungroup().map(
     |   |              lambda doc: { 'match': doc['group'], 'total': doc['reduction'].sum(
     |   |                  lambda set: set['matches'][doc['group']].sum()
     |   |              )}).run(conn)
     |   |          
     |   |          [
     |   |              { 'match': 'a', 'total': 36 },
     |   |              { 'match': 'b', 'total': 115 },
     |   |              { 'match': 'c', 'total': 174 }
     |   |          ]
     |   |      
     |   |      The inner `sum` adds the scores by match within each document; the outer `sum` adds those results together for a total across all the documents.
     |   |      
     |   |      If you want to operate on all the groups rather than operating on each
     |   |      group (e.g. if you want to order the groups by their reduction), you
     |   |      can use [ungroup](http://rethinkdb.com/api/python/ungroup/) to turn a grouped stream or
     |   |      grouped data into an array of objects representing the groups.
     |   |      
     |   |      *Example* Ungrouping grouped data.
     |   |      
     |   |          > r.table('games').group('player').max('points')['points'].ungroup().run(conn)
     |   |          
     |   |          [
     |   |              {
     |   |                  "group": "Alice",
     |   |                  "reduction": 7
     |   |              },
     |   |              {
     |   |                  "group": "Bob",
     |   |                  "reduction": 15
     |   |              }
     |   |          ]
     |   |      
     |   |      Ungrouping is useful e.g. for ordering grouped data, or for inserting
     |   |      grouped data into a table.
     |   |      
     |   |      *Example* What is the maximum number of points scored by each
     |   |      player, with the highest scorers first?
     |   |      
     |   |          > r.table('games').group('player').max('points')['points'].ungroup().order_by(
     |   |                  r.desc('reduction')).run(conn)
     |   |          
     |   |          [
     |   |              {
     |   |                  "group": "Bob",
     |   |                  "reduction": 15
     |   |              },
     |   |              {
     |   |                  "group": "Alice",
     |   |                  "reduction": 7
     |   |              }
     |   |          ]
     |   |      
     |   |      When grouped data are returned to the client, they are transformed
     |   |      into a client-specific native type.  (Something similar is done with
     |   |      [times](http://rethinkdb.com/docs/dates-and-times/).)  In Python, grouped data are
     |   |      transformed into a `dictionary`. If the group value is an `array`, the
     |   |      key is converted to a `tuple`. If the group value is a `dictionary`,
     |   |      it will be converted to a `frozenset`.
     |   |      
     |   |      If you instead want to receive the raw
     |   |      pseudotype from the server (e.g. if you're planning to serialize the
     |   |      result as JSON), you can specify `group_format: 'raw'` as an optional
     |   |      argument to `run`:
     |   |      
     |   |      *Example* Get back the raw `GROUPED_DATA` pseudotype.
     |   |      
     |   |          > r.table('games').group('player').avg('points').run(conn, group_format='raw')
     |   |          
     |   |          {
     |   |              "$reql_type$": "GROUPED_DATA",
     |   |              "data": [
     |   |                  ["Alice", 4.5],
     |   |                  ["Bob", 12.5]
     |   |              ]
     |   |          }
     |   |      
     |   |      Not passing the `group_format` flag would return:
     |   |      
     |   |          {
     |   |              "Alice": 4.5,
     |   |              "Bob": 12.5
     |   |          }
     |   |      
     |   |      You might also want to use the [ungroup](http://rethinkdb.com/api/python/ungroup/)
     |   |      command (see above), which will turn the grouped data into an array of
     |   |      objects on the server.
     |   |      
     |   |      If you run a query that returns a grouped stream, it will be
     |   |      automatically converted to grouped data before being sent back to you
     |   |      (there is currently no efficient way to stream groups from RethinkDB).
     |   |      This grouped data is subject to the array size limit (see [run](http://rethinkdb.com/api/python/run)).
     |   |      
     |   |      In general, operations on grouped streams will be efficiently
     |   |      distributed, and operations on grouped data won't be.  You can figure
     |   |      out what you're working with by putting `type_of` on the end of your
     |   |      query.  Below are efficient and inefficient examples.
     |   |      
     |   |      *Example* Efficient operation.
     |   |      
     |   |          # r.table('games').group('player').type_of().run(conn)
     |   |          # Returns "GROUPED_STREAM"
     |   |          r.table('games').group('player').min('points').run(conn) # EFFICIENT
     |   |      
     |   |      *Example* Inefficient operation.
     |   |      
     |   |          # r.table('games').group('player').order_by('score').type_of().run(conn)
     |   |          # Returns "GROUPED_DATA"
     |   |          r.table('games').group('player').order_by('score').nth(0).run(conn) # INEFFICIENT
     |   |      
     |   |      What does it mean to be inefficient here?  When operating on grouped
     |   |      data rather than a grouped stream, *all* of the data has to be
     |   |      available on the node processing the query.  This means that the
     |   |      operation will only use one server's resources, and will require
     |   |      memory proportional to the size of the grouped data it's operating
     |   |      on.  (In the case of the `order_by` in the inefficient example, that
     |   |      means memory proportional **to the size of the table**.)  The array
     |   |      limit is also enforced for grouped data, so the `order_by` example
     |   |      would fail for tables with more than 100,000 rows unless you used the `array_limit` option with `run`.
     |   |      
     |   |      *Example* What is the maximum number of points scored by each
     |   |      player in free games?
     |   |      
     |   |          > r.table('games').filter(lambda game:
     |   |                  game['type'] = 'free'
     |   |              ).group('player').max('points')['points'].run(conn)
     |   |          
     |   |          {
     |   |              "Alice": 7,
     |   |              "Bob": 10
     |   |          }
     |   |      
     |   |      *Example* What is each player's highest even and odd score?
     |   |      
     |   |          > r.table('games')
     |   |              .group('name', lambda game:
     |   |                  game['points'] % 2
     |   |              ).max('points')['points'].run(conn)
     |   |          
     |   |          {
     |   |              ("Alice", 1): 7,
     |   |              ("Bob", 0): 10,
     |   |              ("Bob", 1): 15
     |   |          }
     |   |  
     |   |  gt(self, *args)
     |   |      value > value -> bool
     |   |      value.gt(value) -> bool
     |   |      
     |   |      Test if the first value is greater than other.
     |   |      
     |   |      *Example* Is 2 greater than 2?
     |   |      
     |   |          (r.expr(2) > 2).run(conn)
     |   |          r.expr(2).gt(2).run(conn)
     |   |  
     |   |  has_fields(self, *args)
     |   |      sequence.has_fields([selector1, selector2...]) -> stream
     |   |      array.has_fields([selector1, selector2...]) -> array
     |   |      object.has_fields([selector1, selector2...]) -> boolean
     |   |      
     |   |      Test if an object has one or more fields. An object has a field if it has that key and the key has a non-null value. For instance, the object `{'a': 1,'b': 2,'c': null}` has the fields `a` and `b`.
     |   |      
     |   |      When applied to a single object, `has_fields` returns `true` if the object has the fields and `false` if it does not. When applied to a sequence, it will return a new sequence (an array or stream) containing the elements that have the specified fields.
     |   |      
     |   |      *Example* Return the players who have won games.
     |   |      
     |   |          r.table('players').has_fields('games_won').run(conn)
     |   |      
     |   |      *Example* Test if a specific player has won any games.
     |   |      
     |   |          r.table('players').get(
     |   |              'b5ec9714-837e-400c-aa74-dbd35c9a7c4c').has_fields('games_won').run(conn)
     |   |      
     |   |      **Nested Fields**
     |   |      
     |   |      `has_fields` lets you test for nested fields in objects. If the value of a field is itself a set of key/value pairs, you can test for the presence of specific keys.
     |   |      
     |   |      *Example* In the `players` table, the `games_won` field contains one or more fields for kinds of games won:
     |   |      
     |   |          {
     |   |              'games_won': {
     |   |                  'playoffs': 2,
     |   |                  'championships': 1
     |   |              }
     |   |          }
     |   |      
     |   |      Return players who have the "championships" field.
     |   |      
     |   |          r.table('players').has_fields({'games_won': {'championships': true}}).run(conn)
     |   |      
     |   |      Note that `true` in the example above is testing for the existence of `championships` as a field, not testing to see if the value of the `championships` field is set to `true`. There's a more convenient shorthand form available. (See [pluck](http://rethinkdb.com/api/python/pluck) for more details on this.)
     |   |      
     |   |          r.table('players').has_fields({'games_won': 'championships'}).run(conn)
     |   |  
     |   |  hours(self, *args)
     |   |      time.hours() -> number
     |   |      
     |   |      Return the hour in a time object as a number between 0 and 23.
     |   |      
     |   |      *Example* Return all the posts submitted after midnight and before 4am.
     |   |      
     |   |          r.table("posts").filter(lambda post:
     |   |              post["date"].hours() < 4
     |   |          ).run(conn)
     |   |  
     |   |  in_timezone(self, *args)
     |   |      time.in_timezone(timezone) -> time
     |   |      
     |   |      Return a new time object with a different timezone. While the time stays the same, the results returned by methods such as hours() will change since they take the timezone into account. The timezone argument has to be of the ISO 8601 format.
     |   |      
     |   |      *Example* Hour of the day in San Francisco (UTC/GMT -8, without daylight saving time).
     |   |      
     |   |          r.now().in_timezone('-08:00').hours().run(conn)
     |   |  
     |   |  includes(self, *args)
     |   |      sequence.includes(geometry) -> sequence
     |   |      geometry.includes(geometry) -> bool
     |   |      
     |   |      Tests whether a geometry object is completely contained within another. When applied to a sequence of geometry objects, `includes` acts as a [filter](http://rethinkdb.com/api/python/filter), returning a sequence of objects from the sequence that include the argument.
     |   |      
     |   |      *Example* Is `point2` included within a 2000-meter circle around `point1`?
     |   |      
     |   |          > point1 = r.point(-117.220406,32.719464)
     |   |          > point2 = r.point(-117.206201,32.725186)
     |   |          > r.circle(point1, 2000).includes(point2).run(conn)
     |   |          
     |   |          True
     |   |      
     |   |      *Example* Which of the locations in a list of parks include `circle1`?
     |   |      
     |   |          circle1 = r.circle([-117.220406,32.719464], 10, unit='mi')
     |   |          r.table('parks')['area'].includes(circle1).run(conn)
     |   |  
     |   |  info(self, *args)
     |   |      any.info() -> object
     |   |      
     |   |      Get information about a ReQL value.
     |   |      
     |   |      *Example* Get information about a table such as primary key, or cache size.
     |   |      
     |   |          r.table('marvel').info().run(conn)
     |   |  
     |   |  inner_join(self, *args)
     |   |      sequence.inner_join(other_sequence, predicate) -> stream
     |   |      array.inner_join(other_sequence, predicate) -> array
     |   |      
     |   |      Returns an inner join of two sequences. The returned sequence represents an intersection of the left-hand sequence and the right-hand sequence: each row of the left-hand sequence will be compared with each row of the right-hand sequence to find all pairs of rows which satisfy the predicate. Each matched pair of rows of both sequences are combined into a result row. In most cases, you will want to follow the join with [zip](http://rethinkdb.com/api/python/zip) to combine the left and right results.
     |   |      
     |   |      Note that `inner_join` is slower and much less efficient than using [eq_join](http://rethinkdb.com/api/python/eq_join/) or [concat_map](http://rethinkdb.com/api/python/concat_map/) with [get_all](http://rethinkdb.com/api/python/get_all/). You should avoid using `inner_join` in commands when possible.
     |   |      
     |   |      *Example* Return a list of all matchups between Marvel and DC heroes in which the DC hero could beat the Marvel hero in a fight.
     |   |      
     |   |          r.table('marvel').inner_join(r.table('dc'),
     |   |              lambda marvel_row, dc_row: marvel_row['strength'] < dc_row['strength']
     |   |          ).zip().run(conn)
     |   |      
     |   |      (Compare this to an [outer_join](http://rethinkdb.com/api/python/outer_join) with the same inputs and predicate, which would return a list of *all* Marvel heroes along with any DC heroes with a higher strength.)
     |   |  
     |   |  insert_at(self, *args)
     |   |      array.insert_at(index, value) -> array
     |   |      
     |   |      Insert a value in to an array at a given index. Returns the modified array.
     |   |      
     |   |      *Example* Hulk decides to join the avengers.
     |   |      
     |   |          r.expr(["Iron Man", "Spider-Man"]).insert_at(1, "Hulk").run(conn)
     |   |  
     |   |  intersects(self, *args)
     |   |      sequence.intersects(geometry) -> sequence
     |   |      geometry.intersects(geometry) -> bool
     |   |      
     |   |      Tests whether two geometry objects intersect with one another. When applied to a sequence of geometry objects, `intersects` acts as a [filter](http://rethinkdb.com/api/python/filter), returning a sequence of objects from the sequence that intersect with the argument.
     |   |      
     |   |      *Example* Is `point2` within a 2000-meter circle around `point1`?
     |   |      
     |   |          > point1 = r.point(-117.220406,32.719464)
     |   |          > point2 = r.point(-117.206201,32.725186)
     |   |          > r.circle(point1, 2000).intersects(point2).run(conn)
     |   |          
     |   |          True
     |   |      
     |   |      *Example* Which of the locations in a list of parks intersect `circle1`?
     |   |      
     |   |          circle1 = r.circle([-117.220406,32.719464], 10, unit='mi')
     |   |          r.table('parks')('area').intersects(circle1).run(conn)
     |   |  
     |   |  is_empty(self, *args)
     |   |      sequence.is_empty() -> bool
     |   |      
     |   |      Test if a sequence is empty.
     |   |      
     |   |      *Example* Are there any documents in the marvel table?
     |   |      
     |   |          r.table('marvel').is_empty().run(conn)
     |   |  
     |   |  keys(self, *args)
     |   |      singleSelection.keys() -> array
     |   |      object.keys() -> array
     |   |      
     |   |      Return an array containing all of the object's keys.
     |   |      
     |   |      *Example* Get all the keys of a row.
     |   |      
     |   |          r.table('marvel').get('ironman').keys().run(conn)
     |   |  
     |   |  le(self, *args)
     |   |      value <= value -> bool
     |   |      value.le(value) -> bool
     |   |      
     |   |      Test if the first value is less than or equal to other.
     |   |      
     |   |      *Example* Is 2 less than or equal to 2?
     |   |      
     |   |          (r.expr(2) <= 2).run(conn)
     |   |          r.expr(2).le(2).run(conn)
     |   |  
     |   |  limit(self, *args)
     |   |      sequence.limit(n) -> stream
     |   |      array.limit(n) -> array
     |   |      
     |   |      End the sequence after the given number of elements.
     |   |      
     |   |      *Example* Only so many can fit in our Pantheon of heroes.
     |   |      
     |   |          r.table('marvel').order_by('belovedness').limit(10).run(conn)
     |   |  
     |   |  lt(self, *args)
     |   |      value < value -> bool
     |   |      value.lt(value) -> bool
     |   |      
     |   |      Test if the first value is less than other.
     |   |      
     |   |      *Example* Is 2 less than 2?
     |   |      
     |   |          (r.expr(2) < 2).run(conn)
     |   |          r.expr(2).lt(2).run(conn)
     |   |  
     |   |  map(self, *args)
     |   |      sequence1.map([sequence2, ...], mapping_function) -> stream
     |   |      array1.map([sequence2, ...], mapping_function) -> array
     |   |      r.map(sequence1[, sequence2, ...], mapping_function) -> stream
     |   |      r.map(array1[, array2, ...], mapping_function) -> array
     |   |      
     |   |      Transform each element of one or more sequences by applying a mapping function to them. If `map` is run with two or more sequences, it will iterate for as many items as there are in the shortest sequence.
     |   |      
     |   |      Note that `map` can only be applied to sequences, not single values. If you wish to apply a function to a single value/selection (including an array), use the [do](http://rethinkdb.com/api/python/do) command.
     |   |      
     |   |      *Example* Return the first five squares.
     |   |      
     |   |          > r.expr([1, 2, 3, 4, 5]).map(lambda val: (val * val)).run(conn)
     |   |          
     |   |          [1, 4, 9, 16, 25]
     |   |      
     |   |      *Example* Sum the elements of three sequences.
     |   |      
     |   |          > sequence1 = [100, 200, 300, 400]
     |   |          > sequence2 = [10, 20, 30, 40]
     |   |          > sequence3 = [1, 2, 3, 4]
     |   |          > r.map(sequence1, sequence2, sequence3,
     |   |              lambda val1, val2, val3: (val1 + val2 + val3)).run(conn)
     |   |          
     |   |          [111, 222, 333, 444]
     |   |      
     |   |      *Example* Rename a field when retrieving documents using `map` and `merge`.
     |   |      
     |   |      This example renames the field `id` to `user_id` when retrieving documents from the table `users`.
     |   |      
     |   |          r.table('users').map(
     |   |              lambda doc: doc.merge({'user_id': doc['id']}).without('id')).run(conn)
     |   |      
     |   |      Note that in this case, [row](http://rethinkdb.com/api/python/row) may be used as an alternative to writing an anonymous function, as it returns the same value as the function parameter receives:
     |   |      
     |   |          r.table('users').map(
     |   |              r.row.merge({'user_id': r.row['id']}).without('id')).run(conn)
     |   |      
     |   |      *Example* Assign every superhero an archenemy.
     |   |      
     |   |          r.table('heroes').map(r.table('villains'),
     |   |              lambda hero, villain: hero.merge({'villain': villain})).run(conn)
     |   |  
     |   |  match(self, *args)
     |   |      string.match(regexp) -> None/object
     |   |      
     |   |      Matches against a regular expression. If there is a match, returns an object with the fields:
     |   |      
     |   |      - `str`: The matched string
     |   |      - `start`: The matched string's start
     |   |      - `end`: The matched string's end
     |   |      - `groups`: The capture groups defined with parentheses
     |   |      
     |   |      If no match is found, returns `None`.
     |   |      
     |   |      Accepts RE2 syntax
     |   |      ([https://code.google.com/p/re2/wiki/Syntax](https://code.google.com/p/re2/wiki/Syntax)).
     |   |      You can enable case-insensitive matching by prefixing the regular expression with
     |   |      `(?i)`. See the linked RE2 documentation for more flags.
     |   |      
     |   |      The `match` command does not support backreferences.
     |   |      
     |   |      *Example* Get all users whose name starts with "A". Because `None` evaluates to `false` in
     |   |      `filter`, you can just use the result of `match` for the predicate.
     |   |      
     |   |          r.table('users').filter(lambda doc:
     |   |              doc['name'].match("^A")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Get all users whose name ends with "n".
     |   |      
     |   |          r.table('users').filter(lambda doc:
     |   |              doc['name'].match("n$")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Get all users whose name has "li" in it
     |   |      
     |   |          r.table('users').filter(lambda doc:
     |   |              doc['name'].match("li")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Get all users whose name is "John" with a case-insensitive search.
     |   |      
     |   |          r.table('users').filter(lambda doc:
     |   |              doc['name'].match("(?i)^john$")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Get all users whose name is composed of only characters between "a" and "z".
     |   |      
     |   |          r.table('users').filter(lambda doc:
     |   |              doc['name'].match("(?i)^[a-z]+$")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Get all users where the zipcode is a string of 5 digits.
     |   |      
     |   |          r.table('users').filter(lambda doc:
     |   |              doc['zipcode'].match("\d{5}")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Retrieve the domain of a basic email
     |   |      
     |   |          r.expr("name@domain.com").match(".*@(.*)").run(conn)
     |   |      
     |   |      Result:
     |   |      
     |   |          {
     |   |              "start": 0,
     |   |              "end": 20,
     |   |              "str": "name@domain.com",
     |   |              "groups":[
     |   |                  {
     |   |                      "end": 17,
     |   |                      "start": 7,
     |   |                      "str": "domain.com"
     |   |                  }
     |   |              ]
     |   |          }
     |   |      
     |   |      You can then retrieve only the domain with the [\[\]](http://rethinkdb.com/api/python/get_field) selector.
     |   |      
     |   |          r.expr("name@domain.com").match(".*@(.*)")["groups"][0]["str"].run(conn)
     |   |      
     |   |      Returns `'domain.com'`
     |   |      
     |   |      *Example* Fail to parse out the domain and returns `None`.
     |   |      
     |   |          r.expr("name[at]domain.com").match(".*@(.*)").run(conn)
     |   |  
     |   |  max(self, *args, **kwargs)
     |   |      sequence.max(field_or_function) -> element
     |   |      sequence.max(index='index') -> element
     |   |      
     |   |      Finds the maximum element of a sequence. The `max` command can be called with:
     |   |      
     |   |      * a **field name**, to return the element of the sequence with the largest value in that field;
     |   |      * an **index**, to return the element of the sequence with the largest value in that index;
     |   |      * a **function**, to apply the function to every element within the sequence and return the element which returns the largest value from the function, ignoring any elements where the function returns `None` or produces a non-existence error.
     |   |      
     |   |      Calling `max` on an empty sequence will throw a non-existence error; this can be handled using the [default](http://rethinkdb.com/api/python/default/) command.
     |   |      
     |   |      *Example* Return the maximum value in the list `[3, 5, 7]`.
     |   |      
     |   |          r.expr([3, 5, 7]).max().run(conn)
     |   |      
     |   |      *Example* Return the user who has scored the most points.
     |   |      
     |   |          r.table('users').max('points').run(conn)
     |   |      
     |   |      *Example* The same as above, but using a secondary index on the `points` field.
     |   |      
     |   |          r.table('users').max(index='points').run(conn)
     |   |      
     |   |      *Example* Return the user who has scored the most points, adding in bonus points from a separate field using a function.
     |   |      
     |   |          r.table('users').max(lambda user:
     |   |              user['points'] + user['bonus_points']
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Return the highest number of points any user has ever scored. This returns the value of that `points` field, not a document.
     |   |      
     |   |          r.table('users').max('points')['points'].run(conn)
     |   |      
     |   |      *Example* Return the user who has scored the most points, but add a default `None` return value to prevent an error if no user has ever scored points.
     |   |      
     |   |          r.table('users').max('points').default(None).run(conn)
     |   |  
     |   |  merge(self, *args)
     |   |      singleSelection.merge(object|function) -> object
     |   |      object.merge(object|function) -> object
     |   |      sequence.merge(object|function) -> stream
     |   |      array.merge(object|function) -> array
     |   |      
     |   |      Merge two objects together to construct a new object with properties from both. Gives preference to attributes from other when there is a conflict. `merge` also accepts a subquery function that returns an object, which will be used similarly to a [map](http://rethinkdb.com/api/python/map/) function.
     |   |      
     |   |      *Example* Equip IronMan for battle.
     |   |      
     |   |          r.table('marvel').get('IronMan').merge(
     |   |              r.table('loadouts').get('alienInvasionKit')
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Equip every hero for battle, using a subquery function to retrieve their weapons.
     |   |      
     |   |          r.table('marvel').merge(lambda hero:
     |   |              { 'weapons': r.table('weapons').get(hero['weapon_id']) }
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Use `merge` to join each blog post with its comments.
     |   |      
     |   |      Note that the sequence being merged&mdash;in this example, the comments&mdash;must be coerced from a selection to an array. Without `coerce_to` the operation will throw an error ("Expected type DATUM but found SELECTION").
     |   |      
     |   |          r.table('posts').merge(lambda post:
     |   |              { 'comments': r.table('comments').get_all(post['id'],
     |   |                  index='post_id').coerce_to('array') }
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Merge can be used recursively to modify object within objects.
     |   |      
     |   |          r.expr({'weapons' : {'spectacular graviton beam' : {'dmg' : 10, 'cooldown' : 20}}}).merge(
     |   |              {'weapons' : {'spectacular graviton beam' : {'dmg' : 10}}}
     |   |          ).run(conn)
     |   |      
     |   |      *Example* To replace a nested object with another object you can use the literal keyword.
     |   |      
     |   |          r.expr({'weapons' : {'spectacular graviton beam' : {'dmg' : 10, 'cooldown' : 20}}}).merge(
     |   |              {'weapons' : r.literal({'repulsor rays' : {'dmg' : 3, 'cooldown' : 0}})}
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Literal can be used to remove keys from an object as well.
     |   |      
     |   |          r.expr({'weapons' : {'spectacular graviton beam' : {'dmg' : 10, 'cooldown' : 20}}}).merge(
     |   |              {'weapons' : {'spectacular graviton beam' : r.literal()}}
     |   |          ).run(conn)
     |   |  
     |   |  min(self, *args, **kwargs)
     |   |      sequence.min(field_or_function) -> element
     |   |      sequence.min(index='index') -> element
     |   |      
     |   |      Finds the minimum element of a sequence. The `min` command can be called with:
     |   |      
     |   |      * a **field name**, to return the element of the sequence with the smallest value in that field;
     |   |      * an **index**, to return the element of the sequence with the smallest value in that index;
     |   |      * a **function**, to apply the function to every element within the sequence and return the element which returns the smallest value from the function, ignoring any elements where the function returns `None` or produces a non-existence error.
     |   |      
     |   |      Calling `min` on an empty sequence will throw a non-existence error; this can be handled using the [default](http://rethinkdb.com/api/python/default/) command.
     |   |      
     |   |      *Example* Return the minimum value in the list `[3, 5, 7]`.
     |   |      
     |   |          r.expr([3, 5, 7]).min().run(conn)
     |   |      
     |   |      *Example* Return the user who has scored the fewest points.
     |   |      
     |   |          r.table('users').min('points').run(conn)
     |   |      
     |   |      *Example* The same as above, but using a secondary index on the `points` field.
     |   |      
     |   |          r.table('users').min(index='points').run(conn)
     |   |      
     |   |      *Example* Return the user who has scored the fewest points, adding in bonus points from a separate field using a function.
     |   |      
     |   |          r.table('users').min(lambda user:
     |   |              user['points'] + user['bonus_points']
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Return the smallest number of points any user has ever scored. This returns the value of that `points` field, not a document.
     |   |      
     |   |          r.table('users').min('points')['points'].run(conn)
     |   |      
     |   |      *Example* Return the user who has scored the fewest points, but add a default `None` return value to prevent an error if no user has ever scored points.
     |   |      
     |   |          r.table('users').min('points').default(None).run(conn)
     |   |  
     |   |  minutes(self, *args)
     |   |      time.minutes() -> number
     |   |      
     |   |      Return the minute in a time object as a number between 0 and 59.
     |   |      
     |   |      *Example* Return all the posts submitted during the first 10 minutes of every hour.
     |   |      
     |   |          r.table("posts").filter(lambda post:
     |   |              post["date"].minutes() < 10
     |   |          ).run(conn)
     |   |  
     |   |  mod(self, *args)
     |   |  
     |   |  month(self, *args)
     |   |      time.month() -> number
     |   |      
     |   |      Return the month of a time object as a number between 1 and 12. For your convenience, the terms r.january, r.february etc. are defined and map to the appropriate integer.
     |   |      
     |   |      *Example* Retrieve all the users who were born in November.
     |   |      
     |   |          r.table("users").filter(
     |   |              r.row["birthdate"].month() == 11
     |   |          )
     |   |      
     |   |      *Example* Retrieve all the users who were born in November.
     |   |      
     |   |          r.table("users").filter(
     |   |              r.row["birthdate"].month() == r.november
     |   |          )
     |   |  
     |   |  mul(self, *args)
     |   |  
     |   |  ne(self, *args)
     |   |      value != value -> bool
     |   |      value.ne(value) -> bool
     |   |      
     |   |      Test if two values are not equal.
     |   |      
     |   |      *Example* Does 2 not equal 2?
     |   |      
     |   |          (r.expr(2) != 2).run(conn)
     |   |          r.expr(2).ne(2).run(conn)
     |   |  
     |   |  not_(self, *args)
     |   |      bool.not_() -> bool
     |   |      not_(bool) -> bool
     |   |      (~bool) -> bool
     |   |      
     |   |      Compute the logical inverse (not) of an expression.
     |   |      
     |   |      `not_` can be called either via method chaining, immediately after an expression that evaluates as a boolean value, or by passing the expression as a parameter to `not_`.  All values that are not `False` or `None` will be converted to `True`.
     |   |      
     |   |      You may also use `~` as a shorthand operator.
     |   |      
     |   |      *Example* Not true is false.
     |   |      
     |   |          r.not_(True).run(conn)
     |   |          r.expr(True).not_().run(conn)
     |   |          (~r.expr(True)).run(conn)
     |   |      
     |   |      These evaluate to `false`.
     |   |      
     |   |      Note that when using `~` the expression is wrapped in parentheses. Without this, Python will evaluate `r.expr(True)` *first* rather than using the ReQL operator and return an incorrect value. (`~True` evaluates to &minus;2 in Python.)
     |   |      
     |   |      *Example* Return all the users that do not have a "flag" field.
     |   |      
     |   |          r.table('users').filter(
     |   |              lambda users: (~users.has_fields('flag'))
     |   |          ).run(conn)
     |   |      
     |   |      *Example* As above, but prefix-style.
     |   |      
     |   |          r.table('users').filter(
     |   |              lambda users: r.not_(users.has_fields('flag'))
     |   |          ).run(conn)
     |   |  
     |   |  nth(self, *args)
     |   |      sequence.nth(index) -> object
     |   |      selection.nth(index) -> selection&lt;object&gt;
     |   |      
     |   |      Get the *nth* element of a sequence, counting from zero. If the argument is negative, count from the last element.
     |   |      
     |   |      In Python, you can use `[]` with an integer as a shorthand for `nth`.
     |   |      
     |   |      *Example* Select the second element in the array.
     |   |      
     |   |          r.expr([1,2,3]).nth(1).run(conn)
     |   |          r.expr([1,2,3])[1].run(conn)
     |   |      
     |   |      *Example* Select the bronze medalist from the competitors.
     |   |      
     |   |          r.table('players').order_by(index=r.desc('score')).nth(3).run(conn)
     |   |      
     |   |      *Example* Select the last place competitor.
     |   |      
     |   |          r.table('players').order_by(index=r.desc('score')).nth(-1).run(conn)
     |   |  
     |   |  offsets_of(self, *args)
     |   |      sequence.offsets_of(datum | predicate) -> array
     |   |      
     |   |      Get the indexes of an element in a sequence. If the argument is a predicate, get the indexes of all elements matching it.
     |   |      
     |   |      *Example* Find the position of the letter 'c'.
     |   |      
     |   |          r.expr(['a','b','c']).offsets_of('c').run(conn)
     |   |      
     |   |      *Example* Find the popularity ranking of invisible heroes.
     |   |      
     |   |          r.table('marvel').union(r.table('dc')).order_by('popularity').offsets_of(
     |   |              r.row['superpowers'].contains('invisibility')
     |   |          ).run(conn)
     |   |  
     |   |  or_(self, *args)
     |   |  
     |   |  order_by(self, *args, **kwargs)
     |   |      table.order_by([key1...], index=index_name) -> selection<stream>
     |   |      selection.order_by(key1, [key2...]) -> selection<array>
     |   |      sequence.order_by(key1, [key2...]) -> array
     |   |      
     |   |      Sort the sequence by document values of the given key(s). To specify
     |   |      the ordering, wrap the attribute with either `r.asc` or `r.desc`
     |   |      (defaults to ascending).
     |   |      
     |   |      __Note:__ RethinkDB uses byte-wise ordering for `orderBy` and does not support Unicode collations; non-ASCII characters will be sorted by UTF-8 codepoint.
     |   |      
     |   |      Sorting without an index requires the server to hold the sequence in
     |   |      memory, and is limited to 100,000 documents (or the setting of the `arrayLimit` option for [run](http://rethinkdb.com/api/python/run)). Sorting with an index can
     |   |      be done on arbitrarily large tables, or after a `between` command
     |   |      using the same index.
     |   |      
     |   |      *Example* Order all the posts using the index `date`.   
     |   |      
     |   |          r.table('posts').order_by(index='date').run(conn)
     |   |      
     |   |      The index must have been previously created with [index_create](http://rethinkdb.com/api/python/index_create/).
     |   |      
     |   |          r.table('posts').index_create('date').run(conn)
     |   |      
     |   |      You can also select a descending ordering:
     |   |      
     |   |          r.table('posts').order_by(index=r.desc('date')).run(conn, callback)
     |   |      
     |   |      *Example* Order a sequence without an index.
     |   |      
     |   |          r.table('posts').get(1)['comments'].order_by('date')
     |   |      
     |   |      You can also select a descending ordering:
     |   |      
     |   |          r.table('posts').get(1)['comments'].order_by(r.desc('date'))
     |   |      
     |   |      If you're doing ad-hoc analysis and know your table won't have more then 100,000
     |   |      elements (or you've changed the setting of the `arrayLimit` option for [run](http://rethinkdb.com/api/python/run)) you can run `order_by` without an index:
     |   |      
     |   |          r.table('small_table').order_by('date')
     |   |      
     |   |      *Example* You can efficiently order using multiple fields by using a
     |   |      [compound index](http://www.rethinkdb.com/docs/secondary-indexes/python/).
     |   |      
     |   |      Order by date and title.
     |   |      
     |   |          r.table('posts').order_by(index='date_and_title').run(conn)
     |   |      
     |   |      The index must have been previously created with [index_create](http://rethinkdb.com/api/python/index_create/).
     |   |      
     |   |          r.table('posts').index_create('date_and_title', lambda post:
     |   |              [post["date"], post["title"]]).run(conn)
     |   |      
     |   |      _Note_: You cannot specify multiple orders in a compound index. See [issue #2306](https://github.com/rethinkdb/rethinkdb/issues/2306)
     |   |      to track progress.
     |   |      
     |   |      *Example* If you have a sequence with fewer documents than the `array_limit`, you can order it
     |   |      by multiple fields without an index.
     |   |      
     |   |          r.table('small_table').order_by('date', r.desc('title'))
     |   |      
     |   |      *Example* Notice that an index ordering always has highest
     |   |      precedence. The following query orders posts by date, and if multiple
     |   |      posts were published on the same date, they will be ordered by title.
     |   |      
     |   |          r.table('post').order_by('title', index='date').run(conn)
     |   |      *Example* You can use [nested field](http://rethinkdb.com/docs/cookbook/python/#filtering-based-on-nested-fields) syntax to sort on fields from subdocuments. (You can also create indexes on nested fields using this syntax with `index_create`.)
     |   |      
     |   |          r.table('user').order_by(lambda user: user['group']['id']).run(conn)
     |   |      
     |   |      *Example* You can efficiently order data on arbitrary expressions using indexes.
     |   |      
     |   |          r.table('posts').order_by(index='votes').run(conn)
     |   |      
     |   |      The index must have been previously created with [index_create](http://rethinkdb.com/api/ruby/index_create/).
     |   |      
     |   |          r.table('posts').index_create('votes', lambda post:
     |   |              post["upvotes"]-post["downvotes"]
     |   |          ).run(conn)
     |   |      
     |   |      *Example* If you have a sequence with fewer documents than the `array_limit`, you can order it with an arbitrary function directly.
     |   |      
     |   |          r.table('small_table').order_by(lambda doc:
     |   |              doc['upvotes']-doc['downvotes']
     |   |          );
     |   |      
     |   |      You can also select a descending ordering:
     |   |      
     |   |          r.table('small_table').order_by(r.desc(lambda doc:
     |   |              doc['upvotes']-doc['downvotes']
     |   |          ));
     |   |      
     |   |      *Example* Ordering after a `between` command can be done as long as the same index is being used.
     |   |      
     |   |          r.table("posts").between(r.time(2013, 1, 1, '+00:00'), r.time(2013, 1, 1, '+00:00'), index='date')
     |   |              .order_by(index='date').run(conn);
     |   |  
     |   |  outer_join(self, *args)
     |   |      sequence.outer_join(other_sequence, predicate) -> stream
     |   |      array.outer_join(other_sequence, predicate) -> array
     |   |      
     |   |      Returns a left outer join of two sequences. The returned sequence represents a union of the left-hand sequence and the right-hand sequence: all documents in the left-hand sequence will be returned, each matched with a document in the right-hand sequence if one satisfies the predicate condition. In most cases, you will want to follow the join with [zip](http://rethinkdb.com/api/python/zip) to combine the left and right results.
     |   |      
     |   |      Note that `outer_join` is slower and much less efficient than using [concat_map](http://rethinkdb.com/api/python/concat_map/) with [get_all](http://rethinkdb.com/api/python/get_all). You should avoid using `outer_join` in commands when possible.
     |   |      
     |   |      *Example* Return a list of all Marvel heroes, paired with any DC heroes who could beat them in a fight.
     |   |      
     |   |          r.table('marvel').outer_join(r.table('dc'),
     |   |            lambda marvel_row, dc_row: marvel_row['strength'] < dc_row['strength']
     |   |          ).zip().run(conn)
     |   |      
     |   |      (Compare this to an [inner_join](http://rethinkdb.com/api/python/inner_join) with the same inputs and predicate, which would return a list only of the matchups in which the DC hero has the higher strength.)
     |   |  
     |   |  pluck(self, *args)
     |   |      sequence.pluck([selector1, selector2...]) -> stream
     |   |      array.pluck([selector1, selector2...]) -> array
     |   |      object.pluck([selector1, selector2...]) -> object
     |   |      singleSelection.pluck([selector1, selector2...]) -> object
     |   |      
     |   |      Plucks out one or more attributes from either an object or a sequence of objects
     |   |      (projection).
     |   |      
     |   |      *Example* We just need information about IronMan's reactor and not the rest of the
     |   |      document.
     |   |      
     |   |          r.table('marvel').get('IronMan').pluck('reactorState', 'reactorPower').run(conn)
     |   |      
     |   |      *Example* For the hero beauty contest we only care about certain qualities.
     |   |      
     |   |          r.table('marvel').pluck('beauty', 'muscleTone', 'charm').run(conn)
     |   |      
     |   |      *Example* Pluck can also be used on nested objects.
     |   |      
     |   |          r.table('marvel').pluck({'abilities' : {'damage' : True, 'mana_cost' : True}, 'weapons' : True}).run(conn)
     |   |      
     |   |      *Example* The nested syntax can quickly become overly verbose so there's a shorthand
     |   |      for it.
     |   |      
     |   |          r.table('marvel').pluck({'abilities' : ['damage', 'mana_cost']}, 'weapons').run(conn)
     |   |      
     |   |      For more information read the [nested field documentation](http://rethinkdb.com/docs/nested-fields/).
     |   |  
     |   |  polygon_sub(self, *args)
     |   |      polygon1.polygon_sub(polygon2) -> polygon
     |   |      
     |   |      Use `polygon2` to "punch out" a hole in `polygon1`. `polygon2` must be completely contained within `polygon1` and must have no holes itself (it must not be the output of `polygon_sub` itself).
     |   |      
     |   |      *Example* Define a polygon with a hole punched in it.
     |   |      
     |   |          outer_polygon = r.polygon(
     |   |              [-122.4,37.7],
     |   |              [-122.4,37.3],
     |   |              [-121.8,37.3],
     |   |              [-121.8,37.7]
     |   |          )
     |   |          inner_polygon = r.polygon(
     |   |              [-122.3,37.4],
     |   |              [-122.3,37.6],
     |   |              [-122.0,37.6],
     |   |              [-122.0,37.4]
     |   |          )
     |   |          outer_polygon.polygon_sub(inner_polygon).run(conn)
     |   |  
     |   |  prepend(self, *args)
     |   |      array.prepend(value) -> array
     |   |      
     |   |      Prepend a value to an array.
     |   |      
     |   |      *Example* Retrieve Iron Man's equipment list with the addition of some new boots.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].prepend('newBoots').run(conn)
     |   |  
     |   |  reduce(self, *args)
     |   |      sequence.reduce(reduction_function) -> value
     |   |      
     |   |      Produce a single value from a sequence through repeated application of a reduction
     |   |      function.  
     |   |      The reduction function can be called on:
     |   |      
     |   |      - two elements of the sequence
     |   |      - one element of the sequence and one result of a previous reduction
     |   |      - two results of previous reductions
     |   |      
     |   |      The reduction function can be called on the results of two previous reductions because the
     |   |      `reduce` command is distributed and parallelized across shards and CPU cores. A common
     |   |      mistaken when using the `reduce` command is to suppose that the reduction is executed
     |   |      from left to right. Read the [map-reduce in RethinkDB](http://rethinkdb.com/docs/map-reduce/) article to
     |   |      see an example.
     |   |      
     |   |      If the sequence is empty, the server will produce a `RqlRuntimeError` that can be
     |   |      caught with `default`.  
     |   |      If the sequence has only one element, the first element will be returned.
     |   |      
     |   |      *Example* Return the number of documents in the table `posts`.
     |   |      
     |   |          r.table("posts").map(lambda doc: 1)
     |   |              .reduce(lambda left, right: left+right)
     |   |              .default(0).run(conn)
     |   |      
     |   |      A shorter way to execute this query is to use [count](http://rethinkdb.com/api/python/count).
     |   |      
     |   |      *Example* Suppose that each `post` has a field `comments` that is an array of
     |   |      comments.  
     |   |      Return the number of comments for all posts.
     |   |      
     |   |          r.table("posts").map(lambda doc:
     |   |              doc["comments"].count()
     |   |          ).reduce(lambda left, right:
     |   |              left+right
     |   |          ).default(0).run(conn)
     |   |      
     |   |      *Example* Suppose that each `post` has a field `comments` that is an array of
     |   |      comments.  
     |   |      Return the maximum number comments per post.
     |   |      
     |   |          r.table("posts").map(lambda doc:
     |   |              doc["comments"].count()
     |   |          ).reduce(lambda left, right:
     |   |              r.branch(
     |   |                  left > right,
     |   |                  left,
     |   |                  right
     |   |              )
     |   |          ).default(0).run(conn)
     |   |      
     |   |      A shorter way to execute this query is to use [max](http://rethinkdb.com/api/python/max).
     |   |  
     |   |  replace(self, *args, **kwargs)
     |   |      table.replace(json | expr[, durability="hard", return_changes=False, non_atomic=False])
     |   |          -> object
     |   |      selection.replace(json | expr[, durability="hard", return_changes=False, non_atomic=False])
     |   |          -> object
     |   |      singleSelection.replace(json | expr[, durability="hard", return_changes=False, non_atomic=False])
     |   |          -> object
     |   |      
     |   |      Replace documents in a table. Accepts a JSON document or a ReQL expression, and replaces
     |   |      the original document with the new one. The new document must have the same primary key
     |   |      as the original document.
     |   |      
     |   |      The optional arguments are:
     |   |      
     |   |      - `durability`: possible values are `hard` and `soft`. This option will override the
     |   |      table or query's durability setting (set in [run](http://rethinkdb.com/api/python/run/)).  
     |   |      In soft durability mode RethinkDB will acknowledge the write immediately after
     |   |      receiving it, but before the write has been committed to disk.
     |   |      - `return_changes`: if set to `True`, return a `changes` array consisting of `old_val`/`new_val` objects describing the changes made.
     |   |      - `non_atomic`: if set to `True`, executes the replacement and distributes the result to replicas in a non-atomic fashion. This flag is required to perform non-deterministic updates, such as those that require reading data from another table.
     |   |      
     |   |      Replace returns an object that contains the following attributes:
     |   |      
     |   |      - `replaced`: the number of documents that were replaced
     |   |      - `unchanged`: the number of documents that would have been modified, except that the
     |   |      new value was the same as the old value
     |   |      - `inserted`: the number of new documents added. You can have new documents inserted if
     |   |      you do a point-replace on a key that isn't in the table or you do a replace on a
     |   |      selection and one of the documents you are replacing has been deleted
     |   |      - `deleted`: the number of deleted documents when doing a replace with `None`
     |   |      - `errors`: the number of errors encountered while performing the replace.
     |   |      - `first_error`: If errors were encountered, contains the text of the first error.
     |   |      - `skipped`: 0 for a replace operation
     |   |      - `changes`: if `return_changes` is set to `True`, this will be an array of objects, one for each objected affected by the `replace` operation. Each object will have two keys: `{"new_val": <new value>, "old_val": <old value>}`.
     |   |      
     |   |      *Example* Replace the document with the primary key `1`.
     |   |      
     |   |          r.table("posts").get(1).replace({
     |   |              "id": 1,
     |   |              "title": "Lorem ipsum",
     |   |              "content": "Aleas jacta est",
     |   |              "status": "draft"
     |   |          }).run(conn)
     |   |      
     |   |      *Example* Remove the field `status` from all posts.
     |   |      
     |   |          r.table("posts").replace(lambda post:
     |   |              post.without("status")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Remove all the fields that are not `id`, `title` or `content`.
     |   |      
     |   |          r.table("posts").replace(lambda post:
     |   |              post.pluck("id", "title", "content")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Replace the document with the primary key `1` using soft durability.
     |   |      
     |   |          r.table("posts").get(1).replace({
     |   |              "id": 1,
     |   |              "title": "Lorem ipsum",
     |   |              "content": "Aleas jacta est",
     |   |              "status": "draft"
     |   |          }, durability="soft").run(conn)
     |   |      
     |   |      *Example* Replace the document with the primary key `1` and return the values of the document before
     |   |      and after the replace operation.
     |   |      
     |   |          r.table("posts").get(1).replace({
     |   |              "id": 1,
     |   |              "title": "Lorem ipsum",
     |   |              "content": "Aleas jacta est",
     |   |              "status": "published"
     |   |          }, return_changes=True).run(conn)
     |   |      
     |   |      The result will have a `changes` field:
     |   |      
     |   |          {
     |   |              "deleted": 0,
     |   |              "errors":  0,
     |   |              "inserted": 0,
     |   |              "changes": [
     |   |                  {
     |   |                      "new_val": {
     |   |                          "id":1,
     |   |                          "title": "Lorem ipsum"
     |   |                          "content": "Aleas jacta est",
     |   |                          "status": "published",
     |   |                      },
     |   |                      "old_val": {
     |   |                          "id":1,
     |   |                          "title": "Lorem ipsum"
     |   |                          "content": "TODO",
     |   |                          "status": "draft",
     |   |                          "author": "William",
     |   |                      }
     |   |                  }
     |   |              ],   
     |   |              "replaced": 1,
     |   |              "skipped": 0,
     |   |              "unchanged": 0
     |   |          }
     |   |  
     |   |  run(self, c=None, **global_optargs)
     |   |      query.run(conn, use_outdated=False, time_format='native', profile=False, durability="hard") -> cursor
     |   |      query.run(conn, use_outdated=False, time_format='native', profile=False, durability="hard") -> object
     |   |      
     |   |      Run a query on a connection, returning either a single JSON result or
     |   |      a cursor, depending on the query.
     |   |      
     |   |      The optional arguments are:
     |   |      
     |   |      - `use_outdated`: whether or not outdated reads are OK (default: `False`).
     |   |      - `time_format`: what format to return times in (default: `'native'`).
     |   |        Set this to `'raw'` if you want times returned as JSON objects for exporting.
     |   |      - `profile`: whether or not to return a profile of the query's
     |   |        execution (default: `False`).
     |   |      - `durability`: possible values are `'hard'` and `'soft'`. In soft durability mode RethinkDB
     |   |      will acknowledge the write immediately after receiving it, but before the write has
     |   |      been committed to disk.
     |   |      - `group_format`: what format to return `grouped_data` and `grouped_streams` in (default: `'native'`).
     |   |        Set this to `'raw'` if you want the raw pseudotype.
     |   |      - `noreply`: set to `True` to not receive the result object or cursor and return immediately.
     |   |      - `db`: the database to run this query against as a string. The default is the database specified in the `db` parameter to [connect](http://rethinkdb.com/api/python/connect/) (which defaults to `test`). The database may also be specified with the [db](http://rethinkdb.com/api/python/db/) command.
     |   |      - `array_limit`: the maximum numbers of array elements that can be returned by a query (default: 100,000). This affects all ReQL commands that return arrays. Note that it has no effect on the size of arrays being _written_ to the database; those always have an upper limit of 100,000 elements.
     |   |      - `binary_format`: what format to return binary data in (default: `'native'`). Set this to `'raw'` if you want the raw pseudotype.
     |   |      - `min_batch_rows`: minimum number of rows to wait for before batching a result set (default: 8). This is an integer.
     |   |      - `max_batch_rows`: maximum number of rows to wait for before batching a result set (default: unlimited). This is an integer.
     |   |      - `max_batch_bytes`: maximum number of bytes to wait for before batching a result set (default: 1024). This is an integer.
     |   |      - `max_batch_seconds`: maximum number of seconds to wait before batching a result set (default: 0.5). This is a float (not an integer) and may be specified to the microsecond.
     |   |      - `first_batch_scaledown_factor`: factor to scale the other parameters down by on the first batch (default: 4). For example, with this set to 8 and `max_batch_rows` set to 80, on the first batch `max_batch_rows` will be adjusted to 10 (80 / 8). This allows the first batch to return faster.
     |   |      
     |   |      *Example* Run a query on the connection `conn` and print out every
     |   |      row in the result.
     |   |      
     |   |          for doc in r.table('marvel').run(conn):
     |   |              print doc
     |   |      
     |   |      *Example* If you are OK with potentially out of date data from all
     |   |      the tables involved in this query and want potentially faster reads,
     |   |      pass a flag allowing out of date data in an options object. Settings
     |   |      for individual tables will supercede this global setting for all
     |   |      tables in the query.
     |   |      
     |   |          r.table('marvel').run(conn, use_outdated=True)
     |   |      
     |   |      *Example* If you just want to send a write and forget about it, you
     |   |      can set `noreply` to true in the options. In this case `run` will
     |   |      return immediately.
     |   |      
     |   |          r.table('marvel').run(conn, noreply=True)
     |   |      
     |   |      *Example* If you want to specify whether to wait for a write to be
     |   |      written to disk (overriding the table's default settings), you can set
     |   |      `durability` to `'hard'` or `'soft'` in the options.
     |   |      
     |   |          r.table('marvel')
     |   |              .insert({ 'superhero': 'Iron Man', 'superpower': 'Arc Reactor' })
     |   |              .run(conn, noreply=True, durability='soft')
     |   |      
     |   |      *Example* If you do not want a time object to be converted to a
     |   |      native date object, you can pass a `time_format` flag to prevent it
     |   |      (valid flags are "raw" and "native"). This query returns an object
     |   |      with two fields (`epoch_time` and `$reql_type$`) instead of a native date
     |   |      object.
     |   |      
     |   |          r.now().run(conn, time_format="raw")
     |   |      
     |   |      *Example* Specify the database to use for the query.
     |   |      
     |   |          for doc in r.table('marvel').run(conn, db='heroes'):
     |   |              print doc
     |   |      
     |   |      This is equivalent to using the `db` command to specify the database:
     |   |      
     |   |          r.db('heroes').table('marvel').run(conn) ...
     |   |      
     |   |      *Example* Change the batching parameters for this query.
     |   |      
     |   |          r.table('marvel').run(conn, max_batch_rows=16, max_batch_bytes=2048)
     |   |  
     |   |  sample(self, *args)
     |   |      sequence.sample(number) -> selection
     |   |      stream.sample(number) -> array
     |   |      array.sample(number) -> array
     |   |      
     |   |      Select a given number of elements from a sequence with uniform random distribution. Selection is done without replacement.
     |   |      
     |   |      If the sequence has less than the requested number of elements (i.e., calling `sample(10)` on a sequence with only five elements), `sample` will return the entire sequence in a random order.
     |   |      
     |   |      *Example* Select 3 random heroes.
     |   |      
     |   |          r.table('marvel').sample(3).run(conn)
     |   |  
     |   |  seconds(self, *args)
     |   |      time.seconds() -> number
     |   |      
     |   |      Return the seconds in a time object as a number between 0 and 59.999 (double precision).
     |   |      
     |   |      *Example* Return the post submitted during the first 30 seconds of every minute.
     |   |      
     |   |          r.table("posts").filter(lambda post:
     |   |              post["date"].seconds() < 30
     |   |          ).run(conn)
     |   |  
     |   |  set_difference(self, *args)
     |   |      array.set_difference(array) -> array
     |   |      
     |   |      Remove the elements of one array from another and return them as a set (an array with
     |   |      distinct values).
     |   |      
     |   |      *Example* Check which pieces of equipment Iron Man has, excluding a fixed list.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].set_difference(['newBoots', 'arc_reactor']).run(conn)
     |   |  
     |   |  set_insert(self, *args)
     |   |      array.set_insert(value) -> array
     |   |      
     |   |      Add a value to an array and return it as a set (an array with distinct values).
     |   |      
     |   |      *Example* Retrieve Iron Man's equipment list with the addition of some new boots.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].set_insert('newBoots').run(conn)
     |   |  
     |   |  set_intersection(self, *args)
     |   |      array.set_intersection(array) -> array
     |   |      
     |   |      Intersect two arrays returning values that occur in both of them as a set (an array with
     |   |      distinct values).
     |   |      
     |   |      *Example* Check which pieces of equipment Iron Man has from a fixed list.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].set_intersection(['newBoots', 'arc_reactor']).run(conn)
     |   |  
     |   |  set_union(self, *args)
     |   |      array.set_union(array) -> array
     |   |      
     |   |      Add a several values to an array and return it as a set (an array with distinct values).
     |   |      
     |   |      *Example* Retrieve Iron Man's equipment list with the addition of some new boots and an arc reactor.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].set_union(['newBoots', 'arc_reactor']).run(conn)
     |   |  
     |   |  skip(self, *args)
     |   |      sequence.skip(n) -> stream
     |   |      array.skip(n) -> array
     |   |      
     |   |      Skip a number of elements from the head of the sequence.
     |   |      
     |   |      *Example* Here in conjunction with `order_by` we choose to ignore the most successful heroes.
     |   |      
     |   |          r.table('marvel').order_by('successMetric').skip(10).run(conn)
     |   |  
     |   |  slice(self, *args, **kwargs)
     |   |      selection.slice(start_index[, end_index, left_bound='closed', right_bound='open']) -> selection
     |   |      stream.slice(start_index[, end_index, left_bound='closed', right_bound='open']) -> stream
     |   |      array.slice(start_index[, end_index, left_bound='closed', right_bound='open']) -> array
     |   |      binary.slice(start_index[, end_index, left_bound='closed', right_bound='open']) -> binary
     |   |      
     |   |      Return the elements of a sequence within the specified range.
     |   |      
     |   |      `slice` returns the range between `start_index` and `end_index`. If only `start_index` is specified, `slice` returns the range from that index to the end of the sequence. Specify `left_bound` or `right_bound` as `open` or `closed` to indicate whether to include that endpoint of the range by default: `closed` returns that endpoint, while `open` does not. By default, `left_bound` is closed and `right_bound` is open, so the range `(10,13)` will return the tenth, eleventh and twelfth elements in the sequence.
     |   |      
     |   |      If `end_index` is past the end of the sequence, all elements from `start_index` to the end of the sequence will be returned. If `start_index` is past the end of the sequence or `end_index` is less than `start_index`, a zero-element sequence will be returned (although see below for negative `end_index` values). An error will be raised on a negative `start_index`.
     |   |      
     |   |      A negative `end_index` is allowed with arrays; in that case, the returned range counts backward from the array's end. That is, the range of `(2,-1)` returns the second element through the next-to-last element of the range. A negative `end_index` is not allowed with a stream. (An `end_index` of &minus;1 *is* allowed with a stream if `right_bound` is closed; this behaves as if no `end_index` was specified.)
     |   |      
     |   |      If `slice` is used with a [binary](http://rethinkdb.com/api/python/binary) object, the indexes refer to byte positions within the object. That is, the range `(10,20)` will refer to the 10th byte through the 19th byte.
     |   |      
     |   |      If you are only specifying the indexes and not the bounding options, you may use Python's slice operator as a shorthand: `[start_index:end_index]`.
     |   |      
     |   |      **Example:** Return the fourth, fifth and sixth youngest players. (The youngest player is at index 0, so those are elements 3&ndash;5.)
     |   |      
     |   |          r.table('players').order_by(index='age').slice(3,6).run(conn)
     |   |      
     |   |      Or, using Python's slice operator:
     |   |      
     |   |          r.table('players').filter({'class': 'amateur'})[10:20].run(conn)
     |   |      
     |   |      **Example:** Return all but the top three players who have a red flag.
     |   |      
     |   |          r.table('players').filter({'flag': 'red'}).order_by(index=r.desc('score')).slice(3).run(conn)
     |   |      
     |   |      **Example:** Return holders of tickets `X` through `Y`, assuming tickets are numbered sequentially. We want to include ticket `Y`.
     |   |      
     |   |          r.table('users').order_by(index='ticket').slice(x, y, right_bound='closed').run(conn)
     |   |      
     |   |      **Example:** Return the elements of an array from the second through two from the end (that is, not including the last two).
     |   |      
     |   |          r.expr([0,1,2,3,4,5]).slice(2,-2).run(conn)
     |   |      
     |   |      Result:
     |   |      
     |   |          [2,3]
     |   |  
     |   |  splice_at(self, *args)
     |   |      array.splice_at(index, array) -> array
     |   |      
     |   |      Insert several values in to an array at a given index. Returns the modified array.
     |   |      
     |   |      *Example* Hulk and Thor decide to join the avengers.
     |   |      
     |   |          r.expr(["Iron Man", "Spider-Man"]).splice_at(1, ["Hulk", "Thor"]).run(conn)
     |   |  
     |   |  split(self, *args)
     |   |      string.split([separator, [max_splits]]) -> array
     |   |      
     |   |      Splits a string into substrings.  Splits on whitespace when called
     |   |      with no arguments.  When called with a separator, splits on that
     |   |      separator.  When called with a separator and a maximum number of
     |   |      splits, splits on that separator at most `max_splits` times.  (Can be
     |   |      called with `None` as the separator if you want to split on whitespace
     |   |      while still specifying `max_splits`.)
     |   |      
     |   |      Mimics the behavior of Python's `string.split` in edge cases, except
     |   |      for splitting on the empty string, which instead produces an array of
     |   |      single-character strings.
     |   |      
     |   |      *Example* Split on whitespace.
     |   |      
     |   |          > r.expr("foo  bar bax").split().run(conn)
     |   |          ["foo", "bar", "bax"]
     |   |      
     |   |      *Example* Split the entries in a CSV file.
     |   |      
     |   |          > r.expr("12,37,,22,").split(",").run(conn)
     |   |          ["12", "37", "", "22", ""]
     |   |      
     |   |      *Example* Split a string into characters.
     |   |      
     |   |          > r.expr("mlucy").split("").run(conn)
     |   |          ["m", "l", "u", "c", "y"]
     |   |      
     |   |      *Example* Split the entries in a CSV file, but only at most 3
     |   |      times.
     |   |      
     |   |          > r.expr("12,37,,22,").split(",", 3).run(conn)
     |   |          ["12", "37", "", "22,"]
     |   |      
     |   |      *Example* Split on whitespace at most once (i.e. get the first word).
     |   |      
     |   |          > r.expr("foo  bar bax").split(None, 1).run(conn)
     |   |          ["foo", "bar bax"]
     |   |  
     |   |  sub(self, *args)
     |   |  
     |   |  sum(self, *args)
     |   |      sequence.sum([field_or_function]) -> number
     |   |      
     |   |      Sums all the elements of a sequence.  If called with a field name,
     |   |      sums all the values of that field in the sequence, skipping elements
     |   |      of the sequence that lack that field.  If called with a function,
     |   |      calls that function on every element of the sequence and sums the
     |   |      results, skipping elements of the sequence where that function returns
     |   |      `None` or a non-existence error.
     |   |      
     |   |      Returns `0` when called on an empty sequence.
     |   |      
     |   |      *Example* What's 3 + 5 + 7?
     |   |      
     |   |          r.expr([3, 5, 7]).sum().run(conn)
     |   |      
     |   |      *Example* How many points have been scored across all games?
     |   |      
     |   |          r.table('games').sum('points').run(conn)
     |   |      
     |   |      *Example* How many points have been scored across all games,
     |   |      counting bonus points?
     |   |      
     |   |          r.table('games').sum(lambda game:
     |   |              game['points'] + game['bonus_points']
     |   |          ).run(conn)
     |   |  
     |   |  time_of_day(self, *args)
     |   |      time.time_of_day() -> number
     |   |      
     |   |      Return the number of seconds elapsed since the beginning of the day stored in the time object.
     |   |      
     |   |      *Example* Retrieve posts that were submitted before noon.
     |   |      
     |   |          r.table("posts").filter(
     |   |              r.row["date"].time_of_day() <= 12*60*60
     |   |          ).run(conn)
     |   |  
     |   |  timezone(self, *args)
     |   |      time.timezone() -> string
     |   |      
     |   |      Return the timezone of the time object.
     |   |      
     |   |      *Example* Return all the users in the "-07:00" timezone.
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user["subscriptionDate"].timezone() == "-07:00"
     |   |          )
     |   |  
     |   |  to_epoch_time(self, *args)
     |   |      time.to_epoch_time() -> number
     |   |      
     |   |      Convert a time object to its epoch time.
     |   |      
     |   |      *Example* Return the current time in seconds since the Unix Epoch with millisecond-precision.
     |   |      
     |   |          r.now().to_epoch_time()
     |   |  
     |   |  to_geojson(self, *args)
     |   |      geometry.to_geojson() -> object
     |   |      
     |   |      Convert a ReQL geometry object to a [GeoJSON][] object.
     |   |      
     |   |      [GeoJSON]: http://geojson.org
     |   |      
     |   |      *Example* Convert a ReQL geometry object to a GeoJSON object.
     |   |      
     |   |          > r.table(geo).get('sfo')['location'].to_geojson.run(conn)
     |   |          
     |   |          {
     |   |              'type': 'Point',
     |   |              'coordinates': [ -122.423246, 37.779388 ]
     |   |          }
     |   |  
     |   |  to_iso8601(self, *args)
     |   |      time.to_iso8601() -> number
     |   |      
     |   |      Convert a time object to its iso 8601 format.
     |   |      
     |   |      *Example* Return the current time in an ISO8601 format.
     |   |      
     |   |          r.now().to_iso8601()
     |   |  
     |   |  to_json(self, *args)
     |   |      value.to_json_string() -> string
     |   |      value.to_json() -> string
     |   |      
     |   |      Convert a ReQL value or object to a JSON string. You may use either `to_json_string` or `to_json`.
     |   |      
     |   |      *Example* Get a ReQL document as a JSON string.
     |   |      
     |   |          > r.table('hero').get(1).to_json()
     |   |          
     |   |          '{"id": 1, "name": "Batman", "city": "Gotham", "powers": ["martial arts", "cinematic entrances"]}'
     |   |  
     |   |  to_json_string(self, *args)
     |   |      value.to_json_string() -> string
     |   |      value.to_json() -> string
     |   |      
     |   |      Convert a ReQL value or object to a JSON string. You may use either `to_json_string` or `to_json`.
     |   |      
     |   |      *Example* Get a ReQL document as a JSON string.
     |   |      
     |   |          > r.table('hero').get(1).to_json()
     |   |          
     |   |          '{"id": 1, "name": "Batman", "city": "Gotham", "powers": ["martial arts", "cinematic entrances"]}'
     |   |  
     |   |  type_of(self, *args)
     |   |      any.type_of() -> string
     |   |      
     |   |      Gets the type of a value.
     |   |      
     |   |      *Example* Get the type of a string.
     |   |      
     |   |          r.expr("foo").type_of().run(conn)
     |   |  
     |   |  ungroup(self, *args)
     |   |      grouped_stream.ungroup() -> array
     |   |      grouped_data.ungroup() -> array
     |   |      
     |   |      Takes a grouped stream or grouped data and turns it into an array of
     |   |      objects representing the groups.  Any commands chained after `ungroup`
     |   |      will operate on this array, rather than operating on each group
     |   |      individually.  This is useful if you want to e.g. order the groups by
     |   |      the value of their reduction.
     |   |      
     |   |      The format of the array returned by `ungroup` is the same as the
     |   |      default native format of grouped data in the JavaScript driver and
     |   |      data explorer.
     |   |      
     |   |      *Example* What is the maximum number of points scored by each
     |   |      player, with the highest scorers first?
     |   |      
     |   |      Suppose that the table `games` has the following data:
     |   |      
     |   |          [
     |   |              {"id": 2, "player": "Bob", "points": 15, "type": "ranked"},
     |   |              {"id": 5, "player": "Alice", "points": 7, "type": "free"},
     |   |              {"id": 11, "player": "Bob", "points": 10, "type": "free"},
     |   |              {"id": 12, "player": "Alice", "points": 2, "type": "free"}
     |   |          ]
     |   |      
     |   |      We can use this query:
     |   |      
     |   |          r.table('games')
     |   |             .group('player').max('points')['points']
     |   |             .ungroup().order_by(r.desc('reduction')).run(conn)
     |   |      
     |   |      Result: 
     |   |      
     |   |          [
     |   |              {
     |   |                  "group": "Bob",
     |   |                  "reduction": 15
     |   |              },
     |   |              {
     |   |                  "group": "Alice",
     |   |                  "reduction": 7
     |   |              }
     |   |          ]
     |   |      
     |   |      *Example* Select one random player and all their games.
     |   |      
     |   |          r.table('games').group('player').ungroup().sample(1).run(conn)
     |   |      
     |   |      Result:
     |   |      
     |   |          [
     |   |              {
     |   |                  "group": "Bob",
     |   |                  "reduction": [
     |   |                      {"id": 2, "player": "Bob", "points": 15, "type": "ranked"},
     |   |                      {"id": 11, "player": "Bob", "points": 10, "type": "free"}
     |   |                  ]
     |   |              }
     |   |          ]
     |   |      
     |   |      Note that if you didn't call `ungroup`, you would instead select one
     |   |      random game from each player:
     |   |      
     |   |          r.table('games').group('player').sample(1).run(conn)
     |   |      
     |   |      Result:
     |   |      
     |   |          {
     |   |              "Alice": [
     |   |                  {"id": 5, "player": "Alice", "points": 7, "type": "free"}
     |   |              ],
     |   |              "Bob": [
     |   |                  {"id": 11, "player": "Bob", "points": 10, "type": "free"}
     |   |              ]
     |   |          }
     |   |      
     |   |      *Example* Types!
     |   |      
     |   |          r.table('games').group('player').type_of().run(conn) # Returns "GROUPED_STREAM"
     |   |          r.table('games').group('player').ungroup().type_of().run(conn) # Returns "ARRAY"
     |   |          r.table('games').group('player').avg('points').run(conn) # Returns "GROUPED_DATA"
     |   |          r.table('games').group('player').avg('points').ungroup().run(conn) #Returns "ARRAY"
     |   |  
     |   |  union(self, *args)
     |   |      sequence.union(sequence) -> array
     |   |      
     |   |      Concatenate two sequences.
     |   |      
     |   |      *Example* Construct a stream of all heroes.
     |   |      
     |   |          r.table('marvel').union(r.table('dc')).run(conn)
     |   |  
     |   |  upcase(self, *args)
     |   |      string.upcase() -> string
     |   |      
     |   |      Uppercases a string.
     |   |      
     |   |      *Example*
     |   |      
     |   |          > r.expr("Sentence about LaTeX.").upcase().run(conn)
     |   |          "SENTENCE ABOUT LATEX."
     |   |      
     |   |      __Note:__ `upcase` and `downcase` only affect ASCII characters.
     |   |  
     |   |  update(self, *args, **kwargs)
     |   |      table.update(json | expr[, durability="hard", return_changes=False, non_atomic=False])
     |   |          -> object
     |   |      selection.update(json | expr[, durability="hard", return_changes=False, non_atomic=False])
     |   |          -> object
     |   |      singleSelection.update(json | expr[, durability="hard", return_changes=False, non_atomic=False])
     |   |          -> object
     |   |      
     |   |      Update JSON documents in a table. Accepts a JSON document, a ReQL expression, or a
     |   |      combination of the two.
     |   |      
     |   |      The optional arguments are:
     |   |      
     |   |      - `durability`: possible values are `hard` and `soft`. This option will override the
     |   |      table or query's durability setting (set in [run](http://rethinkdb.com/api/python/run/)).  
     |   |      In soft durability mode RethinkDB will acknowledge the write immediately after
     |   |      receiving it, but before the write has been committed to disk.
     |   |      - `return_changes`: if set to `True`, return a `changes` array consisting of `old_val`/`new_val` objects describing the changes made.
     |   |      - `non_atomic`: if set to `True`, executes the update and distributes the result to replicas in a non-atomic fashion. This flag is required to perform non-deterministic updates, such as those that require reading data from another table.
     |   |      
     |   |      Update returns an object that contains the following attributes:
     |   |      
     |   |      - `replaced`: the number of documents that were updated.
     |   |      - `unchanged`: the number of documents that would have been modified except the new
     |   |      value was the same as the old value.
     |   |      - `skipped`: the number of documents that were skipped because the document didn't exist.
     |   |      - `errors`: the number of errors encountered while performing the update.
     |   |      - `first_error`: If errors were encountered, contains the text of the first error.
     |   |      - `deleted` and `inserted`: 0 for an update operation.
     |   |      - `changes`: if `return_changes` is set to `True`, this will be an array of objects, one for each objected affected by the `update` operation. Each object will have two keys: `{"new_val": <new value>, "old_val": <old value>}`.
     |   |      
     |   |      *Example* Update the status of the post with `id` of `1` to `published`.
     |   |      
     |   |          r.table("posts").get(1).update({"status": "published"}).run(conn)
     |   |      
     |   |      *Example* Update the status of all posts to `published`.
     |   |      
     |   |          r.table("posts").update({"status": "published"}).run(conn)
     |   |      
     |   |      *Example* Update the status of all the post written by William.
     |   |      
     |   |          r.table("posts").filter({"author": "William"}).update({"status": "published"}).run(conn)
     |   |      
     |   |      *Example* Increment the field `view` with `id` of `1`.
     |   |      This query will throw an error if the field `views` doesn't exist.
     |   |      
     |   |          r.table("posts").get(1).update({
     |   |              "views": r.row["views"]+1
     |   |          }).run(conn)
     |   |      
     |   |      *Example* Increment the field `view` of the post with `id` of `1`.
     |   |      If the field `views` does not exist, it will be set to `0`.
     |   |      
     |   |          r.table("posts").update({
     |   |              "views": (r.row["views"]+1).default(0)
     |   |          }).run(conn)
     |   |      
     |   |      *Example* Perform a conditional update.  
     |   |      If the post has more than 100 views, set the `type` of a post to `hot`, else set it to `normal`.
     |   |      
     |   |          r.table("posts").get(1).update(lambda post:
     |   |              r.branch(
     |   |                  post["views"] > 100,
     |   |                  {"type": "hot"},
     |   |                  {"type": "normal"}
     |   |              )
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Update the field `num_comments` with the result of a sub-query. Because
     |   |      this update is not atomic, you must pass the `non_atomic` flag.
     |   |      
     |   |          r.table("posts").get(1).update({
     |   |              "num_comments": r.table("comments").filter({"id_post": 1}).count()
     |   |          }, non_atomic=True ).run(conn)
     |   |      
     |   |      If you forget to specify the `non_atomic` flag, you will get a `RqlRuntimeError`.
     |   |      
     |   |      RqlRuntimeError: Could not prove function deterministic.  Maybe you want to use the non_atomic flag? 
     |   |      
     |   |      *Example* Update the field `num_comments` with a random value between 0 and 100.  
     |   |      This update cannot be proven deterministic because of `r.js` (and in fact is not), so you
     |   |      must pass the `non_atomic` flag.
     |   |      
     |   |          r.table("posts").get(1).update({
     |   |              "num_comments": r.js("Math.floor(Math.random()*100)")
     |   |          }, non_atomic=True ).run(conn)
     |   |      
     |   |      *Example* Update the status of the post with `id` of `1` using soft durability.
     |   |      
     |   |          r.table("posts").get(1).update({status: "published"}, durability="soft").run(conn)
     |   |      
     |   |      *Example* Increment the field `views` and return the values of the document before
     |   |      and after the update operation.
     |   |      
     |   |          r.table("posts").get(1).update({
     |   |              "views": r.row["views"]+1
     |   |          }, return_changes=True).run(conn)
     |   |      
     |   |      The result will have a `changes` field:
     |   |      
     |   |          {
     |   |              "deleted": 1,
     |   |              "errors": 0,
     |   |              "inserted": 0,
     |   |              "changes": [
     |   |                  {
     |   |                      "new_val": {
     |   |                          "id": 1,
     |   |                          "author": "Julius_Caesar",
     |   |                          "title": "Commentarii de Bello Gallico",
     |   |                          "content": "Aleas jacta est",
     |   |                          "views": 207
     |   |                      },
     |   |                      "old_val": {
     |   |                          "id": 1,
     |   |                          "author": "Julius_Caesar",
     |   |                          "title": "Commentarii de Bello Gallico",
     |   |                          "content": "Aleas jacta est",
     |   |                          "views": 206
     |   |                      }
     |   |                  }
     |   |              ],
     |   |              "replaced": 0,
     |   |              "skipped": 0,
     |   |              "unchanged": 0
     |   |          }
     |   |  
     |   |  with_fields(self, *args)
     |   |      sequence.with_fields([selector1, selector2...]) -> stream
     |   |      array.with_fields([selector1, selector2...]) -> array
     |   |      
     |   |      Plucks one or more attributes from a sequence of objects, filtering out any objects in the sequence that do not have the specified fields. Functionally, this is identical to `has_fields` followed by `pluck` on a sequence.
     |   |      
     |   |      *Example* Get a list of users and their posts, excluding any users who have not made any posts.
     |   |      
     |   |      Existing table structure:
     |   |      
     |   |          [
     |   |              { 'id': 1, 'user': 'bob', 'email': 'bob@foo.com', 'posts': [ 1, 4, 5 ] },
     |   |              { 'id': 2, 'user': 'george', 'email': 'george@foo.com' },
     |   |              { 'id': 3, 'user': 'jane', 'email': 'jane@foo.com', 'posts': [ 2, 3, 6 ] }
     |   |          ]
     |   |      
     |   |      Command and output:
     |   |      
     |   |          r.table('users').with_fields('id', 'user', 'posts').run(conn)
     |   |          
     |   |          [
     |   |              { 'id': 1, 'user': 'bob', 'posts': [ 1, 4, 5 ] },
     |   |              { 'id': 3, 'user': 'jane', 'posts': [ 2, 3, 6 ] }
     |   |          ]
     |   |      
     |   |      *Example* Use the [nested field syntax](http://rethinkdb.com/docs/nested-fields/) to get a list of users with cell phone numbers in their contacts.
     |   |      
     |   |          r.table('users').with_fields('id', 'user', {contact: {'phone': 'work'}).run(conn)
     |   |  
     |   |  without(self, *args)
     |   |      sequence.without([selector1, selector2...]) -> stream
     |   |      array.without([selector1, selector2...]) -> array
     |   |      singleSelection.without([selector1, selector2...]) -> object
     |   |      object.without([selector1, selector2...]) -> object
     |   |      
     |   |      The opposite of pluck; takes an object or a sequence of objects, and returns them with
     |   |      the specified paths removed.
     |   |      
     |   |      *Example* Since we don't need it for this computation we'll save bandwidth and leave
     |   |      out the list of IronMan's romantic conquests.
     |   |      
     |   |          r.table('marvel').get('IronMan').without('personalVictoriesList').run(conn)
     |   |      
     |   |      *Example* Without their prized weapons, our enemies will quickly be vanquished.
     |   |      
     |   |          r.table('enemies').without('weapons').run(conn)
     |   |      
     |   |      *Example* Nested objects can be used to remove the damage subfield from the weapons and abilities fields.
     |   |      
     |   |          r.table('marvel').without({'weapons' : {'damage' : True}, 'abilities' : {'damage' : True}}).run(conn)
     |   |      
     |   |      *Example* The nested syntax can quickly become overly verbose so there's a shorthand for it.
     |   |      
     |   |          r.table('marvel').without({'weapons' : 'damage', 'abilities' : 'damage'}).run(conn)
     |   |  
     |   |  year(self, *args)
     |   |      time.year() -> number
     |   |      
     |   |      Return the year of a time object.
     |   |      
     |   |      *Example* Retrieve all the users born in 1986.
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user["birthdate"].year() == 1986
     |   |          ).run(conn)
     |   |  
     |   |  zip(self, *args)
     |   |      stream.zip() -> stream
     |   |      array.zip() -> array
     |   |      
     |   |      Used to 'zip' up the result of a join by merging the 'right' fields into 'left' fields of each member of the sequence.
     |   |      
     |   |      *Example* 'zips up' the sequence by merging the left and right fields produced by a join.
     |   |      
     |   |          r.table('marvel').eq_join('main_dc_collaborator', r.table('dc')).zip().run(conn)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors defined here:
     |   |  
     |   |  __dict__
     |   |      dictionary for instance variables (if defined)
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |  
     |  class RqlRuntimeError(RqlQueryError)
     |   |  Method resolution order:
     |   |      RqlRuntimeError
     |   |      RqlQueryError
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods defined here:
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlQueryError:
     |   |  
     |   |  __init__(self, message, term, frames)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlError:
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from RqlError:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  class RqlTimeoutError(RqlError)
     |   |  Method resolution order:
     |   |      RqlTimeoutError
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods defined here:
     |   |  
     |   |  __init__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlError:
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from RqlError:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  add(*args)
     |      number + number -> number
     |      string + string -> string
     |      array + array -> array
     |      time + number -> time
     |      
     |      Sum two numbers, concatenate two strings, or concatenate 2 arrays.
     |      
     |      *Example* It's as easy as 2 + 2 = 4.
     |      
     |          > (r.expr(2) + 2).run(conn)
     |          
     |          4
     |      
     |      *Example* Strings can be concatenated too.
     |      
     |          > (r.expr("foo") + "bar").run(conn)
     |          
     |          "foobar"
     |      
     |      *Example* Arrays can be concatenated too.
     |      
     |          > (r.expr(["foo", "bar"]) + ["buzz"]).run(conn)
     |          
     |          ['foo', 'bar', 'buzz']
     |      
     |      *Example* Create a date one year from now.
     |      
     |          r.now() + 365*24*60*60
     |      
     |      *Example* Use [args](http://rethinkdb.com/api/python/args) with `add` to sum multiple values.
     |      
     |          > r.add(r.args([10, 20, 30])).run(conn)
     |          
     |          60
     |      
     |      *Example* Concatenate an array of strings with `args`.
     |      
     |          > r.add(r.args(['foo', 'bar', 'buzz'])).run(conn)
     |          
     |          "foobarbuzz"
     |  
     |  and_(*args)
     |      bool & bool -> bool
     |      r.and_(bool, bool) -> bool
     |      bool.and_(bool) -> bool
     |      
     |      Compute the logical "and" of two or more values. The `and_` command can be used as an infix operator after its first argument (`r.expr(True).and_(False)`) or given all of its arguments as parameters (`r.and_(True, False)`). The standard Python and operator, `&`, may also be used with ReQL.
     |      
     |      *Example* Return whether both `a` and `b` evaluate to true.
     |      
     |          > a = True
     |          > b = False
     |          > (r.expr(a) & b).run(conn)
     |          
     |          False
     |      *Example* Return whether all of `x`, `y` and `z` evaluate to true.
     |      
     |          > x = True
     |          > y = True
     |          > z = True
     |          > r.and_(x, y, z).run(conn)
     |          
     |          True
     |  
     |  april = <RqlQuery instance: r.april >
     |  args(*args)
     |      r.args(array) -> special
     |      
     |      `r.args` is a special term that's used to splice an array of arguments
     |      into another term.  This is useful when you want to call a variadic
     |      term such as `get_all` with a set of arguments produced at runtime.
     |      
     |      This is analogous to unpacking argument lists in Python.
     |      
     |      *Example* Get Alice and Bob from the table `people`.
     |      
     |          r.table('people').get_all('Alice', 'Bob').run(conn)
     |          # or
     |          r.table('people').get_all(r.args(['Alice', 'Bob'])).run(conn)
     |      
     |      *Example* Get all of Alice's children from the table `people`.
     |      
     |          # r.table('people').get('Alice') returns {'id': 'Alice', 'children': ['Bob', 'Carol']}
     |          r.table('people').get_all(r.args(r.table('people').get('Alice')['children'])).run(conn)
     |  
     |  asc(*args)
     |      # orderBy orders
     |  
     |  august = <RqlQuery instance: r.august >
     |  binary(data)
     |      r.binary(data) -> binary
     |      
     |      Encapsulate binary data within a query.
     |      
     |      The type of data `binary` accepts depends on the client language. In Python, it expects a parameter of `bytes` type. Using a `bytes` object within a query implies the use of `binary` and the ReQL driver will automatically perform the coercion (in Python 3 only).
     |      
     |      Binary objects returned to the client in JavaScript will also be of the `bytes` type. This can be changed with the `binary_format` option provided to [run](http://rethinkdb.com/api/python/run) to return "raw" objects.
     |      
     |      Only a limited subset of ReQL commands may be chained after `binary`:
     |      
     |      * [coerce_to](http://rethinkdb.com/api/python/coerce_to/) can coerce `binary` objects to `string` types
     |      * [count](http://rethinkdb.com/api/python/count/) will return the number of bytes in the object
     |      * [slice](http://rethinkdb.com/api/python/slice/) will treat bytes like array indexes (i.e., `slice(10,20)` will return bytes 10&ndash;19)
     |      * [type_of](http://rethinkdb.com/api/python/type_of) returns `PTYPE<BINARY>`
     |      * [info](http://rethinkdb.com/api/python/info) will return information on a binary object.
     |      
     |      *Example* Save an avatar image to a existing user record.
     |      
     |          f = open('./default_avatar.png', 'rb')
     |          avatar_image = f.read()
     |          f.close()
     |          r.table('users').get(100).update({'avatar': r.binary(avatar_image)}).run(conn)
     |      
     |      *Example* Get the size of an existing avatar image.
     |      
     |          r.table('users').get(100)['avatar'].count().run(conn)
     |          
     |          14156
     |      
     |      Read more details about RethinkDB's binary object support: [Storing binary objects](http://rethinkdb.com/docs/storing-binary/).
     |  
     |  branch(*args)
     |      r.branch(test, true_branch, false_branch) -> any
     |      
     |      If the `test` expression returns `False` or `None`, the `false_branch` will be evaluated.
     |      Otherwise, the `true_branch` will be evaluated.
     |         
     |      The `branch` command is effectively an `if` renamed due to language constraints.
     |      
     |      *Example* Return heroes and superheroes.
     |      
     |          r.table('marvel').map(
     |              r.branch(
     |                  r.row['victories'] > 100,
     |                  r.row['name'] + ' is a superhero',
     |                  r.row['name'] + ' is a hero'
     |              )
     |          ).run(conn)
     |      
     |      If the documents in the table `marvel` are:
     |      
     |          [{
     |              "name": "Iron Man",
     |              "victories": 214
     |          },
     |          {
     |              "name": "Jubilee",
     |              "victories": 9
     |          }]
     |      
     |      The results will be:
     |      
     |          [
     |              "Iron Man is a superhero",
     |              "Jubilee is a hero"
     |          ]
     |  
     |  circle(*args, **kwargs)
     |      r.circle([longitude, latitude], radius[, num_vertices=32, geo_system='WGS84', unit='m', fill=True]) -> geometry
     |      r.circle(point, radius[, {num_vertices=32, geo_system='WGS84', unit='m', fill=True]) -> geometry
     |      
     |      Construct a circular line or polygon. A circle in RethinkDB is a polygon or line *approximating* a circle of a given radius around a given center, consisting of a specified number of vertices (default 32).
     |      
     |      The center may be specified either by two floating point numbers, the latitude (&minus;90 to 90) and longitude (&minus;180 to 180) of the point on a perfect sphere (see [Geospatial support](http://rethinkdb.com/docs/geo-support/) for more information on ReQL's coordinate system), or by a point object. The radius is a floating point number whose units are meters by default, although that may be changed with the `unit` argument.
     |      
     |      Optional arguments available with `circle` are:
     |      
     |      * `num_vertices`: the number of vertices in the polygon or line. Defaults to 32.
     |      * `geo_system`: the reference ellipsoid to use for geographic coordinates. Possible values are `WGS84` (the default), a common standard for Earth's geometry, or `unit_sphere`, a perfect sphere of 1 meter radius.
     |      * `unit`: Unit for the radius distance. Possible values are `m` (meter, the default), `km` (kilometer), `mi` (international mile), `nm` (nautical mile), `ft` (international foot).
     |      * `fill`: if `True` (the default) the circle is filled, creating a polygon; if `False` the circle is unfilled (creating a line).
     |      
     |      *Example* Define a circle.
     |      
     |          r.table('geo').insert({
     |              'id': 300,
     |              'name': 'Hayes Valley',
     |              'neighborhood': r.circle([-122.423246,37.779388], 1000)
     |          }).run(conn)
     |  
     |  connect(host='localhost', port=28015, db=None, auth_key='', timeout=20, **kwargs)
     |      r.connect(host="localhost", port=28015, db="test", auth_key="", timeout=20) -> connection
     |      r.connect(host) -> connection
     |      
     |      Create a new connection to the database server. The keyword arguments are:
     |      
     |      - `host`: host of the RethinkDB instance. The default value is `localhost`.
     |      - `port`: the driver port, by default `28015`.
     |      - `db`: the database used if not explicitly specified in a query, by default `test`.
     |      - `auth_key`: the authentication key, by default the empty string.
     |      - `timeout`: timeout period in seconds for the connection to be opened (default `20`).
     |      
     |      If the connection cannot be established, a `RqlDriverError` exception will be thrown.
     |      
     |      The authentication key can be set from the RethinkDB command line tool. Once set, client connections must provide the key as an option to `run` in order to make the connection. For more information, read "Using the RethinkDB authentication system" in the documentation on [securing your cluster](http://rethinkdb.com/docs/security/).
     |      
     |      __Note:__ Currently, the Python driver is not thread-safe. Each thread or multiprocessing PID should be given its own connection object. (This is likely to change in a future release of RethinkDB; you can track issue [#2427](https://github.com/rethinkdb/rethinkdb/issues/2427) for progress.)
     |      
     |      *Example* Opens a connection using the default host and port but specifying the default database.
     |      
     |          conn = r.connect(db='marvel')
     |      
     |      *Example* Opens a new connection to the database.
     |      
     |          conn = r.connect(host = 'localhost',
     |                           port = 28015,
     |                           db = 'heroes',
     |                           auth_key = 'hunter2')
     |  
     |  db(*args)
     |      r.db(db_name) -> db
     |      
     |      Reference a database.
     |      
     |      *Example* Before we can query a table we have to select the correct database.
     |      
     |          r.db('heroes').table('marvel').run(conn)
     |  
     |  db_create(*args)
     |      r.db_create(db_name) -> object
     |      
     |      Create a database. A RethinkDB database is a collection of tables, similar to
     |      relational databases.
     |      
     |      If successful, the command returns an object with two fields:
     |      
     |      * `dbs_created`: always `1`.
     |      * `config_changes`: a list containing one object with two fields, `old_val` and `new_val`:
     |          * `old_val`: always `None`.
     |          * `new_val`: the database's new [config](http://rethinkdb.com/api/python/config) value.
     |      
     |      If a database with the same name already exists, the command throws `RqlRuntimeError`.
     |      
     |      Note: Only alphanumeric characters and underscores are valid for the database name.
     |      
     |      *Example* Create a database named 'superheroes'.
     |      
     |          r.db_create('superheroes').run(conn)
     |          
     |          {
     |              "config_changes": [
     |                  {
     |                      "new_val": {
     |                          "id": "e4689cfc-e903-4532-a0e6-2d6797a43f07",
     |                          "name": "superheroes"
     |                      },
     |                      "old_val": None
     |                  }
     |              ],
     |              "dbs_created": 1
     |          }
     |  
     |  db_drop(*args)
     |      r.db_drop(db_name) -> object
     |      
     |      Drop a database. The database, all its tables, and corresponding data will be deleted.
     |      
     |      If successful, the command returns an object with two fields:
     |      
     |      * `dbs_dropped`: always `1`.
     |      * `tables_dropped`: the number of tables in the dropped database.
     |      * `config_changes`: a list containing one two-field object, `old_val` and `new_val`:
     |          * `old_val`: the database's original [config](http://rethinkdb.com/api/python/config) value.
     |          * `new_val`: always `None`.
     |      
     |      If the given database does not exist, the command throws `RqlRuntimeError`.
     |      
     |      *Example* Drop a database named 'superheroes'.
     |      
     |          r.db_drop('superheroes').run(conn)
     |          
     |          {
     |              "config_changes": [
     |                  {
     |                      "old_val": {
     |                          "id": "e4689cfc-e903-4532-a0e6-2d6797a43f07",
     |                          "name": "superheroes"
     |                      },
     |                      "new_val": None
     |                  }
     |              ],
     |              "tables_dropped": 3,
     |              "dbs_dropped": 1
     |          }
     |  
     |  db_list(*args)
     |      r.db_list() -> array
     |      
     |      List all database names in the system. The result is a list of strings.
     |      
     |      *Example* List all databases.
     |      
     |          r.db_list().run(conn)
     |  
     |  december = <RqlQuery instance: r.december >
     |  desc(*args)
     |  
     |  distance(*args, **kwargs)
     |  
     |  div(*args)
     |      number / number -> number
     |      
     |      Divide two numbers.
     |      
     |      *Example* It's as easy as 2 / 2 = 1.
     |      
     |          (r.expr(2) / 2).run(conn)
     |  
     |  do(*args)
     |  
     |  epoch_time(*args)
     |      r.epoch_time(epoch_time) -> time
     |      
     |      Create a time object based on seconds since epoch. The first argument is a double and
     |      will be rounded to three decimal places (millisecond-precision).
     |      
     |      *Example* Update the birthdate of the user "John" to November 3rd, 1986.
     |      
     |          r.table("user").get("John").update({"birthdate": r.epoch_time(531360000)}).run(conn)
     |  
     |  eq(*args)
     |      # math and logic
     |  
     |  error(*msg)
     |      r.error(message) -> error
     |      
     |      Throw a runtime error. If called with no arguments inside the second argument to `default`, re-throw the current error.
     |      
     |      *Example* Iron Man can't possibly have lost a battle:
     |      
     |          r.table('marvel').get('IronMan').do(
     |              lambda ironman: r.branch(ironman['victories'] < ironman['battles'],
     |                                       r.error('impossible code path'),
     |                                       ironman)
     |          ).run(conn)
     |  
     |  expr(val, nesting_depth=20)
     |      r.expr(value) -> value
     |      
     |      Construct a ReQL JSON object from a native object.
     |      
     |      If the native object is of the `bytes` type, then `expr` will return a binary object. See [binary](http://rethinkdb.com/api/python/binary) for more information.
     |      
     |      *Example* Objects wrapped with expr can then be manipulated by ReQL API functions.
     |      
     |          r.expr({'a':'b'}).merge({'b':[1,2,3]}).run(conn)
     |  
     |  february = <RqlQuery instance: r.february >
     |  friday = <RqlQuery instance: r.friday >
     |  ge(*args)
     |  
     |  geojson(*args)
     |      r.geojson(geojson) -> geometry
     |      
     |      Convert a [GeoJSON][] object to a ReQL geometry object.
     |      
     |      [GeoJSON]: http://geojson.org
     |      
     |      RethinkDB only allows conversion of GeoJSON objects which have ReQL equivalents: Point, LineString, and Polygon. MultiPoint, MultiLineString, and MultiPolygon are not supported. (You could, however, store multiple points, lines and polygons in an array and use a geospatial multi index with them.)
     |      
     |      Only longitude/latitude coordinates are supported. GeoJSON objects that use Cartesian coordinates, specify an altitude, or specify their own coordinate reference system will be rejected.
     |      
     |      *Example* Convert a GeoJSON object to a ReQL geometry object.
     |      
     |          geo_json = {
     |              'type': 'Point',
     |              'coordinates': [ -122.423246, 37.779388 ]
     |          }
     |          r.table('geo').insert({
     |              'id': 'sfo',
     |              'name': 'San Francisco',
     |              'location': r.geojson(geo_json)
     |          }).run(conn)
     |  
     |  gt(*args)
     |  
     |  http(url, **kwargs)
     |      r.http(url[, options]) -> value
     |      r.http(url[, options]) -> stream
     |      
     |      Retrieve data from the specified URL over HTTP.  The return type depends on the `result_format` option, which checks the `Content-Type` of the response by default.
     |      
     |      *Example* Perform an HTTP `GET` and store the result in a table.
     |      
     |          r.table('posts').insert(r.http('http://httpbin.org/get')).run(conn)
     |      
     |      See [the tutorial](http://rethinkdb.com/docs/external-api-access/) on `r.http` for more examples on how to use this command.
     |      
     |      * `timeout`: Number of seconds to wait before timing out and aborting the operation. Default: 30.
     |      
     |      * `reattempts`: An integer giving the number of attempts to make in cast of connection errors or potentially-temporary HTTP errors. Default: 5.
     |      
     |      * `redirects`: An integer giving the number of redirects and location headers to follow. Default: 1.
     |      
     |      * `verify`: Verify the server's SSL certificate, specified as a boolean. Default: True.
     |      
     |      * `result_format`: The format the result should be returned in. The values can be `'text'` (always return as a string), `'json'` (parse the result as JSON, raising an error if the parsing fails), `'jsonp'` (parse the result as [padded JSON](http://www.json-p.org/)), `'binary'` (return a binary object), or `'auto'` . The default is `'auto'`.
     |      
     |          When `result_format` is `'auto'`, the response body will be parsed according to the `Content-Type` of the response:
     |          * `application/json`: parse as `'json'`
     |          * `application/json-p`, `text/json-p`, `text/javascript`: parse as `'jsonp'`
     |          * `audio/*`, `video/*`, `image/*`, `application/octet-stream`: return a binary object
     |          * Anything else: parse as `'text'`
     |      
     |      * `method`: HTTP method to use for the request. One of `GET`, `POST`, `PUT`, `PATCH`, `DELETE` or `HEAD`. Default: `GET`.
     |      
     |      * `auth`: Authentication information in the form of an object with key/value pairs indicating the authentication type (in the `type` key) and any required information. Types currently supported are `basic` and `digest` for HTTP Basic and HTTP Digest authentication respectively. If `type` is omitted, `basic` is assumed. Example:
     |      
     |              ```py
     |              r.http('http://httpbin.org/basic-auth/fred/mxyzptlk',
     |                 auth={ 'type': 'basic', 'user': 'fred', 'pass': 'mxyzptlk' }).run(conn)
     |              ```
     |      
     |      * `params`: URL parameters to append to the URL as encoded key/value pairs, specified as an object. For example, `{ 'query': 'banana', 'limit': 2 }` will be appended as `?query=banana&limit=2`. Default: none.
     |      
     |      * `header`: Extra header lines to include. The value may be an array of strings or an object. Default: none.
     |      
     |          Unless specified otherwise, `r.http` will by default use the headers `Accept-Encoding: deflate=1;gzip=0.5` and `User-Agent: RethinkDB/VERSION`.
     |      
     |      * `data`: Data to send to the server on a `POST`, `PUT`, `PATCH`, or `DELETE` request.
     |      
     |          For `PUT`, `PATCH` and `DELETE` requests, the value will be serialized to JSON and placed in the request body, and the `Content-Type` will be set to `application/json`.
     |      
     |              For `POST` requests, data may be either an object or a string. Objects will be written to the body as form-encoded key/value pairs (values must be numbers, strings, or `None`). Strings will be put directly into the body.  If `data` is not a string or an object, an error will be thrown.
     |      
     |          If `data` is not specified, no data will be sent.
     |      
     |      `r.http` supports depagination, which will request multiple pages in a row and aggregate the results into a stream.  The use of this feature is controlled by the optional arguments `page` and `page_limit`.  Either none or both of these arguments must be provided.
     |      
     |      * `page`: This option may specify either a built-in pagination strategy (as a string), or a function to provide the next URL and/or `params` to request.
     |      
     |          At the moment, the only supported built-in is `'link-next'`, which is equivalent to `lambda info: info['header']['link']['rel="next"'].default(None)`.
     |      
     |          *Example* Perform a GitHub search and collect up to 3 pages of results.
     |      
     |          ```py
     |          r.http("https://api.github.com/search/code?q=addClass+user:mozilla",
     |                 page='link-next', page_limit=3).run(conn)
     |          ```
     |      
     |          As a function, `page` takes one parameter, an object of the format:
     |      
     |          ```py
     |          {
     |              'params': object, # the URL parameters used in the last request
     |              'header': object, # the HTTP headers of the last response as key/value pairs
     |              'body': value # the body of the last response in the format specified by `result_format`
     |          }
     |          ```
     |      
     |          The `header` field will be a parsed version of the header with fields lowercased, like so:
     |      
     |          ```py
     |          {
     |              'content-length': '1024',
     |              'content-type': 'application/json',
     |              'date': 'Thu, 1 Jan 1970 00:00:00 GMT',
     |              'link': {
     |                  'rel="last"': 'http://example.com/?page=34',
     |                  'rel="next"': 'http://example.com/?page=2'
     |              }
     |          }
     |          ```
     |      
     |          The `page` function may return a string corresponding to the next URL to request, `None` indicating that there is no more to get, or an object of the format:
     |      
     |          ```py
     |          {
     |              'url': string, # the next URL to request, or None for no more pages
     |              'params': object # new URL parameters to use, will be merged with the previous request's params
     |          }
     |          ```
     |      
     |      * `page_limit`: An integer specifying the maximum number of requests to issue using the `page` functionality.  This is to prevent overuse of API quotas, and must be specified with `page`.
     |          * `-1`: no limit
     |          * `0`: no requests will be made, an empty stream will be returned
     |          * `n`: `n` requests will be made
     |      
     |      # Examples
     |      
     |      *Example* Perform multiple requests with different parameters.
     |      
     |          r.expr([1, 2, 3]).map(lambda i: r.http('http://httpbin.org/get',
     |                                                 params={ 'user': i })).run(conn)
     |      
     |      *Example* Perform a `PUT` request for each item in a table.
     |      
     |          r.table('data').map(lambda row: r.http('http://httpbin.org/put',
     |                                                 method='PUT', data=row)).run(conn)
     |      
     |      *Example* Perform a `POST` request with accompanying data.
     |      
     |      Using form-encoded data:
     |      
     |          r.http('http://httpbin.org/post',
     |                 method='POST',
     |                 data={ 'player': 'Bob', 'game': 'tic tac toe' }).run(conn)
     |      
     |      Using JSON data:
     |      
     |          r.http('http://httpbin.org/post',
     |                 method='POST',
     |                 data=r.expr(value).coerce_to('string'),
     |                 header={ 'Content-Type': 'application/json' }).run(conn)
     |      
     |      *Example* Perform depagination with a custom `page` function.
     |      
     |          r.http('example.com/pages',
     |                 page=lambda info: info['body']['meta']['next'].default(None),
     |                 page_limit=5).run(conn)
     |      
     |      # Learn more
     |      
     |      See [the tutorial](http://rethinkdb.com/docs/external-api-access/) on `r.http` for more examples on how to use this command.
     |  
     |  info(*args)
     |  
     |  intersects(*args)
     |  
     |  iso8601(*args, **kwargs)
     |      r.iso8601(iso8601Date[, default_timezone='']) -> time
     |      
     |      Create a time object based on an ISO 8601 date-time string (e.g. '2013-01-01T01:01:01+00:00'). We support all valid ISO 8601 formats except for week dates. If you pass an ISO 8601 date-time without a time zone, you must specify the time zone with the `default_timezone` argument. Read more about the ISO 8601 format at [Wikipedia](http://en.wikipedia.org/wiki/ISO_8601).
     |      
     |      *Example* Update the time of John's birth.
     |      
     |          r.table("user").get("John").update({"birth": r.iso8601('1986-11-03T08:30:00-07:00')}).run(conn)
     |  
     |  january = <RqlQuery instance: r.january >
     |  js(*args, **kwargs)
     |      r.js(js_string[, timeout=<number>]) -> value
     |      
     |      Create a javascript expression.
     |      
     |      *Example* Concatenate two strings using JavaScript.
     |      
     |      `timeout` is the number of seconds before `r.js` times out. The default value is 5 seconds.
     |      
     |      {% infobox %}
     |      Whenever possible, you should use native ReQL commands rather than `r.js` for better performance.
     |      {% endinfobox %}
     |      
     |          r.js("'str1' + 'str2'").run(conn)
     |      
     |      *Example* Select all documents where the 'magazines' field is greater than 5 by running JavaScript on the server.
     |      
     |          r.table('marvel').filter(
     |              r.js('(function (row) { return row.magazines.length > 5; })')
     |          ).run(conn)
     |      
     |      *Example* You may also specify a timeout in seconds (defaults to 5).
     |      
     |          r.js('while(true) {}', timeout=1.3).run(conn)
     |  
     |  json(*args)
     |      r.json(json_string) -> value
     |      
     |      Parse a JSON string on the server.
     |      
     |      *Example* Send an array to the server'
     |      
     |          r.json("[1,2,3]").run(conn)
     |  
     |  july = <RqlQuery instance: r.july >
     |  june = <RqlQuery instance: r.june >
     |  le(*args)
     |  
     |  line(*args)
     |      r.line([lon1, lat1], [lon2, lat2], ...) -> line
     |      r.line(point1, point2, ...) -> line
     |      
     |      Construct a geometry object of type Line. The line can be specified in one of two ways:
     |      
     |      * Two or more two-item arrays, specifying latitude and longitude numbers of the line's vertices;
     |      * Two or more [Point](http://rethinkdb.com/api/python/point) objects specifying the line's vertices.
     |      
     |      Longitude (&minus;180 to 180) and latitude (&minus;90 to 90) of vertices are plotted on a perfect sphere. See [Geospatial support](http://rethinkdb.com/docs/geo-support/) for more information on ReQL's coordinate system.
     |      
     |      *Example* Define a line.
     |      
     |          r.table('geo').insert({
     |              'id': 101,
     |              'route': r.line([-122.423246,37.779388], [-121.886420,37.329898])
     |          }).run(conn)
     |  
     |  literal(*args)
     |      r.literal(object) -> special
     |      
     |      Replace an object in a field instead of merging it with an existing object in a `merge` or `update` operation. = Using `literal` with no arguments in a `merge` or `update` operation will remove the corresponding field.
     |      
     |      *Example* Replace one nested document with another rather than merging the fields.
     |      
     |      Assume your users table has this structure:
     |      
     |          [
     |              {
     |                  "id": 1,
     |                  "name": "Alice",
     |                  "data": {
     |                      "age": 18,
     |                      "city": "Dallas"
     |                  }
     |              }       
     |              ...
     |          ]
     |      
     |      Using `update` to modify the `data` field will normally merge the nested documents:
     |      
     |          r.table('users').get(1).update({ 'data': { 'age': 19, 'job': 'Engineer' } }).run(conn)
     |          
     |          {
     |              "id": 1,
     |              "name": "Alice",
     |              "data": {
     |                  "age": 19,
     |                  "city": "Dallas",
     |                  "job": "Engineer"
     |              }
     |          }       
     |      
     |      That will preserve `city` and other existing fields. But to replace the entire `data` document with a new object, use `literal`:
     |      
     |          r.table('users').get(1).update({ 'data': r.literal({ 'age': 19, 'job': 'Engineer' }) }).run(conn)
     |          
     |          {
     |              "id": 1,
     |              "name": "Alice",
     |              "data": {
     |                  "age": 19,
     |                  "job": "Engineer"
     |              }
     |          }       
     |      
     |      *Example* Use `literal` to remove a field from a document.
     |      
     |          r.table('users').get(1).merge({ "data": r.literal() }).run(conn)
     |          
     |          {
     |              "id": 1,
     |              "name": "Alice"
     |          }
     |  
     |  lt(*args)
     |  
     |  make_timezone(*args)
     |  
     |  map(*args)
     |  
     |  march = <RqlQuery instance: r.march >
     |  maxval = <RqlQuery instance: r.maxval >
     |  may = <RqlQuery instance: r.may >
     |  minval = <RqlQuery instance: r.minval >
     |  mod(*args)
     |      number % number -> number
     |      
     |      Find the remainder when dividing two numbers.
     |      
     |      *Example* It's as easy as 2 % 2 = 0.
     |      
     |          (r.expr(2) % 2).run(conn)
     |      
     |      `
     |  
     |  monday = <RqlQuery instance: r.monday >
     |  mul(*args)
     |      number * number -> number
     |      array * number -> array
     |      
     |      Multiply two numbers, or make a periodic array.
     |      
     |      *Example* It's as easy as 2 * 2 = 4.
     |      
     |          (r.expr(2) * 2).run(conn)
     |      
     |      *Example* Arrays can be multiplied by numbers as well.
     |      
     |          (r.expr(["This", "is", "the", "song", "that", "never", "ends."]) * 100).run(conn)
     |  
     |  ne(*args)
     |  
     |  not_(*args)
     |      bool.not_() -> bool
     |      not_(bool) -> bool
     |      (~bool) -> bool
     |      
     |      Compute the logical inverse (not) of an expression.
     |      
     |      `not_` can be called either via method chaining, immediately after an expression that evaluates as a boolean value, or by passing the expression as a parameter to `not_`.  All values that are not `False` or `None` will be converted to `True`.
     |      
     |      You may also use `~` as a shorthand operator.
     |      
     |      *Example* Not true is false.
     |      
     |          r.not_(True).run(conn)
     |          r.expr(True).not_().run(conn)
     |          (~r.expr(True)).run(conn)
     |      
     |      These evaluate to `false`.
     |      
     |      Note that when using `~` the expression is wrapped in parentheses. Without this, Python will evaluate `r.expr(True)` *first* rather than using the ReQL operator and return an incorrect value. (`~True` evaluates to &minus;2 in Python.)
     |      
     |      *Example* Return all the users that do not have a "flag" field.
     |      
     |          r.table('users').filter(
     |              lambda users: (~users.has_fields('flag'))
     |          ).run(conn)
     |      
     |      *Example* As above, but prefix-style.
     |      
     |          r.table('users').filter(
     |              lambda users: r.not_(users.has_fields('flag'))
     |          ).run(conn)
     |  
     |  november = <RqlQuery instance: r.november >
     |  now(*args)
     |      r.now() -> time
     |      
     |      Return a time object representing the current time in UTC. The command now() is computed once when the server receives the query, so multiple instances of r.now() will always return the same time inside a query.
     |      
     |      *Example* Add a new user with the time at which he subscribed.
     |      
     |          r.table("users").insert({
     |              "name": "John",
     |              "subscription_date": r.now()
     |          }).run(conn)
     |  
     |  object(*args)
     |      r.object([key, value,]...) -> object
     |      
     |      Creates an object from a list of key-value pairs, where the keys must
     |      be strings.  `r.object(A, B, C, D)` is equivalent to
     |      `r.expr([[A, B], [C, D]]).coerce_to('OBJECT')`.
     |      
     |      *Example* Create a simple object.
     |      
     |          > r.object('id', 5, 'data', ['foo', 'bar']).run(conn)
     |          {'data': ["foo", "bar"], 'id': 5}
     |  
     |  october = <RqlQuery instance: r.october >
     |  or_(*args)
     |      bool | bool -> bool
     |      bool.or_(bool[, bool, ...]) -> bool
     |      r.or_(bool, bool) -> bool
     |      
     |      Compute the logical "or" of two or more values. The `or_` command can be used as an infix operator after its first argument (`r.expr(True).or_(False)`) or given all of its arguments as parameters (`r.or_(True, False)`). The standard Python or operator, `|`, may also be used with ReQL.
     |      
     |      *Example* Return whether either `a` or `b` evaluate to true.
     |      
     |          > a = True
     |          > b = False
     |          > (r.expr(a) | b).run(conn)
     |          
     |          True
     |      
     |      *Example* Return whether any of `x`, `y` or `z` evaluate to true.
     |      
     |          > x = False
     |          > y = False
     |          > z = False
     |          > r.or_(x, y, z).run(conn)
     |          
     |          False
     |      
     |      __Note:__ When using `or` inside a `filter` predicate to test the values of fields that may not exist on the documents being tested, you should use the `default` command with those fields so they explicitly return `False`.
     |      
     |          r.table('posts').filter(lambda post:
     |              post['category'].default('foo').eq('article').or(
     |                  post['genre'].default('foo').eq('mystery'))
     |          ).run(conn)
     |  
     |  point(*args)
     |      r.point(longitude, latitude) -> point
     |      
     |      Construct a geometry object of type Point. The point is specified by two floating point numbers, the longitude (&minus;180 to 180) and latitude (&minus;90 to 90) of the point on a perfect sphere. See [Geospatial support](http://rethinkdb.com/docs/geo-support/) for more information on ReQL's coordinate system.
     |      
     |      *Example* Define a point.
     |      
     |          r.table('geo').insert({
     |              'id': 1,
     |              'name': 'San Francisco',
     |              'location': r.point(-122.423246,37.779388)
     |          }).run(conn)
     |  
     |  polygon(*args)
     |      r.polygon([lon1, lat1], [lon2, lat2], ...) -> polygon
     |      r.polygon(point1, point2, ...) -> polygon
     |      
     |      Construct a geometry object of type Polygon. The Polygon can be specified in one of two ways:
     |      
     |      * Three or more two-item arrays, specifying latitude and longitude numbers of the polygon's vertices;
     |      * Three or more [Point](http://rethinkdb.com/api/python/point) objects specifying the polygon's vertices.
     |      
     |      Longitude (&minus;180 to 180) and latitude (&minus;90 to 90) of vertices are plotted on a perfect sphere. See [Geospatial support](http://rethinkdb.com/docs/geo-support/) for more information on ReQL's coordinate system.
     |      
     |      If the last point does not specify the same coordinates as the first point, `polygon` will close the polygon by connecting them. You cannot directly construct a polygon with holes in it using `polygon`, but you can use [polygon_sub](http://rethinkdb.com/api/python/polygon_sub) to use a second polygon within the interior of the first to define a hole.
     |      
     |      *Example* Define a polygon.
     |      
     |          r.table('geo').insert({
     |              'id': 101,
     |              'rectangle': r.polygon(
     |                  [-122.423246,37.779388],
     |                  [-122.423246,37.329898],
     |                  [-121.886420,37.329898],
     |                  [-121.886420,37.779388]
     |              )
     |          }).run(conn)
     |  
     |  random(*args, **kwargs)
     |      r.random() -> number
     |      r.random(number[, number], float=True) -> number
     |      r.random(integer[, integer]) -> integer
     |      
     |      Generate a random number between given (or implied) bounds. `random` takes zero, one or two arguments.
     |      
     |      - With __zero__ arguments, the result will be a floating-point number in the range `[0,1)` (from 0 up to but not including 1).
     |      - With __one__ argument _x,_ the result will be in the range `[0,x)`, and will be integer unless `float=True` is given as an option. Specifying a floating point number without the `float` option will raise an error.
     |      - With __two__ arguments _x_ and _y,_ the result will be in the range `[x,y)`, and will be integer unless `float=True` is given as an option.  If _x_ and _y_ are equal an error will occur, unless the floating-point option has been specified, in which case _x_ will be returned. Specifying a floating point number without the `float` option will raise an error.
     |      
     |      Note: The last argument given will always be the 'open' side of the range, but when
     |      generating a floating-point number, the 'open' side may be less than the 'closed' side.
     |      
     |      *Example* Generate a random number in the range `[0,1)`
     |      
     |          r.random().run(conn)
     |      
     |      *Example* Generate a random integer in the range `[0,100)`
     |      
     |          r.random(100).run(conn)
     |          r.random(0, 100).run(conn)
     |      
     |      *Example* Generate a random number in the range `(-2.24,1.59]`
     |      
     |          r.random(1.59, -2.24, float=True).run(conn)
     |  
     |  range(*args)
     |      r.range() -> stream
     |      r.range([start_value, ]end_value) -> stream
     |      
     |      Generate a stream of sequential integers in a specified range. `range` takes 0, 1 or 2 arguments:
     |      
     |      * With no arguments, `range` returns an "infinite" stream from 0 up to and including the maximum integer value;
     |      * With one argument, `range` returns a stream from 0 up to but not including the end value;
     |      * With two arguments, `range` returns a stream from the start value up to but not including the end value.
     |      
     |      Note that the left bound (including the implied left bound of 0 in the 0- and 1-argument form) is always closed and the right bound is always open: the start value will always be included in the returned range and the end value will *not* be included in the returned range.
     |      
     |      Any specified arguments must be integers, or a `RqlRuntimeError` will be thrown. If the start value is equal or to higher than the end value, no error will be thrown but a zero-element stream will be returned.
     |      
     |      *Example* Return a four-element range of `[0, 1, 2, 3]`.
     |      
     |          > r.range(4).run(conn)
     |          
     |          [0, 1, 2, 3]
     |      
     |      You can also use the [limit](http://rethinkdb.com/api/python/limit) command with the no-argument variant to achieve the same result in this case:
     |      
     |          > r.range().limit(4).run(conn)
     |          
     |          [0, 1, 2, 3]
     |      
     |      *Example* Return a range from -5 through 5.
     |      
     |          > r.range(-5, 6).run(conn)
     |          
     |          [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]
     |  
     |  rebalance(*args, **kwargs)
     |  
     |  reconfigure(*args, **kwargs)
     |  
     |  row = <RqlQuery instance: r.row >
     |  saturday = <RqlQuery instance: r.saturday >
     |  september = <RqlQuery instance: r.september >
     |  set_loop_type(library)
     |  
     |  sub(*args)
     |      number - number -> number
     |      time - time -> number
     |      time - number -> time
     |      
     |      Subtract two numbers.
     |      
     |      *Example* It's as easy as 2 - 2 = 0.
     |      
     |          (r.expr(2) - 2).run(conn)
     |      
     |      *Example* Create a date one year ago today.
     |      
     |          r.now() - 365*24*60*60
     |      
     |      *Example* Retrieve how many seconds elapsed between today and date
     |      
     |          r.now() - date
     |  
     |  sunday = <RqlQuery instance: r.sunday >
     |  table(*args, **kwargs)
     |  
     |  table_create(*args, **kwargs)
     |  
     |  table_drop(*args)
     |  
     |  table_list(*args)
     |  
     |  thursday = <RqlQuery instance: r.thursday >
     |  time(*args)
     |      r.time(year, month, day[, hour, minute, second], timezone)
     |          -> time
     |      
     |      Create a time object for a specific time.
     |      
     |      A few restrictions exist on the arguments:
     |      
     |      - `year` is an integer between 1400 and 9,999.
     |      - `month` is an integer between 1 and 12.
     |      - `day` is an integer between 1 and 31.
     |      - `hour` is an integer.
     |      - `minutes` is an integer.
     |      - `seconds` is a double. Its value will be rounded to three decimal places
     |      (millisecond-precision).
     |      - `timezone` can be `'Z'` (for UTC) or a string with the format `±[hh]:[mm]`.
     |      
     |      *Example* Update the birthdate of the user "John" to November 3rd, 1986 UTC.
     |      
     |          r.table("user").get("John").update({"birthdate": r.time(1986, 11, 3, 'Z')}).run(conn)
     |  
     |  tuesday = <RqlQuery instance: r.tuesday >
     |  type_of(*args)
     |  
     |  uuid(*args)
     |      r.uuid() -> string
     |      
     |      Return a UUID (universally unique identifier), a string that can be used as a unique ID.
     |      
     |      *Example* Generate a UUID.
     |      
     |          > r.uuid().run(conn)
     |          
     |          27961a0e-f4e8-4eb3-bf95-c5203e1d87b9
     |  
     |  wait(*args, **kwargs)
     |  
     |  wednesday = <RqlQuery instance: r.wednesday >
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    rethinkdb = class r(__builtin__.object)
     |  # The builtins here defends against re-importing something obscuring `object`.
     |  
     |  Static methods defined here:
     |  
     |  class Connection(__builtin__.object)
     |   |  Methods defined here:
     |   |  
     |   |  __enter__(self)
     |   |  
     |   |  __exit__(self, type, value, traceback)
     |   |  
     |   |  __init__(self, conn_type, host, port, db, auth_key, timeout, **kwargs)
     |   |  
     |   |  check_open(self)
     |   |  
     |   |  close(self, noreply_wait=True)
     |   |      conn.close(noreply_wait=True)
     |   |      
     |   |      Close an open connection.
     |   |      
     |   |      Closing a connection normally waits until all outstanding requests have finished and then frees any open resources associated with the connection. By passing `False` to the `noreply_wait` optional argument, the connection will be closed immediately, possibly aborting any outstanding noreply writes.
     |   |      
     |   |      A noreply query is executed by passing the `noreply` option to the [run](http://rethinkdb.com/api/python/run/) command, indicating that `run()` should not wait for the query to complete before returning. You may also explicitly wait for a noreply query to complete by using the [noreply_wait](http://rethinkdb.com/api/python/noreply_wait) command.
     |   |      
     |   |      *Example* Close an open connection, waiting for noreply writes to finish.
     |   |      
     |   |          conn.close()
     |   |      
     |   |      *Example* Close an open connection immediately.
     |   |      
     |   |          conn.close(noreply_wait=False)
     |   |  
     |   |  is_open(self)
     |   |  
     |   |  noreply_wait(self)
     |   |      conn.noreply_wait()
     |   |      
     |   |      `noreply_wait` ensures that previous queries with the `noreply` flag have been processed
     |   |      by the server. Note that this guarantee only applies to queries run on the given connection.
     |   |      
     |   |      *Example* We have previously run queries with the `noreply` argument set to `True`. Now
     |   |      wait until the server has processed them.
     |   |      
     |   |          conn.noreply_wait()
     |   |  
     |   |  reconnect(self, noreply_wait=True, timeout=None)
     |   |      conn.reconnect(noreply_wait=True)
     |   |      
     |   |      Close and reopen a connection.
     |   |      
     |   |      Closing a connection normally waits until all outstanding requests have finished and then frees any open resources associated with the connection. By passing `False` to the `noreply_wait` optional argument, the connection will be closed immediately, possibly aborting any outstanding noreply writes.
     |   |      
     |   |      A noreply query is executed by passing the `noreply` option to the [run](http://rethinkdb.com/api/python/run/) command, indicating that `run()` should not wait for the query to complete before returning. You may also explicitly wait for a noreply query to complete by using the [noreply_wait](http://rethinkdb.com/api/python/noreply_wait) command.
     |   |      
     |   |      *Example* Cancel outstanding requests/queries that are no longer needed.
     |   |      
     |   |          conn.reconnect(noreply_wait=False)
     |   |  
     |   |  repl(self)
     |   |      conn.repl()
     |   |      
     |   |      Set the default connection to make REPL use easier. Allows calling
     |   |      `.run()` on queries without specifying a connection.
     |   |      
     |   |      __Note:__ Avoid using `repl` in application code. RethinkDB connection objects are not thread-safe, and calls to `connect` from multiple threads may change the global connection object used by `repl`. Applications should specify connections explicitly.
     |   |      
     |   |      *Example* Set the default connection for the REPL, then call
     |   |      `run()` without specifying the connection.
     |   |      
     |   |          r.connect(db='marvel').repl()
     |   |          r.table('heroes').run()
     |   |  
     |   |  use(self, db)
     |   |      conn.use(db_name)
     |   |      
     |   |      Change the default database on this connection.
     |   |      
     |   |      *Example* Change the default database so that we don't need to
     |   |      specify the database when referencing a table.
     |   |      
     |   |          conn.use('marvel')
     |   |          r.table('heroes').run(conn) # refers to r.db('marvel').table('heroes')
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors defined here:
     |   |  
     |   |  __dict__
     |   |      dictionary for instance variables (if defined)
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |  
     |  class Cursor(__builtin__.object)
     |   |  # This class encapsulates all shared behavior between cursor implementations.
     |   |  # It provides iteration over the cursor using `iter`, as well as incremental
     |   |  # iteration using `next`.
     |   |  #
     |   |  # query - the original query that resulted in the cursor, used for:
     |   |  #     query.term - the term to be used for pretty-printing backtraces
     |   |  #     query.token - the token to use for subsequent CONTINUE and STOP requests
     |   |  #     query.global_optargs - dictate how to format results
     |   |  # items - The current list of items obtained from the server, this is
     |   |  #     added to in `_extend`, which is called by the ConnectionInstance when a
     |   |  #     new response arrives for this cursor.
     |   |  # outstanding_requests - The number of requests that are currently awaiting
     |   |  #     a response from the server.  This will typically be 0 or 1 unless the
     |   |  #     cursor is exhausted, but this can be higher if `close` is called.
     |   |  # threshold - a CONTINUE request will be sent when the length of `items` goes
     |   |  #     below this number.
     |   |  # error - indicates the current state of the cursor:
     |   |  #     None - there is more data available from the server and no errors have
     |   |  #         occurred yet
     |   |  #     Exception - an error has occurred in the cursor and should be raised
     |   |  #         to the user once all results in `items` have been returned.  This
     |   |  #         will be a RqlCursorEmpty exception if the cursor completed successfully.
     |   |  #
     |   |  # A class that derives from this should implement the following functions:
     |   |  #     def _get_next(self, timeout):
     |   |  #         where `timeout` is the maximum amount of time (in seconds) to wait for the
     |   |  #         next result in the cursor before raising a RqlTimeoutError.
     |   |  #     def _empty_error(self):
     |   |  #         which returns the appropriate error to be raised when the cursor is empty
     |   |  
     |   |  Methods defined here:
     |   |  
     |   |  __init__(self, conn_instance, query)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  close(self)
     |   |      cursor.close()
     |   |      
     |   |      Close a cursor. Closing a cursor cancels the corresponding query and frees the memory
     |   |      associated with the open request.
     |   |      
     |   |      *Example* Close a cursor.
     |   |      
     |   |          cursor.close()
     |   |  
     |   |  next(self, wait=True)
     |   |      cursor.next([wait=True])
     |   |      
     |   |      Get the next element in the cursor.
     |   |      
     |   |      The optional `wait` argument specifies whether to wait for the next available element and how long to wait:
     |   |      
     |   |      * `True`: Wait indefinitely (the default).
     |   |      * `False`: Do not wait at all. If data is immediately available, it will be returned; if it is not available, a `RqlDriverError` will be raised.
     |   |      * number: Wait up the specified number of seconds for data to be available before raising `RqlDriverError`.
     |   |      
     |   |      The behavior of `next` will be identical with `False`, `None` or the number `0`.
     |   |      
     |   |      Calling `next` the first time on a cursor provides the first element of the cursor. If the data set is exhausted (e.g., you have retrieved all the documents in a table), a `StopIteration` error will be raised when `next` is called.
     |   |      
     |   |      *Example* Retrieve the next element.
     |   |      
     |   |          cursor = r.table('superheroes').run(conn)
     |   |          doc = cursor.next()
     |   |      
     |   |      *Example* Retrieve the next element on a [changefeed](http://rethinkdb.com/docs/changefeeds/python), waiting up to five seconds.
     |   |      
     |   |          cursor = r.table('superheroes').changes().run(conn)
     |   |          doc = cursor.next(wait=5)
     |   |      
     |   |      __Note:__ RethinkDB sequences can be iterated through via the Python [Iterable][it] interface. The canonical way to retrieve all the results is to use a [for...in](../each/) loop or [list()](../to_array/).
     |   |      
     |   |      [it]: https://docs.python.org/3.4/library/stdtypes.html#iterator-types
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors defined here:
     |   |  
     |   |  __dict__
     |   |      dictionary for instance variables (if defined)
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |  
     |  class RqlClientError(RqlQueryError)
     |   |  Method resolution order:
     |   |      RqlClientError
     |   |      RqlQueryError
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods inherited from RqlQueryError:
     |   |  
     |   |  __init__(self, message, term, frames)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlError:
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from RqlError:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  class RqlCompileError(RqlQueryError)
     |   |  Method resolution order:
     |   |      RqlCompileError
     |   |      RqlQueryError
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods inherited from RqlQueryError:
     |   |  
     |   |  __init__(self, message, term, frames)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlError:
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from RqlError:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  class RqlCursorEmpty(RqlQueryError)
     |   |  Method resolution order:
     |   |      RqlCursorEmpty
     |   |      RqlQueryError
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods defined here:
     |   |  
     |   |  __init__(self, term)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlQueryError:
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlError:
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from RqlError:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  class RqlDriverError(RqlError)
     |   |  Method resolution order:
     |   |      RqlDriverError
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods inherited from RqlError:
     |   |  
     |   |  __init__(self, message)
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from RqlError:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  class RqlError(exceptions.Exception)
     |   |  Method resolution order:
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods defined here:
     |   |  
     |   |  __init__(self, message)
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors defined here:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  class RqlQuery(__builtin__.object)
     |   |  Methods defined here:
     |   |  
     |   |  __add__(self, other)
     |   |      number + number -> number
     |   |      string + string -> string
     |   |      array + array -> array
     |   |      time + number -> time
     |   |      
     |   |      Sum two numbers, concatenate two strings, or concatenate 2 arrays.
     |   |      
     |   |      *Example* It's as easy as 2 + 2 = 4.
     |   |      
     |   |          > (r.expr(2) + 2).run(conn)
     |   |          
     |   |          4
     |   |      
     |   |      *Example* Strings can be concatenated too.
     |   |      
     |   |          > (r.expr("foo") + "bar").run(conn)
     |   |          
     |   |          "foobar"
     |   |      
     |   |      *Example* Arrays can be concatenated too.
     |   |      
     |   |          > (r.expr(["foo", "bar"]) + ["buzz"]).run(conn)
     |   |          
     |   |          ['foo', 'bar', 'buzz']
     |   |      
     |   |      *Example* Create a date one year from now.
     |   |      
     |   |          r.now() + 365*24*60*60
     |   |      
     |   |      *Example* Use [args](http://rethinkdb.com/api/python/args) with `add` to sum multiple values.
     |   |      
     |   |          > r.add(r.args([10, 20, 30])).run(conn)
     |   |          
     |   |          60
     |   |      
     |   |      *Example* Concatenate an array of strings with `args`.
     |   |      
     |   |          > r.add(r.args(['foo', 'bar', 'buzz'])).run(conn)
     |   |          
     |   |          "foobarbuzz"
     |   |  
     |   |  __and__(self, other)
     |   |      bool & bool -> bool
     |   |      r.and_(bool, bool) -> bool
     |   |      bool.and_(bool) -> bool
     |   |      
     |   |      Compute the logical "and" of two or more values. The `and_` command can be used as an infix operator after its first argument (`r.expr(True).and_(False)`) or given all of its arguments as parameters (`r.and_(True, False)`). The standard Python and operator, `&`, may also be used with ReQL.
     |   |      
     |   |      *Example* Return whether both `a` and `b` evaluate to true.
     |   |      
     |   |          > a = True
     |   |          > b = False
     |   |          > (r.expr(a) & b).run(conn)
     |   |          
     |   |          False
     |   |      *Example* Return whether all of `x`, `y` and `z` evaluate to true.
     |   |      
     |   |          > x = True
     |   |          > y = True
     |   |          > z = True
     |   |          > r.and_(x, y, z).run(conn)
     |   |          
     |   |          True
     |   |  
     |   |  __div__(self, other)
     |   |      number / number -> number
     |   |      
     |   |      Divide two numbers.
     |   |      
     |   |      *Example* It's as easy as 2 / 2 = 1.
     |   |      
     |   |          (r.expr(2) / 2).run(conn)
     |   |  
     |   |  __eq__(self, other)
     |   |      value == value -> bool
     |   |      value.eq(value) -> bool
     |   |      
     |   |      Test if two values are equal.
     |   |      
     |   |      *Example* Does 2 equal 2?
     |   |      
     |   |          (r.expr(2) == 2).run(conn)
     |   |          r.expr(2).eq(2).run(conn)
     |   |  
     |   |  __ge__(self, other)
     |   |      value >= value -> bool
     |   |      value.ge(value) -> bool
     |   |      
     |   |      Test if the first value is greater than or equal to other.
     |   |      
     |   |      *Example* Is 2 greater than or equal to 2?
     |   |      
     |   |          (r.expr(2) >= 2).run(conn)
     |   |          r.expr(2).ge(2).run(conn)
     |   |  
     |   |  __getitem__(self, index)
     |   |      sequence[attr] -> sequence
     |   |      singleSelection[attr] -> value
     |   |      object[attr] -> value
     |   |      array[index] -> value
     |   |      
     |   |      Get a single field from an object. If called on a sequence, gets that field from every object in the sequence, skipping objects that lack it.
     |   |      
     |   |      *Example* What was Iron Man's first appearance in a comic?
     |   |      
     |   |          r.table('marvel').get('IronMan')['firstAppearance'].run(conn)
     |   |      
     |   |      The `[]` command also accepts integer arguments as array offsets, like the [nth](http://rethinkdb.com/api/python/nth) command.
     |   |      
     |   |      *Example* Get the fourth element in a sequence. (The first element is position `0`, so the fourth element is position `3`.)
     |   |      
     |   |          r.expr([10, 20, 30, 40, 50])[3]
     |   |          
     |   |          40
     |   |  
     |   |  __gt__(self, other)
     |   |      value > value -> bool
     |   |      value.gt(value) -> bool
     |   |      
     |   |      Test if the first value is greater than other.
     |   |      
     |   |      *Example* Is 2 greater than 2?
     |   |      
     |   |          (r.expr(2) > 2).run(conn)
     |   |          r.expr(2).gt(2).run(conn)
     |   |  
     |   |  __init__(self, *args, **optargs)
     |   |      # Instantiate this AST node with the given pos and opt args
     |   |  
     |   |  __invert__(self)
     |   |      bool.not_() -> bool
     |   |      not_(bool) -> bool
     |   |      (~bool) -> bool
     |   |      
     |   |      Compute the logical inverse (not) of an expression.
     |   |      
     |   |      `not_` can be called either via method chaining, immediately after an expression that evaluates as a boolean value, or by passing the expression as a parameter to `not_`.  All values that are not `False` or `None` will be converted to `True`.
     |   |      
     |   |      You may also use `~` as a shorthand operator.
     |   |      
     |   |      *Example* Not true is false.
     |   |      
     |   |          r.not_(True).run(conn)
     |   |          r.expr(True).not_().run(conn)
     |   |          (~r.expr(True)).run(conn)
     |   |      
     |   |      These evaluate to `false`.
     |   |      
     |   |      Note that when using `~` the expression is wrapped in parentheses. Without this, Python will evaluate `r.expr(True)` *first* rather than using the ReQL operator and return an incorrect value. (`~True` evaluates to &minus;2 in Python.)
     |   |      
     |   |      *Example* Return all the users that do not have a "flag" field.
     |   |      
     |   |          r.table('users').filter(
     |   |              lambda users: (~users.has_fields('flag'))
     |   |          ).run(conn)
     |   |      
     |   |      *Example* As above, but prefix-style.
     |   |      
     |   |          r.table('users').filter(
     |   |              lambda users: r.not_(users.has_fields('flag'))
     |   |          ).run(conn)
     |   |  
     |   |  __iter__(*args, **kwargs)
     |   |  
     |   |  __le__(self, other)
     |   |      value <= value -> bool
     |   |      value.le(value) -> bool
     |   |      
     |   |      Test if the first value is less than or equal to other.
     |   |      
     |   |      *Example* Is 2 less than or equal to 2?
     |   |      
     |   |          (r.expr(2) <= 2).run(conn)
     |   |          r.expr(2).le(2).run(conn)
     |   |  
     |   |  __lt__(self, other)
     |   |      value < value -> bool
     |   |      value.lt(value) -> bool
     |   |      
     |   |      Test if the first value is less than other.
     |   |      
     |   |      *Example* Is 2 less than 2?
     |   |      
     |   |          (r.expr(2) < 2).run(conn)
     |   |          r.expr(2).lt(2).run(conn)
     |   |  
     |   |  __mod__(self, other)
     |   |      number % number -> number
     |   |      
     |   |      Find the remainder when dividing two numbers.
     |   |      
     |   |      *Example* It's as easy as 2 % 2 = 0.
     |   |      
     |   |          (r.expr(2) % 2).run(conn)
     |   |      
     |   |      `
     |   |  
     |   |  __mul__(self, other)
     |   |      number * number -> number
     |   |      array * number -> array
     |   |      
     |   |      Multiply two numbers, or make a periodic array.
     |   |      
     |   |      *Example* It's as easy as 2 * 2 = 4.
     |   |      
     |   |          (r.expr(2) * 2).run(conn)
     |   |      
     |   |      *Example* Arrays can be multiplied by numbers as well.
     |   |      
     |   |          (r.expr(["This", "is", "the", "song", "that", "never", "ends."]) * 100).run(conn)
     |   |  
     |   |  __ne__(self, other)
     |   |      value != value -> bool
     |   |      value.ne(value) -> bool
     |   |      
     |   |      Test if two values are not equal.
     |   |      
     |   |      *Example* Does 2 not equal 2?
     |   |      
     |   |          (r.expr(2) != 2).run(conn)
     |   |          r.expr(2).ne(2).run(conn)
     |   |  
     |   |  __or__(self, other)
     |   |      bool | bool -> bool
     |   |      bool.or_(bool[, bool, ...]) -> bool
     |   |      r.or_(bool, bool) -> bool
     |   |      
     |   |      Compute the logical "or" of two or more values. The `or_` command can be used as an infix operator after its first argument (`r.expr(True).or_(False)`) or given all of its arguments as parameters (`r.or_(True, False)`). The standard Python or operator, `|`, may also be used with ReQL.
     |   |      
     |   |      *Example* Return whether either `a` or `b` evaluate to true.
     |   |      
     |   |          > a = True
     |   |          > b = False
     |   |          > (r.expr(a) | b).run(conn)
     |   |          
     |   |          True
     |   |      
     |   |      *Example* Return whether any of `x`, `y` or `z` evaluate to true.
     |   |      
     |   |          > x = False
     |   |          > y = False
     |   |          > z = False
     |   |          > r.or_(x, y, z).run(conn)
     |   |          
     |   |          False
     |   |      
     |   |      __Note:__ When using `or` inside a `filter` predicate to test the values of fields that may not exist on the documents being tested, you should use the `default` command with those fields so they explicitly return `False`.
     |   |      
     |   |          r.table('posts').filter(lambda post:
     |   |              post['category'].default('foo').eq('article').or(
     |   |                  post['genre'].default('foo').eq('mystery'))
     |   |          ).run(conn)
     |   |  
     |   |  __radd__(self, other)
     |   |  
     |   |  __rand__(self, other)
     |   |  
     |   |  __rdiv__(self, other)
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  __rmod__(self, other)
     |   |  
     |   |  __rmul__(self, other)
     |   |  
     |   |  __ror__(self, other)
     |   |  
     |   |  __rsub__(self, other)
     |   |  
     |   |  __rtruediv__(self, other)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  __sub__(self, other)
     |   |      number - number -> number
     |   |      time - time -> number
     |   |      time - number -> time
     |   |      
     |   |      Subtract two numbers.
     |   |      
     |   |      *Example* It's as easy as 2 - 2 = 0.
     |   |      
     |   |          (r.expr(2) - 2).run(conn)
     |   |      
     |   |      *Example* Create a date one year ago today.
     |   |      
     |   |          r.now() - 365*24*60*60
     |   |      
     |   |      *Example* Retrieve how many seconds elapsed between today and date
     |   |      
     |   |          r.now() - date
     |   |  
     |   |  __truediv__(self, other)
     |   |  
     |   |  add(self, *args)
     |   |  
     |   |  and_(self, *args)
     |   |  
     |   |  append(self, *args)
     |   |      array.append(value) -> array
     |   |      
     |   |      Append a value to an array.
     |   |      
     |   |      *Example* Retrieve Iron Man's equipment list with the addition of some new boots.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].append('newBoots').run(conn)
     |   |  
     |   |  avg(self, *args)
     |   |      sequence.avg([field_or_function]) -> number
     |   |      
     |   |      Averages all the elements of a sequence.  If called with a field name,
     |   |      averages all the values of that field in the sequence, skipping
     |   |      elements of the sequence that lack that field.  If called with a
     |   |      function, calls that function on every element of the sequence and
     |   |      averages the results, skipping elements of the sequence where that
     |   |      function returns `None` or a non-existence error.
     |   |      
     |   |      Produces a non-existence error when called on an empty sequence.  You
     |   |      can handle this case with `default`.
     |   |      
     |   |      *Example* What's the average of 3, 5, and 7?
     |   |      
     |   |          r.expr([3, 5, 7]).avg().run(conn)
     |   |      
     |   |      *Example* What's the average number of points scored in a game?
     |   |      
     |   |          r.table('games').avg('points').run(conn)
     |   |      
     |   |      *Example* What's the average number of points scored in a game,
     |   |      counting bonus points?
     |   |      
     |   |          r.table('games').avg(lambda game:
     |   |              game['points'] + game['bonus_points']
     |   |          ).run(conn)
     |   |      
     |   |      *Example* What's the average number of points scored in a game?
     |   |      (But return `None` instead of raising an error if there are no games where
     |   |      points have been scored.)
     |   |      
     |   |          r.table('games').avg('points').default(None).run(conn)
     |   |  
     |   |  between(self, *args, **kwargs)
     |   |      table.between(lower_key, upper_key[, index='id', left_bound='closed', right_bound='open'])
     |   |          -> selection
     |   |      
     |   |      Get all documents between two keys. Accepts three optional arguments: `index`, `left_bound`, and `right_bound`. If `index` is set to the name of a secondary index, `between` will return all documents where that index's value is in the specified range (it uses the primary key by default). `left_bound` or `right_bound` may be set to `open` or `closed` to indicate whether or not to include that endpoint of the range (by default, `left_bound` is closed and `right_bound` is open).
     |   |      
     |   |      You may also use the special constants `r.minval` and `r.maxval` for boundaries, which represent "less than any index key" and "more than any index key" respectively. For instance, if you use `r.minval` as the lower key, then `between` will return all documents whose primary keys (or indexes) are less than the specified upper key.
     |   |      
     |   |      Note that compound indexes are sorted using [lexicographical order][lo]. Take the following range as an example:
     |   |      
     |   |              [[1, "c"] ... [5, "e"]]
     |   |      
     |   |      This range includes all compound keys:
     |   |      
     |   |      * whose first item is 1 and second item is equal or greater than "c";
     |   |      * whose first item is between 1 and 5, *regardless of the value of the second item*;
     |   |      * whose first item is 5 and second item is less than or equal to "e".
     |   |      
     |   |      [lo]: https://en.wikipedia.org/wiki/Lexicographical_order
     |   |      
     |   |      *Example* Find all users with primary key >= 10 and < 20 (a normal half-open interval).
     |   |      
     |   |          r.table('marvel').between(10, 20).run(conn)
     |   |      
     |   |      *Example* Find all users with primary key >= 10 and <= 20 (an interval closed on both sides).
     |   |      
     |   |          r.table('marvel').between(10, 20, right_bound='closed').run(conn)
     |   |      
     |   |      *Example* Find all users with primary key < 20.
     |   |      
     |   |          r.table('marvel').between(r.minval, 20).run(conn)
     |   |      
     |   |      *Example* Find all users with primary key > 10.
     |   |      
     |   |          r.table('marvel').between(10, r.maxval, left_bound='open').run(conn)
     |   |      
     |   |      *Example* Between can be used on secondary indexes too. Just pass an optional index argument giving the secondary index to query.
     |   |      
     |   |          r.table('dc').between('dark_knight', 'man_of_steel', index='code_name').run(conn)
     |   |      
     |   |      *Example* Get all users whose full name is between "John Smith" and "Wade Welles."
     |   |      
     |   |          r.table("users").between(["Smith", "John"], ["Welles", "Wade"],
     |   |              index="full_name").run(conn)
     |   |      
     |   |      *Example* Subscribe to a [changefeed](http://rethinkdb.com/docs/changefeeds/javascript) of teams ranked in the top 10.
     |   |      
     |   |          changes = r.table("teams").between(1, 11, index="rank").changes().run(conn)
     |   |      
     |   |      __Note:__ Between works with secondary indexes on date fields, but will not work with unindexed date fields. To test whether a date value is between two other dates, use the [during](http://rethinkdb.com/api/python/during) command, not `between`.
     |   |      
     |   |      Secondary indexes can be used in extremely powerful ways with `between` and other commands; read the full article on [secondary indexes](http://rethinkdb.com/docs/secondary-indexes) for examples using boolean operations, `contains` and more.
     |   |      
     |   |      __Note:__ RethinkDB uses byte-wise ordering for `between` and does not support Unicode collations; non-ASCII characters will be sorted by UTF-8 codepoint.
     |   |  
     |   |  build(self)
     |   |      # Compile this query to a json-serializable object
     |   |  
     |   |  change_at(self, *args)
     |   |      array.change_at(index, value) -> array
     |   |      
     |   |      Change a value in an array at a given index. Returns the modified array.
     |   |      
     |   |      *Example* Bruce Banner hulks out.
     |   |      
     |   |          r.expr(["Iron Man", "Bruce", "Spider-Man"]).change_at(1, "Hulk").run(conn)
     |   |  
     |   |  changes(self, *args, **kwargs)
     |   |      table.changes(squash=True, include_states=False) -> stream
     |   |      singleSelection.changes(squash=True, include_states=False) -> stream
     |   |      
     |   |      Return an infinite stream of objects representing changes to a query.
     |   |      
     |   |      The `squash` optional argument controls how `changes` batches change notifications:
     |   |      
     |   |      * `True`: When multiple changes to the same document occur before a batch of notifications is sent, the changes are "squashed" into one change. The client receives a notification that will bring it fully up to date with the server. This is the default.
     |   |      * `False`: All changes will be sent to the client verbatim.
     |   |      * `n`: A numeric value (floating point). Similar to `True`, but the server will wait `n` seconds to respond in order to squash as many changes together as possible, reducing network traffic.
     |   |      
     |   |      If the `include_states` optional argument is `True`, the changefeed stream will include special status documents consisting of the field `state` and a string indicating a change in the feed's state. These documents can occur at any point in the feed between the notification documents described below. There are currently two states:
     |   |      
     |   |      * `{"state": "initializing"}` indicates the following documents represent initial values on the feed rather than changes. This will be the first document of a feed that returns initial values.
     |   |      * `{"state": "ready"}` indicates the following documents represent changes. This will be the first document of a feed that does *not* return initial values; otherwise, it will indicate the initial values have all been sent.
     |   |      
     |   |      If `include_states` is `False` (the default), the status documents will not be sent on the feed.
     |   |      
     |   |      If the table becomes unavailable, the changefeed will be disconnected, and a runtime exception will be thrown by the driver.
     |   |      
     |   |      Changefeed notifications take the form of a two-field object:
     |   |      
     |   |          {
     |   |              "old_val": <document before change>,
     |   |              "new_val": <document after change>
     |   |          }
     |   |      
     |   |      The first notification object in the changefeed stream will contain the query's initial value in `new_val` and have no `old_val` field. When a document is deleted, `new_val` will be `None`; when a document is inserted, `old_val` will be `None`.
     |   |      
     |   |      Certain document transformation commands can be chained before changefeeds. For more information, read the [discussion of changefeeds](http://rethinkdb.com/docs/changefeeds/python/) in the "Query language" documentation.
     |   |      
     |   |      The server will buffer up to 100,000 elements. If the buffer limit is hit, early changes will be discarded, and the client will receive an object of the form `{"error": "Changefeed cache over array size limit, skipped X elements."}` where `X` is the number of elements skipped.
     |   |      
     |   |      Commands that operate on streams (such as `filter` or `map`) can usually be chained after `changes`.  However, since the stream produced by `changes` has no ending, commands that need to consume the entire stream before returning (such as `reduce` or `count`) cannot.
     |   |      
     |   |      It's a good idea to open changefeeds on their own connection. If you don't, other queries run on the same connection will experience unpredictable latency spikes while the connection blocks on more changes.
     |   |      
     |   |      *Example* Subscribe to the changes on a table.
     |   |      
     |   |      Start monitoring the changefeed in one client:
     |   |      
     |   |          for change in r.table('games').changes().run(conn):
     |   |            print change
     |   |      
     |   |      As these queries are performed in a second client, the first client would receive and print the following objects:
     |   |      
     |   |          > r.table('games').insert({'id': 1}).run(conn)
     |   |          {'old_val': None, 'new_val': {'id': 1}}
     |   |          
     |   |          > r.table('games').get(1).update({'player1': 'Bob'}).run(conn)
     |   |          {'old_val': {'id': 1}, 'new_val': {'id': 1, 'player1': 'Bob'}}
     |   |          
     |   |          > r.table('games').get(1).replace({'id': 1, 'player1': 'Bob', 'player2': 'Alice'}).run(conn)
     |   |          {'old_val': {'id': 1, 'player1': 'Bob'},
     |   |           'new_val': {'id': 1, 'player1': 'Bob', 'player2': 'Alice'}}
     |   |          
     |   |          > r.table('games').get(1).delete().run(conn)
     |   |          {'old_val': {'id': 1, 'player1': 'Bob', 'player2': 'Alice'}, 'new_val': None}
     |   |          
     |   |          > r.table_drop('games').run(conn)
     |   |          RqlRuntimeError: Changefeed aborted (table unavailable)
     |   |      
     |   |      *Example* Return all the changes that increase a player's score.
     |   |      
     |   |          r.table('test').changes().filter(
     |   |            r.row['new_val']['score'] > r.row['old_val']['score']
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Return all the changes to Bob's score.
     |   |      
     |   |          # Note that this will have to look at and discard all the changes to
     |   |          # rows besides Bob's.  This is currently no way to filter with an index
     |   |          # on changefeeds.
     |   |          r.table('test').changes().filter(r.row['new_val']['name'].eq('Bob')).run(conn)
     |   |      
     |   |      *Example* Return all the inserts on a table.
     |   |      
     |   |          r.table('test').changes().filter(r.row['old_val'].eq(None)).run(conn)
     |   |      
     |   |      *Example* Return all the changes to game 1.
     |   |      
     |   |          r.table('games').get(1).changes().run(conn)
     |   |      
     |   |      *Example* Return all the changes to the top 10 games. This assumes the presence of a `score` secondary index on the `games` table.
     |   |      
     |   |          r.table('games').order_by(index=r.desc('score')).limit(10).run(conn)
     |   |  
     |   |  coerce_to(self, *args)
     |   |      sequence.coerce_to('array') -> array
     |   |      value.coerce_to('string') -> string
     |   |      string.coerce_to('number') -> number
     |   |      array.coerce_to('object') -> object
     |   |      object.coerce_to('array') -> array
     |   |      binary.coerce_to('string') -> string
     |   |      string.coerce_to('binary') -> binary
     |   |      
     |   |      Convert a value of one type into another.
     |   |      
     |   |      * a sequence, selection or object can be coerced to an array
     |   |      * an array of key-value pairs can be coerced to an object
     |   |      * a string can be coerced to a number
     |   |      * any datum (single value) can be coerced to a string
     |   |      * a binary object can be coerced to a string and vice-versa
     |   |      
     |   |      *Example* Coerce a stream to an array to store its output in a field. (A stream cannot be stored in a field directly.)
     |   |      
     |   |          r.table('posts').map(lambda post: post.merge(
     |   |              { 'comments': r.table('comments').get_all(post['id'], index='post_id').coerce_to('array') }
     |   |          )).run(conn)
     |   |      
     |   |      *Example* Coerce an array of pairs into an object.
     |   |      
     |   |          r.expr([['name', 'Ironman'], ['victories', 2000]]).coerce_to('object').run(conn)
     |   |      
     |   |      __Note:__ To coerce a list of key-value pairs like `['name', 'Ironman', 'victories', 2000]` to an object, use the [object](http://rethinkdb.com/api/python/object) command.
     |   |      
     |   |      *Example* Coerce a number to a string.
     |   |      
     |   |          r.expr(1).coerce_to('string').run(conn)
     |   |  
     |   |  concat_map(self, *args)
     |   |      stream.concat_map(mapping_function) -> stream
     |   |      array.concat_map(mapping_function) -> array
     |   |      
     |   |      Concatenate one or more elements into a single sequence using a mapping function.
     |   |      
     |   |      `concat_map` works in a similar fashion to `map`, applying the given function to each element in a sequence, but it will always return a single sequence. If the mapping function returns a sequence, `map` would produce a sequence of sequences:
     |   |      
     |   |          r.expr([1, 2, 3]).map(lambda x: [x, x.mul(2)]).run(conn)
     |   |      
     |   |      Result:
     |   |      
     |   |          [[1, 2], [2, 4], [3, 6]]
     |   |      
     |   |      Whereas `concat_map` with the same mapping function would merge those sequences into one:
     |   |      
     |   |          r.expr([1, 2, 3]).concat_map(lambda x: [x, x.mul(2)]).run(conn)
     |   |      
     |   |      Result:
     |   |      
     |   |          [1, 2, 2, 4, 3, 6]
     |   |      
     |   |      The return value, array or stream, will be the same type as the input.
     |   |      
     |   |      *Example* Construct a sequence of all monsters defeated by Marvel heroes. The field "defeatedMonsters" is an array of one or more monster names.
     |   |      
     |   |          r.table('marvel').concat_map(lambda hero: hero['defeatedMonsters']).run(conn)
     |   |      
     |   |      *Example* Simulate an [eq_join](http://rethinkdb.com/api/python/eq_join/) using `concat_map`. (This is how ReQL joins are implemented internally.)
     |   |      
     |   |          r.table('posts').concat_map(
     |   |              lambda post: r.table('comments').get_all(
     |   |                  post['id'], index='post_id'
     |   |              ).map(
     |   |                  lambda comment: { 'left': post, 'right': comment}
     |   |              )
     |   |          ).run(conn)
     |   |  
     |   |  contains(self, *args)
     |   |      sequence.contains(value1[, value2...]) -> bool
     |   |      sequence.contains(predicate1[, predicate2...]) -> bool
     |   |      
     |   |      When called with values, returns `True` if a sequence contains all the
     |   |      specified values.  When called with predicate functions, returns `True`
     |   |      if for each predicate there exists at least one element of the stream
     |   |      where that predicate returns `True`.
     |   |      
     |   |      *Example* Has Iron Man ever fought Superman?
     |   |      
     |   |          r.table('marvel').get('ironman')['opponents'].contains('superman').run(conn)
     |   |      
     |   |      *Example* Has Iron Man ever defeated Superman in battle?
     |   |      
     |   |          r.table('marvel').get('ironman')['battles'].contains(lambda battle:
     |   |              (battle['winner'] == 'ironman') & (battle['loser'] == 'superman')
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Use `contains` with a predicate function to simulate an `or`. Return the Marvel superheroes who live in Detroit, Chicago or Hoboken.
     |   |      
     |   |          r.table('marvel').filter(
     |   |              lambda hero: r.expr(['Detroit', 'Chicago', 'Hoboken']).contains(hero['city'])
     |   |          ).run(conn)
     |   |  
     |   |  count(self, *args)
     |   |      sequence.count([value_or_predicate]) -> number
     |   |      binary.count() -> number
     |   |      
     |   |      Counts the number of elements in a sequence.  If called with a value,
     |   |      counts the number of times that value occurs in the sequence.  If
     |   |      called with a predicate function, counts the number of elements in the
     |   |      sequence where that function returns `True`.
     |   |      
     |   |      If `count` is called on a [binary](http://rethinkdb.com/api/python/binary) object, it will return the size of the object in bytes.
     |   |      
     |   |      *Example* Count the number of users.
     |   |      
     |   |          r.table('users').count().run(conn)
     |   |      
     |   |      *Example* Count the number of 18 year old users.
     |   |      
     |   |          r.table('users')['age'].count(18).run(conn)
     |   |      
     |   |      *Example* Count the number of users over 18.
     |   |      
     |   |          r.table('users')['age'].count(lambda age: age > 18).run(conn)
     |   |      
     |   |          r.table('users').count(lambda user: user['age'] > 18).run(conn)
     |   |  
     |   |  date(self, *args)
     |   |      time.date() -> time
     |   |      
     |   |      Return a new time object only based on the day, month and year (ie. the same day at 00:00).
     |   |      
     |   |      *Example* Retrieve all the users whose birthday is today
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user["birthdate"].date() == r.now().date()
     |   |          ).run(conn)
     |   |  
     |   |  day(self, *args)
     |   |      time.day() -> number
     |   |      
     |   |      Return the day of a time object as a number between 1 and 31.
     |   |      
     |   |      *Example* Return the users born on the 24th of any month.
     |   |      
     |   |          r.table("users").filter(
     |   |              r.row["birthdate"].day() == 24
     |   |          )
     |   |  
     |   |  day_of_week(self, *args)
     |   |      time.day_of_week() -> number
     |   |      
     |   |      Return the day of week of a time object as a number between 1 and 7 (following ISO 8601 standard). For your convenience, the terms r.monday, r.tuesday etc. are defined and map to the appropriate integer.
     |   |      
     |   |      *Example* Return today's day of week.
     |   |      
     |   |          r.now().day_of_week().run(conn)
     |   |      
     |   |      *Example* Retrieve all the users who were born on a Tuesday.
     |   |      
     |   |          r.table("users").filter( lambda user:
     |   |              user["birthdate"].day_of_week().eq(r.tuesday)
     |   |          )
     |   |  
     |   |  day_of_year(self, *args)
     |   |      time.day_of_year() -> number
     |   |      
     |   |      Return the day of the year of a time object as a number between 1 and 366 (following ISO 8601 standard).
     |   |      
     |   |      *Example* Retrieve all the users who were born the first day of a year.
     |   |      
     |   |          r.table("users").filter(
     |   |              r.row["birthdate"].day_of_year() == 1
     |   |          ).run(conn)
     |   |  
     |   |  default(self, *args)
     |   |      value.default(default_value) -> any
     |   |      sequence.default(default_value) -> any
     |   |      
     |   |      Handle non-existence errors. Tries to evaluate and return its first argument. If an
     |   |      error related to the absence of a value is thrown in the process, or if its first
     |   |      argument returns `None`, returns its second argument. (Alternatively, the second argument
     |   |      may be a function which will be called with either the text of the non-existence error
     |   |      or `None`.)
     |   |      
     |   |      *Example* Suppose we want to retrieve the titles and authors of the table `posts`.
     |   |      In the case where the author field is missing or `None`, we want to retrieve the string
     |   |      `Anonymous`.
     |   |      
     |   |          r.table("posts").map(lambda post:
     |   |              {
     |   |                  "title": post["title"],
     |   |                  "author": post["author"].default("Anonymous")
     |   |              }
     |   |          ).run(conn)
     |   |      
     |   |      We can rewrite the previous query with `r.branch` too.
     |   |      
     |   |          r.table("posts").map(lambda post:
     |   |              r.branch(
     |   |                  post.has_fields("author"),
     |   |                  {
     |   |                      "title": post["title"],
     |   |                      "author": post["author"]
     |   |                  },
     |   |                  {
     |   |                      "title": post["title"],
     |   |                      "author": "Anonymous" 
     |   |                  }
     |   |              )
     |   |          ).run(conn)
     |   |      
     |   |      *Example* The `default` command can be useful to filter documents too. Suppose
     |   |      we want to retrieve all our users who are not grown-ups or whose age is unknown
     |   |      (i.e the field `age` is missing or equals `None`). We can do it with this query:
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              (user["age"] < 18).default(True)
     |   |          ).run(conn)
     |   |      
     |   |      One more way to write the previous query is to set the age to be `-1` when the
     |   |      field is missing.
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user["age"].default(-1) < 18
     |   |          ).run(conn)
     |   |      
     |   |      One last way to do the same query is to use `has_fields`.
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user.has_fields("age").not_() | (user["age"] < 18)
     |   |          ).run(conn)
     |   |      
     |   |      The body of every `filter` is wrapped in an implicit `.default(False)`. You can overwrite
     |   |      the value `False` by passing an option in filter, so the previous query can also be
     |   |      written like this.
     |   |      
     |   |          r.table("users").filter(
     |   |              lambda user: (user["age"] < 18).default(True),
     |   |              default=True
     |   |          ).run(conn)
     |   |  
     |   |  delete(self, *args, **kwargs)
     |   |      table.delete([durability="hard", return_changes=False])
     |   |          -> object
     |   |      selection.delete([durability="hard", return_changes=False])
     |   |          -> object
     |   |      singleSelection.delete([durability="hard", return_changes=False])
     |   |          -> object
     |   |      
     |   |      Delete one or more documents from a table.
     |   |      
     |   |      The optional arguments are:
     |   |      
     |   |      - `durability`: possible values are `hard` and `soft`. This option will override the
     |   |      table or query's durability setting (set in [run](http://rethinkdb.com/api/python/run/)).  
     |   |      In soft durability mode RethinkDB will acknowledge the write immediately after
     |   |      receiving it, but before the write has been committed to disk.
     |   |      - `return_changes`: if set to `True`, return a `changes` array consisting of `old_val`/`new_val` objects describing the changes made.
     |   |      
     |   |      Delete returns an object that contains the following attributes:
     |   |      
     |   |      - `deleted`: the number of documents that were deleted.
     |   |      - `skipped`: the number of documents that were skipped.  
     |   |      For example, if you attempt to delete a batch of documents, and another concurrent query
     |   |      deletes some of those documents first, they will be counted as skipped.
     |   |      - `errors`: the number of errors encountered while performing the delete.
     |   |      - `first_error`: If errors were encountered, contains the text of the first error.
     |   |      - `inserted`, `replaced`, and `unchanged`: all 0 for a delete operation.
     |   |      - `changes`: if `return_changes` is set to `True`, this will be an array of objects, one for each objected affected by the `delete` operation. Each object will have two keys: `{"new_val": None, "old_val": <old value>}`.
     |   |      
     |   |      *Example* Delete a single document from the table `comments`.
     |   |      
     |   |          r.table("comments").get("7eab9e63-73f1-4f33-8ce4-95cbea626f59").delete().run(conn)
     |   |      
     |   |      *Example* Delete all documents from the table `comments`.
     |   |      
     |   |          r.table("comments").delete().run(conn)
     |   |      
     |   |      *Example* Delete all comments where the field `id_post` is `3`.
     |   |      
     |   |          r.table("comments").filter({"id_post": 3}).delete().run(conn)
     |   |      
     |   |      *Example* Delete a single document from the table `comments` and return its value.
     |   |      
     |   |          r.table("comments").get("7eab9e63-73f1-4f33-8ce4-95cbea626f59").delete(return_changes=True).run(conn)
     |   |      
     |   |      The result will look like:
     |   |      
     |   |          {
     |   |              "deleted": 1,
     |   |              "errors": 0,
     |   |              "inserted": 0,
     |   |              "changes": [
     |   |                  {
     |   |                      "new_val": None,
     |   |                      "old_val": {
     |   |                          "id": "7eab9e63-73f1-4f33-8ce4-95cbea626f59",
     |   |                          "author": "William",
     |   |                          "comment": "Great post",
     |   |                          "id_post": 3
     |   |                      }
     |   |                  }
     |   |              ],
     |   |              "replaced": 0,
     |   |              "skipped": 0,
     |   |              "unchanged": 0
     |   |          }
     |   |      
     |   |      *Example* Delete all documents from the table `comments` without waiting for the
     |   |      operation to be flushed to disk.
     |   |      
     |   |          r.table("comments").delete(durability="soft"}).run(conn)
     |   |  
     |   |  delete_at(self, *args)
     |   |      array.delete_at(index [,endIndex]) -> array
     |   |      
     |   |      Remove one or more elements from an array at a given index. Returns the modified array. (Note: `delete_at` operates on arrays, not documents; to delete documents, see the [delete](http://rethinkdb.com/api/python/delete) command.)
     |   |      
     |   |      If only `index` is specified, `delete_at` removes the element at that index. If both `index` and `end_index` are specified, `delete_at` removes the range of elements between `index` and `end_index`, inclusive of `index` but not inclusive of `end_index`.
     |   |      
     |   |      If `end_index` is specified, it must not be less than `index`. Both `index` and `end_index` must be within the array's bounds (i.e., if the array has 10 elements, an `index` or `end_index` of 10 or higher is invalid).
     |   |      
     |   |      By using a negative `index` you can delete from the end of the array. `-1` is the last element in the array, `-2` is the second-to-last element, and so on. You may specify a negative `end_index`, although just as with a positive value, this will not be inclusive. The range `(2,-1)` specifies the third element through the next-to-last element.
     |   |      
     |   |      *Example* Delete the second element of an array.
     |   |      
     |   |          > r.expr(['a','b','c','d','e','f']).delete_at(1).run(conn)
     |   |          
     |   |          ['a', 'c', 'd', 'e', 'f']
     |   |      
     |   |      *Example* Delete the second and third elements of an array.
     |   |      
     |   |          > r.expr(['a','b','c','d','e','f']).delete_at(1,3).run(conn)
     |   |          
     |   |          ['a', 'd', 'e', 'f']
     |   |      
     |   |      *Example* Delete the next-to-last element of an array.
     |   |      
     |   |          > r.expr(['a','b','c','d','e','f']).delete_at(-2).run(conn)
     |   |          
     |   |          ['a', 'b', 'c', 'd', 'f']
     |   |      
     |   |      *Example* Delete a comment on a post.
     |   |      
     |   |      Given a post document such as:
     |   |      
     |   |      {
     |   |          id: '4cf47834-b6f9-438f-9dec-74087e84eb63',
     |   |          title: 'Post title',
     |   |          author: 'Bob',
     |   |          comments: [
     |   |              { author: 'Agatha', text: 'Comment 1' },
     |   |              { author: 'Fred', text: 'Comment 2' }
     |   |          ]
     |   |      }
     |   |      
     |   |      The second comment can be deleted by using `update` and `delete_at` together.
     |   |      
     |   |          r.table('posts').get('4cf47834-b6f9-438f-9dec-74087e84eb63').update(
     |   |              lambda post: { 'comments': post['comments'].delete_at(1) }
     |   |          ).run(conn)
     |   |  
     |   |  difference(self, *args)
     |   |      array.difference(array) -> array
     |   |      
     |   |      Remove the elements of one array from another array.
     |   |      
     |   |      *Example* Retrieve Iron Man's equipment list without boots.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].difference(['Boots']).run(conn)
     |   |      
     |   |      *Example* Remove Iron Man's boots from his equipment.
     |   |      
     |   |          r.table('marvel').get('IronMan')[:equipment].update(lambda doc:
     |   |              {'equipment': doc['equipment'].difference(['Boots'])}
     |   |          ).run(conn)
     |   |  
     |   |  distance(self, *args, **kwargs)
     |   |      geometry.distance(geometry[, geo_system='WGS84', unit='m']) -> number
     |   |      
     |   |      Compute the distance between a point and another geometry object. At least one of the geometry objects specified must be a point.
     |   |      
     |   |      Optional arguments available with `distance` are:
     |   |      
     |   |      * `geo_system`: the reference ellipsoid to use for geographic coordinates. Possible values are `WGS84` (the default), a common standard for Earth's geometry, or `unit_sphere`, a perfect sphere of 1 meter radius.
     |   |      * `unit`: Unit to return the distance in. Possible values are `m` (meter, the default), `km` (kilometer), `mi` (international mile), `nm` (nautical mile), `ft` (international foot).
     |   |      
     |   |      If one of the objects is a polygon or a line, the point will be projected onto the line or polygon assuming a perfect sphere model before the distance is computed (using the model specified with `geo_system`). As a consequence, if the polygon or line is extremely large compared to Earth's radius and the distance is being computed with the default WGS84 model, the results of `distance` should be considered approximate due to the deviation between the ellipsoid and spherical models.
     |   |      
     |   |      *Example* Compute the distance between two points on the Earth in kilometers.
     |   |      
     |   |          > point1 = r.point(-122.423246,37.779388)
     |   |          > point2 = r.point(-117.220406,32.719464)
     |   |          > r.distance(point1, point2, unit='km').run(conn)
     |   |          
     |   |          734.1252496021841
     |   |  
     |   |  distinct(self, *args, **kwargs)
     |   |      sequence.distinct() -> array
     |   |      table.distinct() -> stream
     |   |      table.distinct(index=<indexname>) -> stream
     |   |      
     |   |      Removes duplicate elements from a sequence.
     |   |      
     |   |      The `distinct` command can be called on any sequence, a table, or called on a table with an index.
     |   |      
     |   |      *Example* Which unique villains have been vanquished by marvel heroes?
     |   |      
     |   |          r.table('marvel').concat_map(
     |   |              lambda hero: hero['villain_list']).distinct().run(conn)
     |   |      
     |   |      *Example* Topics in a table of messages have a secondary index on them, and more than one message can have the same topic. What are the unique topics in the table?
     |   |      
     |   |          r.table('messages').distinct(index='topics').run(conn)
     |   |      
     |   |      The above structure is functionally identical to:
     |   |      
     |   |          r.table('messages')['topics'].distinct().run(conn)
     |   |      
     |   |      However, the first form (passing the index as an argument to `distinct`) is faster, and won't run into array limit issues since it's returning a stream.
     |   |  
     |   |  div(self, *args)
     |   |  
     |   |  do(self, *args)
     |   |      any.do(function) -> any
     |   |      r.do([args]*, function) -> any
     |   |      any.do(expr) -> any
     |   |      r.do([args]*, expr) -> any
     |   |      
     |   |      Evaluate an expression and pass its values as arguments to a function or to an expression.
     |   |      
     |   |      The last argument to `do` (or, in some forms, the only argument) is an expression or an anonymous function which receives values from either the previous arguments or from prefixed commands chained before `do`. A common use, for example, would be to retrieve a document with `get` and pass it to a function via `do`. The type of `do`'s result is the type of the value returned from the function or last expression.
     |   |      
     |   |      Arguments passed to the `do` function must be basic data types, and cannot be streams or selections. (Read about [ReQL data types](http://rethinkdb.com/docs/data-types/).) While the arguments will all be evaluated before the function is executed, they may be evaluated in any order, so their values should not be dependent on one another.
     |   |      
     |   |      *Example* Compute a golfer's net score for a game.
     |   |      
     |   |          r.table('players').get('86be93eb-a112-48f5-a829-15b2cb49de1d').do(
     |   |              lambda player: player['gross_score'] - player['course_handicap']
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Return the name of the best scoring player in a two-player golf match.
     |   |      
     |   |          r.do(r.table('players').get(id1), r.table('players').get(id2),
     |   |              (lambda player1, player2:
     |   |                  r.branch(player1['gross_score'].lt(player2['gross_score']),
     |   |                  player1, player2))
     |   |          ).run(conn)
     |   |          
     |   |      
     |   |      Note that `branch`, the ReQL conditional command, must be used instead of `if`. See the `branch` [documentation](http://rethinkdb.com/api/python/branch) for more.
     |   |  
     |   |  downcase(self, *args)
     |   |      string.downcase() -> string
     |   |      
     |   |      Lowercases a string.
     |   |      
     |   |      *Example*
     |   |      
     |   |          > r.expr("Sentence about LaTeX.").downcase().run(conn)
     |   |          "sentence about latex."
     |   |      
     |   |      __Note:__ `upcase` and `downcase` only affect ASCII characters.
     |   |  
     |   |  during(self, *args, **kwargs)
     |   |      time.during(start_time, end_time[, left_bound="closed", right_bound="open"])
     |   |          -> bool
     |   |      
     |   |      Return whether a time is between two other times. By default, this is inclusive of the start time and exclusive of the end time. Set `left_bound` and `right_bound` to explicitly include (`closed`) or exclude (`open`) that endpoint of the range.
     |   |      
     |   |      *Example* Retrieve all the posts that were posted between December 1st, 2013 (inclusive) and December 10th, 2013 (exclusive).
     |   |      
     |   |          r.table("posts").filter(
     |   |              r.row['date'].during(r.time(2013, 12, 1, "Z"), r.time(2013, 12, 10, "Z"))
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Retrieve all the posts that were posted between December 1st, 2013 (exclusive) and December 10th, 2013 (inclusive).
     |   |      
     |   |          r.table("posts").filter(
     |   |              r.row['date'].during(r.time(2013, 12, 1, "Z"), r.time(2013, 12, 10, "Z"), left_bound="open", right_bound="closed")
     |   |          ).run(conn)
     |   |  
     |   |  eq(self, *args)
     |   |      value == value -> bool
     |   |      value.eq(value) -> bool
     |   |      
     |   |      Test if two values are equal.
     |   |      
     |   |      *Example* Does 2 equal 2?
     |   |      
     |   |          (r.expr(2) == 2).run(conn)
     |   |          r.expr(2).eq(2).run(conn)
     |   |  
     |   |  eq_join(self, *args, **kwargs)
     |   |      sequence.eq_join(left_field, right_table[, index='id']) -> sequence
     |   |      
     |   |      Join tables using a field on the left-hand sequence matching primary keys or secondary indexes on the right-hand table. `eq_join` is more efficient than other Re_qL join types, and operates much faster. Documents in the result set consist of pairs of left-hand and right-hand documents, matched when the field on the left-hand side exists and is non-null and an entry with that field's value exists in the specified index on the right-hand side.
     |   |      
     |   |      The result set of `eq_join` is a stream or array of objects. Each object in the returned set will be an object of the form `{ left: <left-document>, right: <right-document> }`, where the values of `left` and `right` will be the joined documents. Use the <code><a href="/api/python/zip/">zip</a></code> command to merge the `left` and `right` fields together.
     |   |      
     |   |      **Example:** Match players with the games they've played against one another.
     |   |      
     |   |      The players table contains these documents:
     |   |      
     |   |          [
     |   |              { 'id': 1, 'player': 'George', 'gameId': 1 },
     |   |              { 'id': 2, 'player': 'Agatha', 'gameId': 3 },
     |   |              { 'id': 3, 'player': 'Fred', 'gameId': 2 },
     |   |              { 'id': 4, 'player': 'Marie', 'gameId': 2 },
     |   |              { 'id': 5, 'player': 'Earnest', 'gameId': 1 },
     |   |              { 'id': 6, 'player': 'Beth', 'gameId': 3 }
     |   |          ]
     |   |      
     |   |      The games table contains these documents:
     |   |      
     |   |          [
     |   |              { 'id': 1, 'field': 'Little Delving' },
     |   |              { 'id': 2, 'field': 'Rushock Bog' },
     |   |              { 'id': 3, 'field': 'Bucklebury' }
     |   |          ]
     |   |      
     |   |      Join these tables using `game_id` on the player table and `id` on the games table:
     |   |      
     |   |          r.table('players').eq_join('game_id', r.table('games')).run(conn)
     |   |      
     |   |      This will return a result set such as the following:
     |   |      
     |   |          [
     |   |              {
     |   |                  "left" : { "gameId" : 3, "id" : 2, "player" : "Agatha" },
     |   |                  "right" : { "id" : 3, "field" : "Bucklebury" }
     |   |              },
     |   |              {
     |   |                  "left" : { "gameId" : 2, "id" : 3, "player" : "Fred" },
     |   |                  "right" : { "id" : 2, "field" : "Rushock Bog" }
     |   |              },
     |   |              ...
     |   |          ]
     |   |      
     |   |      What you likely want is the result of using `zip` with that. For clarity, we'll use `without` to drop the `id` field from the games table (it conflicts with the `id` field for the players and it's redundant anyway), and we'll order it by the games.
     |   |      
     |   |          r.table('players').eq_join('game_id', r.table('games')).without({'right': "id"}).zip().order_by('game_id').run(conn)
     |   |          
     |   |          [
     |   |              { "field": "Little Delving", "gameId": 1, "id": 5, "player": "Earnest" },
     |   |              { "field": "Little Delving", "gameId": 1, "id": 1, "player": "George" },
     |   |              { "field": "Rushock Bog", "gameId": 2, "id": 3, "player": "Fred" },
     |   |              { "field": "Rushock Bog", "gameId": 2, "id": 4, "player": "Marie" },
     |   |              { "field": "Bucklebury", "gameId": 3, "id": 6, "player": "Beth" },
     |   |              { "field": "Bucklebury", "gameId": 3, "id": 2, "player": "Agatha" }
     |   |          ]
     |   |      
     |   |      For more information, see [Table joins in Rethink_dB](http://rethinkdb.com/docs/table-joins/).
     |   |      
     |   |      **Example:** Use a secondary index on the right table rather than the primary key. If players have a secondary index on their cities, we can get a list of arenas with players in the same area.
     |   |      
     |   |          r.table('arenas').eq_join('city_id', r.table('arenas'), index='city_id').run(conn)
     |   |      
     |   |      **Example:** Use a nested key as the join field. Suppose the documents in the players table were structured like this:
     |   |      
     |   |          { 'id': 1, 'player': 'George', 'game': {'id': 1} },
     |   |          { 'id': 2, 'player': 'Agatha', 'game': {'id': 3} },
     |   |          ...
     |   |      
     |   |      Simply specify the field using the `row` command instead of a string.
     |   |      
     |   |          r.table('players').eq_join(r.row['game']['id'], r.table('games')).without({'right': 'id'}).zip().run(conn)
     |   |          
     |   |          [
     |   |              { "field": "Little Delving", "game": { "id": 1 }, "id": 5, "player": "Earnest" },
     |   |              { "field": "Little Delving", "game": { "id": 1 }, "id": 1, "player": "George" },
     |   |              ...
     |   |          ]
     |   |      
     |   |      **Example:** Use a function instead of a field to join on a more complicated expression. Suppose the players have lists of favorite games ranked in order in a field such as `"favorites": [3, 2, 1]`. Get a list of players and their top favorite:
     |   |      
     |   |          r.table('players3').eq_join(
     |   |              lambda player: player['favorites'].nth(0),
     |   |              r.table('games')
     |   |          ).without([{'left': ['favorites', 'game_id', 'id']}, {'right': 'id'}]).zip()
     |   |      
     |   |      Result:
     |   |      
     |   |          [
     |   |              { "field": "Rushock Bog", "name": "Fred" },
     |   |              { "field": "Little Delving", "name": "George" },
     |   |              ...
     |   |          ]
     |   |  
     |   |  fill(self, *args)
     |   |      line.fill() -> polygon
     |   |      
     |   |      Convert a Line object into a Polygon object. If the last point does not specify the same coordinates as the first point, `polygon` will close the polygon by connecting them.
     |   |      
     |   |      Longitude (&minus;180 to 180) and latitude (&minus;90 to 90) of vertices are plotted on a perfect sphere. See [Geospatial support](http://rethinkdb.com/docs/geo-support/) for more information on ReQL's coordinate system.
     |   |      
     |   |      If the last point does not specify the same coordinates as the first point, `polygon` will close the polygon by connecting them. You cannot directly construct a polygon with holes in it using `polygon`, but you can use [polygon_sub](http://rethinkdb.com/api/python/polygon_sub) to use a second polygon within the interior of the first to define a hole.
     |   |      
     |   |      *Example* Create a line object and then convert it to a polygon.
     |   |      
     |   |          r.table('geo').insert({
     |   |              'id': 201,
     |   |              'rectangle': r.line(
     |   |                  [-122.423246,37.779388],
     |   |                  [-122.423246,37.329898],
     |   |                  [-121.886420,37.329898],
     |   |                  [-121.886420,37.779388]
     |   |              )
     |   |          }).run(conn)
     |   |          
     |   |          r.table('geo').get(201).update({
     |   |              'rectangle': r.row('rectangle').fill()
     |   |          }).run(conn)
     |   |  
     |   |  filter(self, *args, **kwargs)
     |   |      selection.filter(predicate[, default=False]) -> selection
     |   |      stream.filter(predicate[, default=False]) -> stream
     |   |      array.filter(predicate[, default=False]) -> array
     |   |      
     |   |      Return all the elements in a sequence for which the given predicate is true. The return value of `filter` will be the same as the input (sequence, stream, or array). Documents can be filtered in a variety of ways&mdash;ranges, nested values, boolean conditions, and the results of anonymous functions.
     |   |      
     |   |      By default, `filter` will silently skip documents with missing fields: if the predicate tries to access a field that doesn't exist (for instance, the predicate `{'age': 30}` applied to a document with no `age` field), that document will not be returned in the result set, and no error will be generated. This behavior can be changed with the `default` optional argument.
     |   |      
     |   |      * If `default` is set to `True`, documents with missing fields will be returned rather than skipped.
     |   |      * If `default` is set to `r.error()`, an `RqlRuntimeError` will be thrown when a document with a missing field is tested.
     |   |      * If `default` is set to `False` (the default), documents with missing fields will be skipped.
     |   |      
     |   |      *Example* Get all users who are 30 years old.
     |   |      
     |   |          r.table('users').filter({'age': 30}).run(conn)
     |   |      
     |   |      The predicate `{'age': 30}` selects documents in the `users` table with an `age` field whose value is `30`. Documents with an `age` field set to any other value *or* with no `age` field present are skipped.
     |   |      
     |   |      While the `{'field': value}` style of predicate is useful for exact matches, a more general way to write a predicate is to use the [row](http://rethinkdb.com/api/python/row) command with a comparison operator such as [eq](http://rethinkdb.com/api/python/eq) (`==`) or [gt](http://rethinkdb.com/api/python/gt) (`>`), or to use a lambda function that returns `True` or `False`.
     |   |      
     |   |          r.table('users').filter(r.row["age"] == 30).run(conn)
     |   |      
     |   |      In this case, the predicate `r.row["age"] == 30` returns `True` if the field `age` is equal to 30. You can write this predicate as a lambda function instead:
     |   |      
     |   |          r.table('users').filter(lambda user:
     |   |              user["age"] == 30
     |   |          ).run(conn)
     |   |      
     |   |      Predicates to `filter` are evaluated on the server, and must use ReQL expressions. Some Python comparison operators are overloaded by the RethinkDB driver and will be translated to ReQL, such as `==`, `<`/`>` and `|`/`&` (note the single character form, rather than `||`/`&&`).
     |   |      
     |   |      Also, predicates must evaluate document fields. They cannot evaluate [secondary indexes](http://rethinkdb.com/docs/secondary-indexes/).
     |   |      
     |   |      *Example* Get all users who are more than 18 years old.
     |   |      
     |   |          r.table("users").filter(r.row["age"] > 18).run(conn)
     |   |      
     |   |      *Example* Get all users who are less than 18 years old and more than 13 years old.
     |   |      
     |   |          r.table("users").filter((r.row["age"] < 18) & (r.row["age"] > 13)).run(conn)
     |   |      
     |   |      *Example* Get all users who are more than 18 years old or have their parental consent.
     |   |      
     |   |          r.table("users").filter(
     |   |              (r.row["age"] >= 18) | (r.row["hasParentalConsent"])).run(conn)
     |   |      
     |   |      *Example* Retrieve all users who subscribed between January 1st, 2012
     |   |      (included) and January 1st, 2013 (excluded).
     |   |      
     |   |          r.table("users").filter(
     |   |              lambda user: user["subscription_date"].during(
     |   |                  r.time(2012, 1, 1, 'Z'), r.time(2013, 1, 1, 'Z'))
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Retrieve all users who have a gmail account (whose field `email` ends with `@gmail.com`).
     |   |      
     |   |          r.table("users").filter(
     |   |              lambda user: user["email"].match("@gmail.com$")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Filter based on the presence of a value in an array.
     |   |      
     |   |      Given this schema for the `users` table:
     |   |      
     |   |          {
     |   |              "name": <type 'str'>
     |   |              "places_visited": [<type 'str'>]
     |   |          }
     |   |      
     |   |      Retrieve all users whose field `places_visited` contains `France`.
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user["places_visited"].contains("France")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Filter based on nested fields.
     |   |      
     |   |      Given this schema for the `users` table:
     |   |      
     |   |          {
     |   |              "id": <type 'str'>
     |   |              "name": {
     |   |                  "first": <type 'str'>,
     |   |                  "middle": <type 'str'>,
     |   |                  "last": <type 'str'>
     |   |              }
     |   |          }
     |   |      
     |   |      Retrieve all users named "William Adama" (first name "William", last name
     |   |      "Adama"), with any middle name.
     |   |      
     |   |          r.table("users").filter({
     |   |              "name": {
     |   |                  "first": "William",
     |   |                  "last": "Adama"
     |   |              }
     |   |          }).run(conn)
     |   |      
     |   |      If you want an exact match for a field that is an object, you will have to use `r.literal`.
     |   |      
     |   |      Retrieve all users named "William Adama" (first name "William", last name
     |   |      "Adama"), and who do not have a middle name.
     |   |      
     |   |          r.table("users").filter(r.literal({
     |   |              "name": {
     |   |                  "first": "William",
     |   |                  "last": "Adama"
     |   |              }
     |   |          })).run(conn)
     |   |      
     |   |      You may rewrite these with lambda functions.
     |   |      
     |   |          r.table("users").filter(
     |   |              lambda user:
     |   |              (user["name"]["first"] == "William")
     |   |                  & (user["name"]["last"] == "Adama")
     |   |          ).run(conn)
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user["name"] == {
     |   |                  "first": "William",
     |   |                  "last": "Adama"
     |   |              }
     |   |          ).run(conn)
     |   |      
     |   |      By default, documents missing fields tested by the `filter` predicate are skipped. In the previous examples, users without an `age` field are not returned. By passing the optional `default` argument to `filter`, you can change this behavior.
     |   |      
     |   |      *Example* Get all users less than 18 years old or whose `age` field is missing.
     |   |      
     |   |          r.table("users").filter(r.row["age"] < 18, default=True).run(conn)
     |   |      
     |   |      *Example* Get all users more than 18 years old. Throw an error if a
     |   |      document is missing the field `age`.
     |   |      
     |   |          r.table("users").filter(r.row["age"] > 18, default=r.error()).run(conn)
     |   |      
     |   |      *Example* Get all users who have given their phone number (all the documents whose field `phone_number` exists and is not `None`).
     |   |      
     |   |          r.table('users').filter(
     |   |              lambda user: user.has_fields('phone_number')
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Get all users with an "editor" role or an "admin" privilege.
     |   |      
     |   |          r.table('users').filter(
     |   |              lambda user: (user['role'] == 'editor').default(False) |
     |   |                  (user['privilege'] == 'admin').default(False)
     |   |          ).run(conn)
     |   |      
     |   |      Instead of using the `default` optional argument to `filter`, we have to use default values on the fields within the `or` clause. Why? If the field on the left side of the `or` clause is missing from a document&mdash;in this case, if the user doesn't have a `role` field&mdash;the predicate will generate an error, and will return `False` (or the value the `default` argument is set to) without evaluating the right side of the `or`. By using `.default(False)` on the fields, each side of the `or` will evaluate to either the field's value or `False` if the field doesn't exist.
     |   |  
     |   |  for_each(self, *args)
     |   |      sequence.for_each(write_query) -> object
     |   |      
     |   |      Loop over a sequence, evaluating the given write query for each element.
     |   |      
     |   |      *Example* Now that our heroes have defeated their villains, we can safely remove them from the villain table.
     |   |      
     |   |          r.table('marvel').for_each(
     |   |              lambda hero: r.table('villains').get(hero['villainDefeated']).delete()
     |   |          ).run(conn)
     |   |  
     |   |  ge(self, *args)
     |   |      value >= value -> bool
     |   |      value.ge(value) -> bool
     |   |      
     |   |      Test if the first value is greater than or equal to other.
     |   |      
     |   |      *Example* Is 2 greater than or equal to 2?
     |   |      
     |   |          (r.expr(2) >= 2).run(conn)
     |   |          r.expr(2).ge(2).run(conn)
     |   |  
     |   |  get_field(self, *args)
     |   |      sequence.get_field(attr) -> sequence
     |   |      singleSelection.get_field(attr) -> value
     |   |      object.get_field(attr) -> value
     |   |      
     |   |      Get a single field from an object. If called on a sequence, gets that field from every
     |   |      object in the sequence, skipping objects that lack it.
     |   |      
     |   |      *Example* What was Iron Man's first appearance in a comic?
     |   |      
     |   |          r.table('marvel').get('IronMan').get_field('firstAppearance').run(conn)
     |   |  
     |   |  group(self, *args, **kwargs)
     |   |      sequence.group(field_or_function..., [index='index_name', multi=False]) -> grouped_stream
     |   |      
     |   |      Takes a stream and partitions it into multiple groups based on the
     |   |      fields or functions provided.
     |   |      
     |   |      With the `multi` flag single documents can be assigned to multiple groups, similar to the behavior of [multi-indexes](http://rethinkdb.com/docs/secondary-indexes/python). When `multi` is `True` and the grouping value is an array, documents will be placed in each group that corresponds to the elements of the array. If the array is empty the row will be ignored.
     |   |      
     |   |      *Example* Grouping games by player.
     |   |      
     |   |      Suppose that the table `games` has the following data:
     |   |      
     |   |          [
     |   |              {"id": 2, "player": "Bob", "points": 15, "type": "ranked"},
     |   |              {"id": 5, "player": "Alice", "points": 7, "type": "free"},
     |   |              {"id": 11, "player": "Bob", "points": 10, "type": "free"},
     |   |              {"id": 12, "player": "Alice", "points": 2, "type": "free"}
     |   |          ]
     |   |      
     |   |      Grouping games by player can be done with:
     |   |      
     |   |          > r.table('games').group('player').run(conn)
     |   |          
     |   |          {
     |   |              "Alice": [
     |   |                  {"id": 5, "player": "Alice", "points": 7, "type": "free"},
     |   |                  {"id": 12, "player": "Alice", "points": 2, "type": "free"}
     |   |              ],
     |   |              "Bob": [
     |   |                  {"id": 2, "player": "Bob", "points": 15, "type": "ranked"},
     |   |                  {"id": 11, "player": "Bob", "points": 10, "type": "free"}
     |   |              ]
     |   |          }
     |   |      
     |   |      Commands chained after `group` will be called on each of these grouped
     |   |      sub-streams, producing grouped data.
     |   |      
     |   |      *Example* What is each player's best game?
     |   |      
     |   |          > r.table('games').group('player').max('points').run(conn)
     |   |          
     |   |          {
     |   |              "Alice": {"id": 5, "player": "Alice", "points": 7, "type": "free"},
     |   |              "Bob": {"id": 2, "player": "Bob", "points": 15, "type": "ranked"}
     |   |          }
     |   |      
     |   |      Commands chained onto grouped data will operate on each grouped datum,
     |   |      producing more grouped data.
     |   |      
     |   |      *Example* What is the maximum number of points scored by each player?
     |   |      
     |   |          > r.table('games').group('player').max('points')['points'].run(conn)
     |   |          
     |   |          {
     |   |              "Alice": 7,
     |   |              "Bob": 15
     |   |          }
     |   |      
     |   |      You can also group by more than one field.
     |   |      
     |   |      *Example* What is the maximum number of points scored by each
     |   |      player for each game type?
     |   |      
     |   |          > r.table('games').group('player', 'type').max('points')['points'].run(conn)
     |   |          
     |   |          {
     |   |              ("Alice", "free"): 7,
     |   |              ("Bob", "free"): 10,
     |   |              ("Bob", "ranked"): 15
     |   |          }
     |   |      
     |   |      You can also group by a function.
     |   |      
     |   |      *Example* What is the maximum number of points scored by each
     |   |      player for each game type?
     |   |      
     |   |          > r.table('games')
     |   |              .group(lambda game:
     |   |                  game.pluck('player', 'type')
     |   |              ).max('points')['points'].run(conn)
     |   |          
     |   |          {
     |   |              frozenset([('player', 'Alice'), ('type', 'free')]): 7,
     |   |              frozenset([('player', 'Bob'), ('type', 'free')]): 10,
     |   |              frozenset([('player', 'Bob'), ('type', 'ranked')]): 15,
     |   |          }
     |   |      
     |   |      Using a function, you can also group by date on a ReQL [date field](http://rethinkdb.com/docs/dates-and-times/javascript/).
     |   |      
     |   |      *Example* How many matches have been played this year by month?
     |   |      
     |   |          > r.table('matches').group(
     |   |                lambda match: [match['date'].year(), match['date'].month()]
     |   |            ).count().run(conn)
     |   |          
     |   |          {
     |   |              (2014, 2): 2,
     |   |              (2014, 3): 2,
     |   |              (2014, 4): 1,
     |   |              (2014, 5): 3
     |   |          }
     |   |      
     |   |      You can also group by an index.
     |   |      
     |   |      *Example* What is the maximum number of points scored by game type?
     |   |      
     |   |          > r.table('games').group(index='type').max('points')['points'].run(conn)
     |   |          
     |   |          {
     |   |              "free": 10,
     |   |              "ranked": 15
     |   |          }
     |   |      
     |   |      Suppose that the table `games2` has the following data:
     |   |      
     |   |          [
     |   |              { 'id': 1, 'matches': {'a': [1, 2, 3], 'b': [4, 5, 6]} },
     |   |              { 'id': 2, 'matches': {'b': [100], 'c': [7, 8, 9]} },
     |   |              { 'id': 3, 'matches': {'a': [10, 20], 'c': [70, 80]} }
     |   |          ]
     |   |      
     |   |      Using the `multi` option we can group data by match A, B or C.
     |   |      
     |   |          > r.table('games2').group(r.row['matches'].keys(), multi=True).run(conn)
     |   |          
     |   |          [
     |   |              {
     |   |                  'group': 'a',
     |   |                  'reduction': [ <id 1>, <id 3> ]
     |   |              },
     |   |              {
     |   |                  'group': 'b',
     |   |                  'reduction': [ <id 1>, <id 2> ]
     |   |              },
     |   |              {
     |   |                  'group': 'c',
     |   |                  'reduction': [ <id 2>, <id 3> ]
     |   |              }
     |   |          ]
     |   |      
     |   |      (The full result set is abbreviated in the figure; `<id 1>, <id 2>` and `<id 3>` would be the entire documents matching those keys.)
     |   |      
     |   |      *Example* Use [map](http://rethinkdb.com/api/python/map) and [sum](http://rethinkdb.com/api/python/sum) to get the total points scored for each match.
     |   |      
     |   |          r.table('games2').group(r.row['matches'].keys(), multi=True).ungroup().map(
     |   |              lambda doc: { 'match': doc['group'], 'total': doc['reduction'].sum(
     |   |                  lambda set: set['matches'][doc['group']].sum()
     |   |              )}).run(conn)
     |   |          
     |   |          [
     |   |              { 'match': 'a', 'total': 36 },
     |   |              { 'match': 'b', 'total': 115 },
     |   |              { 'match': 'c', 'total': 174 }
     |   |          ]
     |   |      
     |   |      The inner `sum` adds the scores by match within each document; the outer `sum` adds those results together for a total across all the documents.
     |   |      
     |   |      If you want to operate on all the groups rather than operating on each
     |   |      group (e.g. if you want to order the groups by their reduction), you
     |   |      can use [ungroup](http://rethinkdb.com/api/python/ungroup/) to turn a grouped stream or
     |   |      grouped data into an array of objects representing the groups.
     |   |      
     |   |      *Example* Ungrouping grouped data.
     |   |      
     |   |          > r.table('games').group('player').max('points')['points'].ungroup().run(conn)
     |   |          
     |   |          [
     |   |              {
     |   |                  "group": "Alice",
     |   |                  "reduction": 7
     |   |              },
     |   |              {
     |   |                  "group": "Bob",
     |   |                  "reduction": 15
     |   |              }
     |   |          ]
     |   |      
     |   |      Ungrouping is useful e.g. for ordering grouped data, or for inserting
     |   |      grouped data into a table.
     |   |      
     |   |      *Example* What is the maximum number of points scored by each
     |   |      player, with the highest scorers first?
     |   |      
     |   |          > r.table('games').group('player').max('points')['points'].ungroup().order_by(
     |   |                  r.desc('reduction')).run(conn)
     |   |          
     |   |          [
     |   |              {
     |   |                  "group": "Bob",
     |   |                  "reduction": 15
     |   |              },
     |   |              {
     |   |                  "group": "Alice",
     |   |                  "reduction": 7
     |   |              }
     |   |          ]
     |   |      
     |   |      When grouped data are returned to the client, they are transformed
     |   |      into a client-specific native type.  (Something similar is done with
     |   |      [times](http://rethinkdb.com/docs/dates-and-times/).)  In Python, grouped data are
     |   |      transformed into a `dictionary`. If the group value is an `array`, the
     |   |      key is converted to a `tuple`. If the group value is a `dictionary`,
     |   |      it will be converted to a `frozenset`.
     |   |      
     |   |      If you instead want to receive the raw
     |   |      pseudotype from the server (e.g. if you're planning to serialize the
     |   |      result as JSON), you can specify `group_format: 'raw'` as an optional
     |   |      argument to `run`:
     |   |      
     |   |      *Example* Get back the raw `GROUPED_DATA` pseudotype.
     |   |      
     |   |          > r.table('games').group('player').avg('points').run(conn, group_format='raw')
     |   |          
     |   |          {
     |   |              "$reql_type$": "GROUPED_DATA",
     |   |              "data": [
     |   |                  ["Alice", 4.5],
     |   |                  ["Bob", 12.5]
     |   |              ]
     |   |          }
     |   |      
     |   |      Not passing the `group_format` flag would return:
     |   |      
     |   |          {
     |   |              "Alice": 4.5,
     |   |              "Bob": 12.5
     |   |          }
     |   |      
     |   |      You might also want to use the [ungroup](http://rethinkdb.com/api/python/ungroup/)
     |   |      command (see above), which will turn the grouped data into an array of
     |   |      objects on the server.
     |   |      
     |   |      If you run a query that returns a grouped stream, it will be
     |   |      automatically converted to grouped data before being sent back to you
     |   |      (there is currently no efficient way to stream groups from RethinkDB).
     |   |      This grouped data is subject to the array size limit (see [run](http://rethinkdb.com/api/python/run)).
     |   |      
     |   |      In general, operations on grouped streams will be efficiently
     |   |      distributed, and operations on grouped data won't be.  You can figure
     |   |      out what you're working with by putting `type_of` on the end of your
     |   |      query.  Below are efficient and inefficient examples.
     |   |      
     |   |      *Example* Efficient operation.
     |   |      
     |   |          # r.table('games').group('player').type_of().run(conn)
     |   |          # Returns "GROUPED_STREAM"
     |   |          r.table('games').group('player').min('points').run(conn) # EFFICIENT
     |   |      
     |   |      *Example* Inefficient operation.
     |   |      
     |   |          # r.table('games').group('player').order_by('score').type_of().run(conn)
     |   |          # Returns "GROUPED_DATA"
     |   |          r.table('games').group('player').order_by('score').nth(0).run(conn) # INEFFICIENT
     |   |      
     |   |      What does it mean to be inefficient here?  When operating on grouped
     |   |      data rather than a grouped stream, *all* of the data has to be
     |   |      available on the node processing the query.  This means that the
     |   |      operation will only use one server's resources, and will require
     |   |      memory proportional to the size of the grouped data it's operating
     |   |      on.  (In the case of the `order_by` in the inefficient example, that
     |   |      means memory proportional **to the size of the table**.)  The array
     |   |      limit is also enforced for grouped data, so the `order_by` example
     |   |      would fail for tables with more than 100,000 rows unless you used the `array_limit` option with `run`.
     |   |      
     |   |      *Example* What is the maximum number of points scored by each
     |   |      player in free games?
     |   |      
     |   |          > r.table('games').filter(lambda game:
     |   |                  game['type'] = 'free'
     |   |              ).group('player').max('points')['points'].run(conn)
     |   |          
     |   |          {
     |   |              "Alice": 7,
     |   |              "Bob": 10
     |   |          }
     |   |      
     |   |      *Example* What is each player's highest even and odd score?
     |   |      
     |   |          > r.table('games')
     |   |              .group('name', lambda game:
     |   |                  game['points'] % 2
     |   |              ).max('points')['points'].run(conn)
     |   |          
     |   |          {
     |   |              ("Alice", 1): 7,
     |   |              ("Bob", 0): 10,
     |   |              ("Bob", 1): 15
     |   |          }
     |   |  
     |   |  gt(self, *args)
     |   |      value > value -> bool
     |   |      value.gt(value) -> bool
     |   |      
     |   |      Test if the first value is greater than other.
     |   |      
     |   |      *Example* Is 2 greater than 2?
     |   |      
     |   |          (r.expr(2) > 2).run(conn)
     |   |          r.expr(2).gt(2).run(conn)
     |   |  
     |   |  has_fields(self, *args)
     |   |      sequence.has_fields([selector1, selector2...]) -> stream
     |   |      array.has_fields([selector1, selector2...]) -> array
     |   |      object.has_fields([selector1, selector2...]) -> boolean
     |   |      
     |   |      Test if an object has one or more fields. An object has a field if it has that key and the key has a non-null value. For instance, the object `{'a': 1,'b': 2,'c': null}` has the fields `a` and `b`.
     |   |      
     |   |      When applied to a single object, `has_fields` returns `true` if the object has the fields and `false` if it does not. When applied to a sequence, it will return a new sequence (an array or stream) containing the elements that have the specified fields.
     |   |      
     |   |      *Example* Return the players who have won games.
     |   |      
     |   |          r.table('players').has_fields('games_won').run(conn)
     |   |      
     |   |      *Example* Test if a specific player has won any games.
     |   |      
     |   |          r.table('players').get(
     |   |              'b5ec9714-837e-400c-aa74-dbd35c9a7c4c').has_fields('games_won').run(conn)
     |   |      
     |   |      **Nested Fields**
     |   |      
     |   |      `has_fields` lets you test for nested fields in objects. If the value of a field is itself a set of key/value pairs, you can test for the presence of specific keys.
     |   |      
     |   |      *Example* In the `players` table, the `games_won` field contains one or more fields for kinds of games won:
     |   |      
     |   |          {
     |   |              'games_won': {
     |   |                  'playoffs': 2,
     |   |                  'championships': 1
     |   |              }
     |   |          }
     |   |      
     |   |      Return players who have the "championships" field.
     |   |      
     |   |          r.table('players').has_fields({'games_won': {'championships': true}}).run(conn)
     |   |      
     |   |      Note that `true` in the example above is testing for the existence of `championships` as a field, not testing to see if the value of the `championships` field is set to `true`. There's a more convenient shorthand form available. (See [pluck](http://rethinkdb.com/api/python/pluck) for more details on this.)
     |   |      
     |   |          r.table('players').has_fields({'games_won': 'championships'}).run(conn)
     |   |  
     |   |  hours(self, *args)
     |   |      time.hours() -> number
     |   |      
     |   |      Return the hour in a time object as a number between 0 and 23.
     |   |      
     |   |      *Example* Return all the posts submitted after midnight and before 4am.
     |   |      
     |   |          r.table("posts").filter(lambda post:
     |   |              post["date"].hours() < 4
     |   |          ).run(conn)
     |   |  
     |   |  in_timezone(self, *args)
     |   |      time.in_timezone(timezone) -> time
     |   |      
     |   |      Return a new time object with a different timezone. While the time stays the same, the results returned by methods such as hours() will change since they take the timezone into account. The timezone argument has to be of the ISO 8601 format.
     |   |      
     |   |      *Example* Hour of the day in San Francisco (UTC/GMT -8, without daylight saving time).
     |   |      
     |   |          r.now().in_timezone('-08:00').hours().run(conn)
     |   |  
     |   |  includes(self, *args)
     |   |      sequence.includes(geometry) -> sequence
     |   |      geometry.includes(geometry) -> bool
     |   |      
     |   |      Tests whether a geometry object is completely contained within another. When applied to a sequence of geometry objects, `includes` acts as a [filter](http://rethinkdb.com/api/python/filter), returning a sequence of objects from the sequence that include the argument.
     |   |      
     |   |      *Example* Is `point2` included within a 2000-meter circle around `point1`?
     |   |      
     |   |          > point1 = r.point(-117.220406,32.719464)
     |   |          > point2 = r.point(-117.206201,32.725186)
     |   |          > r.circle(point1, 2000).includes(point2).run(conn)
     |   |          
     |   |          True
     |   |      
     |   |      *Example* Which of the locations in a list of parks include `circle1`?
     |   |      
     |   |          circle1 = r.circle([-117.220406,32.719464], 10, unit='mi')
     |   |          r.table('parks')['area'].includes(circle1).run(conn)
     |   |  
     |   |  info(self, *args)
     |   |      any.info() -> object
     |   |      
     |   |      Get information about a ReQL value.
     |   |      
     |   |      *Example* Get information about a table such as primary key, or cache size.
     |   |      
     |   |          r.table('marvel').info().run(conn)
     |   |  
     |   |  inner_join(self, *args)
     |   |      sequence.inner_join(other_sequence, predicate) -> stream
     |   |      array.inner_join(other_sequence, predicate) -> array
     |   |      
     |   |      Returns an inner join of two sequences. The returned sequence represents an intersection of the left-hand sequence and the right-hand sequence: each row of the left-hand sequence will be compared with each row of the right-hand sequence to find all pairs of rows which satisfy the predicate. Each matched pair of rows of both sequences are combined into a result row. In most cases, you will want to follow the join with [zip](http://rethinkdb.com/api/python/zip) to combine the left and right results.
     |   |      
     |   |      Note that `inner_join` is slower and much less efficient than using [eq_join](http://rethinkdb.com/api/python/eq_join/) or [concat_map](http://rethinkdb.com/api/python/concat_map/) with [get_all](http://rethinkdb.com/api/python/get_all/). You should avoid using `inner_join` in commands when possible.
     |   |      
     |   |      *Example* Return a list of all matchups between Marvel and DC heroes in which the DC hero could beat the Marvel hero in a fight.
     |   |      
     |   |          r.table('marvel').inner_join(r.table('dc'),
     |   |              lambda marvel_row, dc_row: marvel_row['strength'] < dc_row['strength']
     |   |          ).zip().run(conn)
     |   |      
     |   |      (Compare this to an [outer_join](http://rethinkdb.com/api/python/outer_join) with the same inputs and predicate, which would return a list of *all* Marvel heroes along with any DC heroes with a higher strength.)
     |   |  
     |   |  insert_at(self, *args)
     |   |      array.insert_at(index, value) -> array
     |   |      
     |   |      Insert a value in to an array at a given index. Returns the modified array.
     |   |      
     |   |      *Example* Hulk decides to join the avengers.
     |   |      
     |   |          r.expr(["Iron Man", "Spider-Man"]).insert_at(1, "Hulk").run(conn)
     |   |  
     |   |  intersects(self, *args)
     |   |      sequence.intersects(geometry) -> sequence
     |   |      geometry.intersects(geometry) -> bool
     |   |      
     |   |      Tests whether two geometry objects intersect with one another. When applied to a sequence of geometry objects, `intersects` acts as a [filter](http://rethinkdb.com/api/python/filter), returning a sequence of objects from the sequence that intersect with the argument.
     |   |      
     |   |      *Example* Is `point2` within a 2000-meter circle around `point1`?
     |   |      
     |   |          > point1 = r.point(-117.220406,32.719464)
     |   |          > point2 = r.point(-117.206201,32.725186)
     |   |          > r.circle(point1, 2000).intersects(point2).run(conn)
     |   |          
     |   |          True
     |   |      
     |   |      *Example* Which of the locations in a list of parks intersect `circle1`?
     |   |      
     |   |          circle1 = r.circle([-117.220406,32.719464], 10, unit='mi')
     |   |          r.table('parks')('area').intersects(circle1).run(conn)
     |   |  
     |   |  is_empty(self, *args)
     |   |      sequence.is_empty() -> bool
     |   |      
     |   |      Test if a sequence is empty.
     |   |      
     |   |      *Example* Are there any documents in the marvel table?
     |   |      
     |   |          r.table('marvel').is_empty().run(conn)
     |   |  
     |   |  keys(self, *args)
     |   |      singleSelection.keys() -> array
     |   |      object.keys() -> array
     |   |      
     |   |      Return an array containing all of the object's keys.
     |   |      
     |   |      *Example* Get all the keys of a row.
     |   |      
     |   |          r.table('marvel').get('ironman').keys().run(conn)
     |   |  
     |   |  le(self, *args)
     |   |      value <= value -> bool
     |   |      value.le(value) -> bool
     |   |      
     |   |      Test if the first value is less than or equal to other.
     |   |      
     |   |      *Example* Is 2 less than or equal to 2?
     |   |      
     |   |          (r.expr(2) <= 2).run(conn)
     |   |          r.expr(2).le(2).run(conn)
     |   |  
     |   |  limit(self, *args)
     |   |      sequence.limit(n) -> stream
     |   |      array.limit(n) -> array
     |   |      
     |   |      End the sequence after the given number of elements.
     |   |      
     |   |      *Example* Only so many can fit in our Pantheon of heroes.
     |   |      
     |   |          r.table('marvel').order_by('belovedness').limit(10).run(conn)
     |   |  
     |   |  lt(self, *args)
     |   |      value < value -> bool
     |   |      value.lt(value) -> bool
     |   |      
     |   |      Test if the first value is less than other.
     |   |      
     |   |      *Example* Is 2 less than 2?
     |   |      
     |   |          (r.expr(2) < 2).run(conn)
     |   |          r.expr(2).lt(2).run(conn)
     |   |  
     |   |  map(self, *args)
     |   |      sequence1.map([sequence2, ...], mapping_function) -> stream
     |   |      array1.map([sequence2, ...], mapping_function) -> array
     |   |      r.map(sequence1[, sequence2, ...], mapping_function) -> stream
     |   |      r.map(array1[, array2, ...], mapping_function) -> array
     |   |      
     |   |      Transform each element of one or more sequences by applying a mapping function to them. If `map` is run with two or more sequences, it will iterate for as many items as there are in the shortest sequence.
     |   |      
     |   |      Note that `map` can only be applied to sequences, not single values. If you wish to apply a function to a single value/selection (including an array), use the [do](http://rethinkdb.com/api/python/do) command.
     |   |      
     |   |      *Example* Return the first five squares.
     |   |      
     |   |          > r.expr([1, 2, 3, 4, 5]).map(lambda val: (val * val)).run(conn)
     |   |          
     |   |          [1, 4, 9, 16, 25]
     |   |      
     |   |      *Example* Sum the elements of three sequences.
     |   |      
     |   |          > sequence1 = [100, 200, 300, 400]
     |   |          > sequence2 = [10, 20, 30, 40]
     |   |          > sequence3 = [1, 2, 3, 4]
     |   |          > r.map(sequence1, sequence2, sequence3,
     |   |              lambda val1, val2, val3: (val1 + val2 + val3)).run(conn)
     |   |          
     |   |          [111, 222, 333, 444]
     |   |      
     |   |      *Example* Rename a field when retrieving documents using `map` and `merge`.
     |   |      
     |   |      This example renames the field `id` to `user_id` when retrieving documents from the table `users`.
     |   |      
     |   |          r.table('users').map(
     |   |              lambda doc: doc.merge({'user_id': doc['id']}).without('id')).run(conn)
     |   |      
     |   |      Note that in this case, [row](http://rethinkdb.com/api/python/row) may be used as an alternative to writing an anonymous function, as it returns the same value as the function parameter receives:
     |   |      
     |   |          r.table('users').map(
     |   |              r.row.merge({'user_id': r.row['id']}).without('id')).run(conn)
     |   |      
     |   |      *Example* Assign every superhero an archenemy.
     |   |      
     |   |          r.table('heroes').map(r.table('villains'),
     |   |              lambda hero, villain: hero.merge({'villain': villain})).run(conn)
     |   |  
     |   |  match(self, *args)
     |   |      string.match(regexp) -> None/object
     |   |      
     |   |      Matches against a regular expression. If there is a match, returns an object with the fields:
     |   |      
     |   |      - `str`: The matched string
     |   |      - `start`: The matched string's start
     |   |      - `end`: The matched string's end
     |   |      - `groups`: The capture groups defined with parentheses
     |   |      
     |   |      If no match is found, returns `None`.
     |   |      
     |   |      Accepts RE2 syntax
     |   |      ([https://code.google.com/p/re2/wiki/Syntax](https://code.google.com/p/re2/wiki/Syntax)).
     |   |      You can enable case-insensitive matching by prefixing the regular expression with
     |   |      `(?i)`. See the linked RE2 documentation for more flags.
     |   |      
     |   |      The `match` command does not support backreferences.
     |   |      
     |   |      *Example* Get all users whose name starts with "A". Because `None` evaluates to `false` in
     |   |      `filter`, you can just use the result of `match` for the predicate.
     |   |      
     |   |          r.table('users').filter(lambda doc:
     |   |              doc['name'].match("^A")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Get all users whose name ends with "n".
     |   |      
     |   |          r.table('users').filter(lambda doc:
     |   |              doc['name'].match("n$")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Get all users whose name has "li" in it
     |   |      
     |   |          r.table('users').filter(lambda doc:
     |   |              doc['name'].match("li")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Get all users whose name is "John" with a case-insensitive search.
     |   |      
     |   |          r.table('users').filter(lambda doc:
     |   |              doc['name'].match("(?i)^john$")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Get all users whose name is composed of only characters between "a" and "z".
     |   |      
     |   |          r.table('users').filter(lambda doc:
     |   |              doc['name'].match("(?i)^[a-z]+$")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Get all users where the zipcode is a string of 5 digits.
     |   |      
     |   |          r.table('users').filter(lambda doc:
     |   |              doc['zipcode'].match("\d{5}")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Retrieve the domain of a basic email
     |   |      
     |   |          r.expr("name@domain.com").match(".*@(.*)").run(conn)
     |   |      
     |   |      Result:
     |   |      
     |   |          {
     |   |              "start": 0,
     |   |              "end": 20,
     |   |              "str": "name@domain.com",
     |   |              "groups":[
     |   |                  {
     |   |                      "end": 17,
     |   |                      "start": 7,
     |   |                      "str": "domain.com"
     |   |                  }
     |   |              ]
     |   |          }
     |   |      
     |   |      You can then retrieve only the domain with the [\[\]](http://rethinkdb.com/api/python/get_field) selector.
     |   |      
     |   |          r.expr("name@domain.com").match(".*@(.*)")["groups"][0]["str"].run(conn)
     |   |      
     |   |      Returns `'domain.com'`
     |   |      
     |   |      *Example* Fail to parse out the domain and returns `None`.
     |   |      
     |   |          r.expr("name[at]domain.com").match(".*@(.*)").run(conn)
     |   |  
     |   |  max(self, *args, **kwargs)
     |   |      sequence.max(field_or_function) -> element
     |   |      sequence.max(index='index') -> element
     |   |      
     |   |      Finds the maximum element of a sequence. The `max` command can be called with:
     |   |      
     |   |      * a **field name**, to return the element of the sequence with the largest value in that field;
     |   |      * an **index**, to return the element of the sequence with the largest value in that index;
     |   |      * a **function**, to apply the function to every element within the sequence and return the element which returns the largest value from the function, ignoring any elements where the function returns `None` or produces a non-existence error.
     |   |      
     |   |      Calling `max` on an empty sequence will throw a non-existence error; this can be handled using the [default](http://rethinkdb.com/api/python/default/) command.
     |   |      
     |   |      *Example* Return the maximum value in the list `[3, 5, 7]`.
     |   |      
     |   |          r.expr([3, 5, 7]).max().run(conn)
     |   |      
     |   |      *Example* Return the user who has scored the most points.
     |   |      
     |   |          r.table('users').max('points').run(conn)
     |   |      
     |   |      *Example* The same as above, but using a secondary index on the `points` field.
     |   |      
     |   |          r.table('users').max(index='points').run(conn)
     |   |      
     |   |      *Example* Return the user who has scored the most points, adding in bonus points from a separate field using a function.
     |   |      
     |   |          r.table('users').max(lambda user:
     |   |              user['points'] + user['bonus_points']
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Return the highest number of points any user has ever scored. This returns the value of that `points` field, not a document.
     |   |      
     |   |          r.table('users').max('points')['points'].run(conn)
     |   |      
     |   |      *Example* Return the user who has scored the most points, but add a default `None` return value to prevent an error if no user has ever scored points.
     |   |      
     |   |          r.table('users').max('points').default(None).run(conn)
     |   |  
     |   |  merge(self, *args)
     |   |      singleSelection.merge(object|function) -> object
     |   |      object.merge(object|function) -> object
     |   |      sequence.merge(object|function) -> stream
     |   |      array.merge(object|function) -> array
     |   |      
     |   |      Merge two objects together to construct a new object with properties from both. Gives preference to attributes from other when there is a conflict. `merge` also accepts a subquery function that returns an object, which will be used similarly to a [map](http://rethinkdb.com/api/python/map/) function.
     |   |      
     |   |      *Example* Equip IronMan for battle.
     |   |      
     |   |          r.table('marvel').get('IronMan').merge(
     |   |              r.table('loadouts').get('alienInvasionKit')
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Equip every hero for battle, using a subquery function to retrieve their weapons.
     |   |      
     |   |          r.table('marvel').merge(lambda hero:
     |   |              { 'weapons': r.table('weapons').get(hero['weapon_id']) }
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Use `merge` to join each blog post with its comments.
     |   |      
     |   |      Note that the sequence being merged&mdash;in this example, the comments&mdash;must be coerced from a selection to an array. Without `coerce_to` the operation will throw an error ("Expected type DATUM but found SELECTION").
     |   |      
     |   |          r.table('posts').merge(lambda post:
     |   |              { 'comments': r.table('comments').get_all(post['id'],
     |   |                  index='post_id').coerce_to('array') }
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Merge can be used recursively to modify object within objects.
     |   |      
     |   |          r.expr({'weapons' : {'spectacular graviton beam' : {'dmg' : 10, 'cooldown' : 20}}}).merge(
     |   |              {'weapons' : {'spectacular graviton beam' : {'dmg' : 10}}}
     |   |          ).run(conn)
     |   |      
     |   |      *Example* To replace a nested object with another object you can use the literal keyword.
     |   |      
     |   |          r.expr({'weapons' : {'spectacular graviton beam' : {'dmg' : 10, 'cooldown' : 20}}}).merge(
     |   |              {'weapons' : r.literal({'repulsor rays' : {'dmg' : 3, 'cooldown' : 0}})}
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Literal can be used to remove keys from an object as well.
     |   |      
     |   |          r.expr({'weapons' : {'spectacular graviton beam' : {'dmg' : 10, 'cooldown' : 20}}}).merge(
     |   |              {'weapons' : {'spectacular graviton beam' : r.literal()}}
     |   |          ).run(conn)
     |   |  
     |   |  min(self, *args, **kwargs)
     |   |      sequence.min(field_or_function) -> element
     |   |      sequence.min(index='index') -> element
     |   |      
     |   |      Finds the minimum element of a sequence. The `min` command can be called with:
     |   |      
     |   |      * a **field name**, to return the element of the sequence with the smallest value in that field;
     |   |      * an **index**, to return the element of the sequence with the smallest value in that index;
     |   |      * a **function**, to apply the function to every element within the sequence and return the element which returns the smallest value from the function, ignoring any elements where the function returns `None` or produces a non-existence error.
     |   |      
     |   |      Calling `min` on an empty sequence will throw a non-existence error; this can be handled using the [default](http://rethinkdb.com/api/python/default/) command.
     |   |      
     |   |      *Example* Return the minimum value in the list `[3, 5, 7]`.
     |   |      
     |   |          r.expr([3, 5, 7]).min().run(conn)
     |   |      
     |   |      *Example* Return the user who has scored the fewest points.
     |   |      
     |   |          r.table('users').min('points').run(conn)
     |   |      
     |   |      *Example* The same as above, but using a secondary index on the `points` field.
     |   |      
     |   |          r.table('users').min(index='points').run(conn)
     |   |      
     |   |      *Example* Return the user who has scored the fewest points, adding in bonus points from a separate field using a function.
     |   |      
     |   |          r.table('users').min(lambda user:
     |   |              user['points'] + user['bonus_points']
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Return the smallest number of points any user has ever scored. This returns the value of that `points` field, not a document.
     |   |      
     |   |          r.table('users').min('points')['points'].run(conn)
     |   |      
     |   |      *Example* Return the user who has scored the fewest points, but add a default `None` return value to prevent an error if no user has ever scored points.
     |   |      
     |   |          r.table('users').min('points').default(None).run(conn)
     |   |  
     |   |  minutes(self, *args)
     |   |      time.minutes() -> number
     |   |      
     |   |      Return the minute in a time object as a number between 0 and 59.
     |   |      
     |   |      *Example* Return all the posts submitted during the first 10 minutes of every hour.
     |   |      
     |   |          r.table("posts").filter(lambda post:
     |   |              post["date"].minutes() < 10
     |   |          ).run(conn)
     |   |  
     |   |  mod(self, *args)
     |   |  
     |   |  month(self, *args)
     |   |      time.month() -> number
     |   |      
     |   |      Return the month of a time object as a number between 1 and 12. For your convenience, the terms r.january, r.february etc. are defined and map to the appropriate integer.
     |   |      
     |   |      *Example* Retrieve all the users who were born in November.
     |   |      
     |   |          r.table("users").filter(
     |   |              r.row["birthdate"].month() == 11
     |   |          )
     |   |      
     |   |      *Example* Retrieve all the users who were born in November.
     |   |      
     |   |          r.table("users").filter(
     |   |              r.row["birthdate"].month() == r.november
     |   |          )
     |   |  
     |   |  mul(self, *args)
     |   |  
     |   |  ne(self, *args)
     |   |      value != value -> bool
     |   |      value.ne(value) -> bool
     |   |      
     |   |      Test if two values are not equal.
     |   |      
     |   |      *Example* Does 2 not equal 2?
     |   |      
     |   |          (r.expr(2) != 2).run(conn)
     |   |          r.expr(2).ne(2).run(conn)
     |   |  
     |   |  not_(self, *args)
     |   |      bool.not_() -> bool
     |   |      not_(bool) -> bool
     |   |      (~bool) -> bool
     |   |      
     |   |      Compute the logical inverse (not) of an expression.
     |   |      
     |   |      `not_` can be called either via method chaining, immediately after an expression that evaluates as a boolean value, or by passing the expression as a parameter to `not_`.  All values that are not `False` or `None` will be converted to `True`.
     |   |      
     |   |      You may also use `~` as a shorthand operator.
     |   |      
     |   |      *Example* Not true is false.
     |   |      
     |   |          r.not_(True).run(conn)
     |   |          r.expr(True).not_().run(conn)
     |   |          (~r.expr(True)).run(conn)
     |   |      
     |   |      These evaluate to `false`.
     |   |      
     |   |      Note that when using `~` the expression is wrapped in parentheses. Without this, Python will evaluate `r.expr(True)` *first* rather than using the ReQL operator and return an incorrect value. (`~True` evaluates to &minus;2 in Python.)
     |   |      
     |   |      *Example* Return all the users that do not have a "flag" field.
     |   |      
     |   |          r.table('users').filter(
     |   |              lambda users: (~users.has_fields('flag'))
     |   |          ).run(conn)
     |   |      
     |   |      *Example* As above, but prefix-style.
     |   |      
     |   |          r.table('users').filter(
     |   |              lambda users: r.not_(users.has_fields('flag'))
     |   |          ).run(conn)
     |   |  
     |   |  nth(self, *args)
     |   |      sequence.nth(index) -> object
     |   |      selection.nth(index) -> selection&lt;object&gt;
     |   |      
     |   |      Get the *nth* element of a sequence, counting from zero. If the argument is negative, count from the last element.
     |   |      
     |   |      In Python, you can use `[]` with an integer as a shorthand for `nth`.
     |   |      
     |   |      *Example* Select the second element in the array.
     |   |      
     |   |          r.expr([1,2,3]).nth(1).run(conn)
     |   |          r.expr([1,2,3])[1].run(conn)
     |   |      
     |   |      *Example* Select the bronze medalist from the competitors.
     |   |      
     |   |          r.table('players').order_by(index=r.desc('score')).nth(3).run(conn)
     |   |      
     |   |      *Example* Select the last place competitor.
     |   |      
     |   |          r.table('players').order_by(index=r.desc('score')).nth(-1).run(conn)
     |   |  
     |   |  offsets_of(self, *args)
     |   |      sequence.offsets_of(datum | predicate) -> array
     |   |      
     |   |      Get the indexes of an element in a sequence. If the argument is a predicate, get the indexes of all elements matching it.
     |   |      
     |   |      *Example* Find the position of the letter 'c'.
     |   |      
     |   |          r.expr(['a','b','c']).offsets_of('c').run(conn)
     |   |      
     |   |      *Example* Find the popularity ranking of invisible heroes.
     |   |      
     |   |          r.table('marvel').union(r.table('dc')).order_by('popularity').offsets_of(
     |   |              r.row['superpowers'].contains('invisibility')
     |   |          ).run(conn)
     |   |  
     |   |  or_(self, *args)
     |   |  
     |   |  order_by(self, *args, **kwargs)
     |   |      table.order_by([key1...], index=index_name) -> selection<stream>
     |   |      selection.order_by(key1, [key2...]) -> selection<array>
     |   |      sequence.order_by(key1, [key2...]) -> array
     |   |      
     |   |      Sort the sequence by document values of the given key(s). To specify
     |   |      the ordering, wrap the attribute with either `r.asc` or `r.desc`
     |   |      (defaults to ascending).
     |   |      
     |   |      __Note:__ RethinkDB uses byte-wise ordering for `orderBy` and does not support Unicode collations; non-ASCII characters will be sorted by UTF-8 codepoint.
     |   |      
     |   |      Sorting without an index requires the server to hold the sequence in
     |   |      memory, and is limited to 100,000 documents (or the setting of the `arrayLimit` option for [run](http://rethinkdb.com/api/python/run)). Sorting with an index can
     |   |      be done on arbitrarily large tables, or after a `between` command
     |   |      using the same index.
     |   |      
     |   |      *Example* Order all the posts using the index `date`.   
     |   |      
     |   |          r.table('posts').order_by(index='date').run(conn)
     |   |      
     |   |      The index must have been previously created with [index_create](http://rethinkdb.com/api/python/index_create/).
     |   |      
     |   |          r.table('posts').index_create('date').run(conn)
     |   |      
     |   |      You can also select a descending ordering:
     |   |      
     |   |          r.table('posts').order_by(index=r.desc('date')).run(conn, callback)
     |   |      
     |   |      *Example* Order a sequence without an index.
     |   |      
     |   |          r.table('posts').get(1)['comments'].order_by('date')
     |   |      
     |   |      You can also select a descending ordering:
     |   |      
     |   |          r.table('posts').get(1)['comments'].order_by(r.desc('date'))
     |   |      
     |   |      If you're doing ad-hoc analysis and know your table won't have more then 100,000
     |   |      elements (or you've changed the setting of the `arrayLimit` option for [run](http://rethinkdb.com/api/python/run)) you can run `order_by` without an index:
     |   |      
     |   |          r.table('small_table').order_by('date')
     |   |      
     |   |      *Example* You can efficiently order using multiple fields by using a
     |   |      [compound index](http://www.rethinkdb.com/docs/secondary-indexes/python/).
     |   |      
     |   |      Order by date and title.
     |   |      
     |   |          r.table('posts').order_by(index='date_and_title').run(conn)
     |   |      
     |   |      The index must have been previously created with [index_create](http://rethinkdb.com/api/python/index_create/).
     |   |      
     |   |          r.table('posts').index_create('date_and_title', lambda post:
     |   |              [post["date"], post["title"]]).run(conn)
     |   |      
     |   |      _Note_: You cannot specify multiple orders in a compound index. See [issue #2306](https://github.com/rethinkdb/rethinkdb/issues/2306)
     |   |      to track progress.
     |   |      
     |   |      *Example* If you have a sequence with fewer documents than the `array_limit`, you can order it
     |   |      by multiple fields without an index.
     |   |      
     |   |          r.table('small_table').order_by('date', r.desc('title'))
     |   |      
     |   |      *Example* Notice that an index ordering always has highest
     |   |      precedence. The following query orders posts by date, and if multiple
     |   |      posts were published on the same date, they will be ordered by title.
     |   |      
     |   |          r.table('post').order_by('title', index='date').run(conn)
     |   |      *Example* You can use [nested field](http://rethinkdb.com/docs/cookbook/python/#filtering-based-on-nested-fields) syntax to sort on fields from subdocuments. (You can also create indexes on nested fields using this syntax with `index_create`.)
     |   |      
     |   |          r.table('user').order_by(lambda user: user['group']['id']).run(conn)
     |   |      
     |   |      *Example* You can efficiently order data on arbitrary expressions using indexes.
     |   |      
     |   |          r.table('posts').order_by(index='votes').run(conn)
     |   |      
     |   |      The index must have been previously created with [index_create](http://rethinkdb.com/api/ruby/index_create/).
     |   |      
     |   |          r.table('posts').index_create('votes', lambda post:
     |   |              post["upvotes"]-post["downvotes"]
     |   |          ).run(conn)
     |   |      
     |   |      *Example* If you have a sequence with fewer documents than the `array_limit`, you can order it with an arbitrary function directly.
     |   |      
     |   |          r.table('small_table').order_by(lambda doc:
     |   |              doc['upvotes']-doc['downvotes']
     |   |          );
     |   |      
     |   |      You can also select a descending ordering:
     |   |      
     |   |          r.table('small_table').order_by(r.desc(lambda doc:
     |   |              doc['upvotes']-doc['downvotes']
     |   |          ));
     |   |      
     |   |      *Example* Ordering after a `between` command can be done as long as the same index is being used.
     |   |      
     |   |          r.table("posts").between(r.time(2013, 1, 1, '+00:00'), r.time(2013, 1, 1, '+00:00'), index='date')
     |   |              .order_by(index='date').run(conn);
     |   |  
     |   |  outer_join(self, *args)
     |   |      sequence.outer_join(other_sequence, predicate) -> stream
     |   |      array.outer_join(other_sequence, predicate) -> array
     |   |      
     |   |      Returns a left outer join of two sequences. The returned sequence represents a union of the left-hand sequence and the right-hand sequence: all documents in the left-hand sequence will be returned, each matched with a document in the right-hand sequence if one satisfies the predicate condition. In most cases, you will want to follow the join with [zip](http://rethinkdb.com/api/python/zip) to combine the left and right results.
     |   |      
     |   |      Note that `outer_join` is slower and much less efficient than using [concat_map](http://rethinkdb.com/api/python/concat_map/) with [get_all](http://rethinkdb.com/api/python/get_all). You should avoid using `outer_join` in commands when possible.
     |   |      
     |   |      *Example* Return a list of all Marvel heroes, paired with any DC heroes who could beat them in a fight.
     |   |      
     |   |          r.table('marvel').outer_join(r.table('dc'),
     |   |            lambda marvel_row, dc_row: marvel_row['strength'] < dc_row['strength']
     |   |          ).zip().run(conn)
     |   |      
     |   |      (Compare this to an [inner_join](http://rethinkdb.com/api/python/inner_join) with the same inputs and predicate, which would return a list only of the matchups in which the DC hero has the higher strength.)
     |   |  
     |   |  pluck(self, *args)
     |   |      sequence.pluck([selector1, selector2...]) -> stream
     |   |      array.pluck([selector1, selector2...]) -> array
     |   |      object.pluck([selector1, selector2...]) -> object
     |   |      singleSelection.pluck([selector1, selector2...]) -> object
     |   |      
     |   |      Plucks out one or more attributes from either an object or a sequence of objects
     |   |      (projection).
     |   |      
     |   |      *Example* We just need information about IronMan's reactor and not the rest of the
     |   |      document.
     |   |      
     |   |          r.table('marvel').get('IronMan').pluck('reactorState', 'reactorPower').run(conn)
     |   |      
     |   |      *Example* For the hero beauty contest we only care about certain qualities.
     |   |      
     |   |          r.table('marvel').pluck('beauty', 'muscleTone', 'charm').run(conn)
     |   |      
     |   |      *Example* Pluck can also be used on nested objects.
     |   |      
     |   |          r.table('marvel').pluck({'abilities' : {'damage' : True, 'mana_cost' : True}, 'weapons' : True}).run(conn)
     |   |      
     |   |      *Example* The nested syntax can quickly become overly verbose so there's a shorthand
     |   |      for it.
     |   |      
     |   |          r.table('marvel').pluck({'abilities' : ['damage', 'mana_cost']}, 'weapons').run(conn)
     |   |      
     |   |      For more information read the [nested field documentation](http://rethinkdb.com/docs/nested-fields/).
     |   |  
     |   |  polygon_sub(self, *args)
     |   |      polygon1.polygon_sub(polygon2) -> polygon
     |   |      
     |   |      Use `polygon2` to "punch out" a hole in `polygon1`. `polygon2` must be completely contained within `polygon1` and must have no holes itself (it must not be the output of `polygon_sub` itself).
     |   |      
     |   |      *Example* Define a polygon with a hole punched in it.
     |   |      
     |   |          outer_polygon = r.polygon(
     |   |              [-122.4,37.7],
     |   |              [-122.4,37.3],
     |   |              [-121.8,37.3],
     |   |              [-121.8,37.7]
     |   |          )
     |   |          inner_polygon = r.polygon(
     |   |              [-122.3,37.4],
     |   |              [-122.3,37.6],
     |   |              [-122.0,37.6],
     |   |              [-122.0,37.4]
     |   |          )
     |   |          outer_polygon.polygon_sub(inner_polygon).run(conn)
     |   |  
     |   |  prepend(self, *args)
     |   |      array.prepend(value) -> array
     |   |      
     |   |      Prepend a value to an array.
     |   |      
     |   |      *Example* Retrieve Iron Man's equipment list with the addition of some new boots.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].prepend('newBoots').run(conn)
     |   |  
     |   |  reduce(self, *args)
     |   |      sequence.reduce(reduction_function) -> value
     |   |      
     |   |      Produce a single value from a sequence through repeated application of a reduction
     |   |      function.  
     |   |      The reduction function can be called on:
     |   |      
     |   |      - two elements of the sequence
     |   |      - one element of the sequence and one result of a previous reduction
     |   |      - two results of previous reductions
     |   |      
     |   |      The reduction function can be called on the results of two previous reductions because the
     |   |      `reduce` command is distributed and parallelized across shards and CPU cores. A common
     |   |      mistaken when using the `reduce` command is to suppose that the reduction is executed
     |   |      from left to right. Read the [map-reduce in RethinkDB](http://rethinkdb.com/docs/map-reduce/) article to
     |   |      see an example.
     |   |      
     |   |      If the sequence is empty, the server will produce a `RqlRuntimeError` that can be
     |   |      caught with `default`.  
     |   |      If the sequence has only one element, the first element will be returned.
     |   |      
     |   |      *Example* Return the number of documents in the table `posts`.
     |   |      
     |   |          r.table("posts").map(lambda doc: 1)
     |   |              .reduce(lambda left, right: left+right)
     |   |              .default(0).run(conn)
     |   |      
     |   |      A shorter way to execute this query is to use [count](http://rethinkdb.com/api/python/count).
     |   |      
     |   |      *Example* Suppose that each `post` has a field `comments` that is an array of
     |   |      comments.  
     |   |      Return the number of comments for all posts.
     |   |      
     |   |          r.table("posts").map(lambda doc:
     |   |              doc["comments"].count()
     |   |          ).reduce(lambda left, right:
     |   |              left+right
     |   |          ).default(0).run(conn)
     |   |      
     |   |      *Example* Suppose that each `post` has a field `comments` that is an array of
     |   |      comments.  
     |   |      Return the maximum number comments per post.
     |   |      
     |   |          r.table("posts").map(lambda doc:
     |   |              doc["comments"].count()
     |   |          ).reduce(lambda left, right:
     |   |              r.branch(
     |   |                  left > right,
     |   |                  left,
     |   |                  right
     |   |              )
     |   |          ).default(0).run(conn)
     |   |      
     |   |      A shorter way to execute this query is to use [max](http://rethinkdb.com/api/python/max).
     |   |  
     |   |  replace(self, *args, **kwargs)
     |   |      table.replace(json | expr[, durability="hard", return_changes=False, non_atomic=False])
     |   |          -> object
     |   |      selection.replace(json | expr[, durability="hard", return_changes=False, non_atomic=False])
     |   |          -> object
     |   |      singleSelection.replace(json | expr[, durability="hard", return_changes=False, non_atomic=False])
     |   |          -> object
     |   |      
     |   |      Replace documents in a table. Accepts a JSON document or a ReQL expression, and replaces
     |   |      the original document with the new one. The new document must have the same primary key
     |   |      as the original document.
     |   |      
     |   |      The optional arguments are:
     |   |      
     |   |      - `durability`: possible values are `hard` and `soft`. This option will override the
     |   |      table or query's durability setting (set in [run](http://rethinkdb.com/api/python/run/)).  
     |   |      In soft durability mode RethinkDB will acknowledge the write immediately after
     |   |      receiving it, but before the write has been committed to disk.
     |   |      - `return_changes`: if set to `True`, return a `changes` array consisting of `old_val`/`new_val` objects describing the changes made.
     |   |      - `non_atomic`: if set to `True`, executes the replacement and distributes the result to replicas in a non-atomic fashion. This flag is required to perform non-deterministic updates, such as those that require reading data from another table.
     |   |      
     |   |      Replace returns an object that contains the following attributes:
     |   |      
     |   |      - `replaced`: the number of documents that were replaced
     |   |      - `unchanged`: the number of documents that would have been modified, except that the
     |   |      new value was the same as the old value
     |   |      - `inserted`: the number of new documents added. You can have new documents inserted if
     |   |      you do a point-replace on a key that isn't in the table or you do a replace on a
     |   |      selection and one of the documents you are replacing has been deleted
     |   |      - `deleted`: the number of deleted documents when doing a replace with `None`
     |   |      - `errors`: the number of errors encountered while performing the replace.
     |   |      - `first_error`: If errors were encountered, contains the text of the first error.
     |   |      - `skipped`: 0 for a replace operation
     |   |      - `changes`: if `return_changes` is set to `True`, this will be an array of objects, one for each objected affected by the `replace` operation. Each object will have two keys: `{"new_val": <new value>, "old_val": <old value>}`.
     |   |      
     |   |      *Example* Replace the document with the primary key `1`.
     |   |      
     |   |          r.table("posts").get(1).replace({
     |   |              "id": 1,
     |   |              "title": "Lorem ipsum",
     |   |              "content": "Aleas jacta est",
     |   |              "status": "draft"
     |   |          }).run(conn)
     |   |      
     |   |      *Example* Remove the field `status` from all posts.
     |   |      
     |   |          r.table("posts").replace(lambda post:
     |   |              post.without("status")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Remove all the fields that are not `id`, `title` or `content`.
     |   |      
     |   |          r.table("posts").replace(lambda post:
     |   |              post.pluck("id", "title", "content")
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Replace the document with the primary key `1` using soft durability.
     |   |      
     |   |          r.table("posts").get(1).replace({
     |   |              "id": 1,
     |   |              "title": "Lorem ipsum",
     |   |              "content": "Aleas jacta est",
     |   |              "status": "draft"
     |   |          }, durability="soft").run(conn)
     |   |      
     |   |      *Example* Replace the document with the primary key `1` and return the values of the document before
     |   |      and after the replace operation.
     |   |      
     |   |          r.table("posts").get(1).replace({
     |   |              "id": 1,
     |   |              "title": "Lorem ipsum",
     |   |              "content": "Aleas jacta est",
     |   |              "status": "published"
     |   |          }, return_changes=True).run(conn)
     |   |      
     |   |      The result will have a `changes` field:
     |   |      
     |   |          {
     |   |              "deleted": 0,
     |   |              "errors":  0,
     |   |              "inserted": 0,
     |   |              "changes": [
     |   |                  {
     |   |                      "new_val": {
     |   |                          "id":1,
     |   |                          "title": "Lorem ipsum"
     |   |                          "content": "Aleas jacta est",
     |   |                          "status": "published",
     |   |                      },
     |   |                      "old_val": {
     |   |                          "id":1,
     |   |                          "title": "Lorem ipsum"
     |   |                          "content": "TODO",
     |   |                          "status": "draft",
     |   |                          "author": "William",
     |   |                      }
     |   |                  }
     |   |              ],   
     |   |              "replaced": 1,
     |   |              "skipped": 0,
     |   |              "unchanged": 0
     |   |          }
     |   |  
     |   |  run(self, c=None, **global_optargs)
     |   |      query.run(conn, use_outdated=False, time_format='native', profile=False, durability="hard") -> cursor
     |   |      query.run(conn, use_outdated=False, time_format='native', profile=False, durability="hard") -> object
     |   |      
     |   |      Run a query on a connection, returning either a single JSON result or
     |   |      a cursor, depending on the query.
     |   |      
     |   |      The optional arguments are:
     |   |      
     |   |      - `use_outdated`: whether or not outdated reads are OK (default: `False`).
     |   |      - `time_format`: what format to return times in (default: `'native'`).
     |   |        Set this to `'raw'` if you want times returned as JSON objects for exporting.
     |   |      - `profile`: whether or not to return a profile of the query's
     |   |        execution (default: `False`).
     |   |      - `durability`: possible values are `'hard'` and `'soft'`. In soft durability mode RethinkDB
     |   |      will acknowledge the write immediately after receiving it, but before the write has
     |   |      been committed to disk.
     |   |      - `group_format`: what format to return `grouped_data` and `grouped_streams` in (default: `'native'`).
     |   |        Set this to `'raw'` if you want the raw pseudotype.
     |   |      - `noreply`: set to `True` to not receive the result object or cursor and return immediately.
     |   |      - `db`: the database to run this query against as a string. The default is the database specified in the `db` parameter to [connect](http://rethinkdb.com/api/python/connect/) (which defaults to `test`). The database may also be specified with the [db](http://rethinkdb.com/api/python/db/) command.
     |   |      - `array_limit`: the maximum numbers of array elements that can be returned by a query (default: 100,000). This affects all ReQL commands that return arrays. Note that it has no effect on the size of arrays being _written_ to the database; those always have an upper limit of 100,000 elements.
     |   |      - `binary_format`: what format to return binary data in (default: `'native'`). Set this to `'raw'` if you want the raw pseudotype.
     |   |      - `min_batch_rows`: minimum number of rows to wait for before batching a result set (default: 8). This is an integer.
     |   |      - `max_batch_rows`: maximum number of rows to wait for before batching a result set (default: unlimited). This is an integer.
     |   |      - `max_batch_bytes`: maximum number of bytes to wait for before batching a result set (default: 1024). This is an integer.
     |   |      - `max_batch_seconds`: maximum number of seconds to wait before batching a result set (default: 0.5). This is a float (not an integer) and may be specified to the microsecond.
     |   |      - `first_batch_scaledown_factor`: factor to scale the other parameters down by on the first batch (default: 4). For example, with this set to 8 and `max_batch_rows` set to 80, on the first batch `max_batch_rows` will be adjusted to 10 (80 / 8). This allows the first batch to return faster.
     |   |      
     |   |      *Example* Run a query on the connection `conn` and print out every
     |   |      row in the result.
     |   |      
     |   |          for doc in r.table('marvel').run(conn):
     |   |              print doc
     |   |      
     |   |      *Example* If you are OK with potentially out of date data from all
     |   |      the tables involved in this query and want potentially faster reads,
     |   |      pass a flag allowing out of date data in an options object. Settings
     |   |      for individual tables will supercede this global setting for all
     |   |      tables in the query.
     |   |      
     |   |          r.table('marvel').run(conn, use_outdated=True)
     |   |      
     |   |      *Example* If you just want to send a write and forget about it, you
     |   |      can set `noreply` to true in the options. In this case `run` will
     |   |      return immediately.
     |   |      
     |   |          r.table('marvel').run(conn, noreply=True)
     |   |      
     |   |      *Example* If you want to specify whether to wait for a write to be
     |   |      written to disk (overriding the table's default settings), you can set
     |   |      `durability` to `'hard'` or `'soft'` in the options.
     |   |      
     |   |          r.table('marvel')
     |   |              .insert({ 'superhero': 'Iron Man', 'superpower': 'Arc Reactor' })
     |   |              .run(conn, noreply=True, durability='soft')
     |   |      
     |   |      *Example* If you do not want a time object to be converted to a
     |   |      native date object, you can pass a `time_format` flag to prevent it
     |   |      (valid flags are "raw" and "native"). This query returns an object
     |   |      with two fields (`epoch_time` and `$reql_type$`) instead of a native date
     |   |      object.
     |   |      
     |   |          r.now().run(conn, time_format="raw")
     |   |      
     |   |      *Example* Specify the database to use for the query.
     |   |      
     |   |          for doc in r.table('marvel').run(conn, db='heroes'):
     |   |              print doc
     |   |      
     |   |      This is equivalent to using the `db` command to specify the database:
     |   |      
     |   |          r.db('heroes').table('marvel').run(conn) ...
     |   |      
     |   |      *Example* Change the batching parameters for this query.
     |   |      
     |   |          r.table('marvel').run(conn, max_batch_rows=16, max_batch_bytes=2048)
     |   |  
     |   |  sample(self, *args)
     |   |      sequence.sample(number) -> selection
     |   |      stream.sample(number) -> array
     |   |      array.sample(number) -> array
     |   |      
     |   |      Select a given number of elements from a sequence with uniform random distribution. Selection is done without replacement.
     |   |      
     |   |      If the sequence has less than the requested number of elements (i.e., calling `sample(10)` on a sequence with only five elements), `sample` will return the entire sequence in a random order.
     |   |      
     |   |      *Example* Select 3 random heroes.
     |   |      
     |   |          r.table('marvel').sample(3).run(conn)
     |   |  
     |   |  seconds(self, *args)
     |   |      time.seconds() -> number
     |   |      
     |   |      Return the seconds in a time object as a number between 0 and 59.999 (double precision).
     |   |      
     |   |      *Example* Return the post submitted during the first 30 seconds of every minute.
     |   |      
     |   |          r.table("posts").filter(lambda post:
     |   |              post["date"].seconds() < 30
     |   |          ).run(conn)
     |   |  
     |   |  set_difference(self, *args)
     |   |      array.set_difference(array) -> array
     |   |      
     |   |      Remove the elements of one array from another and return them as a set (an array with
     |   |      distinct values).
     |   |      
     |   |      *Example* Check which pieces of equipment Iron Man has, excluding a fixed list.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].set_difference(['newBoots', 'arc_reactor']).run(conn)
     |   |  
     |   |  set_insert(self, *args)
     |   |      array.set_insert(value) -> array
     |   |      
     |   |      Add a value to an array and return it as a set (an array with distinct values).
     |   |      
     |   |      *Example* Retrieve Iron Man's equipment list with the addition of some new boots.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].set_insert('newBoots').run(conn)
     |   |  
     |   |  set_intersection(self, *args)
     |   |      array.set_intersection(array) -> array
     |   |      
     |   |      Intersect two arrays returning values that occur in both of them as a set (an array with
     |   |      distinct values).
     |   |      
     |   |      *Example* Check which pieces of equipment Iron Man has from a fixed list.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].set_intersection(['newBoots', 'arc_reactor']).run(conn)
     |   |  
     |   |  set_union(self, *args)
     |   |      array.set_union(array) -> array
     |   |      
     |   |      Add a several values to an array and return it as a set (an array with distinct values).
     |   |      
     |   |      *Example* Retrieve Iron Man's equipment list with the addition of some new boots and an arc reactor.
     |   |      
     |   |          r.table('marvel').get('IronMan')['equipment'].set_union(['newBoots', 'arc_reactor']).run(conn)
     |   |  
     |   |  skip(self, *args)
     |   |      sequence.skip(n) -> stream
     |   |      array.skip(n) -> array
     |   |      
     |   |      Skip a number of elements from the head of the sequence.
     |   |      
     |   |      *Example* Here in conjunction with `order_by` we choose to ignore the most successful heroes.
     |   |      
     |   |          r.table('marvel').order_by('successMetric').skip(10).run(conn)
     |   |  
     |   |  slice(self, *args, **kwargs)
     |   |      selection.slice(start_index[, end_index, left_bound='closed', right_bound='open']) -> selection
     |   |      stream.slice(start_index[, end_index, left_bound='closed', right_bound='open']) -> stream
     |   |      array.slice(start_index[, end_index, left_bound='closed', right_bound='open']) -> array
     |   |      binary.slice(start_index[, end_index, left_bound='closed', right_bound='open']) -> binary
     |   |      
     |   |      Return the elements of a sequence within the specified range.
     |   |      
     |   |      `slice` returns the range between `start_index` and `end_index`. If only `start_index` is specified, `slice` returns the range from that index to the end of the sequence. Specify `left_bound` or `right_bound` as `open` or `closed` to indicate whether to include that endpoint of the range by default: `closed` returns that endpoint, while `open` does not. By default, `left_bound` is closed and `right_bound` is open, so the range `(10,13)` will return the tenth, eleventh and twelfth elements in the sequence.
     |   |      
     |   |      If `end_index` is past the end of the sequence, all elements from `start_index` to the end of the sequence will be returned. If `start_index` is past the end of the sequence or `end_index` is less than `start_index`, a zero-element sequence will be returned (although see below for negative `end_index` values). An error will be raised on a negative `start_index`.
     |   |      
     |   |      A negative `end_index` is allowed with arrays; in that case, the returned range counts backward from the array's end. That is, the range of `(2,-1)` returns the second element through the next-to-last element of the range. A negative `end_index` is not allowed with a stream. (An `end_index` of &minus;1 *is* allowed with a stream if `right_bound` is closed; this behaves as if no `end_index` was specified.)
     |   |      
     |   |      If `slice` is used with a [binary](http://rethinkdb.com/api/python/binary) object, the indexes refer to byte positions within the object. That is, the range `(10,20)` will refer to the 10th byte through the 19th byte.
     |   |      
     |   |      If you are only specifying the indexes and not the bounding options, you may use Python's slice operator as a shorthand: `[start_index:end_index]`.
     |   |      
     |   |      **Example:** Return the fourth, fifth and sixth youngest players. (The youngest player is at index 0, so those are elements 3&ndash;5.)
     |   |      
     |   |          r.table('players').order_by(index='age').slice(3,6).run(conn)
     |   |      
     |   |      Or, using Python's slice operator:
     |   |      
     |   |          r.table('players').filter({'class': 'amateur'})[10:20].run(conn)
     |   |      
     |   |      **Example:** Return all but the top three players who have a red flag.
     |   |      
     |   |          r.table('players').filter({'flag': 'red'}).order_by(index=r.desc('score')).slice(3).run(conn)
     |   |      
     |   |      **Example:** Return holders of tickets `X` through `Y`, assuming tickets are numbered sequentially. We want to include ticket `Y`.
     |   |      
     |   |          r.table('users').order_by(index='ticket').slice(x, y, right_bound='closed').run(conn)
     |   |      
     |   |      **Example:** Return the elements of an array from the second through two from the end (that is, not including the last two).
     |   |      
     |   |          r.expr([0,1,2,3,4,5]).slice(2,-2).run(conn)
     |   |      
     |   |      Result:
     |   |      
     |   |          [2,3]
     |   |  
     |   |  splice_at(self, *args)
     |   |      array.splice_at(index, array) -> array
     |   |      
     |   |      Insert several values in to an array at a given index. Returns the modified array.
     |   |      
     |   |      *Example* Hulk and Thor decide to join the avengers.
     |   |      
     |   |          r.expr(["Iron Man", "Spider-Man"]).splice_at(1, ["Hulk", "Thor"]).run(conn)
     |   |  
     |   |  split(self, *args)
     |   |      string.split([separator, [max_splits]]) -> array
     |   |      
     |   |      Splits a string into substrings.  Splits on whitespace when called
     |   |      with no arguments.  When called with a separator, splits on that
     |   |      separator.  When called with a separator and a maximum number of
     |   |      splits, splits on that separator at most `max_splits` times.  (Can be
     |   |      called with `None` as the separator if you want to split on whitespace
     |   |      while still specifying `max_splits`.)
     |   |      
     |   |      Mimics the behavior of Python's `string.split` in edge cases, except
     |   |      for splitting on the empty string, which instead produces an array of
     |   |      single-character strings.
     |   |      
     |   |      *Example* Split on whitespace.
     |   |      
     |   |          > r.expr("foo  bar bax").split().run(conn)
     |   |          ["foo", "bar", "bax"]
     |   |      
     |   |      *Example* Split the entries in a CSV file.
     |   |      
     |   |          > r.expr("12,37,,22,").split(",").run(conn)
     |   |          ["12", "37", "", "22", ""]
     |   |      
     |   |      *Example* Split a string into characters.
     |   |      
     |   |          > r.expr("mlucy").split("").run(conn)
     |   |          ["m", "l", "u", "c", "y"]
     |   |      
     |   |      *Example* Split the entries in a CSV file, but only at most 3
     |   |      times.
     |   |      
     |   |          > r.expr("12,37,,22,").split(",", 3).run(conn)
     |   |          ["12", "37", "", "22,"]
     |   |      
     |   |      *Example* Split on whitespace at most once (i.e. get the first word).
     |   |      
     |   |          > r.expr("foo  bar bax").split(None, 1).run(conn)
     |   |          ["foo", "bar bax"]
     |   |  
     |   |  sub(self, *args)
     |   |  
     |   |  sum(self, *args)
     |   |      sequence.sum([field_or_function]) -> number
     |   |      
     |   |      Sums all the elements of a sequence.  If called with a field name,
     |   |      sums all the values of that field in the sequence, skipping elements
     |   |      of the sequence that lack that field.  If called with a function,
     |   |      calls that function on every element of the sequence and sums the
     |   |      results, skipping elements of the sequence where that function returns
     |   |      `None` or a non-existence error.
     |   |      
     |   |      Returns `0` when called on an empty sequence.
     |   |      
     |   |      *Example* What's 3 + 5 + 7?
     |   |      
     |   |          r.expr([3, 5, 7]).sum().run(conn)
     |   |      
     |   |      *Example* How many points have been scored across all games?
     |   |      
     |   |          r.table('games').sum('points').run(conn)
     |   |      
     |   |      *Example* How many points have been scored across all games,
     |   |      counting bonus points?
     |   |      
     |   |          r.table('games').sum(lambda game:
     |   |              game['points'] + game['bonus_points']
     |   |          ).run(conn)
     |   |  
     |   |  time_of_day(self, *args)
     |   |      time.time_of_day() -> number
     |   |      
     |   |      Return the number of seconds elapsed since the beginning of the day stored in the time object.
     |   |      
     |   |      *Example* Retrieve posts that were submitted before noon.
     |   |      
     |   |          r.table("posts").filter(
     |   |              r.row["date"].time_of_day() <= 12*60*60
     |   |          ).run(conn)
     |   |  
     |   |  timezone(self, *args)
     |   |      time.timezone() -> string
     |   |      
     |   |      Return the timezone of the time object.
     |   |      
     |   |      *Example* Return all the users in the "-07:00" timezone.
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user["subscriptionDate"].timezone() == "-07:00"
     |   |          )
     |   |  
     |   |  to_epoch_time(self, *args)
     |   |      time.to_epoch_time() -> number
     |   |      
     |   |      Convert a time object to its epoch time.
     |   |      
     |   |      *Example* Return the current time in seconds since the Unix Epoch with millisecond-precision.
     |   |      
     |   |          r.now().to_epoch_time()
     |   |  
     |   |  to_geojson(self, *args)
     |   |      geometry.to_geojson() -> object
     |   |      
     |   |      Convert a ReQL geometry object to a [GeoJSON][] object.
     |   |      
     |   |      [GeoJSON]: http://geojson.org
     |   |      
     |   |      *Example* Convert a ReQL geometry object to a GeoJSON object.
     |   |      
     |   |          > r.table(geo).get('sfo')['location'].to_geojson.run(conn)
     |   |          
     |   |          {
     |   |              'type': 'Point',
     |   |              'coordinates': [ -122.423246, 37.779388 ]
     |   |          }
     |   |  
     |   |  to_iso8601(self, *args)
     |   |      time.to_iso8601() -> number
     |   |      
     |   |      Convert a time object to its iso 8601 format.
     |   |      
     |   |      *Example* Return the current time in an ISO8601 format.
     |   |      
     |   |          r.now().to_iso8601()
     |   |  
     |   |  to_json(self, *args)
     |   |      value.to_json_string() -> string
     |   |      value.to_json() -> string
     |   |      
     |   |      Convert a ReQL value or object to a JSON string. You may use either `to_json_string` or `to_json`.
     |   |      
     |   |      *Example* Get a ReQL document as a JSON string.
     |   |      
     |   |          > r.table('hero').get(1).to_json()
     |   |          
     |   |          '{"id": 1, "name": "Batman", "city": "Gotham", "powers": ["martial arts", "cinematic entrances"]}'
     |   |  
     |   |  to_json_string(self, *args)
     |   |      value.to_json_string() -> string
     |   |      value.to_json() -> string
     |   |      
     |   |      Convert a ReQL value or object to a JSON string. You may use either `to_json_string` or `to_json`.
     |   |      
     |   |      *Example* Get a ReQL document as a JSON string.
     |   |      
     |   |          > r.table('hero').get(1).to_json()
     |   |          
     |   |          '{"id": 1, "name": "Batman", "city": "Gotham", "powers": ["martial arts", "cinematic entrances"]}'
     |   |  
     |   |  type_of(self, *args)
     |   |      any.type_of() -> string
     |   |      
     |   |      Gets the type of a value.
     |   |      
     |   |      *Example* Get the type of a string.
     |   |      
     |   |          r.expr("foo").type_of().run(conn)
     |   |  
     |   |  ungroup(self, *args)
     |   |      grouped_stream.ungroup() -> array
     |   |      grouped_data.ungroup() -> array
     |   |      
     |   |      Takes a grouped stream or grouped data and turns it into an array of
     |   |      objects representing the groups.  Any commands chained after `ungroup`
     |   |      will operate on this array, rather than operating on each group
     |   |      individually.  This is useful if you want to e.g. order the groups by
     |   |      the value of their reduction.
     |   |      
     |   |      The format of the array returned by `ungroup` is the same as the
     |   |      default native format of grouped data in the JavaScript driver and
     |   |      data explorer.
     |   |      
     |   |      *Example* What is the maximum number of points scored by each
     |   |      player, with the highest scorers first?
     |   |      
     |   |      Suppose that the table `games` has the following data:
     |   |      
     |   |          [
     |   |              {"id": 2, "player": "Bob", "points": 15, "type": "ranked"},
     |   |              {"id": 5, "player": "Alice", "points": 7, "type": "free"},
     |   |              {"id": 11, "player": "Bob", "points": 10, "type": "free"},
     |   |              {"id": 12, "player": "Alice", "points": 2, "type": "free"}
     |   |          ]
     |   |      
     |   |      We can use this query:
     |   |      
     |   |          r.table('games')
     |   |             .group('player').max('points')['points']
     |   |             .ungroup().order_by(r.desc('reduction')).run(conn)
     |   |      
     |   |      Result: 
     |   |      
     |   |          [
     |   |              {
     |   |                  "group": "Bob",
     |   |                  "reduction": 15
     |   |              },
     |   |              {
     |   |                  "group": "Alice",
     |   |                  "reduction": 7
     |   |              }
     |   |          ]
     |   |      
     |   |      *Example* Select one random player and all their games.
     |   |      
     |   |          r.table('games').group('player').ungroup().sample(1).run(conn)
     |   |      
     |   |      Result:
     |   |      
     |   |          [
     |   |              {
     |   |                  "group": "Bob",
     |   |                  "reduction": [
     |   |                      {"id": 2, "player": "Bob", "points": 15, "type": "ranked"},
     |   |                      {"id": 11, "player": "Bob", "points": 10, "type": "free"}
     |   |                  ]
     |   |              }
     |   |          ]
     |   |      
     |   |      Note that if you didn't call `ungroup`, you would instead select one
     |   |      random game from each player:
     |   |      
     |   |          r.table('games').group('player').sample(1).run(conn)
     |   |      
     |   |      Result:
     |   |      
     |   |          {
     |   |              "Alice": [
     |   |                  {"id": 5, "player": "Alice", "points": 7, "type": "free"}
     |   |              ],
     |   |              "Bob": [
     |   |                  {"id": 11, "player": "Bob", "points": 10, "type": "free"}
     |   |              ]
     |   |          }
     |   |      
     |   |      *Example* Types!
     |   |      
     |   |          r.table('games').group('player').type_of().run(conn) # Returns "GROUPED_STREAM"
     |   |          r.table('games').group('player').ungroup().type_of().run(conn) # Returns "ARRAY"
     |   |          r.table('games').group('player').avg('points').run(conn) # Returns "GROUPED_DATA"
     |   |          r.table('games').group('player').avg('points').ungroup().run(conn) #Returns "ARRAY"
     |   |  
     |   |  union(self, *args)
     |   |      sequence.union(sequence) -> array
     |   |      
     |   |      Concatenate two sequences.
     |   |      
     |   |      *Example* Construct a stream of all heroes.
     |   |      
     |   |          r.table('marvel').union(r.table('dc')).run(conn)
     |   |  
     |   |  upcase(self, *args)
     |   |      string.upcase() -> string
     |   |      
     |   |      Uppercases a string.
     |   |      
     |   |      *Example*
     |   |      
     |   |          > r.expr("Sentence about LaTeX.").upcase().run(conn)
     |   |          "SENTENCE ABOUT LATEX."
     |   |      
     |   |      __Note:__ `upcase` and `downcase` only affect ASCII characters.
     |   |  
     |   |  update(self, *args, **kwargs)
     |   |      table.update(json | expr[, durability="hard", return_changes=False, non_atomic=False])
     |   |          -> object
     |   |      selection.update(json | expr[, durability="hard", return_changes=False, non_atomic=False])
     |   |          -> object
     |   |      singleSelection.update(json | expr[, durability="hard", return_changes=False, non_atomic=False])
     |   |          -> object
     |   |      
     |   |      Update JSON documents in a table. Accepts a JSON document, a ReQL expression, or a
     |   |      combination of the two.
     |   |      
     |   |      The optional arguments are:
     |   |      
     |   |      - `durability`: possible values are `hard` and `soft`. This option will override the
     |   |      table or query's durability setting (set in [run](http://rethinkdb.com/api/python/run/)).  
     |   |      In soft durability mode RethinkDB will acknowledge the write immediately after
     |   |      receiving it, but before the write has been committed to disk.
     |   |      - `return_changes`: if set to `True`, return a `changes` array consisting of `old_val`/`new_val` objects describing the changes made.
     |   |      - `non_atomic`: if set to `True`, executes the update and distributes the result to replicas in a non-atomic fashion. This flag is required to perform non-deterministic updates, such as those that require reading data from another table.
     |   |      
     |   |      Update returns an object that contains the following attributes:
     |   |      
     |   |      - `replaced`: the number of documents that were updated.
     |   |      - `unchanged`: the number of documents that would have been modified except the new
     |   |      value was the same as the old value.
     |   |      - `skipped`: the number of documents that were skipped because the document didn't exist.
     |   |      - `errors`: the number of errors encountered while performing the update.
     |   |      - `first_error`: If errors were encountered, contains the text of the first error.
     |   |      - `deleted` and `inserted`: 0 for an update operation.
     |   |      - `changes`: if `return_changes` is set to `True`, this will be an array of objects, one for each objected affected by the `update` operation. Each object will have two keys: `{"new_val": <new value>, "old_val": <old value>}`.
     |   |      
     |   |      *Example* Update the status of the post with `id` of `1` to `published`.
     |   |      
     |   |          r.table("posts").get(1).update({"status": "published"}).run(conn)
     |   |      
     |   |      *Example* Update the status of all posts to `published`.
     |   |      
     |   |          r.table("posts").update({"status": "published"}).run(conn)
     |   |      
     |   |      *Example* Update the status of all the post written by William.
     |   |      
     |   |          r.table("posts").filter({"author": "William"}).update({"status": "published"}).run(conn)
     |   |      
     |   |      *Example* Increment the field `view` with `id` of `1`.
     |   |      This query will throw an error if the field `views` doesn't exist.
     |   |      
     |   |          r.table("posts").get(1).update({
     |   |              "views": r.row["views"]+1
     |   |          }).run(conn)
     |   |      
     |   |      *Example* Increment the field `view` of the post with `id` of `1`.
     |   |      If the field `views` does not exist, it will be set to `0`.
     |   |      
     |   |          r.table("posts").update({
     |   |              "views": (r.row["views"]+1).default(0)
     |   |          }).run(conn)
     |   |      
     |   |      *Example* Perform a conditional update.  
     |   |      If the post has more than 100 views, set the `type` of a post to `hot`, else set it to `normal`.
     |   |      
     |   |          r.table("posts").get(1).update(lambda post:
     |   |              r.branch(
     |   |                  post["views"] > 100,
     |   |                  {"type": "hot"},
     |   |                  {"type": "normal"}
     |   |              )
     |   |          ).run(conn)
     |   |      
     |   |      *Example* Update the field `num_comments` with the result of a sub-query. Because
     |   |      this update is not atomic, you must pass the `non_atomic` flag.
     |   |      
     |   |          r.table("posts").get(1).update({
     |   |              "num_comments": r.table("comments").filter({"id_post": 1}).count()
     |   |          }, non_atomic=True ).run(conn)
     |   |      
     |   |      If you forget to specify the `non_atomic` flag, you will get a `RqlRuntimeError`.
     |   |      
     |   |      RqlRuntimeError: Could not prove function deterministic.  Maybe you want to use the non_atomic flag? 
     |   |      
     |   |      *Example* Update the field `num_comments` with a random value between 0 and 100.  
     |   |      This update cannot be proven deterministic because of `r.js` (and in fact is not), so you
     |   |      must pass the `non_atomic` flag.
     |   |      
     |   |          r.table("posts").get(1).update({
     |   |              "num_comments": r.js("Math.floor(Math.random()*100)")
     |   |          }, non_atomic=True ).run(conn)
     |   |      
     |   |      *Example* Update the status of the post with `id` of `1` using soft durability.
     |   |      
     |   |          r.table("posts").get(1).update({status: "published"}, durability="soft").run(conn)
     |   |      
     |   |      *Example* Increment the field `views` and return the values of the document before
     |   |      and after the update operation.
     |   |      
     |   |          r.table("posts").get(1).update({
     |   |              "views": r.row["views"]+1
     |   |          }, return_changes=True).run(conn)
     |   |      
     |   |      The result will have a `changes` field:
     |   |      
     |   |          {
     |   |              "deleted": 1,
     |   |              "errors": 0,
     |   |              "inserted": 0,
     |   |              "changes": [
     |   |                  {
     |   |                      "new_val": {
     |   |                          "id": 1,
     |   |                          "author": "Julius_Caesar",
     |   |                          "title": "Commentarii de Bello Gallico",
     |   |                          "content": "Aleas jacta est",
     |   |                          "views": 207
     |   |                      },
     |   |                      "old_val": {
     |   |                          "id": 1,
     |   |                          "author": "Julius_Caesar",
     |   |                          "title": "Commentarii de Bello Gallico",
     |   |                          "content": "Aleas jacta est",
     |   |                          "views": 206
     |   |                      }
     |   |                  }
     |   |              ],
     |   |              "replaced": 0,
     |   |              "skipped": 0,
     |   |              "unchanged": 0
     |   |          }
     |   |  
     |   |  with_fields(self, *args)
     |   |      sequence.with_fields([selector1, selector2...]) -> stream
     |   |      array.with_fields([selector1, selector2...]) -> array
     |   |      
     |   |      Plucks one or more attributes from a sequence of objects, filtering out any objects in the sequence that do not have the specified fields. Functionally, this is identical to `has_fields` followed by `pluck` on a sequence.
     |   |      
     |   |      *Example* Get a list of users and their posts, excluding any users who have not made any posts.
     |   |      
     |   |      Existing table structure:
     |   |      
     |   |          [
     |   |              { 'id': 1, 'user': 'bob', 'email': 'bob@foo.com', 'posts': [ 1, 4, 5 ] },
     |   |              { 'id': 2, 'user': 'george', 'email': 'george@foo.com' },
     |   |              { 'id': 3, 'user': 'jane', 'email': 'jane@foo.com', 'posts': [ 2, 3, 6 ] }
     |   |          ]
     |   |      
     |   |      Command and output:
     |   |      
     |   |          r.table('users').with_fields('id', 'user', 'posts').run(conn)
     |   |          
     |   |          [
     |   |              { 'id': 1, 'user': 'bob', 'posts': [ 1, 4, 5 ] },
     |   |              { 'id': 3, 'user': 'jane', 'posts': [ 2, 3, 6 ] }
     |   |          ]
     |   |      
     |   |      *Example* Use the [nested field syntax](http://rethinkdb.com/docs/nested-fields/) to get a list of users with cell phone numbers in their contacts.
     |   |      
     |   |          r.table('users').with_fields('id', 'user', {contact: {'phone': 'work'}).run(conn)
     |   |  
     |   |  without(self, *args)
     |   |      sequence.without([selector1, selector2...]) -> stream
     |   |      array.without([selector1, selector2...]) -> array
     |   |      singleSelection.without([selector1, selector2...]) -> object
     |   |      object.without([selector1, selector2...]) -> object
     |   |      
     |   |      The opposite of pluck; takes an object or a sequence of objects, and returns them with
     |   |      the specified paths removed.
     |   |      
     |   |      *Example* Since we don't need it for this computation we'll save bandwidth and leave
     |   |      out the list of IronMan's romantic conquests.
     |   |      
     |   |          r.table('marvel').get('IronMan').without('personalVictoriesList').run(conn)
     |   |      
     |   |      *Example* Without their prized weapons, our enemies will quickly be vanquished.
     |   |      
     |   |          r.table('enemies').without('weapons').run(conn)
     |   |      
     |   |      *Example* Nested objects can be used to remove the damage subfield from the weapons and abilities fields.
     |   |      
     |   |          r.table('marvel').without({'weapons' : {'damage' : True}, 'abilities' : {'damage' : True}}).run(conn)
     |   |      
     |   |      *Example* The nested syntax can quickly become overly verbose so there's a shorthand for it.
     |   |      
     |   |          r.table('marvel').without({'weapons' : 'damage', 'abilities' : 'damage'}).run(conn)
     |   |  
     |   |  year(self, *args)
     |   |      time.year() -> number
     |   |      
     |   |      Return the year of a time object.
     |   |      
     |   |      *Example* Retrieve all the users born in 1986.
     |   |      
     |   |          r.table("users").filter(lambda user:
     |   |              user["birthdate"].year() == 1986
     |   |          ).run(conn)
     |   |  
     |   |  zip(self, *args)
     |   |      stream.zip() -> stream
     |   |      array.zip() -> array
     |   |      
     |   |      Used to 'zip' up the result of a join by merging the 'right' fields into 'left' fields of each member of the sequence.
     |   |      
     |   |      *Example* 'zips up' the sequence by merging the left and right fields produced by a join.
     |   |      
     |   |          r.table('marvel').eq_join('main_dc_collaborator', r.table('dc')).zip().run(conn)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors defined here:
     |   |  
     |   |  __dict__
     |   |      dictionary for instance variables (if defined)
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |  
     |  class RqlRuntimeError(RqlQueryError)
     |   |  Method resolution order:
     |   |      RqlRuntimeError
     |   |      RqlQueryError
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods defined here:
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlQueryError:
     |   |  
     |   |  __init__(self, message, term, frames)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlError:
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from RqlError:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  class RqlTimeoutError(RqlError)
     |   |  Method resolution order:
     |   |      RqlTimeoutError
     |   |      RqlError
     |   |      exceptions.Exception
     |   |      exceptions.BaseException
     |   |      __builtin__.object
     |   |  
     |   |  Methods defined here:
     |   |  
     |   |  __init__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from RqlError:
     |   |  
     |   |  __repr__(self)
     |   |  
     |   |  __str__(self)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from RqlError:
     |   |  
     |   |  __weakref__
     |   |      list of weak references to the object (if defined)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data and other attributes inherited from exceptions.Exception:
     |   |  
     |   |  __new__ = <built-in method __new__ of type object>
     |   |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Methods inherited from exceptions.BaseException:
     |   |  
     |   |  __delattr__(...)
     |   |      x.__delattr__('name') <==> del x.name
     |   |  
     |   |  __getattribute__(...)
     |   |      x.__getattribute__('name') <==> x.name
     |   |  
     |   |  __getitem__(...)
     |   |      x.__getitem__(y) <==> x[y]
     |   |  
     |   |  __getslice__(...)
     |   |      x.__getslice__(i, j) <==> x[i:j]
     |   |      
     |   |      Use of negative indices is not supported.
     |   |  
     |   |  __reduce__(...)
     |   |  
     |   |  __setattr__(...)
     |   |      x.__setattr__('name', value) <==> x.name = value
     |   |  
     |   |  __setstate__(...)
     |   |  
     |   |  __unicode__(...)
     |   |  
     |   |  ----------------------------------------------------------------------
     |   |  Data descriptors inherited from exceptions.BaseException:
     |   |  
     |   |  __dict__
     |   |  
     |   |  args
     |   |  
     |   |  message
     |  
     |  add(*args)
     |      number + number -> number
     |      string + string -> string
     |      array + array -> array
     |      time + number -> time
     |      
     |      Sum two numbers, concatenate two strings, or concatenate 2 arrays.
     |      
     |      *Example* It's as easy as 2 + 2 = 4.
     |      
     |          > (r.expr(2) + 2).run(conn)
     |          
     |          4
     |      
     |      *Example* Strings can be concatenated too.
     |      
     |          > (r.expr("foo") + "bar").run(conn)
     |          
     |          "foobar"
     |      
     |      *Example* Arrays can be concatenated too.
     |      
     |          > (r.expr(["foo", "bar"]) + ["buzz"]).run(conn)
     |          
     |          ['foo', 'bar', 'buzz']
     |      
     |      *Example* Create a date one year from now.
     |      
     |          r.now() + 365*24*60*60
     |      
     |      *Example* Use [args](http://rethinkdb.com/api/python/args) with `add` to sum multiple values.
     |      
     |          > r.add(r.args([10, 20, 30])).run(conn)
     |          
     |          60
     |      
     |      *Example* Concatenate an array of strings with `args`.
     |      
     |          > r.add(r.args(['foo', 'bar', 'buzz'])).run(conn)
     |          
     |          "foobarbuzz"
     |  
     |  and_(*args)
     |      bool & bool -> bool
     |      r.and_(bool, bool) -> bool
     |      bool.and_(bool) -> bool
     |      
     |      Compute the logical "and" of two or more values. The `and_` command can be used as an infix operator after its first argument (`r.expr(True).and_(False)`) or given all of its arguments as parameters (`r.and_(True, False)`). The standard Python and operator, `&`, may also be used with ReQL.
     |      
     |      *Example* Return whether both `a` and `b` evaluate to true.
     |      
     |          > a = True
     |          > b = False
     |          > (r.expr(a) & b).run(conn)
     |          
     |          False
     |      *Example* Return whether all of `x`, `y` and `z` evaluate to true.
     |      
     |          > x = True
     |          > y = True
     |          > z = True
     |          > r.and_(x, y, z).run(conn)
     |          
     |          True
     |  
     |  april = <RqlQuery instance: r.april >
     |  args(*args)
     |      r.args(array) -> special
     |      
     |      `r.args` is a special term that's used to splice an array of arguments
     |      into another term.  This is useful when you want to call a variadic
     |      term such as `get_all` with a set of arguments produced at runtime.
     |      
     |      This is analogous to unpacking argument lists in Python.
     |      
     |      *Example* Get Alice and Bob from the table `people`.
     |      
     |          r.table('people').get_all('Alice', 'Bob').run(conn)
     |          # or
     |          r.table('people').get_all(r.args(['Alice', 'Bob'])).run(conn)
     |      
     |      *Example* Get all of Alice's children from the table `people`.
     |      
     |          # r.table('people').get('Alice') returns {'id': 'Alice', 'children': ['Bob', 'Carol']}
     |          r.table('people').get_all(r.args(r.table('people').get('Alice')['children'])).run(conn)
     |  
     |  asc(*args)
     |      # orderBy orders
     |  
     |  august = <RqlQuery instance: r.august >
     |  binary(data)
     |      r.binary(data) -> binary
     |      
     |      Encapsulate binary data within a query.
     |      
     |      The type of data `binary` accepts depends on the client language. In Python, it expects a parameter of `bytes` type. Using a `bytes` object within a query implies the use of `binary` and the ReQL driver will automatically perform the coercion (in Python 3 only).
     |      
     |      Binary objects returned to the client in JavaScript will also be of the `bytes` type. This can be changed with the `binary_format` option provided to [run](http://rethinkdb.com/api/python/run) to return "raw" objects.
     |      
     |      Only a limited subset of ReQL commands may be chained after `binary`:
     |      
     |      * [coerce_to](http://rethinkdb.com/api/python/coerce_to/) can coerce `binary` objects to `string` types
     |      * [count](http://rethinkdb.com/api/python/count/) will return the number of bytes in the object
     |      * [slice](http://rethinkdb.com/api/python/slice/) will treat bytes like array indexes (i.e., `slice(10,20)` will return bytes 10&ndash;19)
     |      * [type_of](http://rethinkdb.com/api/python/type_of) returns `PTYPE<BINARY>`
     |      * [info](http://rethinkdb.com/api/python/info) will return information on a binary object.
     |      
     |      *Example* Save an avatar image to a existing user record.
     |      
     |          f = open('./default_avatar.png', 'rb')
     |          avatar_image = f.read()
     |          f.close()
     |          r.table('users').get(100).update({'avatar': r.binary(avatar_image)}).run(conn)
     |      
     |      *Example* Get the size of an existing avatar image.
     |      
     |          r.table('users').get(100)['avatar'].count().run(conn)
     |          
     |          14156
     |      
     |      Read more details about RethinkDB's binary object support: [Storing binary objects](http://rethinkdb.com/docs/storing-binary/).
     |  
     |  branch(*args)
     |      r.branch(test, true_branch, false_branch) -> any
     |      
     |      If the `test` expression returns `False` or `None`, the `false_branch` will be evaluated.
     |      Otherwise, the `true_branch` will be evaluated.
     |         
     |      The `branch` command is effectively an `if` renamed due to language constraints.
     |      
     |      *Example* Return heroes and superheroes.
     |      
     |          r.table('marvel').map(
     |              r.branch(
     |                  r.row['victories'] > 100,
     |                  r.row['name'] + ' is a superhero',
     |                  r.row['name'] + ' is a hero'
     |              )
     |          ).run(conn)
     |      
     |      If the documents in the table `marvel` are:
     |      
     |          [{
     |              "name": "Iron Man",
     |              "victories": 214
     |          },
     |          {
     |              "name": "Jubilee",
     |              "victories": 9
     |          }]
     |      
     |      The results will be:
     |      
     |          [
     |              "Iron Man is a superhero",
     |              "Jubilee is a hero"
     |          ]
     |  
     |  circle(*args, **kwargs)
     |      r.circle([longitude, latitude], radius[, num_vertices=32, geo_system='WGS84', unit='m', fill=True]) -> geometry
     |      r.circle(point, radius[, {num_vertices=32, geo_system='WGS84', unit='m', fill=True]) -> geometry
     |      
     |      Construct a circular line or polygon. A circle in RethinkDB is a polygon or line *approximating* a circle of a given radius around a given center, consisting of a specified number of vertices (default 32).
     |      
     |      The center may be specified either by two floating point numbers, the latitude (&minus;90 to 90) and longitude (&minus;180 to 180) of the point on a perfect sphere (see [Geospatial support](http://rethinkdb.com/docs/geo-support/) for more information on ReQL's coordinate system), or by a point object. The radius is a floating point number whose units are meters by default, although that may be changed with the `unit` argument.
     |      
     |      Optional arguments available with `circle` are:
     |      
     |      * `num_vertices`: the number of vertices in the polygon or line. Defaults to 32.
     |      * `geo_system`: the reference ellipsoid to use for geographic coordinates. Possible values are `WGS84` (the default), a common standard for Earth's geometry, or `unit_sphere`, a perfect sphere of 1 meter radius.
     |      * `unit`: Unit for the radius distance. Possible values are `m` (meter, the default), `km` (kilometer), `mi` (international mile), `nm` (nautical mile), `ft` (international foot).
     |      * `fill`: if `True` (the default) the circle is filled, creating a polygon; if `False` the circle is unfilled (creating a line).
     |      
     |      *Example* Define a circle.
     |      
     |          r.table('geo').insert({
     |              'id': 300,
     |              'name': 'Hayes Valley',
     |              'neighborhood': r.circle([-122.423246,37.779388], 1000)
     |          }).run(conn)
     |  
     |  connect(host='localhost', port=28015, db=None, auth_key='', timeout=20, **kwargs)
     |      r.connect(host="localhost", port=28015, db="test", auth_key="", timeout=20) -> connection
     |      r.connect(host) -> connection
     |      
     |      Create a new connection to the database server. The keyword arguments are:
     |      
     |      - `host`: host of the RethinkDB instance. The default value is `localhost`.
     |      - `port`: the driver port, by default `28015`.
     |      - `db`: the database used if not explicitly specified in a query, by default `test`.
     |      - `auth_key`: the authentication key, by default the empty string.
     |      - `timeout`: timeout period in seconds for the connection to be opened (default `20`).
     |      
     |      If the connection cannot be established, a `RqlDriverError` exception will be thrown.
     |      
     |      The authentication key can be set from the RethinkDB command line tool. Once set, client connections must provide the key as an option to `run` in order to make the connection. For more information, read "Using the RethinkDB authentication system" in the documentation on [securing your cluster](http://rethinkdb.com/docs/security/).
     |      
     |      __Note:__ Currently, the Python driver is not thread-safe. Each thread or multiprocessing PID should be given its own connection object. (This is likely to change in a future release of RethinkDB; you can track issue [#2427](https://github.com/rethinkdb/rethinkdb/issues/2427) for progress.)
     |      
     |      *Example* Opens a connection using the default host and port but specifying the default database.
     |      
     |          conn = r.connect(db='marvel')
     |      
     |      *Example* Opens a new connection to the database.
     |      
     |          conn = r.connect(host = 'localhost',
     |                           port = 28015,
     |                           db = 'heroes',
     |                           auth_key = 'hunter2')
     |  
     |  db(*args)
     |      r.db(db_name) -> db
     |      
     |      Reference a database.
     |      
     |      *Example* Before we can query a table we have to select the correct database.
     |      
     |          r.db('heroes').table('marvel').run(conn)
     |  
     |  db_create(*args)
     |      r.db_create(db_name) -> object
     |      
     |      Create a database. A RethinkDB database is a collection of tables, similar to
     |      relational databases.
     |      
     |      If successful, the command returns an object with two fields:
     |      
     |      * `dbs_created`: always `1`.
     |      * `config_changes`: a list containing one object with two fields, `old_val` and `new_val`:
     |          * `old_val`: always `None`.
     |          * `new_val`: the database's new [config](http://rethinkdb.com/api/python/config) value.
     |      
     |      If a database with the same name already exists, the command throws `RqlRuntimeError`.
     |      
     |      Note: Only alphanumeric characters and underscores are valid for the database name.
     |      
     |      *Example* Create a database named 'superheroes'.
     |      
     |          r.db_create('superheroes').run(conn)
     |          
     |          {
     |              "config_changes": [
     |                  {
     |                      "new_val": {
     |                          "id": "e4689cfc-e903-4532-a0e6-2d6797a43f07",
     |                          "name": "superheroes"
     |                      },
     |                      "old_val": None
     |                  }
     |              ],
     |              "dbs_created": 1
     |          }
     |  
     |  db_drop(*args)
     |      r.db_drop(db_name) -> object
     |      
     |      Drop a database. The database, all its tables, and corresponding data will be deleted.
     |      
     |      If successful, the command returns an object with two fields:
     |      
     |      * `dbs_dropped`: always `1`.
     |      * `tables_dropped`: the number of tables in the dropped database.
     |      * `config_changes`: a list containing one two-field object, `old_val` and `new_val`:
     |          * `old_val`: the database's original [config](http://rethinkdb.com/api/python/config) value.
     |          * `new_val`: always `None`.
     |      
     |      If the given database does not exist, the command throws `RqlRuntimeError`.
     |      
     |      *Example* Drop a database named 'superheroes'.
     |      
     |          r.db_drop('superheroes').run(conn)
     |          
     |          {
     |              "config_changes": [
     |                  {
     |                      "old_val": {
     |                          "id": "e4689cfc-e903-4532-a0e6-2d6797a43f07",
     |                          "name": "superheroes"
     |                      },
     |                      "new_val": None
     |                  }
     |              ],
     |              "tables_dropped": 3,
     |              "dbs_dropped": 1
     |          }
     |  
     |  db_list(*args)
     |      r.db_list() -> array
     |      
     |      List all database names in the system. The result is a list of strings.
     |      
     |      *Example* List all databases.
     |      
     |          r.db_list().run(conn)
     |  
     |  december = <RqlQuery instance: r.december >
     |  desc(*args)
     |  
     |  distance(*args, **kwargs)
     |  
     |  div(*args)
     |      number / number -> number
     |      
     |      Divide two numbers.
     |      
     |      *Example* It's as easy as 2 / 2 = 1.
     |      
     |          (r.expr(2) / 2).run(conn)
     |  
     |  do(*args)
     |  
     |  epoch_time(*args)
     |      r.epoch_time(epoch_time) -> time
     |      
     |      Create a time object based on seconds since epoch. The first argument is a double and
     |      will be rounded to three decimal places (millisecond-precision).
     |      
     |      *Example* Update the birthdate of the user "John" to November 3rd, 1986.
     |      
     |          r.table("user").get("John").update({"birthdate": r.epoch_time(531360000)}).run(conn)
     |  
     |  eq(*args)
     |      # math and logic
     |  
     |  error(*msg)
     |      r.error(message) -> error
     |      
     |      Throw a runtime error. If called with no arguments inside the second argument to `default`, re-throw the current error.
     |      
     |      *Example* Iron Man can't possibly have lost a battle:
     |      
     |          r.table('marvel').get('IronMan').do(
     |              lambda ironman: r.branch(ironman['victories'] < ironman['battles'],
     |                                       r.error('impossible code path'),
     |                                       ironman)
     |          ).run(conn)
     |  
     |  expr(val, nesting_depth=20)
     |      r.expr(value) -> value
     |      
     |      Construct a ReQL JSON object from a native object.
     |      
     |      If the native object is of the `bytes` type, then `expr` will return a binary object. See [binary](http://rethinkdb.com/api/python/binary) for more information.
     |      
     |      *Example* Objects wrapped with expr can then be manipulated by ReQL API functions.
     |      
     |          r.expr({'a':'b'}).merge({'b':[1,2,3]}).run(conn)
     |  
     |  february = <RqlQuery instance: r.february >
     |  friday = <RqlQuery instance: r.friday >
     |  ge(*args)
     |  
     |  geojson(*args)
     |      r.geojson(geojson) -> geometry
     |      
     |      Convert a [GeoJSON][] object to a ReQL geometry object.
     |      
     |      [GeoJSON]: http://geojson.org
     |      
     |      RethinkDB only allows conversion of GeoJSON objects which have ReQL equivalents: Point, LineString, and Polygon. MultiPoint, MultiLineString, and MultiPolygon are not supported. (You could, however, store multiple points, lines and polygons in an array and use a geospatial multi index with them.)
     |      
     |      Only longitude/latitude coordinates are supported. GeoJSON objects that use Cartesian coordinates, specify an altitude, or specify their own coordinate reference system will be rejected.
     |      
     |      *Example* Convert a GeoJSON object to a ReQL geometry object.
     |      
     |          geo_json = {
     |              'type': 'Point',
     |              'coordinates': [ -122.423246, 37.779388 ]
     |          }
     |          r.table('geo').insert({
     |              'id': 'sfo',
     |              'name': 'San Francisco',
     |              'location': r.geojson(geo_json)
     |          }).run(conn)
     |  
     |  gt(*args)
     |  
     |  http(url, **kwargs)
     |      r.http(url[, options]) -> value
     |      r.http(url[, options]) -> stream
     |      
     |      Retrieve data from the specified URL over HTTP.  The return type depends on the `result_format` option, which checks the `Content-Type` of the response by default.
     |      
     |      *Example* Perform an HTTP `GET` and store the result in a table.
     |      
     |          r.table('posts').insert(r.http('http://httpbin.org/get')).run(conn)
     |      
     |      See [the tutorial](http://rethinkdb.com/docs/external-api-access/) on `r.http` for more examples on how to use this command.
     |      
     |      * `timeout`: Number of seconds to wait before timing out and aborting the operation. Default: 30.
     |      
     |      * `reattempts`: An integer giving the number of attempts to make in cast of connection errors or potentially-temporary HTTP errors. Default: 5.
     |      
     |      * `redirects`: An integer giving the number of redirects and location headers to follow. Default: 1.
     |      
     |      * `verify`: Verify the server's SSL certificate, specified as a boolean. Default: True.
     |      
     |      * `result_format`: The format the result should be returned in. The values can be `'text'` (always return as a string), `'json'` (parse the result as JSON, raising an error if the parsing fails), `'jsonp'` (parse the result as [padded JSON](http://www.json-p.org/)), `'binary'` (return a binary object), or `'auto'` . The default is `'auto'`.
     |      
     |          When `result_format` is `'auto'`, the response body will be parsed according to the `Content-Type` of the response:
     |          * `application/json`: parse as `'json'`
     |          * `application/json-p`, `text/json-p`, `text/javascript`: parse as `'jsonp'`
     |          * `audio/*`, `video/*`, `image/*`, `application/octet-stream`: return a binary object
     |          * Anything else: parse as `'text'`
     |      
     |      * `method`: HTTP method to use for the request. One of `GET`, `POST`, `PUT`, `PATCH`, `DELETE` or `HEAD`. Default: `GET`.
     |      
     |      * `auth`: Authentication information in the form of an object with key/value pairs indicating the authentication type (in the `type` key) and any required information. Types currently supported are `basic` and `digest` for HTTP Basic and HTTP Digest authentication respectively. If `type` is omitted, `basic` is assumed. Example:
     |      
     |              ```py
     |              r.http('http://httpbin.org/basic-auth/fred/mxyzptlk',
     |                 auth={ 'type': 'basic', 'user': 'fred', 'pass': 'mxyzptlk' }).run(conn)
     |              ```
     |      
     |      * `params`: URL parameters to append to the URL as encoded key/value pairs, specified as an object. For example, `{ 'query': 'banana', 'limit': 2 }` will be appended as `?query=banana&limit=2`. Default: none.
     |      
     |      * `header`: Extra header lines to include. The value may be an array of strings or an object. Default: none.
     |      
     |          Unless specified otherwise, `r.http` will by default use the headers `Accept-Encoding: deflate=1;gzip=0.5` and `User-Agent: RethinkDB/VERSION`.
     |      
     |      * `data`: Data to send to the server on a `POST`, `PUT`, `PATCH`, or `DELETE` request.
     |      
     |          For `PUT`, `PATCH` and `DELETE` requests, the value will be serialized to JSON and placed in the request body, and the `Content-Type` will be set to `application/json`.
     |      
     |              For `POST` requests, data may be either an object or a string. Objects will be written to the body as form-encoded key/value pairs (values must be numbers, strings, or `None`). Strings will be put directly into the body.  If `data` is not a string or an object, an error will be thrown.
     |      
     |          If `data` is not specified, no data will be sent.
     |      
     |      `r.http` supports depagination, which will request multiple pages in a row and aggregate the results into a stream.  The use of this feature is controlled by the optional arguments `page` and `page_limit`.  Either none or both of these arguments must be provided.
     |      
     |      * `page`: This option may specify either a built-in pagination strategy (as a string), or a function to provide the next URL and/or `params` to request.
     |      
     |          At the moment, the only supported built-in is `'link-next'`, which is equivalent to `lambda info: info['header']['link']['rel="next"'].default(None)`.
     |      
     |          *Example* Perform a GitHub search and collect up to 3 pages of results.
     |      
     |          ```py
     |          r.http("https://api.github.com/search/code?q=addClass+user:mozilla",
     |                 page='link-next', page_limit=3).run(conn)
     |          ```
     |      
     |          As a function, `page` takes one parameter, an object of the format:
     |      
     |          ```py
     |          {
     |              'params': object, # the URL parameters used in the last request
     |              'header': object, # the HTTP headers of the last response as key/value pairs
     |              'body': value # the body of the last response in the format specified by `result_format`
     |          }
     |          ```
     |      
     |          The `header` field will be a parsed version of the header with fields lowercased, like so:
     |      
     |          ```py
     |          {
     |              'content-length': '1024',
     |              'content-type': 'application/json',
     |              'date': 'Thu, 1 Jan 1970 00:00:00 GMT',
     |              'link': {
     |                  'rel="last"': 'http://example.com/?page=34',
     |                  'rel="next"': 'http://example.com/?page=2'
     |              }
     |          }
     |          ```
     |      
     |          The `page` function may return a string corresponding to the next URL to request, `None` indicating that there is no more to get, or an object of the format:
     |      
     |          ```py
     |          {
     |              'url': string, # the next URL to request, or None for no more pages
     |              'params': object # new URL parameters to use, will be merged with the previous request's params
     |          }
     |          ```
     |      
     |      * `page_limit`: An integer specifying the maximum number of requests to issue using the `page` functionality.  This is to prevent overuse of API quotas, and must be specified with `page`.
     |          * `-1`: no limit
     |          * `0`: no requests will be made, an empty stream will be returned
     |          * `n`: `n` requests will be made
     |      
     |      # Examples
     |      
     |      *Example* Perform multiple requests with different parameters.
     |      
     |          r.expr([1, 2, 3]).map(lambda i: r.http('http://httpbin.org/get',
     |                                                 params={ 'user': i })).run(conn)
     |      
     |      *Example* Perform a `PUT` request for each item in a table.
     |      
     |          r.table('data').map(lambda row: r.http('http://httpbin.org/put',
     |                                                 method='PUT', data=row)).run(conn)
     |      
     |      *Example* Perform a `POST` request with accompanying data.
     |      
     |      Using form-encoded data:
     |      
     |          r.http('http://httpbin.org/post',
     |                 method='POST',
     |                 data={ 'player': 'Bob', 'game': 'tic tac toe' }).run(conn)
     |      
     |      Using JSON data:
     |      
     |          r.http('http://httpbin.org/post',
     |                 method='POST',
     |                 data=r.expr(value).coerce_to('string'),
     |                 header={ 'Content-Type': 'application/json' }).run(conn)
     |      
     |      *Example* Perform depagination with a custom `page` function.
     |      
     |          r.http('example.com/pages',
     |                 page=lambda info: info['body']['meta']['next'].default(None),
     |                 page_limit=5).run(conn)
     |      
     |      # Learn more
     |      
     |      See [the tutorial](http://rethinkdb.com/docs/external-api-access/) on `r.http` for more examples on how to use this command.
     |  
     |  info(*args)
     |  
     |  intersects(*args)
     |  
     |  iso8601(*args, **kwargs)
     |      r.iso8601(iso8601Date[, default_timezone='']) -> time
     |      
     |      Create a time object based on an ISO 8601 date-time string (e.g. '2013-01-01T01:01:01+00:00'). We support all valid ISO 8601 formats except for week dates. If you pass an ISO 8601 date-time without a time zone, you must specify the time zone with the `default_timezone` argument. Read more about the ISO 8601 format at [Wikipedia](http://en.wikipedia.org/wiki/ISO_8601).
     |      
     |      *Example* Update the time of John's birth.
     |      
     |          r.table("user").get("John").update({"birth": r.iso8601('1986-11-03T08:30:00-07:00')}).run(conn)
     |  
     |  january = <RqlQuery instance: r.january >
     |  js(*args, **kwargs)
     |      r.js(js_string[, timeout=<number>]) -> value
     |      
     |      Create a javascript expression.
     |      
     |      *Example* Concatenate two strings using JavaScript.
     |      
     |      `timeout` is the number of seconds before `r.js` times out. The default value is 5 seconds.
     |      
     |      {% infobox %}
     |      Whenever possible, you should use native ReQL commands rather than `r.js` for better performance.
     |      {% endinfobox %}
     |      
     |          r.js("'str1' + 'str2'").run(conn)
     |      
     |      *Example* Select all documents where the 'magazines' field is greater than 5 by running JavaScript on the server.
     |      
     |          r.table('marvel').filter(
     |              r.js('(function (row) { return row.magazines.length > 5; })')
     |          ).run(conn)
     |      
     |      *Example* You may also specify a timeout in seconds (defaults to 5).
     |      
     |          r.js('while(true) {}', timeout=1.3).run(conn)
     |  
     |  json(*args)
     |      r.json(json_string) -> value
     |      
     |      Parse a JSON string on the server.
     |      
     |      *Example* Send an array to the server'
     |      
     |          r.json("[1,2,3]").run(conn)
     |  
     |  july = <RqlQuery instance: r.july >
     |  june = <RqlQuery instance: r.june >
     |  le(*args)
     |  
     |  line(*args)
     |      r.line([lon1, lat1], [lon2, lat2], ...) -> line
     |      r.line(point1, point2, ...) -> line
     |      
     |      Construct a geometry object of type Line. The line can be specified in one of two ways:
     |      
     |      * Two or more two-item arrays, specifying latitude and longitude numbers of the line's vertices;
     |      * Two or more [Point](http://rethinkdb.com/api/python/point) objects specifying the line's vertices.
     |      
     |      Longitude (&minus;180 to 180) and latitude (&minus;90 to 90) of vertices are plotted on a perfect sphere. See [Geospatial support](http://rethinkdb.com/docs/geo-support/) for more information on ReQL's coordinate system.
     |      
     |      *Example* Define a line.
     |      
     |          r.table('geo').insert({
     |              'id': 101,
     |              'route': r.line([-122.423246,37.779388], [-121.886420,37.329898])
     |          }).run(conn)
     |  
     |  literal(*args)
     |      r.literal(object) -> special
     |      
     |      Replace an object in a field instead of merging it with an existing object in a `merge` or `update` operation. = Using `literal` with no arguments in a `merge` or `update` operation will remove the corresponding field.
     |      
     |      *Example* Replace one nested document with another rather than merging the fields.
     |      
     |      Assume your users table has this structure:
     |      
     |          [
     |              {
     |                  "id": 1,
     |                  "name": "Alice",
     |                  "data": {
     |                      "age": 18,
     |                      "city": "Dallas"
     |                  }
     |              }       
     |              ...
     |          ]
     |      
     |      Using `update` to modify the `data` field will normally merge the nested documents:
     |      
     |          r.table('users').get(1).update({ 'data': { 'age': 19, 'job': 'Engineer' } }).run(conn)
     |          
     |          {
     |              "id": 1,
     |              "name": "Alice",
     |              "data": {
     |                  "age": 19,
     |                  "city": "Dallas",
     |                  "job": "Engineer"
     |              }
     |          }       
     |      
     |      That will preserve `city` and other existing fields. But to replace the entire `data` document with a new object, use `literal`:
     |      
     |          r.table('users').get(1).update({ 'data': r.literal({ 'age': 19, 'job': 'Engineer' }) }).run(conn)
     |          
     |          {
     |              "id": 1,
     |              "name": "Alice",
     |              "data": {
     |                  "age": 19,
     |                  "job": "Engineer"
     |              }
     |          }       
     |      
     |      *Example* Use `literal` to remove a field from a document.
     |      
     |          r.table('users').get(1).merge({ "data": r.literal() }).run(conn)
     |          
     |          {
     |              "id": 1,
     |              "name": "Alice"
     |          }
     |  
     |  lt(*args)
     |  
     |  make_timezone(*args)
     |  
     |  map(*args)
     |  
     |  march = <RqlQuery instance: r.march >
     |  maxval = <RqlQuery instance: r.maxval >
     |  may = <RqlQuery instance: r.may >
     |  minval = <RqlQuery instance: r.minval >
     |  mod(*args)
     |      number % number -> number
     |      
     |      Find the remainder when dividing two numbers.
     |      
     |      *Example* It's as easy as 2 % 2 = 0.
     |      
     |          (r.expr(2) % 2).run(conn)
     |      
     |      `
     |  
     |  monday = <RqlQuery instance: r.monday >
     |  mul(*args)
     |      number * number -> number
     |      array * number -> array
     |      
     |      Multiply two numbers, or make a periodic array.
     |      
     |      *Example* It's as easy as 2 * 2 = 4.
     |      
     |          (r.expr(2) * 2).run(conn)
     |      
     |      *Example* Arrays can be multiplied by numbers as well.
     |      
     |          (r.expr(["This", "is", "the", "song", "that", "never", "ends."]) * 100).run(conn)
     |  
     |  ne(*args)
     |  
     |  not_(*args)
     |      bool.not_() -> bool
     |      not_(bool) -> bool
     |      (~bool) -> bool
     |      
     |      Compute the logical inverse (not) of an expression.
     |      
     |      `not_` can be called either via method chaining, immediately after an expression that evaluates as a boolean value, or by passing the expression as a parameter to `not_`.  All values that are not `False` or `None` will be converted to `True`.
     |      
     |      You may also use `~` as a shorthand operator.
     |      
     |      *Example* Not true is false.
     |      
     |          r.not_(True).run(conn)
     |          r.expr(True).not_().run(conn)
     |          (~r.expr(True)).run(conn)
     |      
     |      These evaluate to `false`.
     |      
     |      Note that when using `~` the expression is wrapped in parentheses. Without this, Python will evaluate `r.expr(True)` *first* rather than using the ReQL operator and return an incorrect value. (`~True` evaluates to &minus;2 in Python.)
     |      
     |      *Example* Return all the users that do not have a "flag" field.
     |      
     |          r.table('users').filter(
     |              lambda users: (~users.has_fields('flag'))
     |          ).run(conn)
     |      
     |      *Example* As above, but prefix-style.
     |      
     |          r.table('users').filter(
     |              lambda users: r.not_(users.has_fields('flag'))
     |          ).run(conn)
     |  
     |  november = <RqlQuery instance: r.november >
     |  now(*args)
     |      r.now() -> time
     |      
     |      Return a time object representing the current time in UTC. The command now() is computed once when the server receives the query, so multiple instances of r.now() will always return the same time inside a query.
     |      
     |      *Example* Add a new user with the time at which he subscribed.
     |      
     |          r.table("users").insert({
     |              "name": "John",
     |              "subscription_date": r.now()
     |          }).run(conn)
     |  
     |  object(*args)
     |      r.object([key, value,]...) -> object
     |      
     |      Creates an object from a list of key-value pairs, where the keys must
     |      be strings.  `r.object(A, B, C, D)` is equivalent to
     |      `r.expr([[A, B], [C, D]]).coerce_to('OBJECT')`.
     |      
     |      *Example* Create a simple object.
     |      
     |          > r.object('id', 5, 'data', ['foo', 'bar']).run(conn)
     |          {'data': ["foo", "bar"], 'id': 5}
     |  
     |  october = <RqlQuery instance: r.october >
     |  or_(*args)
     |      bool | bool -> bool
     |      bool.or_(bool[, bool, ...]) -> bool
     |      r.or_(bool, bool) -> bool
     |      
     |      Compute the logical "or" of two or more values. The `or_` command can be used as an infix operator after its first argument (`r.expr(True).or_(False)`) or given all of its arguments as parameters (`r.or_(True, False)`). The standard Python or operator, `|`, may also be used with ReQL.
     |      
     |      *Example* Return whether either `a` or `b` evaluate to true.
     |      
     |          > a = True
     |          > b = False
     |          > (r.expr(a) | b).run(conn)
     |          
     |          True
     |      
     |      *Example* Return whether any of `x`, `y` or `z` evaluate to true.
     |      
     |          > x = False
     |          > y = False
     |          > z = False
     |          > r.or_(x, y, z).run(conn)
     |          
     |          False
     |      
     |      __Note:__ When using `or` inside a `filter` predicate to test the values of fields that may not exist on the documents being tested, you should use the `default` command with those fields so they explicitly return `False`.
     |      
     |          r.table('posts').filter(lambda post:
     |              post['category'].default('foo').eq('article').or(
     |                  post['genre'].default('foo').eq('mystery'))
     |          ).run(conn)
     |  
     |  point(*args)
     |      r.point(longitude, latitude) -> point
     |      
     |      Construct a geometry object of type Point. The point is specified by two floating point numbers, the longitude (&minus;180 to 180) and latitude (&minus;90 to 90) of the point on a perfect sphere. See [Geospatial support](http://rethinkdb.com/docs/geo-support/) for more information on ReQL's coordinate system.
     |      
     |      *Example* Define a point.
     |      
     |          r.table('geo').insert({
     |              'id': 1,
     |              'name': 'San Francisco',
     |              'location': r.point(-122.423246,37.779388)
     |          }).run(conn)
     |  
     |  polygon(*args)
     |      r.polygon([lon1, lat1], [lon2, lat2], ...) -> polygon
     |      r.polygon(point1, point2, ...) -> polygon
     |      
     |      Construct a geometry object of type Polygon. The Polygon can be specified in one of two ways:
     |      
     |      * Three or more two-item arrays, specifying latitude and longitude numbers of the polygon's vertices;
     |      * Three or more [Point](http://rethinkdb.com/api/python/point) objects specifying the polygon's vertices.
     |      
     |      Longitude (&minus;180 to 180) and latitude (&minus;90 to 90) of vertices are plotted on a perfect sphere. See [Geospatial support](http://rethinkdb.com/docs/geo-support/) for more information on ReQL's coordinate system.
     |      
     |      If the last point does not specify the same coordinates as the first point, `polygon` will close the polygon by connecting them. You cannot directly construct a polygon with holes in it using `polygon`, but you can use [polygon_sub](http://rethinkdb.com/api/python/polygon_sub) to use a second polygon within the interior of the first to define a hole.
     |      
     |      *Example* Define a polygon.
     |      
     |          r.table('geo').insert({
     |              'id': 101,
     |              'rectangle': r.polygon(
     |                  [-122.423246,37.779388],
     |                  [-122.423246,37.329898],
     |                  [-121.886420,37.329898],
     |                  [-121.886420,37.779388]
     |              )
     |          }).run(conn)
     |  
     |  random(*args, **kwargs)
     |      r.random() -> number
     |      r.random(number[, number], float=True) -> number
     |      r.random(integer[, integer]) -> integer
     |      
     |      Generate a random number between given (or implied) bounds. `random` takes zero, one or two arguments.
     |      
     |      - With __zero__ arguments, the result will be a floating-point number in the range `[0,1)` (from 0 up to but not including 1).
     |      - With __one__ argument _x,_ the result will be in the range `[0,x)`, and will be integer unless `float=True` is given as an option. Specifying a floating point number without the `float` option will raise an error.
     |      - With __two__ arguments _x_ and _y,_ the result will be in the range `[x,y)`, and will be integer unless `float=True` is given as an option.  If _x_ and _y_ are equal an error will occur, unless the floating-point option has been specified, in which case _x_ will be returned. Specifying a floating point number without the `float` option will raise an error.
     |      
     |      Note: The last argument given will always be the 'open' side of the range, but when
     |      generating a floating-point number, the 'open' side may be less than the 'closed' side.
     |      
     |      *Example* Generate a random number in the range `[0,1)`
     |      
     |          r.random().run(conn)
     |      
     |      *Example* Generate a random integer in the range `[0,100)`
     |      
     |          r.random(100).run(conn)
     |          r.random(0, 100).run(conn)
     |      
     |      *Example* Generate a random number in the range `(-2.24,1.59]`
     |      
     |          r.random(1.59, -2.24, float=True).run(conn)
     |  
     |  range(*args)
     |      r.range() -> stream
     |      r.range([start_value, ]end_value) -> stream
     |      
     |      Generate a stream of sequential integers in a specified range. `range` takes 0, 1 or 2 arguments:
     |      
     |      * With no arguments, `range` returns an "infinite" stream from 0 up to and including the maximum integer value;
     |      * With one argument, `range` returns a stream from 0 up to but not including the end value;
     |      * With two arguments, `range` returns a stream from the start value up to but not including the end value.
     |      
     |      Note that the left bound (including the implied left bound of 0 in the 0- and 1-argument form) is always closed and the right bound is always open: the start value will always be included in the returned range and the end value will *not* be included in the returned range.
     |      
     |      Any specified arguments must be integers, or a `RqlRuntimeError` will be thrown. If the start value is equal or to higher than the end value, no error will be thrown but a zero-element stream will be returned.
     |      
     |      *Example* Return a four-element range of `[0, 1, 2, 3]`.
     |      
     |          > r.range(4).run(conn)
     |          
     |          [0, 1, 2, 3]
     |      
     |      You can also use the [limit](http://rethinkdb.com/api/python/limit) command with the no-argument variant to achieve the same result in this case:
     |      
     |          > r.range().limit(4).run(conn)
     |          
     |          [0, 1, 2, 3]
     |      
     |      *Example* Return a range from -5 through 5.
     |      
     |          > r.range(-5, 6).run(conn)
     |          
     |          [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]
     |  
     |  rebalance(*args, **kwargs)
     |  
     |  reconfigure(*args, **kwargs)
     |  
     |  row = <RqlQuery instance: r.row >
     |  saturday = <RqlQuery instance: r.saturday >
     |  september = <RqlQuery instance: r.september >
     |  set_loop_type(library)
     |  
     |  sub(*args)
     |      number - number -> number
     |      time - time -> number
     |      time - number -> time
     |      
     |      Subtract two numbers.
     |      
     |      *Example* It's as easy as 2 - 2 = 0.
     |      
     |          (r.expr(2) - 2).run(conn)
     |      
     |      *Example* Create a date one year ago today.
     |      
     |          r.now() - 365*24*60*60
     |      
     |      *Example* Retrieve how many seconds elapsed between today and date
     |      
     |          r.now() - date
     |  
     |  sunday = <RqlQuery instance: r.sunday >
     |  table(*args, **kwargs)
     |  
     |  table_create(*args, **kwargs)
     |  
     |  table_drop(*args)
     |  
     |  table_list(*args)
     |  
     |  thursday = <RqlQuery instance: r.thursday >
     |  time(*args)
     |      r.time(year, month, day[, hour, minute, second], timezone)
     |          -> time
     |      
     |      Create a time object for a specific time.
     |      
     |      A few restrictions exist on the arguments:
     |      
     |      - `year` is an integer between 1400 and 9,999.
     |      - `month` is an integer between 1 and 12.
     |      - `day` is an integer between 1 and 31.
     |      - `hour` is an integer.
     |      - `minutes` is an integer.
     |      - `seconds` is a double. Its value will be rounded to three decimal places
     |      (millisecond-precision).
     |      - `timezone` can be `'Z'` (for UTC) or a string with the format `±[hh]:[mm]`.
     |      
     |      *Example* Update the birthdate of the user "John" to November 3rd, 1986 UTC.
     |      
     |          r.table("user").get("John").update({"birthdate": r.time(1986, 11, 3, 'Z')}).run(conn)
     |  
     |  tuesday = <RqlQuery instance: r.tuesday >
     |  type_of(*args)
     |  
     |  uuid(*args)
     |      r.uuid() -> string
     |      
     |      Return a UUID (universally unique identifier), a string that can be used as a unique ID.
     |      
     |      *Example* Generate a UUID.
     |      
     |          > r.uuid().run(conn)
     |          
     |          27961a0e-f4e8-4eb3-bf95-c5203e1d87b9
     |  
     |  wait(*args, **kwargs)
     |  
     |  wednesday = <RqlQuery instance: r.wednesday >
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

DATA
    __all__ = ['r', 'rethinkdb', 'RqlError', 'RqlClientError', 'RqlCompile...


Help on Datum in module rethinkdb.ast object:

class Datum(RqlQuery)
 |  # This class handles the conversion of RQL terminal types in both directions
 |  # Going to the server though it does not support R_ARRAY or R_OBJECT as those
 |  # are alternately handled by the MakeArray and MakeObject nodes. Why do this?
 |  # MakeArray and MakeObject are more flexible, allowing us to construct array
 |  # and object expressions from nested RQL expressions. Constructing pure
 |  # R_ARRAYs and R_OBJECTs would require verifying that at all nested levels
 |  # our arrays and objects are composed only of basic types.
 |  
 |  Method resolution order:
 |      Datum
 |      RqlQuery
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, val)
 |  
 |  build(self)
 |  
 |  compose(self, args, optargs)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  args = []
 |  
 |  optargs = {}
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from RqlQuery:
 |  
 |  __add__(self, other)
 |      number + number -> number
 |      string + string -> string
 |      array + array -> array
 |      time + number -> time
 |      
 |      Sum two numbers, concatenate two strings, or concatenate 2 arrays.
 |      
 |      *Example* It's as easy as 2 + 2 = 4.
 |      
 |          > (r.expr(2) + 2).run(conn)
 |          
 |          4
 |      
 |      *Example* Strings can be concatenated too.
 |      
 |          > (r.expr("foo") + "bar").run(conn)
 |          
 |          "foobar"
 |      
 |      *Example* Arrays can be concatenated too.
 |      
 |          > (r.expr(["foo", "bar"]) + ["buzz"]).run(conn)
 |          
 |          ['foo', 'bar', 'buzz']
 |      
 |      *Example* Create a date one year from now.
 |      
 |          r.now() + 365*24*60*60
 |      
 |      *Example* Use [args](http://rethinkdb.com/api/python/args) with `add` to sum multiple values.
 |      
 |          > r.add(r.args([10, 20, 30])).run(conn)
 |          
 |          60
 |      
 |      *Example* Concatenate an array of strings with `args`.
 |      
 |          > r.add(r.args(['foo', 'bar', 'buzz'])).run(conn)
 |          
 |          "foobarbuzz"
 |  
 |  __and__(self, other)
 |      bool & bool -> bool
 |      r.and_(bool, bool) -> bool
 |      bool.and_(bool) -> bool
 |      
 |      Compute the logical "and" of two or more values. The `and_` command can be used as an infix operator after its first argument (`r.expr(True).and_(False)`) or given all of its arguments as parameters (`r.and_(True, False)`). The standard Python and operator, `&`, may also be used with ReQL.
 |      
 |      *Example* Return whether both `a` and `b` evaluate to true.
 |      
 |          > a = True
 |          > b = False
 |          > (r.expr(a) & b).run(conn)
 |          
 |          False
 |      *Example* Return whether all of `x`, `y` and `z` evaluate to true.
 |      
 |          > x = True
 |          > y = True
 |          > z = True
 |          > r.and_(x, y, z).run(conn)
 |          
 |          True
 |  
 |  __div__(self, other)
 |      number / number -> number
 |      
 |      Divide two numbers.
 |      
 |      *Example* It's as easy as 2 / 2 = 1.
 |      
 |          (r.expr(2) / 2).run(conn)
 |  
 |  __eq__(self, other)
 |      value == value -> bool
 |      value.eq(value) -> bool
 |      
 |      Test if two values are equal.
 |      
 |      *Example* Does 2 equal 2?
 |      
 |          (r.expr(2) == 2).run(conn)
 |          r.expr(2).eq(2).run(conn)
 |  
 |  __ge__(self, other)
 |      value >= value -> bool
 |      value.ge(value) -> bool
 |      
 |      Test if the first value is greater than or equal to other.
 |      
 |      *Example* Is 2 greater than or equal to 2?
 |      
 |          (r.expr(2) >= 2).run(conn)
 |          r.expr(2).ge(2).run(conn)
 |  
 |  __getitem__(self, index)
 |      sequence[attr] -> sequence
 |      singleSelection[attr] -> value
 |      object[attr] -> value
 |      array[index] -> value
 |      
 |      Get a single field from an object. If called on a sequence, gets that field from every object in the sequence, skipping objects that lack it.
 |      
 |      *Example* What was Iron Man's first appearance in a comic?
 |      
 |          r.table('marvel').get('IronMan')['firstAppearance'].run(conn)
 |      
 |      The `[]` command also accepts integer arguments as array offsets, like the [nth](http://rethinkdb.com/api/python/nth) command.
 |      
 |      *Example* Get the fourth element in a sequence. (The first element is position `0`, so the fourth element is position `3`.)
 |      
 |          r.expr([10, 20, 30, 40, 50])[3]
 |          
 |          40
 |  
 |  __gt__(self, other)
 |      value > value -> bool
 |      value.gt(value) -> bool
 |      
 |      Test if the first value is greater than other.
 |      
 |      *Example* Is 2 greater than 2?
 |      
 |          (r.expr(2) > 2).run(conn)
 |          r.expr(2).gt(2).run(conn)
 |  
 |  __invert__(self)
 |      bool.not_() -> bool
 |      not_(bool) -> bool
 |      (~bool) -> bool
 |      
 |      Compute the logical inverse (not) of an expression.
 |      
 |      `not_` can be called either via method chaining, immediately after an expression that evaluates as a boolean value, or by passing the expression as a parameter to `not_`.  All values that are not `False` or `None` will be converted to `True`.
 |      
 |      You may also use `~` as a shorthand operator.
 |      
 |      *Example* Not true is false.
 |      
 |          r.not_(True).run(conn)
 |          r.expr(True).not_().run(conn)
 |          (~r.expr(True)).run(conn)
 |      
 |      These evaluate to `false`.
 |      
 |      Note that when using `~` the expression is wrapped in parentheses. Without this, Python will evaluate `r.expr(True)` *first* rather than using the ReQL operator and return an incorrect value. (`~True` evaluates to &minus;2 in Python.)
 |      
 |      *Example* Return all the users that do not have a "flag" field.
 |      
 |          r.table('users').filter(
 |              lambda users: (~users.has_fields('flag'))
 |          ).run(conn)
 |      
 |      *Example* As above, but prefix-style.
 |      
 |          r.table('users').filter(
 |              lambda users: r.not_(users.has_fields('flag'))
 |          ).run(conn)
 |  
 |  __iter__(*args, **kwargs)
 |  
 |  __le__(self, other)
 |      value <= value -> bool
 |      value.le(value) -> bool
 |      
 |      Test if the first value is less than or equal to other.
 |      
 |      *Example* Is 2 less than or equal to 2?
 |      
 |          (r.expr(2) <= 2).run(conn)
 |          r.expr(2).le(2).run(conn)
 |  
 |  __lt__(self, other)
 |      value < value -> bool
 |      value.lt(value) -> bool
 |      
 |      Test if the first value is less than other.
 |      
 |      *Example* Is 2 less than 2?
 |      
 |          (r.expr(2) < 2).run(conn)
 |          r.expr(2).lt(2).run(conn)
 |  
 |  __mod__(self, other)
 |      number % number -> number
 |      
 |      Find the remainder when dividing two numbers.
 |      
 |      *Example* It's as easy as 2 % 2 = 0.
 |      
 |          (r.expr(2) % 2).run(conn)
 |      
 |      `
 |  
 |  __mul__(self, other)
 |      number * number -> number
 |      array * number -> array
 |      
 |      Multiply two numbers, or make a periodic array.
 |      
 |      *Example* It's as easy as 2 * 2 = 4.
 |      
 |          (r.expr(2) * 2).run(conn)
 |      
 |      *Example* Arrays can be multiplied by numbers as well.
 |      
 |          (r.expr(["This", "is", "the", "song", "that", "never", "ends."]) * 100).run(conn)
 |  
 |  __ne__(self, other)
 |      value != value -> bool
 |      value.ne(value) -> bool
 |      
 |      Test if two values are not equal.
 |      
 |      *Example* Does 2 not equal 2?
 |      
 |          (r.expr(2) != 2).run(conn)
 |          r.expr(2).ne(2).run(conn)
 |  
 |  __or__(self, other)
 |      bool | bool -> bool
 |      bool.or_(bool[, bool, ...]) -> bool
 |      r.or_(bool, bool) -> bool
 |      
 |      Compute the logical "or" of two or more values. The `or_` command can be used as an infix operator after its first argument (`r.expr(True).or_(False)`) or given all of its arguments as parameters (`r.or_(True, False)`). The standard Python or operator, `|`, may also be used with ReQL.
 |      
 |      *Example* Return whether either `a` or `b` evaluate to true.
 |      
 |          > a = True
 |          > b = False
 |          > (r.expr(a) | b).run(conn)
 |          
 |          True
 |      
 |      *Example* Return whether any of `x`, `y` or `z` evaluate to true.
 |      
 |          > x = False
 |          > y = False
 |          > z = False
 |          > r.or_(x, y, z).run(conn)
 |          
 |          False
 |      
 |      __Note:__ When using `or` inside a `filter` predicate to test the values of fields that may not exist on the documents being tested, you should use the `default` command with those fields so they explicitly return `False`.
 |      
 |          r.table('posts').filter(lambda post:
 |              post['category'].default('foo').eq('article').or(
 |                  post['genre'].default('foo').eq('mystery'))
 |          ).run(conn)
 |  
 |  __radd__(self, other)
 |  
 |  __rand__(self, other)
 |  
 |  __rdiv__(self, other)
 |  
 |  __repr__(self)
 |  
 |  __rmod__(self, other)
 |  
 |  __rmul__(self, other)
 |  
 |  __ror__(self, other)
 |  
 |  __rsub__(self, other)
 |  
 |  __rtruediv__(self, other)
 |  
 |  __str__(self)
 |  
 |  __sub__(self, other)
 |      number - number -> number
 |      time - time -> number
 |      time - number -> time
 |      
 |      Subtract two numbers.
 |      
 |      *Example* It's as easy as 2 - 2 = 0.
 |      
 |          (r.expr(2) - 2).run(conn)
 |      
 |      *Example* Create a date one year ago today.
 |      
 |          r.now() - 365*24*60*60
 |      
 |      *Example* Retrieve how many seconds elapsed between today and date
 |      
 |          r.now() - date
 |  
 |  __truediv__(self, other)
 |  
 |  add(self, *args)
 |  
 |  and_(self, *args)
 |  
 |  append(self, *args)
 |      array.append(value) -> array
 |      
 |      Append a value to an array.
 |      
 |      *Example* Retrieve Iron Man's equipment list with the addition of some new boots.
 |      
 |          r.table('marvel').get('IronMan')['equipment'].append('newBoots').run(conn)
 |  
 |  avg(self, *args)
 |      sequence.avg([field_or_function]) -> number
 |      
 |      Averages all the elements of a sequence.  If called with a field name,
 |      averages all the values of that field in the sequence, skipping
 |      elements of the sequence that lack that field.  If called with a
 |      function, calls that function on every element of the sequence and
 |      averages the results, skipping elements of the sequence where that
 |      function returns `None` or a non-existence error.
 |      
 |      Produces a non-existence error when called on an empty sequence.  You
 |      can handle this case with `default`.
 |      
 |      *Example* What's the average of 3, 5, and 7?
 |      
 |          r.expr([3, 5, 7]).avg().run(conn)
 |      
 |      *Example* What's the average number of points scored in a game?
 |      
 |          r.table('games').avg('points').run(conn)
 |      
 |      *Example* What's the average number of points scored in a game,
 |      counting bonus points?
 |      
 |          r.table('games').avg(lambda game:
 |              game['points'] + game['bonus_points']
 |          ).run(conn)
 |      
 |      *Example* What's the average number of points scored in a game?
 |      (But return `None` instead of raising an error if there are no games where
 |      points have been scored.)
 |      
 |          r.table('games').avg('points').default(None).run(conn)
 |  
 |  between(self, *args, **kwargs)
 |      table.between(lower_key, upper_key[, index='id', left_bound='closed', right_bound='open'])
 |          -> selection
 |      
 |      Get all documents between two keys. Accepts three optional arguments: `index`, `left_bound`, and `right_bound`. If `index` is set to the name of a secondary index, `between` will return all documents where that index's value is in the specified range (it uses the primary key by default). `left_bound` or `right_bound` may be set to `open` or `closed` to indicate whether or not to include that endpoint of the range (by default, `left_bound` is closed and `right_bound` is open).
 |      
 |      You may also use the special constants `r.minval` and `r.maxval` for boundaries, which represent "less than any index key" and "more than any index key" respectively. For instance, if you use `r.minval` as the lower key, then `between` will return all documents whose primary keys (or indexes) are less than the specified upper key.
 |      
 |      Note that compound indexes are sorted using [lexicographical order][lo]. Take the following range as an example:
 |      
 |              [[1, "c"] ... [5, "e"]]
 |      
 |      This range includes all compound keys:
 |      
 |      * whose first item is 1 and second item is equal or greater than "c";
 |      * whose first item is between 1 and 5, *regardless of the value of the second item*;
 |      * whose first item is 5 and second item is less than or equal to "e".
 |      
 |      [lo]: https://en.wikipedia.org/wiki/Lexicographical_order
 |      
 |      *Example* Find all users with primary key >= 10 and < 20 (a normal half-open interval).
 |      
 |          r.table('marvel').between(10, 20).run(conn)
 |      
 |      *Example* Find all users with primary key >= 10 and <= 20 (an interval closed on both sides).
 |      
 |          r.table('marvel').between(10, 20, right_bound='closed').run(conn)
 |      
 |      *Example* Find all users with primary key < 20.
 |      
 |          r.table('marvel').between(r.minval, 20).run(conn)
 |      
 |      *Example* Find all users with primary key > 10.
 |      
 |          r.table('marvel').between(10, r.maxval, left_bound='open').run(conn)
 |      
 |      *Example* Between can be used on secondary indexes too. Just pass an optional index argument giving the secondary index to query.
 |      
 |          r.table('dc').between('dark_knight', 'man_of_steel', index='code_name').run(conn)
 |      
 |      *Example* Get all users whose full name is between "John Smith" and "Wade Welles."
 |      
 |          r.table("users").between(["Smith", "John"], ["Welles", "Wade"],
 |              index="full_name").run(conn)
 |      
 |      *Example* Subscribe to a [changefeed](http://rethinkdb.com/docs/changefeeds/javascript) of teams ranked in the top 10.
 |      
 |          changes = r.table("teams").between(1, 11, index="rank").changes().run(conn)
 |      
 |      __Note:__ Between works with secondary indexes on date fields, but will not work with unindexed date fields. To test whether a date value is between two other dates, use the [during](http://rethinkdb.com/api/python/during) command, not `between`.
 |      
 |      Secondary indexes can be used in extremely powerful ways with `between` and other commands; read the full article on [secondary indexes](http://rethinkdb.com/docs/secondary-indexes) for examples using boolean operations, `contains` and more.
 |      
 |      __Note:__ RethinkDB uses byte-wise ordering for `between` and does not support Unicode collations; non-ASCII characters will be sorted by UTF-8 codepoint.
 |  
 |  change_at(self, *args)
 |      array.change_at(index, value) -> array
 |      
 |      Change a value in an array at a given index. Returns the modified array.
 |      
 |      *Example* Bruce Banner hulks out.
 |      
 |          r.expr(["Iron Man", "Bruce", "Spider-Man"]).change_at(1, "Hulk").run(conn)
 |  
 |  changes(self, *args, **kwargs)
 |      table.changes(squash=True, include_states=False) -> stream
 |      singleSelection.changes(squash=True, include_states=False) -> stream
 |      
 |      Return an infinite stream of objects representing changes to a query.
 |      
 |      The `squash` optional argument controls how `changes` batches change notifications:
 |      
 |      * `True`: When multiple changes to the same document occur before a batch of notifications is sent, the changes are "squashed" into one change. The client receives a notification that will bring it fully up to date with the server. This is the default.
 |      * `False`: All changes will be sent to the client verbatim.
 |      * `n`: A numeric value (floating point). Similar to `True`, but the server will wait `n` seconds to respond in order to squash as many changes together as possible, reducing network traffic.
 |      
 |      If the `include_states` optional argument is `True`, the changefeed stream will include special status documents consisting of the field `state` and a string indicating a change in the feed's state. These documents can occur at any point in the feed between the notification documents described below. There are currently two states:
 |      
 |      * `{"state": "initializing"}` indicates the following documents represent initial values on the feed rather than changes. This will be the first document of a feed that returns initial values.
 |      * `{"state": "ready"}` indicates the following documents represent changes. This will be the first document of a feed that does *not* return initial values; otherwise, it will indicate the initial values have all been sent.
 |      
 |      If `include_states` is `False` (the default), the status documents will not be sent on the feed.
 |      
 |      If the table becomes unavailable, the changefeed will be disconnected, and a runtime exception will be thrown by the driver.
 |      
 |      Changefeed notifications take the form of a two-field object:
 |      
 |          {
 |              "old_val": <document before change>,
 |              "new_val": <document after change>
 |          }
 |      
 |      The first notification object in the changefeed stream will contain the query's initial value in `new_val` and have no `old_val` field. When a document is deleted, `new_val` will be `None`; when a document is inserted, `old_val` will be `None`.
 |      
 |      Certain document transformation commands can be chained before changefeeds. For more information, read the [discussion of changefeeds](http://rethinkdb.com/docs/changefeeds/python/) in the "Query language" documentation.
 |      
 |      The server will buffer up to 100,000 elements. If the buffer limit is hit, early changes will be discarded, and the client will receive an object of the form `{"error": "Changefeed cache over array size limit, skipped X elements."}` where `X` is the number of elements skipped.
 |      
 |      Commands that operate on streams (such as `filter` or `map`) can usually be chained after `changes`.  However, since the stream produced by `changes` has no ending, commands that need to consume the entire stream before returning (such as `reduce` or `count`) cannot.
 |      
 |      It's a good idea to open changefeeds on their own connection. If you don't, other queries run on the same connection will experience unpredictable latency spikes while the connection blocks on more changes.
 |      
 |      *Example* Subscribe to the changes on a table.
 |      
 |      Start monitoring the changefeed in one client:
 |      
 |          for change in r.table('games').changes().run(conn):
 |            print change
 |      
 |      As these queries are performed in a second client, the first client would receive and print the following objects:
 |      
 |          > r.table('games').insert({'id': 1}).run(conn)
 |          {'old_val': None, 'new_val': {'id': 1}}
 |          
 |          > r.table('games').get(1).update({'player1': 'Bob'}).run(conn)
 |          {'old_val': {'id': 1}, 'new_val': {'id': 1, 'player1': 'Bob'}}
 |          
 |          > r.table('games').get(1).replace({'id': 1, 'player1': 'Bob', 'player2': 'Alice'}).run(conn)
 |          {'old_val': {'id': 1, 'player1': 'Bob'},
 |           'new_val': {'id': 1, 'player1': 'Bob', 'player2': 'Alice'}}
 |          
 |          > r.table('games').get(1).delete().run(conn)
 |          {'old_val': {'id': 1, 'player1': 'Bob', 'player2': 'Alice'}, 'new_val': None}
 |          
 |          > r.table_drop('games').run(conn)
 |          RqlRuntimeError: Changefeed aborted (table unavailable)
 |      
 |      *Example* Return all the changes that increase a player's score.
 |      
 |          r.table('test').changes().filter(
 |            r.row['new_val']['score'] > r.row['old_val']['score']
 |          ).run(conn)
 |      
 |      *Example* Return all the changes to Bob's score.
 |      
 |          # Note that this will have to look at and discard all the changes to
 |          # rows besides Bob's.  This is currently no way to filter with an index
 |          # on changefeeds.
 |          r.table('test').changes().filter(r.row['new_val']['name'].eq('Bob')).run(conn)
 |      
 |      *Example* Return all the inserts on a table.
 |      
 |          r.table('test').changes().filter(r.row['old_val'].eq(None)).run(conn)
 |      
 |      *Example* Return all the changes to game 1.
 |      
 |          r.table('games').get(1).changes().run(conn)
 |      
 |      *Example* Return all the changes to the top 10 games. This assumes the presence of a `score` secondary index on the `games` table.
 |      
 |          r.table('games').order_by(index=r.desc('score')).limit(10).run(conn)
 |  
 |  coerce_to(self, *args)
 |      sequence.coerce_to('array') -> array
 |      value.coerce_to('string') -> string
 |      string.coerce_to('number') -> number
 |      array.coerce_to('object') -> object
 |      object.coerce_to('array') -> array
 |      binary.coerce_to('string') -> string
 |      string.coerce_to('binary') -> binary
 |      
 |      Convert a value of one type into another.
 |      
 |      * a sequence, selection or object can be coerced to an array
 |      * an array of key-value pairs can be coerced to an object
 |      * a string can be coerced to a number
 |      * any datum (single value) can be coerced to a string
 |      * a binary object can be coerced to a string and vice-versa
 |      
 |      *Example* Coerce a stream to an array to store its output in a field. (A stream cannot be stored in a field directly.)
 |      
 |          r.table('posts').map(lambda post: post.merge(
 |              { 'comments': r.table('comments').get_all(post['id'], index='post_id').coerce_to('array') }
 |          )).run(conn)
 |      
 |      *Example* Coerce an array of pairs into an object.
 |      
 |          r.expr([['name', 'Ironman'], ['victories', 2000]]).coerce_to('object').run(conn)
 |      
 |      __Note:__ To coerce a list of key-value pairs like `['name', 'Ironman', 'victories', 2000]` to an object, use the [object](http://rethinkdb.com/api/python/object) command.
 |      
 |      *Example* Coerce a number to a string.
 |      
 |          r.expr(1).coerce_to('string').run(conn)
 |  
 |  concat_map(self, *args)
 |      stream.concat_map(mapping_function) -> stream
 |      array.concat_map(mapping_function) -> array
 |      
 |      Concatenate one or more elements into a single sequence using a mapping function.
 |      
 |      `concat_map` works in a similar fashion to `map`, applying the given function to each element in a sequence, but it will always return a single sequence. If the mapping function returns a sequence, `map` would produce a sequence of sequences:
 |      
 |          r.expr([1, 2, 3]).map(lambda x: [x, x.mul(2)]).run(conn)
 |      
 |      Result:
 |      
 |          [[1, 2], [2, 4], [3, 6]]
 |      
 |      Whereas `concat_map` with the same mapping function would merge those sequences into one:
 |      
 |          r.expr([1, 2, 3]).concat_map(lambda x: [x, x.mul(2)]).run(conn)
 |      
 |      Result:
 |      
 |          [1, 2, 2, 4, 3, 6]
 |      
 |      The return value, array or stream, will be the same type as the input.
 |      
 |      *Example* Construct a sequence of all monsters defeated by Marvel heroes. The field "defeatedMonsters" is an array of one or more monster names.
 |      
 |          r.table('marvel').concat_map(lambda hero: hero['defeatedMonsters']).run(conn)
 |      
 |      *Example* Simulate an [eq_join](http://rethinkdb.com/api/python/eq_join/) using `concat_map`. (This is how ReQL joins are implemented internally.)
 |      
 |          r.table('posts').concat_map(
 |              lambda post: r.table('comments').get_all(
 |                  post['id'], index='post_id'
 |              ).map(
 |                  lambda comment: { 'left': post, 'right': comment}
 |              )
 |          ).run(conn)
 |  
 |  contains(self, *args)
 |      sequence.contains(value1[, value2...]) -> bool
 |      sequence.contains(predicate1[, predicate2...]) -> bool
 |      
 |      When called with values, returns `True` if a sequence contains all the
 |      specified values.  When called with predicate functions, returns `True`
 |      if for each predicate there exists at least one element of the stream
 |      where that predicate returns `True`.
 |      
 |      *Example* Has Iron Man ever fought Superman?
 |      
 |          r.table('marvel').get('ironman')['opponents'].contains('superman').run(conn)
 |      
 |      *Example* Has Iron Man ever defeated Superman in battle?
 |      
 |          r.table('marvel').get('ironman')['battles'].contains(lambda battle:
 |              (battle['winner'] == 'ironman') & (battle['loser'] == 'superman')
 |          ).run(conn)
 |      
 |      *Example* Use `contains` with a predicate function to simulate an `or`. Return the Marvel superheroes who live in Detroit, Chicago or Hoboken.
 |      
 |          r.table('marvel').filter(
 |              lambda hero: r.expr(['Detroit', 'Chicago', 'Hoboken']).contains(hero['city'])
 |          ).run(conn)
 |  
 |  count(self, *args)
 |      sequence.count([value_or_predicate]) -> number
 |      binary.count() -> number
 |      
 |      Counts the number of elements in a sequence.  If called with a value,
 |      counts the number of times that value occurs in the sequence.  If
 |      called with a predicate function, counts the number of elements in the
 |      sequence where that function returns `True`.
 |      
 |      If `count` is called on a [binary](http://rethinkdb.com/api/python/binary) object, it will return the size of the object in bytes.
 |      
 |      *Example* Count the number of users.
 |      
 |          r.table('users').count().run(conn)
 |      
 |      *Example* Count the number of 18 year old users.
 |      
 |          r.table('users')['age'].count(18).run(conn)
 |      
 |      *Example* Count the number of users over 18.
 |      
 |          r.table('users')['age'].count(lambda age: age > 18).run(conn)
 |      
 |          r.table('users').count(lambda user: user['age'] > 18).run(conn)
 |  
 |  date(self, *args)
 |      time.date() -> time
 |      
 |      Return a new time object only based on the day, month and year (ie. the same day at 00:00).
 |      
 |      *Example* Retrieve all the users whose birthday is today
 |      
 |          r.table("users").filter(lambda user:
 |              user["birthdate"].date() == r.now().date()
 |          ).run(conn)
 |  
 |  day(self, *args)
 |      time.day() -> number
 |      
 |      Return the day of a time object as a number between 1 and 31.
 |      
 |      *Example* Return the users born on the 24th of any month.
 |      
 |          r.table("users").filter(
 |              r.row["birthdate"].day() == 24
 |          )
 |  
 |  day_of_week(self, *args)
 |      time.day_of_week() -> number
 |      
 |      Return the day of week of a time object as a number between 1 and 7 (following ISO 8601 standard). For your convenience, the terms r.monday, r.tuesday etc. are defined and map to the appropriate integer.
 |      
 |      *Example* Return today's day of week.
 |      
 |          r.now().day_of_week().run(conn)
 |      
 |      *Example* Retrieve all the users who were born on a Tuesday.
 |      
 |          r.table("users").filter( lambda user:
 |              user["birthdate"].day_of_week().eq(r.tuesday)
 |          )
 |  
 |  day_of_year(self, *args)
 |      time.day_of_year() -> number
 |      
 |      Return the day of the year of a time object as a number between 1 and 366 (following ISO 8601 standard).
 |      
 |      *Example* Retrieve all the users who were born the first day of a year.
 |      
 |          r.table("users").filter(
 |              r.row["birthdate"].day_of_year() == 1
 |          ).run(conn)
 |  
 |  default(self, *args)
 |      value.default(default_value) -> any
 |      sequence.default(default_value) -> any
 |      
 |      Handle non-existence errors. Tries to evaluate and return its first argument. If an
 |      error related to the absence of a value is thrown in the process, or if its first
 |      argument returns `None`, returns its second argument. (Alternatively, the second argument
 |      may be a function which will be called with either the text of the non-existence error
 |      or `None`.)
 |      
 |      *Example* Suppose we want to retrieve the titles and authors of the table `posts`.
 |      In the case where the author field is missing or `None`, we want to retrieve the string
 |      `Anonymous`.
 |      
 |          r.table("posts").map(lambda post:
 |              {
 |                  "title": post["title"],
 |                  "author": post["author"].default("Anonymous")
 |              }
 |          ).run(conn)
 |      
 |      We can rewrite the previous query with `r.branch` too.
 |      
 |          r.table("posts").map(lambda post:
 |              r.branch(
 |                  post.has_fields("author"),
 |                  {
 |                      "title": post["title"],
 |                      "author": post["author"]
 |                  },
 |                  {
 |                      "title": post["title"],
 |                      "author": "Anonymous" 
 |                  }
 |              )
 |          ).run(conn)
 |      
 |      *Example* The `default` command can be useful to filter documents too. Suppose
 |      we want to retrieve all our users who are not grown-ups or whose age is unknown
 |      (i.e the field `age` is missing or equals `None`). We can do it with this query:
 |      
 |          r.table("users").filter(lambda user:
 |              (user["age"] < 18).default(True)
 |          ).run(conn)
 |      
 |      One more way to write the previous query is to set the age to be `-1` when the
 |      field is missing.
 |      
 |          r.table("users").filter(lambda user:
 |              user["age"].default(-1) < 18
 |          ).run(conn)
 |      
 |      One last way to do the same query is to use `has_fields`.
 |      
 |          r.table("users").filter(lambda user:
 |              user.has_fields("age").not_() | (user["age"] < 18)
 |          ).run(conn)
 |      
 |      The body of every `filter` is wrapped in an implicit `.default(False)`. You can overwrite
 |      the value `False` by passing an option in filter, so the previous query can also be
 |      written like this.
 |      
 |          r.table("users").filter(
 |              lambda user: (user["age"] < 18).default(True),
 |              default=True
 |          ).run(conn)
 |  
 |  delete(self, *args, **kwargs)
 |      table.delete([durability="hard", return_changes=False])
 |          -> object
 |      selection.delete([durability="hard", return_changes=False])
 |          -> object
 |      singleSelection.delete([durability="hard", return_changes=False])
 |          -> object
 |      
 |      Delete one or more documents from a table.
 |      
 |      The optional arguments are:
 |      
 |      - `durability`: possible values are `hard` and `soft`. This option will override the
 |      table or query's durability setting (set in [run](http://rethinkdb.com/api/python/run/)).  
 |      In soft durability mode RethinkDB will acknowledge the write immediately after
 |      receiving it, but before the write has been committed to disk.
 |      - `return_changes`: if set to `True`, return a `changes` array consisting of `old_val`/`new_val` objects describing the changes made.
 |      
 |      Delete returns an object that contains the following attributes:
 |      
 |      - `deleted`: the number of documents that were deleted.
 |      - `skipped`: the number of documents that were skipped.  
 |      For example, if you attempt to delete a batch of documents, and another concurrent query
 |      deletes some of those documents first, they will be counted as skipped.
 |      - `errors`: the number of errors encountered while performing the delete.
 |      - `first_error`: If errors were encountered, contains the text of the first error.
 |      - `inserted`, `replaced`, and `unchanged`: all 0 for a delete operation.
 |      - `changes`: if `return_changes` is set to `True`, this will be an array of objects, one for each objected affected by the `delete` operation. Each object will have two keys: `{"new_val": None, "old_val": <old value>}`.
 |      
 |      *Example* Delete a single document from the table `comments`.
 |      
 |          r.table("comments").get("7eab9e63-73f1-4f33-8ce4-95cbea626f59").delete().run(conn)
 |      
 |      *Example* Delete all documents from the table `comments`.
 |      
 |          r.table("comments").delete().run(conn)
 |      
 |      *Example* Delete all comments where the field `id_post` is `3`.
 |      
 |          r.table("comments").filter({"id_post": 3}).delete().run(conn)
 |      
 |      *Example* Delete a single document from the table `comments` and return its value.
 |      
 |          r.table("comments").get("7eab9e63-73f1-4f33-8ce4-95cbea626f59").delete(return_changes=True).run(conn)
 |      
 |      The result will look like:
 |      
 |          {
 |              "deleted": 1,
 |              "errors": 0,
 |              "inserted": 0,
 |              "changes": [
 |                  {
 |                      "new_val": None,
 |                      "old_val": {
 |                          "id": "7eab9e63-73f1-4f33-8ce4-95cbea626f59",
 |                          "author": "William",
 |                          "comment": "Great post",
 |                          "id_post": 3
 |                      }
 |                  }
 |              ],
 |              "replaced": 0,
 |              "skipped": 0,
 |              "unchanged": 0
 |          }
 |      
 |      *Example* Delete all documents from the table `comments` without waiting for the
 |      operation to be flushed to disk.
 |      
 |          r.table("comments").delete(durability="soft"}).run(conn)
 |  
 |  delete_at(self, *args)
 |      array.delete_at(index [,endIndex]) -> array
 |      
 |      Remove one or more elements from an array at a given index. Returns the modified array. (Note: `delete_at` operates on arrays, not documents; to delete documents, see the [delete](http://rethinkdb.com/api/python/delete) command.)
 |      
 |      If only `index` is specified, `delete_at` removes the element at that index. If both `index` and `end_index` are specified, `delete_at` removes the range of elements between `index` and `end_index`, inclusive of `index` but not inclusive of `end_index`.
 |      
 |      If `end_index` is specified, it must not be less than `index`. Both `index` and `end_index` must be within the array's bounds (i.e., if the array has 10 elements, an `index` or `end_index` of 10 or higher is invalid).
 |      
 |      By using a negative `index` you can delete from the end of the array. `-1` is the last element in the array, `-2` is the second-to-last element, and so on. You may specify a negative `end_index`, although just as with a positive value, this will not be inclusive. The range `(2,-1)` specifies the third element through the next-to-last element.
 |      
 |      *Example* Delete the second element of an array.
 |      
 |          > r.expr(['a','b','c','d','e','f']).delete_at(1).run(conn)
 |          
 |          ['a', 'c', 'd', 'e', 'f']
 |      
 |      *Example* Delete the second and third elements of an array.
 |      
 |          > r.expr(['a','b','c','d','e','f']).delete_at(1,3).run(conn)
 |          
 |          ['a', 'd', 'e', 'f']
 |      
 |      *Example* Delete the next-to-last element of an array.
 |      
 |          > r.expr(['a','b','c','d','e','f']).delete_at(-2).run(conn)
 |          
 |          ['a', 'b', 'c', 'd', 'f']
 |      
 |      *Example* Delete a comment on a post.
 |      
 |      Given a post document such as:
 |      
 |      {
 |          id: '4cf47834-b6f9-438f-9dec-74087e84eb63',
 |          title: 'Post title',
 |          author: 'Bob',
 |          comments: [
 |              { author: 'Agatha', text: 'Comment 1' },
 |              { author: 'Fred', text: 'Comment 2' }
 |          ]
 |      }
 |      
 |      The second comment can be deleted by using `update` and `delete_at` together.
 |      
 |          r.table('posts').get('4cf47834-b6f9-438f-9dec-74087e84eb63').update(
 |              lambda post: { 'comments': post['comments'].delete_at(1) }
 |          ).run(conn)
 |  
 |  difference(self, *args)
 |      array.difference(array) -> array
 |      
 |      Remove the elements of one array from another array.
 |      
 |      *Example* Retrieve Iron Man's equipment list without boots.
 |      
 |          r.table('marvel').get('IronMan')['equipment'].difference(['Boots']).run(conn)
 |      
 |      *Example* Remove Iron Man's boots from his equipment.
 |      
 |          r.table('marvel').get('IronMan')[:equipment].update(lambda doc:
 |              {'equipment': doc['equipment'].difference(['Boots'])}
 |          ).run(conn)
 |  
 |  distance(self, *args, **kwargs)
 |      geometry.distance(geometry[, geo_system='WGS84', unit='m']) -> number
 |      
 |      Compute the distance between a point and another geometry object. At least one of the geometry objects specified must be a point.
 |      
 |      Optional arguments available with `distance` are:
 |      
 |      * `geo_system`: the reference ellipsoid to use for geographic coordinates. Possible values are `WGS84` (the default), a common standard for Earth's geometry, or `unit_sphere`, a perfect sphere of 1 meter radius.
 |      * `unit`: Unit to return the distance in. Possible values are `m` (meter, the default), `km` (kilometer), `mi` (international mile), `nm` (nautical mile), `ft` (international foot).
 |      
 |      If one of the objects is a polygon or a line, the point will be projected onto the line or polygon assuming a perfect sphere model before the distance is computed (using the model specified with `geo_system`). As a consequence, if the polygon or line is extremely large compared to Earth's radius and the distance is being computed with the default WGS84 model, the results of `distance` should be considered approximate due to the deviation between the ellipsoid and spherical models.
 |      
 |      *Example* Compute the distance between two points on the Earth in kilometers.
 |      
 |          > point1 = r.point(-122.423246,37.779388)
 |          > point2 = r.point(-117.220406,32.719464)
 |          > r.distance(point1, point2, unit='km').run(conn)
 |          
 |          734.1252496021841
 |  
 |  distinct(self, *args, **kwargs)
 |      sequence.distinct() -> array
 |      table.distinct() -> stream
 |      table.distinct(index=<indexname>) -> stream
 |      
 |      Removes duplicate elements from a sequence.
 |      
 |      The `distinct` command can be called on any sequence, a table, or called on a table with an index.
 |      
 |      *Example* Which unique villains have been vanquished by marvel heroes?
 |      
 |          r.table('marvel').concat_map(
 |              lambda hero: hero['villain_list']).distinct().run(conn)
 |      
 |      *Example* Topics in a table of messages have a secondary index on them, and more than one message can have the same topic. What are the unique topics in the table?
 |      
 |          r.table('messages').distinct(index='topics').run(conn)
 |      
 |      The above structure is functionally identical to:
 |      
 |          r.table('messages')['topics'].distinct().run(conn)
 |      
 |      However, the first form (passing the index as an argument to `distinct`) is faster, and won't run into array limit issues since it's returning a stream.
 |  
 |  div(self, *args)
 |  
 |  do(self, *args)
 |      any.do(function) -> any
 |      r.do([args]*, function) -> any
 |      any.do(expr) -> any
 |      r.do([args]*, expr) -> any
 |      
 |      Evaluate an expression and pass its values as arguments to a function or to an expression.
 |      
 |      The last argument to `do` (or, in some forms, the only argument) is an expression or an anonymous function which receives values from either the previous arguments or from prefixed commands chained before `do`. A common use, for example, would be to retrieve a document with `get` and pass it to a function via `do`. The type of `do`'s result is the type of the value returned from the function or last expression.
 |      
 |      Arguments passed to the `do` function must be basic data types, and cannot be streams or selections. (Read about [ReQL data types](http://rethinkdb.com/docs/data-types/).) While the arguments will all be evaluated before the function is executed, they may be evaluated in any order, so their values should not be dependent on one another.
 |      
 |      *Example* Compute a golfer's net score for a game.
 |      
 |          r.table('players').get('86be93eb-a112-48f5-a829-15b2cb49de1d').do(
 |              lambda player: player['gross_score'] - player['course_handicap']
 |          ).run(conn)
 |      
 |      *Example* Return the name of the best scoring player in a two-player golf match.
 |      
 |          r.do(r.table('players').get(id1), r.table('players').get(id2),
 |              (lambda player1, player2:
 |                  r.branch(player1['gross_score'].lt(player2['gross_score']),
 |                  player1, player2))
 |          ).run(conn)
 |          
 |      
 |      Note that `branch`, the ReQL conditional command, must be used instead of `if`. See the `branch` [documentation](http://rethinkdb.com/api/python/branch) for more.
 |  
 |  downcase(self, *args)
 |      string.downcase() -> string
 |      
 |      Lowercases a string.
 |      
 |      *Example*
 |      
 |          > r.expr("Sentence about LaTeX.").downcase().run(conn)
 |          "sentence about latex."
 |      
 |      __Note:__ `upcase` and `downcase` only affect ASCII characters.
 |  
 |  during(self, *args, **kwargs)
 |      time.during(start_time, end_time[, left_bound="closed", right_bound="open"])
 |          -> bool
 |      
 |      Return whether a time is between two other times. By default, this is inclusive of the start time and exclusive of the end time. Set `left_bound` and `right_bound` to explicitly include (`closed`) or exclude (`open`) that endpoint of the range.
 |      
 |      *Example* Retrieve all the posts that were posted between December 1st, 2013 (inclusive) and December 10th, 2013 (exclusive).
 |      
 |          r.table("posts").filter(
 |              r.row['date'].during(r.time(2013, 12, 1, "Z"), r.time(2013, 12, 10, "Z"))
 |          ).run(conn)
 |      
 |      *Example* Retrieve all the posts that were posted between December 1st, 2013 (exclusive) and December 10th, 2013 (inclusive).
 |      
 |          r.table("posts").filter(
 |              r.row['date'].during(r.time(2013, 12, 1, "Z"), r.time(2013, 12, 10, "Z"), left_bound="open", right_bound="closed")
 |          ).run(conn)
 |  
 |  eq(self, *args)
 |      value == value -> bool
 |      value.eq(value) -> bool
 |      
 |      Test if two values are equal.
 |      
 |      *Example* Does 2 equal 2?
 |      
 |          (r.expr(2) == 2).run(conn)
 |          r.expr(2).eq(2).run(conn)
 |  
 |  eq_join(self, *args, **kwargs)
 |      sequence.eq_join(left_field, right_table[, index='id']) -> sequence
 |      
 |      Join tables using a field on the left-hand sequence matching primary keys or secondary indexes on the right-hand table. `eq_join` is more efficient than other Re_qL join types, and operates much faster. Documents in the result set consist of pairs of left-hand and right-hand documents, matched when the field on the left-hand side exists and is non-null and an entry with that field's value exists in the specified index on the right-hand side.
 |      
 |      The result set of `eq_join` is a stream or array of objects. Each object in the returned set will be an object of the form `{ left: <left-document>, right: <right-document> }`, where the values of `left` and `right` will be the joined documents. Use the <code><a href="/api/python/zip/">zip</a></code> command to merge the `left` and `right` fields together.
 |      
 |      **Example:** Match players with the games they've played against one another.
 |      
 |      The players table contains these documents:
 |      
 |          [
 |              { 'id': 1, 'player': 'George', 'gameId': 1 },
 |              { 'id': 2, 'player': 'Agatha', 'gameId': 3 },
 |              { 'id': 3, 'player': 'Fred', 'gameId': 2 },
 |              { 'id': 4, 'player': 'Marie', 'gameId': 2 },
 |              { 'id': 5, 'player': 'Earnest', 'gameId': 1 },
 |              { 'id': 6, 'player': 'Beth', 'gameId': 3 }
 |          ]
 |      
 |      The games table contains these documents:
 |      
 |          [
 |              { 'id': 1, 'field': 'Little Delving' },
 |              { 'id': 2, 'field': 'Rushock Bog' },
 |              { 'id': 3, 'field': 'Bucklebury' }
 |          ]
 |      
 |      Join these tables using `game_id` on the player table and `id` on the games table:
 |      
 |          r.table('players').eq_join('game_id', r.table('games')).run(conn)
 |      
 |      This will return a result set such as the following:
 |      
 |          [
 |              {
 |                  "left" : { "gameId" : 3, "id" : 2, "player" : "Agatha" },
 |                  "right" : { "id" : 3, "field" : "Bucklebury" }
 |              },
 |              {
 |                  "left" : { "gameId" : 2, "id" : 3, "player" : "Fred" },
 |                  "right" : { "id" : 2, "field" : "Rushock Bog" }
 |              },
 |              ...
 |          ]
 |      
 |      What you likely want is the result of using `zip` with that. For clarity, we'll use `without` to drop the `id` field from the games table (it conflicts with the `id` field for the players and it's redundant anyway), and we'll order it by the games.
 |      
 |          r.table('players').eq_join('game_id', r.table('games')).without({'right': "id"}).zip().order_by('game_id').run(conn)
 |          
 |          [
 |              { "field": "Little Delving", "gameId": 1, "id": 5, "player": "Earnest" },
 |              { "field": "Little Delving", "gameId": 1, "id": 1, "player": "George" },
 |              { "field": "Rushock Bog", "gameId": 2, "id": 3, "player": "Fred" },
 |              { "field": "Rushock Bog", "gameId": 2, "id": 4, "player": "Marie" },
 |              { "field": "Bucklebury", "gameId": 3, "id": 6, "player": "Beth" },
 |              { "field": "Bucklebury", "gameId": 3, "id": 2, "player": "Agatha" }
 |          ]
 |      
 |      For more information, see [Table joins in Rethink_dB](http://rethinkdb.com/docs/table-joins/).
 |      
 |      **Example:** Use a secondary index on the right table rather than the primary key. If players have a secondary index on their cities, we can get a list of arenas with players in the same area.
 |      
 |          r.table('arenas').eq_join('city_id', r.table('arenas'), index='city_id').run(conn)
 |      
 |      **Example:** Use a nested key as the join field. Suppose the documents in the players table were structured like this:
 |      
 |          { 'id': 1, 'player': 'George', 'game': {'id': 1} },
 |          { 'id': 2, 'player': 'Agatha', 'game': {'id': 3} },
 |          ...
 |      
 |      Simply specify the field using the `row` command instead of a string.
 |      
 |          r.table('players').eq_join(r.row['game']['id'], r.table('games')).without({'right': 'id'}).zip().run(conn)
 |          
 |          [
 |              { "field": "Little Delving", "game": { "id": 1 }, "id": 5, "player": "Earnest" },
 |              { "field": "Little Delving", "game": { "id": 1 }, "id": 1, "player": "George" },
 |              ...
 |          ]
 |      
 |      **Example:** Use a function instead of a field to join on a more complicated expression. Suppose the players have lists of favorite games ranked in order in a field such as `"favorites": [3, 2, 1]`. Get a list of players and their top favorite:
 |      
 |          r.table('players3').eq_join(
 |              lambda player: player['favorites'].nth(0),
 |              r.table('games')
 |          ).without([{'left': ['favorites', 'game_id', 'id']}, {'right': 'id'}]).zip()
 |      
 |      Result:
 |      
 |          [
 |              { "field": "Rushock Bog", "name": "Fred" },
 |              { "field": "Little Delving", "name": "George" },
 |              ...
 |          ]
 |  
 |  fill(self, *args)
 |      line.fill() -> polygon
 |      
 |      Convert a Line object into a Polygon object. If the last point does not specify the same coordinates as the first point, `polygon` will close the polygon by connecting them.
 |      
 |      Longitude (&minus;180 to 180) and latitude (&minus;90 to 90) of vertices are plotted on a perfect sphere. See [Geospatial support](http://rethinkdb.com/docs/geo-support/) for more information on ReQL's coordinate system.
 |      
 |      If the last point does not specify the same coordinates as the first point, `polygon` will close the polygon by connecting them. You cannot directly construct a polygon with holes in it using `polygon`, but you can use [polygon_sub](http://rethinkdb.com/api/python/polygon_sub) to use a second polygon within the interior of the first to define a hole.
 |      
 |      *Example* Create a line object and then convert it to a polygon.
 |      
 |          r.table('geo').insert({
 |              'id': 201,
 |              'rectangle': r.line(
 |                  [-122.423246,37.779388],
 |                  [-122.423246,37.329898],
 |                  [-121.886420,37.329898],
 |                  [-121.886420,37.779388]
 |              )
 |          }).run(conn)
 |          
 |          r.table('geo').get(201).update({
 |              'rectangle': r.row('rectangle').fill()
 |          }).run(conn)
 |  
 |  filter(self, *args, **kwargs)
 |      selection.filter(predicate[, default=False]) -> selection
 |      stream.filter(predicate[, default=False]) -> stream
 |      array.filter(predicate[, default=False]) -> array
 |      
 |      Return all the elements in a sequence for which the given predicate is true. The return value of `filter` will be the same as the input (sequence, stream, or array). Documents can be filtered in a variety of ways&mdash;ranges, nested values, boolean conditions, and the results of anonymous functions.
 |      
 |      By default, `filter` will silently skip documents with missing fields: if the predicate tries to access a field that doesn't exist (for instance, the predicate `{'age': 30}` applied to a document with no `age` field), that document will not be returned in the result set, and no error will be generated. This behavior can be changed with the `default` optional argument.
 |      
 |      * If `default` is set to `True`, documents with missing fields will be returned rather than skipped.
 |      * If `default` is set to `r.error()`, an `RqlRuntimeError` will be thrown when a document with a missing field is tested.
 |      * If `default` is set to `False` (the default), documents with missing fields will be skipped.
 |      
 |      *Example* Get all users who are 30 years old.
 |      
 |          r.table('users').filter({'age': 30}).run(conn)
 |      
 |      The predicate `{'age': 30}` selects documents in the `users` table with an `age` field whose value is `30`. Documents with an `age` field set to any other value *or* with no `age` field present are skipped.
 |      
 |      While the `{'field': value}` style of predicate is useful for exact matches, a more general way to write a predicate is to use the [row](http://rethinkdb.com/api/python/row) command with a comparison operator such as [eq](http://rethinkdb.com/api/python/eq) (`==`) or [gt](http://rethinkdb.com/api/python/gt) (`>`), or to use a lambda function that returns `True` or `False`.
 |      
 |          r.table('users').filter(r.row["age"] == 30).run(conn)
 |      
 |      In this case, the predicate `r.row["age"] == 30` returns `True` if the field `age` is equal to 30. You can write this predicate as a lambda function instead:
 |      
 |          r.table('users').filter(lambda user:
 |              user["age"] == 30
 |          ).run(conn)
 |      
 |      Predicates to `filter` are evaluated on the server, and must use ReQL expressions. Some Python comparison operators are overloaded by the RethinkDB driver and will be translated to ReQL, such as `==`, `<`/`>` and `|`/`&` (note the single character form, rather than `||`/`&&`).
 |      
 |      Also, predicates must evaluate document fields. They cannot evaluate [secondary indexes](http://rethinkdb.com/docs/secondary-indexes/).
 |      
 |      *Example* Get all users who are more than 18 years old.
 |      
 |          r.table("users").filter(r.row["age"] > 18).run(conn)
 |      
 |      *Example* Get all users who are less than 18 years old and more than 13 years old.
 |      
 |          r.table("users").filter((r.row["age"] < 18) & (r.row["age"] > 13)).run(conn)
 |      
 |      *Example* Get all users who are more than 18 years old or have their parental consent.
 |      
 |          r.table("users").filter(
 |              (r.row["age"] >= 18) | (r.row["hasParentalConsent"])).run(conn)
 |      
 |      *Example* Retrieve all users who subscribed between January 1st, 2012
 |      (included) and January 1st, 2013 (excluded).
 |      
 |          r.table("users").filter(
 |              lambda user: user["subscription_date"].during(
 |                  r.time(2012, 1, 1, 'Z'), r.time(2013, 1, 1, 'Z'))
 |          ).run(conn)
 |      
 |      *Example* Retrieve all users who have a gmail account (whose field `email` ends with `@gmail.com`).
 |      
 |          r.table("users").filter(
 |              lambda user: user["email"].match("@gmail.com$")
 |          ).run(conn)
 |      
 |      *Example* Filter based on the presence of a value in an array.
 |      
 |      Given this schema for the `users` table:
 |      
 |          {
 |              "name": <type 'str'>
 |              "places_visited": [<type 'str'>]
 |          }
 |      
 |      Retrieve all users whose field `places_visited` contains `France`.
 |      
 |          r.table("users").filter(lambda user:
 |              user["places_visited"].contains("France")
 |          ).run(conn)
 |      
 |      *Example* Filter based on nested fields.
 |      
 |      Given this schema for the `users` table:
 |      
 |          {
 |              "id": <type 'str'>
 |              "name": {
 |                  "first": <type 'str'>,
 |                  "middle": <type 'str'>,
 |                  "last": <type 'str'>
 |              }
 |          }
 |      
 |      Retrieve all users named "William Adama" (first name "William", last name
 |      "Adama"), with any middle name.
 |      
 |          r.table("users").filter({
 |              "name": {
 |                  "first": "William",
 |                  "last": "Adama"
 |              }
 |          }).run(conn)
 |      
 |      If you want an exact match for a field that is an object, you will have to use `r.literal`.
 |      
 |      Retrieve all users named "William Adama" (first name "William", last name
 |      "Adama"), and who do not have a middle name.
 |      
 |          r.table("users").filter(r.literal({
 |              "name": {
 |                  "first": "William",
 |                  "last": "Adama"
 |              }
 |          })).run(conn)
 |      
 |      You may rewrite these with lambda functions.
 |      
 |          r.table("users").filter(
 |              lambda user:
 |              (user["name"]["first"] == "William")
 |                  & (user["name"]["last"] == "Adama")
 |          ).run(conn)
 |      
 |          r.table("users").filter(lambda user:
 |              user["name"] == {
 |                  "first": "William",
 |                  "last": "Adama"
 |              }
 |          ).run(conn)
 |      
 |      By default, documents missing fields tested by the `filter` predicate are skipped. In the previous examples, users without an `age` field are not returned. By passing the optional `default` argument to `filter`, you can change this behavior.
 |      
 |      *Example* Get all users less than 18 years old or whose `age` field is missing.
 |      
 |          r.table("users").filter(r.row["age"] < 18, default=True).run(conn)
 |      
 |      *Example* Get all users more than 18 years old. Throw an error if a
 |      document is missing the field `age`.
 |      
 |          r.table("users").filter(r.row["age"] > 18, default=r.error()).run(conn)
 |      
 |      *Example* Get all users who have given their phone number (all the documents whose field `phone_number` exists and is not `None`).
 |      
 |          r.table('users').filter(
 |              lambda user: user.has_fields('phone_number')
 |          ).run(conn)
 |      
 |      *Example* Get all users with an "editor" role or an "admin" privilege.
 |      
 |          r.table('users').filter(
 |              lambda user: (user['role'] == 'editor').default(False) |
 |                  (user['privilege'] == 'admin').default(False)
 |          ).run(conn)
 |      
 |      Instead of using the `default` optional argument to `filter`, we have to use default values on the fields within the `or` clause. Why? If the field on the left side of the `or` clause is missing from a document&mdash;in this case, if the user doesn't have a `role` field&mdash;the predicate will generate an error, and will return `False` (or the value the `default` argument is set to) without evaluating the right side of the `or`. By using `.default(False)` on the fields, each side of the `or` will evaluate to either the field's value or `False` if the field doesn't exist.
 |  
 |  for_each(self, *args)
 |      sequence.for_each(write_query) -> object
 |      
 |      Loop over a sequence, evaluating the given write query for each element.
 |      
 |      *Example* Now that our heroes have defeated their villains, we can safely remove them from the villain table.
 |      
 |          r.table('marvel').for_each(
 |              lambda hero: r.table('villains').get(hero['villainDefeated']).delete()
 |          ).run(conn)
 |  
 |  ge(self, *args)
 |      value >= value -> bool
 |      value.ge(value) -> bool
 |      
 |      Test if the first value is greater than or equal to other.
 |      
 |      *Example* Is 2 greater than or equal to 2?
 |      
 |          (r.expr(2) >= 2).run(conn)
 |          r.expr(2).ge(2).run(conn)
 |  
 |  get_field(self, *args)
 |      sequence.get_field(attr) -> sequence
 |      singleSelection.get_field(attr) -> value
 |      object.get_field(attr) -> value
 |      
 |      Get a single field from an object. If called on a sequence, gets that field from every
 |      object in the sequence, skipping objects that lack it.
 |      
 |      *Example* What was Iron Man's first appearance in a comic?
 |      
 |          r.table('marvel').get('IronMan').get_field('firstAppearance').run(conn)
 |  
 |  group(self, *args, **kwargs)
 |      sequence.group(field_or_function..., [index='index_name', multi=False]) -> grouped_stream
 |      
 |      Takes a stream and partitions it into multiple groups based on the
 |      fields or functions provided.
 |      
 |      With the `multi` flag single documents can be assigned to multiple groups, similar to the behavior of [multi-indexes](http://rethinkdb.com/docs/secondary-indexes/python). When `multi` is `True` and the grouping value is an array, documents will be placed in each group that corresponds to the elements of the array. If the array is empty the row will be ignored.
 |      
 |      *Example* Grouping games by player.
 |      
 |      Suppose that the table `games` has the following data:
 |      
 |          [
 |              {"id": 2, "player": "Bob", "points": 15, "type": "ranked"},
 |              {"id": 5, "player": "Alice", "points": 7, "type": "free"},
 |              {"id": 11, "player": "Bob", "points": 10, "type": "free"},
 |              {"id": 12, "player": "Alice", "points": 2, "type": "free"}
 |          ]
 |      
 |      Grouping games by player can be done with:
 |      
 |          > r.table('games').group('player').run(conn)
 |          
 |          {
 |              "Alice": [
 |                  {"id": 5, "player": "Alice", "points": 7, "type": "free"},
 |                  {"id": 12, "player": "Alice", "points": 2, "type": "free"}
 |              ],
 |              "Bob": [
 |                  {"id": 2, "player": "Bob", "points": 15, "type": "ranked"},
 |                  {"id": 11, "player": "Bob", "points": 10, "type": "free"}
 |              ]
 |          }
 |      
 |      Commands chained after `group` will be called on each of these grouped
 |      sub-streams, producing grouped data.
 |      
 |      *Example* What is each player's best game?
 |      
 |          > r.table('games').group('player').max('points').run(conn)
 |          
 |          {
 |              "Alice": {"id": 5, "player": "Alice", "points": 7, "type": "free"},
 |              "Bob": {"id": 2, "player": "Bob", "points": 15, "type": "ranked"}
 |          }
 |      
 |      Commands chained onto grouped data will operate on each grouped datum,
 |      producing more grouped data.
 |      
 |      *Example* What is the maximum number of points scored by each player?
 |      
 |          > r.table('games').group('player').max('points')['points'].run(conn)
 |          
 |          {
 |              "Alice": 7,
 |              "Bob": 15
 |          }
 |      
 |      You can also group by more than one field.
 |      
 |      *Example* What is the maximum number of points scored by each
 |      player for each game type?
 |      
 |          > r.table('games').group('player', 'type').max('points')['points'].run(conn)
 |          
 |          {
 |              ("Alice", "free"): 7,
 |              ("Bob", "free"): 10,
 |              ("Bob", "ranked"): 15
 |          }
 |      
 |      You can also group by a function.
 |      
 |      *Example* What is the maximum number of points scored by each
 |      player for each game type?
 |      
 |          > r.table('games')
 |              .group(lambda game:
 |                  game.pluck('player', 'type')
 |              ).max('points')['points'].run(conn)
 |          
 |          {
 |              frozenset([('player', 'Alice'), ('type', 'free')]): 7,
 |              frozenset([('player', 'Bob'), ('type', 'free')]): 10,
 |              frozenset([('player', 'Bob'), ('type', 'ranked')]): 15,
 |          }
 |      
 |      Using a function, you can also group by date on a ReQL [date field](http://rethinkdb.com/docs/dates-and-times/javascript/).
 |      
 |      *Example* How many matches have been played this year by month?
 |      
 |          > r.table('matches').group(
 |                lambda match: [match['date'].year(), match['date'].month()]
 |            ).count().run(conn)
 |          
 |          {
 |              (2014, 2): 2,
 |              (2014, 3): 2,
 |              (2014, 4): 1,
 |              (2014, 5): 3
 |          }
 |      
 |      You can also group by an index.
 |      
 |      *Example* What is the maximum number of points scored by game type?
 |      
 |          > r.table('games').group(index='type').max('points')['points'].run(conn)
 |          
 |          {
 |              "free": 10,
 |              "ranked": 15
 |          }
 |      
 |      Suppose that the table `games2` has the following data:
 |      
 |          [
 |              { 'id': 1, 'matches': {'a': [1, 2, 3], 'b': [4, 5, 6]} },
 |              { 'id': 2, 'matches': {'b': [100], 'c': [7, 8, 9]} },
 |              { 'id': 3, 'matches': {'a': [10, 20], 'c': [70, 80]} }
 |          ]
 |      
 |      Using the `multi` option we can group data by match A, B or C.
 |      
 |          > r.table('games2').group(r.row['matches'].keys(), multi=True).run(conn)
 |          
 |          [
 |              {
 |                  'group': 'a',
 |                  'reduction': [ <id 1>, <id 3> ]
 |              },
 |              {
 |                  'group': 'b',
 |                  'reduction': [ <id 1>, <id 2> ]
 |              },
 |              {
 |                  'group': 'c',
 |                  'reduction': [ <id 2>, <id 3> ]
 |              }
 |          ]
 |      
 |      (The full result set is abbreviated in the figure; `<id 1>, <id 2>` and `<id 3>` would be the entire documents matching those keys.)
 |      
 |      *Example* Use [map](http://rethinkdb.com/api/python/map) and [sum](http://rethinkdb.com/api/python/sum) to get the total points scored for each match.
 |      
 |          r.table('games2').group(r.row['matches'].keys(), multi=True).ungroup().map(
 |              lambda doc: { 'match': doc['group'], 'total': doc['reduction'].sum(
 |                  lambda set: set['matches'][doc['group']].sum()
 |              )}).run(conn)
 |          
 |          [
 |              { 'match': 'a', 'total': 36 },
 |              { 'match': 'b', 'total': 115 },
 |              { 'match': 'c', 'total': 174 }
 |          ]
 |      
 |      The inner `sum` adds the scores by match within each document; the outer `sum` adds those results together for a total across all the documents.
 |      
 |      If you want to operate on all the groups rather than operating on each
 |      group (e.g. if you want to order the groups by their reduction), you
 |      can use [ungroup](http://rethinkdb.com/api/python/ungroup/) to turn a grouped stream or
 |      grouped data into an array of objects representing the groups.
 |      
 |      *Example* Ungrouping grouped data.
 |      
 |          > r.table('games').group('player').max('points')['points'].ungroup().run(conn)
 |          
 |          [
 |              {
 |                  "group": "Alice",
 |                  "reduction": 7
 |              },
 |              {
 |                  "group": "Bob",
 |                  "reduction": 15
 |              }
 |          ]
 |      
 |      Ungrouping is useful e.g. for ordering grouped data, or for inserting
 |      grouped data into a table.
 |      
 |      *Example* What is the maximum number of points scored by each
 |      player, with the highest scorers first?
 |      
 |          > r.table('games').group('player').max('points')['points'].ungroup().order_by(
 |                  r.desc('reduction')).run(conn)
 |          
 |          [
 |              {
 |                  "group": "Bob",
 |                  "reduction": 15
 |              },
 |              {
 |                  "group": "Alice",
 |                  "reduction": 7
 |              }
 |          ]
 |      
 |      When grouped data are returned to the client, they are transformed
 |      into a client-specific native type.  (Something similar is done with
 |      [times](http://rethinkdb.com/docs/dates-and-times/).)  In Python, grouped data are
 |      transformed into a `dictionary`. If the group value is an `array`, the
 |      key is converted to a `tuple`. If the group value is a `dictionary`,
 |      it will be converted to a `frozenset`.
 |      
 |      If you instead want to receive the raw
 |      pseudotype from the server (e.g. if you're planning to serialize the
 |      result as JSON), you can specify `group_format: 'raw'` as an optional
 |      argument to `run`:
 |      
 |      *Example* Get back the raw `GROUPED_DATA` pseudotype.
 |      
 |          > r.table('games').group('player').avg('points').run(conn, group_format='raw')
 |          
 |          {
 |              "$reql_type$": "GROUPED_DATA",
 |              "data": [
 |                  ["Alice", 4.5],
 |                  ["Bob", 12.5]
 |              ]
 |          }
 |      
 |      Not passing the `group_format` flag would return:
 |      
 |          {
 |              "Alice": 4.5,
 |              "Bob": 12.5
 |          }
 |      
 |      You might also want to use the [ungroup](http://rethinkdb.com/api/python/ungroup/)
 |      command (see above), which will turn the grouped data into an array of
 |      objects on the server.
 |      
 |      If you run a query that returns a grouped stream, it will be
 |      automatically converted to grouped data before being sent back to you
 |      (there is currently no efficient way to stream groups from RethinkDB).
 |      This grouped data is subject to the array size limit (see [run](http://rethinkdb.com/api/python/run)).
 |      
 |      In general, operations on grouped streams will be efficiently
 |      distributed, and operations on grouped data won't be.  You can figure
 |      out what you're working with by putting `type_of` on the end of your
 |      query.  Below are efficient and inefficient examples.
 |      
 |      *Example* Efficient operation.
 |      
 |          # r.table('games').group('player').type_of().run(conn)
 |          # Returns "GROUPED_STREAM"
 |          r.table('games').group('player').min('points').run(conn) # EFFICIENT
 |      
 |      *Example* Inefficient operation.
 |      
 |          # r.table('games').group('player').order_by('score').type_of().run(conn)
 |          # Returns "GROUPED_DATA"
 |          r.table('games').group('player').order_by('score').nth(0).run(conn) # INEFFICIENT
 |      
 |      What does it mean to be inefficient here?  When operating on grouped
 |      data rather than a grouped stream, *all* of the data has to be
 |      available on the node processing the query.  This means that the
 |      operation will only use one server's resources, and will require
 |      memory proportional to the size of the grouped data it's operating
 |      on.  (In the case of the `order_by` in the inefficient example, that
 |      means memory proportional **to the size of the table**.)  The array
 |      limit is also enforced for grouped data, so the `order_by` example
 |      would fail for tables with more than 100,000 rows unless you used the `array_limit` option with `run`.
 |      
 |      *Example* What is the maximum number of points scored by each
 |      player in free games?
 |      
 |          > r.table('games').filter(lambda game:
 |                  game['type'] = 'free'
 |              ).group('player').max('points')['points'].run(conn)
 |          
 |          {
 |              "Alice": 7,
 |              "Bob": 10
 |          }
 |      
 |      *Example* What is each player's highest even and odd score?
 |      
 |          > r.table('games')
 |              .group('name', lambda game:
 |                  game['points'] % 2
 |              ).max('points')['points'].run(conn)
 |          
 |          {
 |              ("Alice", 1): 7,
 |              ("Bob", 0): 10,
 |              ("Bob", 1): 15
 |          }
 |  
 |  gt(self, *args)
 |      value > value -> bool
 |      value.gt(value) -> bool
 |      
 |      Test if the first value is greater than other.
 |      
 |      *Example* Is 2 greater than 2?
 |      
 |          (r.expr(2) > 2).run(conn)
 |          r.expr(2).gt(2).run(conn)
 |  
 |  has_fields(self, *args)
 |      sequence.has_fields([selector1, selector2...]) -> stream
 |      array.has_fields([selector1, selector2...]) -> array
 |      object.has_fields([selector1, selector2...]) -> boolean
 |      
 |      Test if an object has one or more fields. An object has a field if it has that key and the key has a non-null value. For instance, the object `{'a': 1,'b': 2,'c': null}` has the fields `a` and `b`.
 |      
 |      When applied to a single object, `has_fields` returns `true` if the object has the fields and `false` if it does not. When applied to a sequence, it will return a new sequence (an array or stream) containing the elements that have the specified fields.
 |      
 |      *Example* Return the players who have won games.
 |      
 |          r.table('players').has_fields('games_won').run(conn)
 |      
 |      *Example* Test if a specific player has won any games.
 |      
 |          r.table('players').get(
 |              'b5ec9714-837e-400c-aa74-dbd35c9a7c4c').has_fields('games_won').run(conn)
 |      
 |      **Nested Fields**
 |      
 |      `has_fields` lets you test for nested fields in objects. If the value of a field is itself a set of key/value pairs, you can test for the presence of specific keys.
 |      
 |      *Example* In the `players` table, the `games_won` field contains one or more fields for kinds of games won:
 |      
 |          {
 |              'games_won': {
 |                  'playoffs': 2,
 |                  'championships': 1
 |              }
 |          }
 |      
 |      Return players who have the "championships" field.
 |      
 |          r.table('players').has_fields({'games_won': {'championships': true}}).run(conn)
 |      
 |      Note that `true` in the example above is testing for the existence of `championships` as a field, not testing to see if the value of the `championships` field is set to `true`. There's a more convenient shorthand form available. (See [pluck](http://rethinkdb.com/api/python/pluck) for more details on this.)
 |      
 |          r.table('players').has_fields({'games_won': 'championships'}).run(conn)
 |  
 |  hours(self, *args)
 |      time.hours() -> number
 |      
 |      Return the hour in a time object as a number between 0 and 23.
 |      
 |      *Example* Return all the posts submitted after midnight and before 4am.
 |      
 |          r.table("posts").filter(lambda post:
 |              post["date"].hours() < 4
 |          ).run(conn)
 |  
 |  in_timezone(self, *args)
 |      time.in_timezone(timezone) -> time
 |      
 |      Return a new time object with a different timezone. While the time stays the same, the results returned by methods such as hours() will change since they take the timezone into account. The timezone argument has to be of the ISO 8601 format.
 |      
 |      *Example* Hour of the day in San Francisco (UTC/GMT -8, without daylight saving time).
 |      
 |          r.now().in_timezone('-08:00').hours().run(conn)
 |  
 |  includes(self, *args)
 |      sequence.includes(geometry) -> sequence
 |      geometry.includes(geometry) -> bool
 |      
 |      Tests whether a geometry object is completely contained within another. When applied to a sequence of geometry objects, `includes` acts as a [filter](http://rethinkdb.com/api/python/filter), returning a sequence of objects from the sequence that include the argument.
 |      
 |      *Example* Is `point2` included within a 2000-meter circle around `point1`?
 |      
 |          > point1 = r.point(-117.220406,32.719464)
 |          > point2 = r.point(-117.206201,32.725186)
 |          > r.circle(point1, 2000).includes(point2).run(conn)
 |          
 |          True
 |      
 |      *Example* Which of the locations in a list of parks include `circle1`?
 |      
 |          circle1 = r.circle([-117.220406,32.719464], 10, unit='mi')
 |          r.table('parks')['area'].includes(circle1).run(conn)
 |  
 |  info(self, *args)
 |      any.info() -> object
 |      
 |      Get information about a ReQL value.
 |      
 |      *Example* Get information about a table such as primary key, or cache size.
 |      
 |          r.table('marvel').info().run(conn)
 |  
 |  inner_join(self, *args)
 |      sequence.inner_join(other_sequence, predicate) -> stream
 |      array.inner_join(other_sequence, predicate) -> array
 |      
 |      Returns an inner join of two sequences. The returned sequence represents an intersection of the left-hand sequence and the right-hand sequence: each row of the left-hand sequence will be compared with each row of the right-hand sequence to find all pairs of rows which satisfy the predicate. Each matched pair of rows of both sequences are combined into a result row. In most cases, you will want to follow the join with [zip](http://rethinkdb.com/api/python/zip) to combine the left and right results.
 |      
 |      Note that `inner_join` is slower and much less efficient than using [eq_join](http://rethinkdb.com/api/python/eq_join/) or [concat_map](http://rethinkdb.com/api/python/concat_map/) with [get_all](http://rethinkdb.com/api/python/get_all/). You should avoid using `inner_join` in commands when possible.
 |      
 |      *Example* Return a list of all matchups between Marvel and DC heroes in which the DC hero could beat the Marvel hero in a fight.
 |      
 |          r.table('marvel').inner_join(r.table('dc'),
 |              lambda marvel_row, dc_row: marvel_row['strength'] < dc_row['strength']
 |          ).zip().run(conn)
 |      
 |      (Compare this to an [outer_join](http://rethinkdb.com/api/python/outer_join) with the same inputs and predicate, which would return a list of *all* Marvel heroes along with any DC heroes with a higher strength.)
 |  
 |  insert_at(self, *args)
 |      array.insert_at(index, value) -> array
 |      
 |      Insert a value in to an array at a given index. Returns the modified array.
 |      
 |      *Example* Hulk decides to join the avengers.
 |      
 |          r.expr(["Iron Man", "Spider-Man"]).insert_at(1, "Hulk").run(conn)
 |  
 |  intersects(self, *args)
 |      sequence.intersects(geometry) -> sequence
 |      geometry.intersects(geometry) -> bool
 |      
 |      Tests whether two geometry objects intersect with one another. When applied to a sequence of geometry objects, `intersects` acts as a [filter](http://rethinkdb.com/api/python/filter), returning a sequence of objects from the sequence that intersect with the argument.
 |      
 |      *Example* Is `point2` within a 2000-meter circle around `point1`?
 |      
 |          > point1 = r.point(-117.220406,32.719464)
 |          > point2 = r.point(-117.206201,32.725186)
 |          > r.circle(point1, 2000).intersects(point2).run(conn)
 |          
 |          True
 |      
 |      *Example* Which of the locations in a list of parks intersect `circle1`?
 |      
 |          circle1 = r.circle([-117.220406,32.719464], 10, unit='mi')
 |          r.table('parks')('area').intersects(circle1).run(conn)
 |  
 |  is_empty(self, *args)
 |      sequence.is_empty() -> bool
 |      
 |      Test if a sequence is empty.
 |      
 |      *Example* Are there any documents in the marvel table?
 |      
 |          r.table('marvel').is_empty().run(conn)
 |  
 |  keys(self, *args)
 |      singleSelection.keys() -> array
 |      object.keys() -> array
 |      
 |      Return an array containing all of the object's keys.
 |      
 |      *Example* Get all the keys of a row.
 |      
 |          r.table('marvel').get('ironman').keys().run(conn)
 |  
 |  le(self, *args)
 |      value <= value -> bool
 |      value.le(value) -> bool
 |      
 |      Test if the first value is less than or equal to other.
 |      
 |      *Example* Is 2 less than or equal to 2?
 |      
 |          (r.expr(2) <= 2).run(conn)
 |          r.expr(2).le(2).run(conn)
 |  
 |  limit(self, *args)
 |      sequence.limit(n) -> stream
 |      array.limit(n) -> array
 |      
 |      End the sequence after the given number of elements.
 |      
 |      *Example* Only so many can fit in our Pantheon of heroes.
 |      
 |          r.table('marvel').order_by('belovedness').limit(10).run(conn)
 |  
 |  lt(self, *args)
 |      value < value -> bool
 |      value.lt(value) -> bool
 |      
 |      Test if the first value is less than other.
 |      
 |      *Example* Is 2 less than 2?
 |      
 |          (r.expr(2) < 2).run(conn)
 |          r.expr(2).lt(2).run(conn)
 |  
 |  map(self, *args)
 |      sequence1.map([sequence2, ...], mapping_function) -> stream
 |      array1.map([sequence2, ...], mapping_function) -> array
 |      r.map(sequence1[, sequence2, ...], mapping_function) -> stream
 |      r.map(array1[, array2, ...], mapping_function) -> array
 |      
 |      Transform each element of one or more sequences by applying a mapping function to them. If `map` is run with two or more sequences, it will iterate for as many items as there are in the shortest sequence.
 |      
 |      Note that `map` can only be applied to sequences, not single values. If you wish to apply a function to a single value/selection (including an array), use the [do](http://rethinkdb.com/api/python/do) command.
 |      
 |      *Example* Return the first five squares.
 |      
 |          > r.expr([1, 2, 3, 4, 5]).map(lambda val: (val * val)).run(conn)
 |          
 |          [1, 4, 9, 16, 25]
 |      
 |      *Example* Sum the elements of three sequences.
 |      
 |          > sequence1 = [100, 200, 300, 400]
 |          > sequence2 = [10, 20, 30, 40]
 |          > sequence3 = [1, 2, 3, 4]
 |          > r.map(sequence1, sequence2, sequence3,
 |              lambda val1, val2, val3: (val1 + val2 + val3)).run(conn)
 |          
 |          [111, 222, 333, 444]
 |      
 |      *Example* Rename a field when retrieving documents using `map` and `merge`.
 |      
 |      This example renames the field `id` to `user_id` when retrieving documents from the table `users`.
 |      
 |          r.table('users').map(
 |              lambda doc: doc.merge({'user_id': doc['id']}).without('id')).run(conn)
 |      
 |      Note that in this case, [row](http://rethinkdb.com/api/python/row) may be used as an alternative to writing an anonymous function, as it returns the same value as the function parameter receives:
 |      
 |          r.table('users').map(
 |              r.row.merge({'user_id': r.row['id']}).without('id')).run(conn)
 |      
 |      *Example* Assign every superhero an archenemy.
 |      
 |          r.table('heroes').map(r.table('villains'),
 |              lambda hero, villain: hero.merge({'villain': villain})).run(conn)
 |  
 |  match(self, *args)
 |      string.match(regexp) -> None/object
 |      
 |      Matches against a regular expression. If there is a match, returns an object with the fields:
 |      
 |      - `str`: The matched string
 |      - `start`: The matched string's start
 |      - `end`: The matched string's end
 |      - `groups`: The capture groups defined with parentheses
 |      
 |      If no match is found, returns `None`.
 |      
 |      Accepts RE2 syntax
 |      ([https://code.google.com/p/re2/wiki/Syntax](https://code.google.com/p/re2/wiki/Syntax)).
 |      You can enable case-insensitive matching by prefixing the regular expression with
 |      `(?i)`. See the linked RE2 documentation for more flags.
 |      
 |      The `match` command does not support backreferences.
 |      
 |      *Example* Get all users whose name starts with "A". Because `None` evaluates to `false` in
 |      `filter`, you can just use the result of `match` for the predicate.
 |      
 |          r.table('users').filter(lambda doc:
 |              doc['name'].match("^A")
 |          ).run(conn)
 |      
 |      *Example* Get all users whose name ends with "n".
 |      
 |          r.table('users').filter(lambda doc:
 |              doc['name'].match("n$")
 |          ).run(conn)
 |      
 |      *Example* Get all users whose name has "li" in it
 |      
 |          r.table('users').filter(lambda doc:
 |              doc['name'].match("li")
 |          ).run(conn)
 |      
 |      *Example* Get all users whose name is "John" with a case-insensitive search.
 |      
 |          r.table('users').filter(lambda doc:
 |              doc['name'].match("(?i)^john$")
 |          ).run(conn)
 |      
 |      *Example* Get all users whose name is composed of only characters between "a" and "z".
 |      
 |          r.table('users').filter(lambda doc:
 |              doc['name'].match("(?i)^[a-z]+$")
 |          ).run(conn)
 |      
 |      *Example* Get all users where the zipcode is a string of 5 digits.
 |      
 |          r.table('users').filter(lambda doc:
 |              doc['zipcode'].match("\d{5}")
 |          ).run(conn)
 |      
 |      *Example* Retrieve the domain of a basic email
 |      
 |          r.expr("name@domain.com").match(".*@(.*)").run(conn)
 |      
 |      Result:
 |      
 |          {
 |              "start": 0,
 |              "end": 20,
 |              "str": "name@domain.com",
 |              "groups":[
 |                  {
 |                      "end": 17,
 |                      "start": 7,
 |                      "str": "domain.com"
 |                  }
 |              ]
 |          }
 |      
 |      You can then retrieve only the domain with the [\[\]](http://rethinkdb.com/api/python/get_field) selector.
 |      
 |          r.expr("name@domain.com").match(".*@(.*)")["groups"][0]["str"].run(conn)
 |      
 |      Returns `'domain.com'`
 |      
 |      *Example* Fail to parse out the domain and returns `None`.
 |      
 |          r.expr("name[at]domain.com").match(".*@(.*)").run(conn)
 |  
 |  max(self, *args, **kwargs)
 |      sequence.max(field_or_function) -> element
 |      sequence.max(index='index') -> element
 |      
 |      Finds the maximum element of a sequence. The `max` command can be called with:
 |      
 |      * a **field name**, to return the element of the sequence with the largest value in that field;
 |      * an **index**, to return the element of the sequence with the largest value in that index;
 |      * a **function**, to apply the function to every element within the sequence and return the element which returns the largest value from the function, ignoring any elements where the function returns `None` or produces a non-existence error.
 |      
 |      Calling `max` on an empty sequence will throw a non-existence error; this can be handled using the [default](http://rethinkdb.com/api/python/default/) command.
 |      
 |      *Example* Return the maximum value in the list `[3, 5, 7]`.
 |      
 |          r.expr([3, 5, 7]).max().run(conn)
 |      
 |      *Example* Return the user who has scored the most points.
 |      
 |          r.table('users').max('points').run(conn)
 |      
 |      *Example* The same as above, but using a secondary index on the `points` field.
 |      
 |          r.table('users').max(index='points').run(conn)
 |      
 |      *Example* Return the user who has scored the most points, adding in bonus points from a separate field using a function.
 |      
 |          r.table('users').max(lambda user:
 |              user['points'] + user['bonus_points']
 |          ).run(conn)
 |      
 |      *Example* Return the highest number of points any user has ever scored. This returns the value of that `points` field, not a document.
 |      
 |          r.table('users').max('points')['points'].run(conn)
 |      
 |      *Example* Return the user who has scored the most points, but add a default `None` return value to prevent an error if no user has ever scored points.
 |      
 |          r.table('users').max('points').default(None).run(conn)
 |  
 |  merge(self, *args)
 |      singleSelection.merge(object|function) -> object
 |      object.merge(object|function) -> object
 |      sequence.merge(object|function) -> stream
 |      array.merge(object|function) -> array
 |      
 |      Merge two objects together to construct a new object with properties from both. Gives preference to attributes from other when there is a conflict. `merge` also accepts a subquery function that returns an object, which will be used similarly to a [map](http://rethinkdb.com/api/python/map/) function.
 |      
 |      *Example* Equip IronMan for battle.
 |      
 |          r.table('marvel').get('IronMan').merge(
 |              r.table('loadouts').get('alienInvasionKit')
 |          ).run(conn)
 |      
 |      *Example* Equip every hero for battle, using a subquery function to retrieve their weapons.
 |      
 |          r.table('marvel').merge(lambda hero:
 |              { 'weapons': r.table('weapons').get(hero['weapon_id']) }
 |          ).run(conn)
 |      
 |      *Example* Use `merge` to join each blog post with its comments.
 |      
 |      Note that the sequence being merged&mdash;in this example, the comments&mdash;must be coerced from a selection to an array. Without `coerce_to` the operation will throw an error ("Expected type DATUM but found SELECTION").
 |      
 |          r.table('posts').merge(lambda post:
 |              { 'comments': r.table('comments').get_all(post['id'],
 |                  index='post_id').coerce_to('array') }
 |          ).run(conn)
 |      
 |      *Example* Merge can be used recursively to modify object within objects.
 |      
 |          r.expr({'weapons' : {'spectacular graviton beam' : {'dmg' : 10, 'cooldown' : 20}}}).merge(
 |              {'weapons' : {'spectacular graviton beam' : {'dmg' : 10}}}
 |          ).run(conn)
 |      
 |      *Example* To replace a nested object with another object you can use the literal keyword.
 |      
 |          r.expr({'weapons' : {'spectacular graviton beam' : {'dmg' : 10, 'cooldown' : 20}}}).merge(
 |              {'weapons' : r.literal({'repulsor rays' : {'dmg' : 3, 'cooldown' : 0}})}
 |          ).run(conn)
 |      
 |      *Example* Literal can be used to remove keys from an object as well.
 |      
 |          r.expr({'weapons' : {'spectacular graviton beam' : {'dmg' : 10, 'cooldown' : 20}}}).merge(
 |              {'weapons' : {'spectacular graviton beam' : r.literal()}}
 |          ).run(conn)
 |  
 |  min(self, *args, **kwargs)
 |      sequence.min(field_or_function) -> element
 |      sequence.min(index='index') -> element
 |      
 |      Finds the minimum element of a sequence. The `min` command can be called with:
 |      
 |      * a **field name**, to return the element of the sequence with the smallest value in that field;
 |      * an **index**, to return the element of the sequence with the smallest value in that index;
 |      * a **function**, to apply the function to every element within the sequence and return the element which returns the smallest value from the function, ignoring any elements where the function returns `None` or produces a non-existence error.
 |      
 |      Calling `min` on an empty sequence will throw a non-existence error; this can be handled using the [default](http://rethinkdb.com/api/python/default/) command.
 |      
 |      *Example* Return the minimum value in the list `[3, 5, 7]`.
 |      
 |          r.expr([3, 5, 7]).min().run(conn)
 |      
 |      *Example* Return the user who has scored the fewest points.
 |      
 |          r.table('users').min('points').run(conn)
 |      
 |      *Example* The same as above, but using a secondary index on the `points` field.
 |      
 |          r.table('users').min(index='points').run(conn)
 |      
 |      *Example* Return the user who has scored the fewest points, adding in bonus points from a separate field using a function.
 |      
 |          r.table('users').min(lambda user:
 |              user['points'] + user['bonus_points']
 |          ).run(conn)
 |      
 |      *Example* Return the smallest number of points any user has ever scored. This returns the value of that `points` field, not a document.
 |      
 |          r.table('users').min('points')['points'].run(conn)
 |      
 |      *Example* Return the user who has scored the fewest points, but add a default `None` return value to prevent an error if no user has ever scored points.
 |      
 |          r.table('users').min('points').default(None).run(conn)
 |  
 |  minutes(self, *args)
 |      time.minutes() -> number
 |      
 |      Return the minute in a time object as a number between 0 and 59.
 |      
 |      *Example* Return all the posts submitted during the first 10 minutes of every hour.
 |      
 |          r.table("posts").filter(lambda post:
 |              post["date"].minutes() < 10
 |          ).run(conn)
 |  
 |  mod(self, *args)
 |  
 |  month(self, *args)
 |      time.month() -> number
 |      
 |      Return the month of a time object as a number between 1 and 12. For your convenience, the terms r.january, r.february etc. are defined and map to the appropriate integer.
 |      
 |      *Example* Retrieve all the users who were born in November.
 |      
 |          r.table("users").filter(
 |              r.row["birthdate"].month() == 11
 |          )
 |      
 |      *Example* Retrieve all the users who were born in November.
 |      
 |          r.table("users").filter(
 |              r.row["birthdate"].month() == r.november
 |          )
 |  
 |  mul(self, *args)
 |  
 |  ne(self, *args)
 |      value != value -> bool
 |      value.ne(value) -> bool
 |      
 |      Test if two values are not equal.
 |      
 |      *Example* Does 2 not equal 2?
 |      
 |          (r.expr(2) != 2).run(conn)
 |          r.expr(2).ne(2).run(conn)
 |  
 |  not_(self, *args)
 |      bool.not_() -> bool
 |      not_(bool) -> bool
 |      (~bool) -> bool
 |      
 |      Compute the logical inverse (not) of an expression.
 |      
 |      `not_` can be called either via method chaining, immediately after an expression that evaluates as a boolean value, or by passing the expression as a parameter to `not_`.  All values that are not `False` or `None` will be converted to `True`.
 |      
 |      You may also use `~` as a shorthand operator.
 |      
 |      *Example* Not true is false.
 |      
 |          r.not_(True).run(conn)
 |          r.expr(True).not_().run(conn)
 |          (~r.expr(True)).run(conn)
 |      
 |      These evaluate to `false`.
 |      
 |      Note that when using `~` the expression is wrapped in parentheses. Without this, Python will evaluate `r.expr(True)` *first* rather than using the ReQL operator and return an incorrect value. (`~True` evaluates to &minus;2 in Python.)
 |      
 |      *Example* Return all the users that do not have a "flag" field.
 |      
 |          r.table('users').filter(
 |              lambda users: (~users.has_fields('flag'))
 |          ).run(conn)
 |      
 |      *Example* As above, but prefix-style.
 |      
 |          r.table('users').filter(
 |              lambda users: r.not_(users.has_fields('flag'))
 |          ).run(conn)
 |  
 |  nth(self, *args)
 |      sequence.nth(index) -> object
 |      selection.nth(index) -> selection&lt;object&gt;
 |      
 |      Get the *nth* element of a sequence, counting from zero. If the argument is negative, count from the last element.
 |      
 |      In Python, you can use `[]` with an integer as a shorthand for `nth`.
 |      
 |      *Example* Select the second element in the array.
 |      
 |          r.expr([1,2,3]).nth(1).run(conn)
 |          r.expr([1,2,3])[1].run(conn)
 |      
 |      *Example* Select the bronze medalist from the competitors.
 |      
 |          r.table('players').order_by(index=r.desc('score')).nth(3).run(conn)
 |      
 |      *Example* Select the last place competitor.
 |      
 |          r.table('players').order_by(index=r.desc('score')).nth(-1).run(conn)
 |  
 |  offsets_of(self, *args)
 |      sequence.offsets_of(datum | predicate) -> array
 |      
 |      Get the indexes of an element in a sequence. If the argument is a predicate, get the indexes of all elements matching it.
 |      
 |      *Example* Find the position of the letter 'c'.
 |      
 |          r.expr(['a','b','c']).offsets_of('c').run(conn)
 |      
 |      *Example* Find the popularity ranking of invisible heroes.
 |      
 |          r.table('marvel').union(r.table('dc')).order_by('popularity').offsets_of(
 |              r.row['superpowers'].contains('invisibility')
 |          ).run(conn)
 |  
 |  or_(self, *args)
 |  
 |  order_by(self, *args, **kwargs)
 |      table.order_by([key1...], index=index_name) -> selection<stream>
 |      selection.order_by(key1, [key2...]) -> selection<array>
 |      sequence.order_by(key1, [key2...]) -> array
 |      
 |      Sort the sequence by document values of the given key(s). To specify
 |      the ordering, wrap the attribute with either `r.asc` or `r.desc`
 |      (defaults to ascending).
 |      
 |      __Note:__ RethinkDB uses byte-wise ordering for `orderBy` and does not support Unicode collations; non-ASCII characters will be sorted by UTF-8 codepoint.
 |      
 |      Sorting without an index requires the server to hold the sequence in
 |      memory, and is limited to 100,000 documents (or the setting of the `arrayLimit` option for [run](http://rethinkdb.com/api/python/run)). Sorting with an index can
 |      be done on arbitrarily large tables, or after a `between` command
 |      using the same index.
 |      
 |      *Example* Order all the posts using the index `date`.   
 |      
 |          r.table('posts').order_by(index='date').run(conn)
 |      
 |      The index must have been previously created with [index_create](http://rethinkdb.com/api/python/index_create/).
 |      
 |          r.table('posts').index_create('date').run(conn)
 |      
 |      You can also select a descending ordering:
 |      
 |          r.table('posts').order_by(index=r.desc('date')).run(conn, callback)
 |      
 |      *Example* Order a sequence without an index.
 |      
 |          r.table('posts').get(1)['comments'].order_by('date')
 |      
 |      You can also select a descending ordering:
 |      
 |          r.table('posts').get(1)['comments'].order_by(r.desc('date'))
 |      
 |      If you're doing ad-hoc analysis and know your table won't have more then 100,000
 |      elements (or you've changed the setting of the `arrayLimit` option for [run](http://rethinkdb.com/api/python/run)) you can run `order_by` without an index:
 |      
 |          r.table('small_table').order_by('date')
 |      
 |      *Example* You can efficiently order using multiple fields by using a
 |      [compound index](http://www.rethinkdb.com/docs/secondary-indexes/python/).
 |      
 |      Order by date and title.
 |      
 |          r.table('posts').order_by(index='date_and_title').run(conn)
 |      
 |      The index must have been previously created with [index_create](http://rethinkdb.com/api/python/index_create/).
 |      
 |          r.table('posts').index_create('date_and_title', lambda post:
 |              [post["date"], post["title"]]).run(conn)
 |      
 |      _Note_: You cannot specify multiple orders in a compound index. See [issue #2306](https://github.com/rethinkdb/rethinkdb/issues/2306)
 |      to track progress.
 |      
 |      *Example* If you have a sequence with fewer documents than the `array_limit`, you can order it
 |      by multiple fields without an index.
 |      
 |          r.table('small_table').order_by('date', r.desc('title'))
 |      
 |      *Example* Notice that an index ordering always has highest
 |      precedence. The following query orders posts by date, and if multiple
 |      posts were published on the same date, they will be ordered by title.
 |      
 |          r.table('post').order_by('title', index='date').run(conn)
 |      *Example* You can use [nested field](http://rethinkdb.com/docs/cookbook/python/#filtering-based-on-nested-fields) syntax to sort on fields from subdocuments. (You can also create indexes on nested fields using this syntax with `index_create`.)
 |      
 |          r.table('user').order_by(lambda user: user['group']['id']).run(conn)
 |      
 |      *Example* You can efficiently order data on arbitrary expressions using indexes.
 |      
 |          r.table('posts').order_by(index='votes').run(conn)
 |      
 |      The index must have been previously created with [index_create](http://rethinkdb.com/api/ruby/index_create/).
 |      
 |          r.table('posts').index_create('votes', lambda post:
 |              post["upvotes"]-post["downvotes"]
 |          ).run(conn)
 |      
 |      *Example* If you have a sequence with fewer documents than the `array_limit`, you can order it with an arbitrary function directly.
 |      
 |          r.table('small_table').order_by(lambda doc:
 |              doc['upvotes']-doc['downvotes']
 |          );
 |      
 |      You can also select a descending ordering:
 |      
 |          r.table('small_table').order_by(r.desc(lambda doc:
 |              doc['upvotes']-doc['downvotes']
 |          ));
 |      
 |      *Example* Ordering after a `between` command can be done as long as the same index is being used.
 |      
 |          r.table("posts").between(r.time(2013, 1, 1, '+00:00'), r.time(2013, 1, 1, '+00:00'), index='date')
 |              .order_by(index='date').run(conn);
 |  
 |  outer_join(self, *args)
 |      sequence.outer_join(other_sequence, predicate) -> stream
 |      array.outer_join(other_sequence, predicate) -> array
 |      
 |      Returns a left outer join of two sequences. The returned sequence represents a union of the left-hand sequence and the right-hand sequence: all documents in the left-hand sequence will be returned, each matched with a document in the right-hand sequence if one satisfies the predicate condition. In most cases, you will want to follow the join with [zip](http://rethinkdb.com/api/python/zip) to combine the left and right results.
 |      
 |      Note that `outer_join` is slower and much less efficient than using [concat_map](http://rethinkdb.com/api/python/concat_map/) with [get_all](http://rethinkdb.com/api/python/get_all). You should avoid using `outer_join` in commands when possible.
 |      
 |      *Example* Return a list of all Marvel heroes, paired with any DC heroes who could beat them in a fight.
 |      
 |          r.table('marvel').outer_join(r.table('dc'),
 |            lambda marvel_row, dc_row: marvel_row['strength'] < dc_row['strength']
 |          ).zip().run(conn)
 |      
 |      (Compare this to an [inner_join](http://rethinkdb.com/api/python/inner_join) with the same inputs and predicate, which would return a list only of the matchups in which the DC hero has the higher strength.)
 |  
 |  pluck(self, *args)
 |      sequence.pluck([selector1, selector2...]) -> stream
 |      array.pluck([selector1, selector2...]) -> array
 |      object.pluck([selector1, selector2...]) -> object
 |      singleSelection.pluck([selector1, selector2...]) -> object
 |      
 |      Plucks out one or more attributes from either an object or a sequence of objects
 |      (projection).
 |      
 |      *Example* We just need information about IronMan's reactor and not the rest of the
 |      document.
 |      
 |          r.table('marvel').get('IronMan').pluck('reactorState', 'reactorPower').run(conn)
 |      
 |      *Example* For the hero beauty contest we only care about certain qualities.
 |      
 |          r.table('marvel').pluck('beauty', 'muscleTone', 'charm').run(conn)
 |      
 |      *Example* Pluck can also be used on nested objects.
 |      
 |          r.table('marvel').pluck({'abilities' : {'damage' : True, 'mana_cost' : True}, 'weapons' : True}).run(conn)
 |      
 |      *Example* The nested syntax can quickly become overly verbose so there's a shorthand
 |      for it.
 |      
 |          r.table('marvel').pluck({'abilities' : ['damage', 'mana_cost']}, 'weapons').run(conn)
 |      
 |      For more information read the [nested field documentation](http://rethinkdb.com/docs/nested-fields/).
 |  
 |  polygon_sub(self, *args)
 |      polygon1.polygon_sub(polygon2) -> polygon
 |      
 |      Use `polygon2` to "punch out" a hole in `polygon1`. `polygon2` must be completely contained within `polygon1` and must have no holes itself (it must not be the output of `polygon_sub` itself).
 |      
 |      *Example* Define a polygon with a hole punched in it.
 |      
 |          outer_polygon = r.polygon(
 |              [-122.4,37.7],
 |              [-122.4,37.3],
 |              [-121.8,37.3],
 |              [-121.8,37.7]
 |          )
 |          inner_polygon = r.polygon(
 |              [-122.3,37.4],
 |              [-122.3,37.6],
 |              [-122.0,37.6],
 |              [-122.0,37.4]
 |          )
 |          outer_polygon.polygon_sub(inner_polygon).run(conn)
 |  
 |  prepend(self, *args)
 |      array.prepend(value) -> array
 |      
 |      Prepend a value to an array.
 |      
 |      *Example* Retrieve Iron Man's equipment list with the addition of some new boots.
 |      
 |          r.table('marvel').get('IronMan')['equipment'].prepend('newBoots').run(conn)
 |  
 |  reduce(self, *args)
 |      sequence.reduce(reduction_function) -> value
 |      
 |      Produce a single value from a sequence through repeated application of a reduction
 |      function.  
 |      The reduction function can be called on:
 |      
 |      - two elements of the sequence
 |      - one element of the sequence and one result of a previous reduction
 |      - two results of previous reductions
 |      
 |      The reduction function can be called on the results of two previous reductions because the
 |      `reduce` command is distributed and parallelized across shards and CPU cores. A common
 |      mistaken when using the `reduce` command is to suppose that the reduction is executed
 |      from left to right. Read the [map-reduce in RethinkDB](http://rethinkdb.com/docs/map-reduce/) article to
 |      see an example.
 |      
 |      If the sequence is empty, the server will produce a `RqlRuntimeError` that can be
 |      caught with `default`.  
 |      If the sequence has only one element, the first element will be returned.
 |      
 |      *Example* Return the number of documents in the table `posts`.
 |      
 |          r.table("posts").map(lambda doc: 1)
 |              .reduce(lambda left, right: left+right)
 |              .default(0).run(conn)
 |      
 |      A shorter way to execute this query is to use [count](http://rethinkdb.com/api/python/count).
 |      
 |      *Example* Suppose that each `post` has a field `comments` that is an array of
 |      comments.  
 |      Return the number of comments for all posts.
 |      
 |          r.table("posts").map(lambda doc:
 |              doc["comments"].count()
 |          ).reduce(lambda left, right:
 |              left+right
 |          ).default(0).run(conn)
 |      
 |      *Example* Suppose that each `post` has a field `comments` that is an array of
 |      comments.  
 |      Return the maximum number comments per post.
 |      
 |          r.table("posts").map(lambda doc:
 |              doc["comments"].count()
 |          ).reduce(lambda left, right:
 |              r.branch(
 |                  left > right,
 |                  left,
 |                  right
 |              )
 |          ).default(0).run(conn)
 |      
 |      A shorter way to execute this query is to use [max](http://rethinkdb.com/api/python/max).
 |  
 |  replace(self, *args, **kwargs)
 |      table.replace(json | expr[, durability="hard", return_changes=False, non_atomic=False])
 |          -> object
 |      selection.replace(json | expr[, durability="hard", return_changes=False, non_atomic=False])
 |          -> object
 |      singleSelection.replace(json | expr[, durability="hard", return_changes=False, non_atomic=False])
 |          -> object
 |      
 |      Replace documents in a table. Accepts a JSON document or a ReQL expression, and replaces
 |      the original document with the new one. The new document must have the same primary key
 |      as the original document.
 |      
 |      The optional arguments are:
 |      
 |      - `durability`: possible values are `hard` and `soft`. This option will override the
 |      table or query's durability setting (set in [run](http://rethinkdb.com/api/python/run/)).  
 |      In soft durability mode RethinkDB will acknowledge the write immediately after
 |      receiving it, but before the write has been committed to disk.
 |      - `return_changes`: if set to `True`, return a `changes` array consisting of `old_val`/`new_val` objects describing the changes made.
 |      - `non_atomic`: if set to `True`, executes the replacement and distributes the result to replicas in a non-atomic fashion. This flag is required to perform non-deterministic updates, such as those that require reading data from another table.
 |      
 |      Replace returns an object that contains the following attributes:
 |      
 |      - `replaced`: the number of documents that were replaced
 |      - `unchanged`: the number of documents that would have been modified, except that the
 |      new value was the same as the old value
 |      - `inserted`: the number of new documents added. You can have new documents inserted if
 |      you do a point-replace on a key that isn't in the table or you do a replace on a
 |      selection and one of the documents you are replacing has been deleted
 |      - `deleted`: the number of deleted documents when doing a replace with `None`
 |      - `errors`: the number of errors encountered while performing the replace.
 |      - `first_error`: If errors were encountered, contains the text of the first error.
 |      - `skipped`: 0 for a replace operation
 |      - `changes`: if `return_changes` is set to `True`, this will be an array of objects, one for each objected affected by the `replace` operation. Each object will have two keys: `{"new_val": <new value>, "old_val": <old value>}`.
 |      
 |      *Example* Replace the document with the primary key `1`.
 |      
 |          r.table("posts").get(1).replace({
 |              "id": 1,
 |              "title": "Lorem ipsum",
 |              "content": "Aleas jacta est",
 |              "status": "draft"
 |          }).run(conn)
 |      
 |      *Example* Remove the field `status` from all posts.
 |      
 |          r.table("posts").replace(lambda post:
 |              post.without("status")
 |          ).run(conn)
 |      
 |      *Example* Remove all the fields that are not `id`, `title` or `content`.
 |      
 |          r.table("posts").replace(lambda post:
 |              post.pluck("id", "title", "content")
 |          ).run(conn)
 |      
 |      *Example* Replace the document with the primary key `1` using soft durability.
 |      
 |          r.table("posts").get(1).replace({
 |              "id": 1,
 |              "title": "Lorem ipsum",
 |              "content": "Aleas jacta est",
 |              "status": "draft"
 |          }, durability="soft").run(conn)
 |      
 |      *Example* Replace the document with the primary key `1` and return the values of the document before
 |      and after the replace operation.
 |      
 |          r.table("posts").get(1).replace({
 |              "id": 1,
 |              "title": "Lorem ipsum",
 |              "content": "Aleas jacta est",
 |              "status": "published"
 |          }, return_changes=True).run(conn)
 |      
 |      The result will have a `changes` field:
 |      
 |          {
 |              "deleted": 0,
 |              "errors":  0,
 |              "inserted": 0,
 |              "changes": [
 |                  {
 |                      "new_val": {
 |                          "id":1,
 |                          "title": "Lorem ipsum"
 |                          "content": "Aleas jacta est",
 |                          "status": "published",
 |                      },
 |                      "old_val": {
 |                          "id":1,
 |                          "title": "Lorem ipsum"
 |                          "content": "TODO",
 |                          "status": "draft",
 |                          "author": "William",
 |                      }
 |                  }
 |              ],   
 |              "replaced": 1,
 |              "skipped": 0,
 |              "unchanged": 0
 |          }
 |  
 |  run(self, c=None, **global_optargs)
 |      query.run(conn, use_outdated=False, time_format='native', profile=False, durability="hard") -> cursor
 |      query.run(conn, use_outdated=False, time_format='native', profile=False, durability="hard") -> object
 |      
 |      Run a query on a connection, returning either a single JSON result or
 |      a cursor, depending on the query.
 |      
 |      The optional arguments are:
 |      
 |      - `use_outdated`: whether or not outdated reads are OK (default: `False`).
 |      - `time_format`: what format to return times in (default: `'native'`).
 |        Set this to `'raw'` if you want times returned as JSON objects for exporting.
 |      - `profile`: whether or not to return a profile of the query's
 |        execution (default: `False`).
 |      - `durability`: possible values are `'hard'` and `'soft'`. In soft durability mode RethinkDB
 |      will acknowledge the write immediately after receiving it, but before the write has
 |      been committed to disk.
 |      - `group_format`: what format to return `grouped_data` and `grouped_streams` in (default: `'native'`).
 |        Set this to `'raw'` if you want the raw pseudotype.
 |      - `noreply`: set to `True` to not receive the result object or cursor and return immediately.
 |      - `db`: the database to run this query against as a string. The default is the database specified in the `db` parameter to [connect](http://rethinkdb.com/api/python/connect/) (which defaults to `test`). The database may also be specified with the [db](http://rethinkdb.com/api/python/db/) command.
 |      - `array_limit`: the maximum numbers of array elements that can be returned by a query (default: 100,000). This affects all ReQL commands that return arrays. Note that it has no effect on the size of arrays being _written_ to the database; those always have an upper limit of 100,000 elements.
 |      - `binary_format`: what format to return binary data in (default: `'native'`). Set this to `'raw'` if you want the raw pseudotype.
 |      - `min_batch_rows`: minimum number of rows to wait for before batching a result set (default: 8). This is an integer.
 |      - `max_batch_rows`: maximum number of rows to wait for before batching a result set (default: unlimited). This is an integer.
 |      - `max_batch_bytes`: maximum number of bytes to wait for before batching a result set (default: 1024). This is an integer.
 |      - `max_batch_seconds`: maximum number of seconds to wait before batching a result set (default: 0.5). This is a float (not an integer) and may be specified to the microsecond.
 |      - `first_batch_scaledown_factor`: factor to scale the other parameters down by on the first batch (default: 4). For example, with this set to 8 and `max_batch_rows` set to 80, on the first batch `max_batch_rows` will be adjusted to 10 (80 / 8). This allows the first batch to return faster.
 |      
 |      *Example* Run a query on the connection `conn` and print out every
 |      row in the result.
 |      
 |          for doc in r.table('marvel').run(conn):
 |              print doc
 |      
 |      *Example* If you are OK with potentially out of date data from all
 |      the tables involved in this query and want potentially faster reads,
 |      pass a flag allowing out of date data in an options object. Settings
 |      for individual tables will supercede this global setting for all
 |      tables in the query.
 |      
 |          r.table('marvel').run(conn, use_outdated=True)
 |      
 |      *Example* If you just want to send a write and forget about it, you
 |      can set `noreply` to true in the options. In this case `run` will
 |      return immediately.
 |      
 |          r.table('marvel').run(conn, noreply=True)
 |      
 |      *Example* If you want to specify whether to wait for a write to be
 |      written to disk (overriding the table's default settings), you can set
 |      `durability` to `'hard'` or `'soft'` in the options.
 |      
 |          r.table('marvel')
 |              .insert({ 'superhero': 'Iron Man', 'superpower': 'Arc Reactor' })
 |              .run(conn, noreply=True, durability='soft')
 |      
 |      *Example* If you do not want a time object to be converted to a
 |      native date object, you can pass a `time_format` flag to prevent it
 |      (valid flags are "raw" and "native"). This query returns an object
 |      with two fields (`epoch_time` and `$reql_type$`) instead of a native date
 |      object.
 |      
 |          r.now().run(conn, time_format="raw")
 |      
 |      *Example* Specify the database to use for the query.
 |      
 |          for doc in r.table('marvel').run(conn, db='heroes'):
 |              print doc
 |      
 |      This is equivalent to using the `db` command to specify the database:
 |      
 |          r.db('heroes').table('marvel').run(conn) ...
 |      
 |      *Example* Change the batching parameters for this query.
 |      
 |          r.table('marvel').run(conn, max_batch_rows=16, max_batch_bytes=2048)
 |  
 |  sample(self, *args)
 |      sequence.sample(number) -> selection
 |      stream.sample(number) -> array
 |      array.sample(number) -> array
 |      
 |      Select a given number of elements from a sequence with uniform random distribution. Selection is done without replacement.
 |      
 |      If the sequence has less than the requested number of elements (i.e., calling `sample(10)` on a sequence with only five elements), `sample` will return the entire sequence in a random order.
 |      
 |      *Example* Select 3 random heroes.
 |      
 |          r.table('marvel').sample(3).run(conn)
 |  
 |  seconds(self, *args)
 |      time.seconds() -> number
 |      
 |      Return the seconds in a time object as a number between 0 and 59.999 (double precision).
 |      
 |      *Example* Return the post submitted during the first 30 seconds of every minute.
 |      
 |          r.table("posts").filter(lambda post:
 |              post["date"].seconds() < 30
 |          ).run(conn)
 |  
 |  set_difference(self, *args)
 |      array.set_difference(array) -> array
 |      
 |      Remove the elements of one array from another and return them as a set (an array with
 |      distinct values).
 |      
 |      *Example* Check which pieces of equipment Iron Man has, excluding a fixed list.
 |      
 |          r.table('marvel').get('IronMan')['equipment'].set_difference(['newBoots', 'arc_reactor']).run(conn)
 |  
 |  set_insert(self, *args)
 |      array.set_insert(value) -> array
 |      
 |      Add a value to an array and return it as a set (an array with distinct values).
 |      
 |      *Example* Retrieve Iron Man's equipment list with the addition of some new boots.
 |      
 |          r.table('marvel').get('IronMan')['equipment'].set_insert('newBoots').run(conn)
 |  
 |  set_intersection(self, *args)
 |      array.set_intersection(array) -> array
 |      
 |      Intersect two arrays returning values that occur in both of them as a set (an array with
 |      distinct values).
 |      
 |      *Example* Check which pieces of equipment Iron Man has from a fixed list.
 |      
 |          r.table('marvel').get('IronMan')['equipment'].set_intersection(['newBoots', 'arc_reactor']).run(conn)
 |  
 |  set_union(self, *args)
 |      array.set_union(array) -> array
 |      
 |      Add a several values to an array and return it as a set (an array with distinct values).
 |      
 |      *Example* Retrieve Iron Man's equipment list with the addition of some new boots and an arc reactor.
 |      
 |          r.table('marvel').get('IronMan')['equipment'].set_union(['newBoots', 'arc_reactor']).run(conn)
 |  
 |  skip(self, *args)
 |      sequence.skip(n) -> stream
 |      array.skip(n) -> array
 |      
 |      Skip a number of elements from the head of the sequence.
 |      
 |      *Example* Here in conjunction with `order_by` we choose to ignore the most successful heroes.
 |      
 |          r.table('marvel').order_by('successMetric').skip(10).run(conn)
 |  
 |  slice(self, *args, **kwargs)
 |      selection.slice(start_index[, end_index, left_bound='closed', right_bound='open']) -> selection
 |      stream.slice(start_index[, end_index, left_bound='closed', right_bound='open']) -> stream
 |      array.slice(start_index[, end_index, left_bound='closed', right_bound='open']) -> array
 |      binary.slice(start_index[, end_index, left_bound='closed', right_bound='open']) -> binary
 |      
 |      Return the elements of a sequence within the specified range.
 |      
 |      `slice` returns the range between `start_index` and `end_index`. If only `start_index` is specified, `slice` returns the range from that index to the end of the sequence. Specify `left_bound` or `right_bound` as `open` or `closed` to indicate whether to include that endpoint of the range by default: `closed` returns that endpoint, while `open` does not. By default, `left_bound` is closed and `right_bound` is open, so the range `(10,13)` will return the tenth, eleventh and twelfth elements in the sequence.
 |      
 |      If `end_index` is past the end of the sequence, all elements from `start_index` to the end of the sequence will be returned. If `start_index` is past the end of the sequence or `end_index` is less than `start_index`, a zero-element sequence will be returned (although see below for negative `end_index` values). An error will be raised on a negative `start_index`.
 |      
 |      A negative `end_index` is allowed with arrays; in that case, the returned range counts backward from the array's end. That is, the range of `(2,-1)` returns the second element through the next-to-last element of the range. A negative `end_index` is not allowed with a stream. (An `end_index` of &minus;1 *is* allowed with a stream if `right_bound` is closed; this behaves as if no `end_index` was specified.)
 |      
 |      If `slice` is used with a [binary](http://rethinkdb.com/api/python/binary) object, the indexes refer to byte positions within the object. That is, the range `(10,20)` will refer to the 10th byte through the 19th byte.
 |      
 |      If you are only specifying the indexes and not the bounding options, you may use Python's slice operator as a shorthand: `[start_index:end_index]`.
 |      
 |      **Example:** Return the fourth, fifth and sixth youngest players. (The youngest player is at index 0, so those are elements 3&ndash;5.)
 |      
 |          r.table('players').order_by(index='age').slice(3,6).run(conn)
 |      
 |      Or, using Python's slice operator:
 |      
 |          r.table('players').filter({'class': 'amateur'})[10:20].run(conn)
 |      
 |      **Example:** Return all but the top three players who have a red flag.
 |      
 |          r.table('players').filter({'flag': 'red'}).order_by(index=r.desc('score')).slice(3).run(conn)
 |      
 |      **Example:** Return holders of tickets `X` through `Y`, assuming tickets are numbered sequentially. We want to include ticket `Y`.
 |      
 |          r.table('users').order_by(index='ticket').slice(x, y, right_bound='closed').run(conn)
 |      
 |      **Example:** Return the elements of an array from the second through two from the end (that is, not including the last two).
 |      
 |          r.expr([0,1,2,3,4,5]).slice(2,-2).run(conn)
 |      
 |      Result:
 |      
 |          [2,3]
 |  
 |  splice_at(self, *args)
 |      array.splice_at(index, array) -> array
 |      
 |      Insert several values in to an array at a given index. Returns the modified array.
 |      
 |      *Example* Hulk and Thor decide to join the avengers.
 |      
 |          r.expr(["Iron Man", "Spider-Man"]).splice_at(1, ["Hulk", "Thor"]).run(conn)
 |  
 |  split(self, *args)
 |      string.split([separator, [max_splits]]) -> array
 |      
 |      Splits a string into substrings.  Splits on whitespace when called
 |      with no arguments.  When called with a separator, splits on that
 |      separator.  When called with a separator and a maximum number of
 |      splits, splits on that separator at most `max_splits` times.  (Can be
 |      called with `None` as the separator if you want to split on whitespace
 |      while still specifying `max_splits`.)
 |      
 |      Mimics the behavior of Python's `string.split` in edge cases, except
 |      for splitting on the empty string, which instead produces an array of
 |      single-character strings.
 |      
 |      *Example* Split on whitespace.
 |      
 |          > r.expr("foo  bar bax").split().run(conn)
 |          ["foo", "bar", "bax"]
 |      
 |      *Example* Split the entries in a CSV file.
 |      
 |          > r.expr("12,37,,22,").split(",").run(conn)
 |          ["12", "37", "", "22", ""]
 |      
 |      *Example* Split a string into characters.
 |      
 |          > r.expr("mlucy").split("").run(conn)
 |          ["m", "l", "u", "c", "y"]
 |      
 |      *Example* Split the entries in a CSV file, but only at most 3
 |      times.
 |      
 |          > r.expr("12,37,,22,").split(",", 3).run(conn)
 |          ["12", "37", "", "22,"]
 |      
 |      *Example* Split on whitespace at most once (i.e. get the first word).
 |      
 |          > r.expr("foo  bar bax").split(None, 1).run(conn)
 |          ["foo", "bar bax"]
 |  
 |  sub(self, *args)
 |  
 |  sum(self, *args)
 |      sequence.sum([field_or_function]) -> number
 |      
 |      Sums all the elements of a sequence.  If called with a field name,
 |      sums all the values of that field in the sequence, skipping elements
 |      of the sequence that lack that field.  If called with a function,
 |      calls that function on every element of the sequence and sums the
 |      results, skipping elements of the sequence where that function returns
 |      `None` or a non-existence error.
 |      
 |      Returns `0` when called on an empty sequence.
 |      
 |      *Example* What's 3 + 5 + 7?
 |      
 |          r.expr([3, 5, 7]).sum().run(conn)
 |      
 |      *Example* How many points have been scored across all games?
 |      
 |          r.table('games').sum('points').run(conn)
 |      
 |      *Example* How many points have been scored across all games,
 |      counting bonus points?
 |      
 |          r.table('games').sum(lambda game:
 |              game['points'] + game['bonus_points']
 |          ).run(conn)
 |  
 |  time_of_day(self, *args)
 |      time.time_of_day() -> number
 |      
 |      Return the number of seconds elapsed since the beginning of the day stored in the time object.
 |      
 |      *Example* Retrieve posts that were submitted before noon.
 |      
 |          r.table("posts").filter(
 |              r.row["date"].time_of_day() <= 12*60*60
 |          ).run(conn)
 |  
 |  timezone(self, *args)
 |      time.timezone() -> string
 |      
 |      Return the timezone of the time object.
 |      
 |      *Example* Return all the users in the "-07:00" timezone.
 |      
 |          r.table("users").filter(lambda user:
 |              user["subscriptionDate"].timezone() == "-07:00"
 |          )
 |  
 |  to_epoch_time(self, *args)
 |      time.to_epoch_time() -> number
 |      
 |      Convert a time object to its epoch time.
 |      
 |      *Example* Return the current time in seconds since the Unix Epoch with millisecond-precision.
 |      
 |          r.now().to_epoch_time()
 |  
 |  to_geojson(self, *args)
 |      geometry.to_geojson() -> object
 |      
 |      Convert a ReQL geometry object to a [GeoJSON][] object.
 |      
 |      [GeoJSON]: http://geojson.org
 |      
 |      *Example* Convert a ReQL geometry object to a GeoJSON object.
 |      
 |          > r.table(geo).get('sfo')['location'].to_geojson.run(conn)
 |          
 |          {
 |              'type': 'Point',
 |              'coordinates': [ -122.423246, 37.779388 ]
 |          }
 |  
 |  to_iso8601(self, *args)
 |      time.to_iso8601() -> number
 |      
 |      Convert a time object to its iso 8601 format.
 |      
 |      *Example* Return the current time in an ISO8601 format.
 |      
 |          r.now().to_iso8601()
 |  
 |  to_json(self, *args)
 |      value.to_json_string() -> string
 |      value.to_json() -> string
 |      
 |      Convert a ReQL value or object to a JSON string. You may use either `to_json_string` or `to_json`.
 |      
 |      *Example* Get a ReQL document as a JSON string.
 |      
 |          > r.table('hero').get(1).to_json()
 |          
 |          '{"id": 1, "name": "Batman", "city": "Gotham", "powers": ["martial arts", "cinematic entrances"]}'
 |  
 |  to_json_string(self, *args)
 |      value.to_json_string() -> string
 |      value.to_json() -> string
 |      
 |      Convert a ReQL value or object to a JSON string. You may use either `to_json_string` or `to_json`.
 |      
 |      *Example* Get a ReQL document as a JSON string.
 |      
 |          > r.table('hero').get(1).to_json()
 |          
 |          '{"id": 1, "name": "Batman", "city": "Gotham", "powers": ["martial arts", "cinematic entrances"]}'
 |  
 |  type_of(self, *args)
 |      any.type_of() -> string
 |      
 |      Gets the type of a value.
 |      
 |      *Example* Get the type of a string.
 |      
 |          r.expr("foo").type_of().run(conn)
 |  
 |  ungroup(self, *args)
 |      grouped_stream.ungroup() -> array
 |      grouped_data.ungroup() -> array
 |      
 |      Takes a grouped stream or grouped data and turns it into an array of
 |      objects representing the groups.  Any commands chained after `ungroup`
 |      will operate on this array, rather than operating on each group
 |      individually.  This is useful if you want to e.g. order the groups by
 |      the value of their reduction.
 |      
 |      The format of the array returned by `ungroup` is the same as the
 |      default native format of grouped data in the JavaScript driver and
 |      data explorer.
 |      
 |      *Example* What is the maximum number of points scored by each
 |      player, with the highest scorers first?
 |      
 |      Suppose that the table `games` has the following data:
 |      
 |          [
 |              {"id": 2, "player": "Bob", "points": 15, "type": "ranked"},
 |              {"id": 5, "player": "Alice", "points": 7, "type": "free"},
 |              {"id": 11, "player": "Bob", "points": 10, "type": "free"},
 |              {"id": 12, "player": "Alice", "points": 2, "type": "free"}
 |          ]
 |      
 |      We can use this query:
 |      
 |          r.table('games')
 |             .group('player').max('points')['points']
 |             .ungroup().order_by(r.desc('reduction')).run(conn)
 |      
 |      Result: 
 |      
 |          [
 |              {
 |                  "group": "Bob",
 |                  "reduction": 15
 |              },
 |              {
 |                  "group": "Alice",
 |                  "reduction": 7
 |              }
 |          ]
 |      
 |      *Example* Select one random player and all their games.
 |      
 |          r.table('games').group('player').ungroup().sample(1).run(conn)
 |      
 |      Result:
 |      
 |          [
 |              {
 |                  "group": "Bob",
 |                  "reduction": [
 |                      {"id": 2, "player": "Bob", "points": 15, "type": "ranked"},
 |                      {"id": 11, "player": "Bob", "points": 10, "type": "free"}
 |                  ]
 |              }
 |          ]
 |      
 |      Note that if you didn't call `ungroup`, you would instead select one
 |      random game from each player:
 |      
 |          r.table('games').group('player').sample(1).run(conn)
 |      
 |      Result:
 |      
 |          {
 |              "Alice": [
 |                  {"id": 5, "player": "Alice", "points": 7, "type": "free"}
 |              ],
 |              "Bob": [
 |                  {"id": 11, "player": "Bob", "points": 10, "type": "free"}
 |              ]
 |          }
 |      
 |      *Example* Types!
 |      
 |          r.table('games').group('player').type_of().run(conn) # Returns "GROUPED_STREAM"
 |          r.table('games').group('player').ungroup().type_of().run(conn) # Returns "ARRAY"
 |          r.table('games').group('player').avg('points').run(conn) # Returns "GROUPED_DATA"
 |          r.table('games').group('player').avg('points').ungroup().run(conn) #Returns "ARRAY"
 |  
 |  union(self, *args)
 |      sequence.union(sequence) -> array
 |      
 |      Concatenate two sequences.
 |      
 |      *Example* Construct a stream of all heroes.
 |      
 |          r.table('marvel').union(r.table('dc')).run(conn)
 |  
 |  upcase(self, *args)
 |      string.upcase() -> string
 |      
 |      Uppercases a string.
 |      
 |      *Example*
 |      
 |          > r.expr("Sentence about LaTeX.").upcase().run(conn)
 |          "SENTENCE ABOUT LATEX."
 |      
 |      __Note:__ `upcase` and `downcase` only affect ASCII characters.
 |  
 |  update(self, *args, **kwargs)
 |      table.update(json | expr[, durability="hard", return_changes=False, non_atomic=False])
 |          -> object
 |      selection.update(json | expr[, durability="hard", return_changes=False, non_atomic=False])
 |          -> object
 |      singleSelection.update(json | expr[, durability="hard", return_changes=False, non_atomic=False])
 |          -> object
 |      
 |      Update JSON documents in a table. Accepts a JSON document, a ReQL expression, or a
 |      combination of the two.
 |      
 |      The optional arguments are:
 |      
 |      - `durability`: possible values are `hard` and `soft`. This option will override the
 |      table or query's durability setting (set in [run](http://rethinkdb.com/api/python/run/)).  
 |      In soft durability mode RethinkDB will acknowledge the write immediately after
 |      receiving it, but before the write has been committed to disk.
 |      - `return_changes`: if set to `True`, return a `changes` array consisting of `old_val`/`new_val` objects describing the changes made.
 |      - `non_atomic`: if set to `True`, executes the update and distributes the result to replicas in a non-atomic fashion. This flag is required to perform non-deterministic updates, such as those that require reading data from another table.
 |      
 |      Update returns an object that contains the following attributes:
 |      
 |      - `replaced`: the number of documents that were updated.
 |      - `unchanged`: the number of documents that would have been modified except the new
 |      value was the same as the old value.
 |      - `skipped`: the number of documents that were skipped because the document didn't exist.
 |      - `errors`: the number of errors encountered while performing the update.
 |      - `first_error`: If errors were encountered, contains the text of the first error.
 |      - `deleted` and `inserted`: 0 for an update operation.
 |      - `changes`: if `return_changes` is set to `True`, this will be an array of objects, one for each objected affected by the `update` operation. Each object will have two keys: `{"new_val": <new value>, "old_val": <old value>}`.
 |      
 |      *Example* Update the status of the post with `id` of `1` to `published`.
 |      
 |          r.table("posts").get(1).update({"status": "published"}).run(conn)
 |      
 |      *Example* Update the status of all posts to `published`.
 |      
 |          r.table("posts").update({"status": "published"}).run(conn)
 |      
 |      *Example* Update the status of all the post written by William.
 |      
 |          r.table("posts").filter({"author": "William"}).update({"status": "published"}).run(conn)
 |      
 |      *Example* Increment the field `view` with `id` of `1`.
 |      This query will throw an error if the field `views` doesn't exist.
 |      
 |          r.table("posts").get(1).update({
 |              "views": r.row["views"]+1
 |          }).run(conn)
 |      
 |      *Example* Increment the field `view` of the post with `id` of `1`.
 |      If the field `views` does not exist, it will be set to `0`.
 |      
 |          r.table("posts").update({
 |              "views": (r.row["views"]+1).default(0)
 |          }).run(conn)
 |      
 |      *Example* Perform a conditional update.  
 |      If the post has more than 100 views, set the `type` of a post to `hot`, else set it to `normal`.
 |      
 |          r.table("posts").get(1).update(lambda post:
 |              r.branch(
 |                  post["views"] > 100,
 |                  {"type": "hot"},
 |                  {"type": "normal"}
 |              )
 |          ).run(conn)
 |      
 |      *Example* Update the field `num_comments` with the result of a sub-query. Because
 |      this update is not atomic, you must pass the `non_atomic` flag.
 |      
 |          r.table("posts").get(1).update({
 |              "num_comments": r.table("comments").filter({"id_post": 1}).count()
 |          }, non_atomic=True ).run(conn)
 |      
 |      If you forget to specify the `non_atomic` flag, you will get a `RqlRuntimeError`.
 |      
 |      RqlRuntimeError: Could not prove function deterministic.  Maybe you want to use the non_atomic flag? 
 |      
 |      *Example* Update the field `num_comments` with a random value between 0 and 100.  
 |      This update cannot be proven deterministic because of `r.js` (and in fact is not), so you
 |      must pass the `non_atomic` flag.
 |      
 |          r.table("posts").get(1).update({
 |              "num_comments": r.js("Math.floor(Math.random()*100)")
 |          }, non_atomic=True ).run(conn)
 |      
 |      *Example* Update the status of the post with `id` of `1` using soft durability.
 |      
 |          r.table("posts").get(1).update({status: "published"}, durability="soft").run(conn)
 |      
 |      *Example* Increment the field `views` and return the values of the document before
 |      and after the update operation.
 |      
 |          r.table("posts").get(1).update({
 |              "views": r.row["views"]+1
 |          }, return_changes=True).run(conn)
 |      
 |      The result will have a `changes` field:
 |      
 |          {
 |              "deleted": 1,
 |              "errors": 0,
 |              "inserted": 0,
 |              "changes": [
 |                  {
 |                      "new_val": {
 |                          "id": 1,
 |                          "author": "Julius_Caesar",
 |                          "title": "Commentarii de Bello Gallico",
 |                          "content": "Aleas jacta est",
 |                          "views": 207
 |                      },
 |                      "old_val": {
 |                          "id": 1,
 |                          "author": "Julius_Caesar",
 |                          "title": "Commentarii de Bello Gallico",
 |                          "content": "Aleas jacta est",
 |                          "views": 206
 |                      }
 |                  }
 |              ],
 |              "replaced": 0,
 |              "skipped": 0,
 |              "unchanged": 0
 |          }
 |  
 |  with_fields(self, *args)
 |      sequence.with_fields([selector1, selector2...]) -> stream
 |      array.with_fields([selector1, selector2...]) -> array
 |      
 |      Plucks one or more attributes from a sequence of objects, filtering out any objects in the sequence that do not have the specified fields. Functionally, this is identical to `has_fields` followed by `pluck` on a sequence.
 |      
 |      *Example* Get a list of users and their posts, excluding any users who have not made any posts.
 |      
 |      Existing table structure:
 |      
 |          [
 |              { 'id': 1, 'user': 'bob', 'email': 'bob@foo.com', 'posts': [ 1, 4, 5 ] },
 |              { 'id': 2, 'user': 'george', 'email': 'george@foo.com' },
 |              { 'id': 3, 'user': 'jane', 'email': 'jane@foo.com', 'posts': [ 2, 3, 6 ] }
 |          ]
 |      
 |      Command and output:
 |      
 |          r.table('users').with_fields('id', 'user', 'posts').run(conn)
 |          
 |          [
 |              { 'id': 1, 'user': 'bob', 'posts': [ 1, 4, 5 ] },
 |              { 'id': 3, 'user': 'jane', 'posts': [ 2, 3, 6 ] }
 |          ]
 |      
 |      *Example* Use the [nested field syntax](http://rethinkdb.com/docs/nested-fields/) to get a list of users with cell phone numbers in their contacts.
 |      
 |          r.table('users').with_fields('id', 'user', {contact: {'phone': 'work'}).run(conn)
 |  
 |  without(self, *args)
 |      sequence.without([selector1, selector2...]) -> stream
 |      array.without([selector1, selector2...]) -> array
 |      singleSelection.without([selector1, selector2...]) -> object
 |      object.without([selector1, selector2...]) -> object
 |      
 |      The opposite of pluck; takes an object or a sequence of objects, and returns them with
 |      the specified paths removed.
 |      
 |      *Example* Since we don't need it for this computation we'll save bandwidth and leave
 |      out the list of IronMan's romantic conquests.
 |      
 |          r.table('marvel').get('IronMan').without('personalVictoriesList').run(conn)
 |      
 |      *Example* Without their prized weapons, our enemies will quickly be vanquished.
 |      
 |          r.table('enemies').without('weapons').run(conn)
 |      
 |      *Example* Nested objects can be used to remove the damage subfield from the weapons and abilities fields.
 |      
 |          r.table('marvel').without({'weapons' : {'damage' : True}, 'abilities' : {'damage' : True}}).run(conn)
 |      
 |      *Example* The nested syntax can quickly become overly verbose so there's a shorthand for it.
 |      
 |          r.table('marvel').without({'weapons' : 'damage', 'abilities' : 'damage'}).run(conn)
 |  
 |  year(self, *args)
 |      time.year() -> number
 |      
 |      Return the year of a time object.
 |      
 |      *Example* Retrieve all the users born in 1986.
 |      
 |          r.table("users").filter(lambda user:
 |              user["birthdate"].year() == 1986
 |          ).run(conn)
 |  
 |  zip(self, *args)
 |      stream.zip() -> stream
 |      array.zip() -> array
 |      
 |      Used to 'zip' up the result of a join by merging the 'right' fields into 'left' fields of each member of the sequence.
 |      
 |      *Example* 'zips up' the sequence by merging the left and right fields produced by a join.
 |      
 |          r.table('marvel').eq_join('main_dc_collaborator', r.table('dc')).zip().run(conn)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from RqlQuery:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

