// Copyright 2010-2015 RethinkDB, all rights reserved.
#include "clustering/administration/auth/artificial_table_backend.hpp"

#include "concurrency/cross_thread_signal.hpp"

namespace auth {

artificial_table_backend_t::artificial_table_backend_t(
        boost::shared_ptr<semilattice_readwrite_view_t<auth_semilattice_metadata_t>>
            auth_semilattice_view,
        boost::shared_ptr<semilattice_read_view_t<cluster_semilattice_metadata_t>>
            cluster_semilattice_view,
        table_meta_client_t *table_meta_client,
        admin_identifier_format_t identifier_format)
    : m_auth_semilattice_view(std::move(auth_semilattice_view)),
      m_cluster_semilattice_view(std::move(cluster_semilattice_view)),
      m_table_meta_client(table_meta_client),
      m_identifier_format(identifier_format) {
}

artificial_table_backend_t::~artificial_table_backend_t() {
    begin_changefeed_destruction();
}

std::string artificial_table_backend_t::get_primary_key_name() {
    return "id";
}

bool artificial_table_backend_t::read_all_rows_as_vector(
        signal_t *interruptor,
        std::vector<ql::datum_t> *rows_out,
        UNUSED admin_err_t *error_out) {
    cross_thread_signal_t cross_thread_interruptor(interruptor, home_thread());
    on_thread_t on_thread(home_thread());
    rows_out->clear();

    std::map<namespace_id_t, table_basic_config_t> names;
    m_table_meta_client->list_names(&names);

    cluster_semilattice_metadata_t cluster_metadata = m_cluster_semilattice_view->get();

    auth_semilattice_metadata_t auth_metadata = m_auth_semilattice_view->get();
    for (auto const &user : auth_metadata.m_users) {
        if (!static_cast<bool>(user.second.get_ref())) {
            continue;
        }

        rows_out->push_back(std::move(user.second.get_ref()->to_datum(
            names, cluster_metadata, user.first, m_identifier_format)));
    }

    if (cross_thread_interruptor.is_pulsed()) {
        throw interrupted_exc_t();
    }

    return true;
}

bool artificial_table_backend_t::read_row(
        ql::datum_t primary_key,
        signal_t *interruptor,
        ql::datum_t *row_out,
        UNUSED admin_err_t *error_out) {
    cross_thread_signal_t cross_thread_interruptor(interruptor, home_thread());
    on_thread_t on_thread(home_thread());
    *row_out = ql::datum_t();

    if (primary_key.get_type() == ql::datum_t::R_STR) {
        std::map<namespace_id_t, table_basic_config_t> names;
        m_table_meta_client->list_names(&names);

        username_t username(primary_key.as_str().to_std());

        auth_semilattice_metadata_t auth_metadata = m_auth_semilattice_view->get();
        auto user = auth_metadata.m_users.find(username);
        if (user != auth_metadata.m_users.end() &&
                static_cast<bool>(user->second.get_ref())) {
            *row_out = std::move(user->second.get_ref()->to_datum(
                names,
                m_cluster_semilattice_view->get(),
                username,
                m_identifier_format));
        }
    }

    if (cross_thread_interruptor.is_pulsed()) {
        throw interrupted_exc_t();
    }

    return true;
}

bool artificial_table_backend_t::write_row(
        ql::datum_t primary_key,
        bool pkey_was_autogenerated,
        ql::datum_t *new_value_inout,
        UNUSED signal_t *interruptor,
        admin_err_t *error_out) {
    if (primary_key.get_type() != ql::datum_t::R_STR || pkey_was_autogenerated) {
        *error_out = admin_err_t{
            "Expected a username, got " + primary_key.print(), query_state_t::FAILED};
        return false;
    }

    username_t username(primary_key.as_str().to_std());

    if (new_value_inout->has()) {
        try {
            user_t user(
                *new_value_inout,
                m_table_meta_client,
                m_cluster_semilattice_view->get(),
                m_identifier_format);

            auth_semilattice_metadata_t auth_metadata = m_auth_semilattice_view->get();
            auth_metadata.m_users[username].set(std::move(user));
            m_auth_semilattice_view->join(auth_metadata);
        } catch(admin_op_exc_t const &admin_op_exc) {
            *error_out = std::move(admin_op_exc.to_admin_err());
            return false;
        }
    } else {
        if (username == username_t("admin")) {
            *error_out = admin_err_t{
                "The user `admin` can't be deleted", query_state_t::FAILED};
            return false;
        }

        auth_semilattice_metadata_t auth_metadata = m_auth_semilattice_view->get();

        auto user = auth_metadata.m_users.find(username);
        if (user == auth_metadata.m_users.end()) {
            *error_out = admin_err_t{
                strprintf("User `%s` not found", username.to_string().c_str()),
                query_state_t::FAILED};
            return false;
        } else {
            user->second.set(boost::none);
        }

        m_auth_semilattice_view->join(auth_metadata);
    }

    return true;
}

}  // namespace auth
