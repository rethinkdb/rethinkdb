// iopyright 2010-2015 RethinkDB, all rights reserved.
#include "clustering/administration/auth/permissions_artificial_table_backend.hpp"

#include "errors.hpp"
#include <boost/algorithm/string/join.hpp>

#include "clustering/administration/datum_adapter.hpp"

namespace auth {

permissions_artificial_table_backend_t::permissions_artificial_table_backend_t(
        boost::shared_ptr<semilattice_readwrite_view_t<auth_semilattice_metadata_t>>
            auth_semilattice_view,
        boost::shared_ptr<semilattice_read_view_t<cluster_semilattice_metadata_t>>
            cluster_semilattice_view,
        table_meta_client_t *table_meta_client,
        admin_identifier_format_t identifier_format)
    : base_artificial_table_backend_t(
        auth_semilattice_view,
        cluster_semilattice_view),
      m_table_meta_client(table_meta_client),
      m_identifier_format(identifier_format) {
}

bool permissions_artificial_table_backend_t::read_all_rows_as_vector(
        UNUSED signal_t *interruptor,
        std::vector<ql::datum_t> *rows_out,
        UNUSED admin_err_t *error_out) {
    rows_out->clear();
    on_thread_t on_thread(home_thread());

    auth_semilattice_metadata_t auth_metadata = m_auth_semilattice_view->get();
    for (auto const &user : auth_metadata.m_users) {
        if (!static_cast<bool>(user.second.get_ref())) {
            continue;
        }

        ql::datum_t username = convert_string_to_datum(user.first.to_string());

        {
            ql::datum_t row;
            if (global_to_datum(
                    user.first,
                    user.second.get_ref()->get_global_permissions(),
                    &row)) {
                rows_out->push_back(std::move(row));
            }
        }

        cluster_semilattice_metadata_t cluster_metadata = m_cluster_semilattice_view->get();
        for (auto const &database : user.second.get_ref()->get_database_permissions()) {
            ql::datum_t row;
            if (database_to_datum(
                    user.first,
                    database.first,
                    database.second,
                    cluster_metadata,
                    &row)) {
                rows_out->push_back(std::move(row));
            }
        }

        for (auto const &table : user.second.get_ref()->get_table_permissions()) {
            // `table_to_datum` will look up the database
            ql::datum_t row;
            if (table_to_datum(
                    user.first,
                    nil_uuid(),
                    table.first,
                    table.second,
                    cluster_metadata,
                    &row)) {
                rows_out->push_back(std::move(row));
            }
        }
    }

    return true;
}

bool permissions_artificial_table_backend_t::read_row(
        ql::datum_t primary_key,
        UNUSED signal_t *interruptor,
        ql::datum_t *row_out,
        UNUSED admin_err_t *error_out) {
    *row_out = ql::datum_t();
    on_thread_t on_thread(home_thread());

    cluster_semilattice_metadata_t cluster_metadata = m_cluster_semilattice_view->get();

    username_t username;
    database_id_t database_id;
    namespace_id_t table_id;
    uint8_t array_size = parse_primary_key(
        primary_key,
        cluster_metadata,
        &username,
        &database_id,
        &table_id);
    if (array_size == 0) {
        return true;
    }

    auth_semilattice_metadata_t auth_metadata = m_auth_semilattice_view->get();
    auto user = auth_metadata.m_users.find(username);
    if (user == auth_metadata.m_users.end() ||
            !static_cast<bool>(user->second.get_ref())) {
        return true;
    }

    // Note these functions will only set `row_out` on success.
    switch (primary_key.arr_size()) {
        case 1:
            global_to_datum(
                username,
                user->second.get_ref()->get_global_permissions(),
                row_out);
            break;
        case 2:
            database_to_datum(
                username,
                database_id,
                user->second.get_ref()->get_database_permissions(database_id),
                cluster_metadata,
                row_out);
            break;
        case 3:
            table_to_datum(
                username,
                database_id,
                table_id,
                user->second.get_ref()->get_table_permissions(table_id),
                cluster_metadata,
                row_out);
            break;
    }

    return true;
}

bool permissions_artificial_table_backend_t::write_row(
        ql::datum_t primary_key,
        bool pkey_was_autogenerated,
        ql::datum_t *new_value_inout,
        UNUSED signal_t *interruptor,
        admin_err_t *error_out) {
    on_thread_t on_thread(home_thread());

    if (pkey_was_autogenerated) {
        *error_out = admin_err_t{
            "You must specify a primary key.", query_state_t::FAILED};
        return false;
    }

    cluster_semilattice_metadata_t cluster_metadata = m_cluster_semilattice_view->get();

    username_t username;
    database_id_t database_id_primary;
    namespace_id_t table_id_primary;
    uint8_t array_size = parse_primary_key(
        primary_key,
        cluster_metadata,
        &username,
        &database_id_primary,
        &table_id_primary,
        error_out);
    if (array_size == 0) {
        return false;
    }

    auth_semilattice_metadata_t auth_metadata = m_auth_semilattice_view->get();
    auto user = auth_metadata.m_users.find(username);
    if (user == auth_metadata.m_users.end() ||
            !static_cast<bool>(user->second.get_ref())) {
        *error_out = admin_err_t{
            "No user named `" + username.to_string() + "`.",
            query_state_t::FAILED};
        return false;
    }

    if (user->first.is_admin()) {
        *error_out = admin_err_t{
            "The permissions of the user `" + username.to_string() + "` can't be modified.",
            query_state_t::FAILED};
        return false;
    }

    if (new_value_inout->has()) {
        std::set<std::string> keys;
        for (size_t i = 0; i < new_value_inout->obj_size(); ++i) {
            keys.insert(new_value_inout->get_pair(i).first.to_std());
        }
        keys.erase("id");

        if (array_size > 1) {
            ql::datum_t database = new_value_inout->get_field("database", ql::NOTHROW);
            if (database.has()) {
                keys.erase("database");

                switch (m_identifier_format) {
                    case admin_identifier_format_t::name:
                        {
                            name_string_t database_name;
                            if (!convert_name_from_datum(
                                    database,
                                    "database name",
                                    &database_name,
                                    error_out)) {
                                return false;
                            }

                            if (cluster_metadata.databases.databases.at(
                                        database_id_primary
                                    ).get_ref().name.get_ref() != database_name) {
                                *error_out = admin_err_t{
                                    "The key `database` does not match the primary key.",
                                    query_state_t::FAILED};
                                return false;
                            }
                        }
                        break;
                    case admin_identifier_format_t::uuid:
                        {
                            database_id_t database_id_secondary;
                            if (!convert_uuid_from_datum(
                                    database, &database_id_secondary, error_out)) {
                                return false;
                            }

                            if (database_id_primary != database_id_secondary) {
                                *error_out = admin_err_t{
                                    "The key `database` does not match the primary key.",
                                    query_state_t::FAILED};
                                return false;
                            }
                        }
                        break;
                }
            }
        }

        if (array_size > 2) {
            ql::datum_t table = new_value_inout->get_field("table", ql::NOTHROW);
            if (table.has()) {
                keys.erase("table");

                switch (m_identifier_format) {
                    case admin_identifier_format_t::name:
                        {
                            name_string_t table_name;
                            if (!convert_name_from_datum(
                                    table,
                                    "table name",
                                    &table_name,
                                    error_out)) {
                                return false;
                            }

                            namespace_id_t table_id_secondary;
                            try {
                                m_table_meta_client->find(
                                    database_id_primary, table_name, &table_id_secondary);
                            } catch (no_such_table_exc_t const &) {
                                 *error_out = admin_err_t{
                                    "The key `table` does not match the primary key.",
                                    query_state_t::FAILED};
                                return false;
                            }
                            if (table_id_primary != table_id_secondary) {
                                *error_out = admin_err_t{
                                    "The key `table` does not match the primary key.",
                                    query_state_t::FAILED};
                                return false;
                            }
                        }
                        break;
                    case admin_identifier_format_t::uuid:
                        {
                            namespace_id_t table_id_secondary;
                            if (!convert_uuid_from_datum(
                                    table, &table_id_secondary, error_out)) {
                                return false;
                            }

                            if (table_id_primary != table_id_secondary) {
                                *error_out = admin_err_t{
                                    "The key `table` does not match the primary key.",
                                    query_state_t::FAILED};
                                return false;
                            }
                        }
                        break;
                }
            }
        }

        bool is_indeterminate = false;

        ql::datum_t permissions = new_value_inout->get_field("permissions", ql::NOTHROW);
        if (permissions.has()) {
            keys.erase("permissions");

            try {
                switch (array_size) {
                    case 1:
                        user->second.apply_write(
                            [&](boost::optional<auth::user_t> *inner_user) {
                                auto &permissions_ref =
                                    inner_user->get().get_global_permissions();

                                permissions_ref.merge(permissions);
                                is_indeterminate = permissions_ref.is_indeterminate();
                            });
                        break;
                    case 2:
                        user->second.apply_write(
                            [&](boost::optional<auth::user_t> *inner_user) {
                                auto &permissions_ref =
                                    inner_user->get().get_database_permissions(
                                        database_id_primary);

                                permissions_ref.merge(permissions);
                                is_indeterminate = permissions_ref.is_indeterminate();
                            });
                        break;
                    case 3:
                        user->second.apply_write(
                            [&](boost::optional<auth::user_t> *inner_user) {
                                auto &permissions_ref =
                                    inner_user->get().get_table_permissions(
                                        table_id_primary);

                                permissions_ref.merge(permissions);
                                is_indeterminate = permissions_ref.is_indeterminate();
                            });
                        break;
                }
            } catch (admin_op_exc_t const &admin_op_exc) {
                *error_out = admin_op_exc.to_admin_err();
                return false;
            }
        } else {
            *error_out = admin_err_t{
                "Expected a field `permissions`.", query_state_t::FAILED};
            return false;
        }

        if (!keys.empty()) {
            *error_out = admin_err_t{
                "Unexpected key(s) `" + boost::algorithm::join(keys, "`, `") + "`.",
                query_state_t::FAILED};
            return false;
        }

        // Updating the permissions to indeterminate is considered equal to a deletion
        if (is_indeterminate) {
            *new_value_inout = ql::datum_t();
        }
    } else {
        switch (array_size) {
            case 1:
                user->second.apply_write([](boost::optional<auth::user_t> *inner_user) {
                    inner_user->get().set_global_permissions(
                        permissions_t(
                            boost::indeterminate,
                            boost::indeterminate,
                            boost::indeterminate,
                            boost::indeterminate));
                });
                break;
            case 2:
                user->second.apply_write([&](boost::optional<auth::user_t> *inner_user) {
                    inner_user->get().set_database_permissions(
                        database_id_primary,
                        permissions_t(
                            boost::indeterminate,
                            boost::indeterminate,
                            boost::indeterminate));
                });
                break;
            case 3:
                user->second.apply_write([&](boost::optional<auth::user_t> *inner_user) {
                    inner_user->get().set_table_permissions(
                        table_id_primary,
                        permissions_t(
                            boost::indeterminate,
                            boost::indeterminate,
                            boost::indeterminate));
                });
                break;
        }
    }

    m_auth_semilattice_view->join(auth_metadata);

    return true;
}

uint8_t permissions_artificial_table_backend_t::parse_primary_key(
        ql::datum_t const &primary_key,
        cluster_semilattice_metadata_t const &cluster_metadata,
        username_t *username_out,
        database_id_t *database_id_out,
        namespace_id_t *table_id_out,
        admin_err_t *admin_err_out) {
    if (primary_key.get_type() != ql::datum_t::R_ARRAY ||
            primary_key.arr_size() < 1 ||
            primary_key.arr_size() > 3) {
        if (admin_err_out != nullptr) {
            *admin_err_out = admin_err_t{
                "Expected an array of one to three items in the primary key, got " +
                    primary_key.print() + ".",
                query_state_t::FAILED};
        }
        return 0;
    }

    ql::datum_t username = primary_key.get(0, ql::NOTHROW);
    if (username.get_type() != ql::datum_t::R_STR) {
        if (admin_err_out != nullptr) {
            *admin_err_out = admin_err_t{
                "Expected a string as the username, got " + username.print() + ".",
                query_state_t::FAILED};
        }
        return 0;
    }
    *username_out = username_t(username.as_str().to_std());

    if (primary_key.arr_size() > 1) {
        ql::datum_t database = primary_key.get(1, ql::NOTHROW);
        if (database.get_type() != ql::datum_t::R_STR ||
                !str_to_uuid(database.as_str().to_std(), database_id_out)) {
            if (admin_err_out != nullptr) {
                *admin_err_out = admin_err_t{
                    "Expected a UUID as the database, got " + database.print() + ".",
                    query_state_t::FAILED};
            }
            return 0;
        }

        auto iter = cluster_metadata.databases.databases.find(*database_id_out);
        if (iter == cluster_metadata.databases.databases.end() ||
                iter->second.is_deleted()) {
            if (admin_err_out != nullptr) {
                *admin_err_out = admin_err_t{
                    strprintf(
                        "No database with UUID `%s` exists.",
                        uuid_to_str(*database_id_out).c_str()),
                    query_state_t::FAILED};
            }
            return 0;
        }
    }

    if (primary_key.arr_size() > 2) {
        ql::datum_t table = primary_key.get(2, ql::NOTHROW);
        if (table.get_type() != ql::datum_t::R_STR ||
                !str_to_uuid(table.as_str().to_std(), table_id_out)) {
            if (admin_err_out != nullptr) {
                *admin_err_out = admin_err_t{
                    "Expected a UUID as the table, got " + table.print() + ".",
                    query_state_t::FAILED};
            }
            return 0;
        }

        table_basic_config_t table_basic_config;
        try {
            m_table_meta_client->get_name(*table_id_out, &table_basic_config);
        } catch (no_such_table_exc_t const &) {
            if (admin_err_out != nullptr) {
                *admin_err_out = admin_err_t{
                    strprintf(
                        "No table with UUID `%s` exists.",
                        uuid_to_str(*table_id_out).c_str()),
                    query_state_t::FAILED};
            }
            return 0;
        }

        if (*database_id_out != table_basic_config.database) {
            if (admin_err_out != nullptr) {
                *admin_err_out = admin_err_t{
                    strprintf(
                        "No table with UUID `%s` exists.",
                        uuid_to_str(*table_id_out).c_str()),
                    query_state_t::FAILED};
            }
            return 0;
        }
    }

    return primary_key.arr_size();
}

bool permissions_artificial_table_backend_t::global_to_datum(
        username_t const &username,
        permissions_t const &permissions,
        ql::datum_t *datum_out) {
    ql::datum_t permissions_datum = permissions.to_datum();
    if (permissions_datum.get_type() != ql::datum_t::R_NULL) {
        ql::datum_object_builder_t builder;

        ql::datum_array_builder_t id_builder(ql::configured_limits_t::unlimited);
        id_builder.add(convert_string_to_datum(username.to_string()));

        builder.overwrite("id", std::move(id_builder).to_datum());
        builder.overwrite("permissions", std::move(permissions_datum));

        *datum_out = std::move(builder).to_datum();
        return true;
    }

    return false;
}

bool permissions_artificial_table_backend_t::database_to_datum(
        username_t const &username,
        database_id_t const &database_id,
        permissions_t const &permissions,
        cluster_semilattice_metadata_t const &cluster_metadata,
        ql::datum_t *datum_out) {
    ql::datum_t permissions_datum = permissions.to_datum();
    if (permissions_datum.get_type() != ql::datum_t::R_NULL) {
        ql::datum_object_builder_t builder;

        ql::datum_array_builder_t id_builder(ql::configured_limits_t::unlimited);
        id_builder.add(convert_string_to_datum(username.to_string()));
        id_builder.add(convert_uuid_to_datum(database_id));

        ql::datum_t database_name_or_uuid;
        if (!convert_database_id_to_datum(
                database_id,
                m_identifier_format,
                cluster_metadata,
                &database_name_or_uuid,
                nullptr)) {
            database_name_or_uuid = ql::datum_t("__deleted_database__");
        }

        builder.overwrite("database", std::move(database_name_or_uuid));
        builder.overwrite("id", std::move(id_builder).to_datum());
        builder.overwrite("permissions", std::move(permissions_datum));

        *datum_out = std::move(builder).to_datum();
        return true;
    }

    return false;
}

bool permissions_artificial_table_backend_t::table_to_datum(
        username_t const &username,
        database_id_t const &database_id,
        namespace_id_t const &table_id,
        permissions_t const &permissions,
        cluster_semilattice_metadata_t const &cluster_metadata,
        ql::datum_t *datum_out) {
    table_basic_config_t table_basic_config;
    try {
        m_table_meta_client->get_name(table_id, &table_basic_config);
    } catch (no_such_table_exc_t const &) {
        return false;
    }
    // `database_id` is only used to check for consistency, it should match the database
    // that the `table_id` is in if `database_id` is provided
    if (!database_id.is_nil() && database_id != table_basic_config.database) {
        return false;
    }

    ql::datum_t permissions_datum = permissions.to_datum();
    if (permissions_datum.get_type() != ql::datum_t::R_NULL) {
        ql::datum_object_builder_t builder;

        ql::datum_array_builder_t id_builder(ql::configured_limits_t::unlimited);
        id_builder.add(convert_string_to_datum(username.to_string()));
        id_builder.add(convert_uuid_to_datum(table_basic_config.database));
        id_builder.add(convert_uuid_to_datum(table_id));

        ql::datum_t database_name_or_uuid;
        ql::datum_t table_name_or_uuid;
        if (!convert_table_id_to_datums(
                table_id,
                m_identifier_format,
                cluster_metadata,
                m_table_meta_client,
                &table_name_or_uuid,
                nullptr,
                &database_name_or_uuid,
                nullptr)) {
            // This shouldn't occur since we checked whether the table exists above
            return false;
        }

        builder.overwrite("database", std::move(database_name_or_uuid));
        builder.overwrite("id", std::move(id_builder).to_datum());
        builder.overwrite("permissions", std::move(permissions_datum));
        builder.overwrite("table", std::move(table_name_or_uuid));

        *datum_out = std::move(builder).to_datum();
        return true;
    }

    return false;
}

}  // namespace auth
