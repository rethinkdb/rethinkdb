// Copyright 2010-2014 RethinkDB, all rights reserved.
#include "clustering/administration/tables/debug_table_status.hpp"

#include "clustering/administration/datum_adapter.hpp"
#include "clustering/administration/servers/config_client.hpp"
#include "clustering/administration/tables/table_config.hpp"
#include "clustering/table_manager/table_meta_client.hpp"

namespace ql {

// src/rdb_protocol/terms/sindex.cc
ql::datum_t sindex_status_to_datum(
        const std::string &,
        const sindex_config_t &,
        const sindex_status_t &);

} // namespace ql

debug_table_status_artificial_table_backend_t::
                debug_table_status_artificial_table_backend_t(
            boost::shared_ptr<semilattice_readwrite_view_t<
                cluster_semilattice_metadata_t> > _semilattice_view,
            table_meta_client_t *_table_meta_client,
            server_config_client_t *_server_config_client) :
        common_table_artificial_table_backend_t(
            _semilattice_view, _table_meta_client, admin_identifier_format_t::uuid),
        server_config_client(_server_config_client) {
}

debug_table_status_artificial_table_backend_t::
        ~debug_table_status_artificial_table_backend_t() {
    begin_changefeed_destruction();
}

bool debug_table_status_artificial_table_backend_t::write_row(
        UNUSED ql::datum_t primary_key,
        UNUSED bool pkey_was_autogenerated,
        UNUSED ql::datum_t *new_value_inout,
        UNUSED signal_t *interruptor,
        std::string *error_out) {
    *error_out = "It's illegal to write to the `rethinkdb.table_status` table.";
    return false;
}

ql::datum_t convert_debug_multi_table_manager_bcard_timestamp_epoch_to_datum(
        const multi_table_manager_bcard_t::timestamp_t::epoch_t &epoch) {
    ql::datum_object_builder_t builder;
    builder.overwrite(
        "timestamp", ql::datum_t(static_cast<double>(epoch.timestamp)));
    builder.overwrite("id", convert_uuid_to_datum(epoch.id));
    return std::move(builder).to_datum();
}

ql::datum_t convert_debug_multi_table_manager_bcard_timestamp_to_datum(
        const multi_table_manager_bcard_t::timestamp_t &timestamp) {
    ql::datum_object_builder_t builder;
    builder.overwrite(
        "epoch",
        convert_debug_multi_table_manager_bcard_timestamp_epoch_to_datum(
            timestamp.epoch));
    builder.overwrite(
        "log_index", ql::datum_t(static_cast<double>(timestamp.log_index)));
    return std::move(builder).to_datum();
}

ql::datum_t convert_debug_store_key_to_datum(const store_key_t &store_key) {
    return ql::datum_t::binary(datum_string_t(
        store_key.size(),
        reinterpret_cast<const char *>(store_key.contents())));
}

ql::datum_t convert_debug_region_to_datum(const region_t &region) {
    ql::datum_object_builder_t builder;
    builder.overwrite("hash_min", ql::datum_t(datum_string_t(
        strprintf("%016" PRIx64, region.beg))));
    builder.overwrite("hash_max", ql::datum_t(datum_string_t(
        strprintf("%016" PRIx64, region.end))));
    builder.overwrite("key_min",
        convert_debug_store_key_to_datum(region.inner.left));
    builder.overwrite("key_max",
        region.inner.right.unbounded
            ? ql::datum_t::null()
            : convert_debug_store_key_to_datum(region.inner.right.key()));
    return std::move(builder).to_datum();
}

ql::datum_t convert_debug_contract_primary_to_datum(
        const contract_t::primary_t &primary) {
    ql::datum_object_builder_t builder;
    builder.overwrite("server", convert_uuid_to_datum(primary.server));
    builder.overwrite(
        "hand_over",
        static_cast<bool>(primary.hand_over)
            ? convert_uuid_to_datum(primary.hand_over.get())
            : ql::datum_t::null());
    return std::move(builder).to_datum();
}

ql::datum_t convert_debug_contracts_to_datum(
        const contracts_and_contract_acks_t::contracts_t &contracts) {
    ql::datum_array_builder_t builder(ql::configured_limits_t::unlimited);
    for (const auto &contract : contracts) {
        ql::datum_object_builder_t contract_builder;
        contract_builder.overwrite(
            "contract", convert_uuid_to_datum(contract.first));
        contract_builder.overwrite(
            "region", convert_debug_region_to_datum(contract.second.first));
        contract_builder.overwrite(
            "replicas", convert_set_to_datum<server_id_t>(
                &convert_uuid_to_datum, contract.second.second.replicas));
        contract_builder.overwrite(
            "voters", convert_set_to_datum<server_id_t>(
                &convert_uuid_to_datum, contract.second.second.voters));
        contract_builder.overwrite(
            "temp_voters",
            static_cast<bool>(contract.second.second.temp_voters)
                ? convert_set_to_datum<server_id_t>(
                    &convert_uuid_to_datum,
                    contract.second.second.temp_voters.get())
                : ql::datum_t::null());
        contract_builder.overwrite(
            "primary",
            static_cast<bool>(contract.second.second.primary)
                ? convert_debug_contract_primary_to_datum(
                    contract.second.second.primary.get())
                : ql::datum_t::null());
        contract_builder.overwrite(
            "branch", convert_uuid_to_datum(contract.second.second.branch));
        builder.add(std::move(contract_builder).to_datum());
    }
    return std::move(builder).to_datum();
}

ql::datum_t convert_debug_table_shard_scheme_to_datum(
        const table_shard_scheme_t &shard_scheme) {
    ql::datum_object_builder_t builder;
    builder.overwrite("split_points", convert_vector_to_datum<store_key_t>(
        &convert_debug_store_key_to_datum, shard_scheme.split_points));
    return std::move(builder).to_datum();
}

ql::datum_t convert_debug_sindex_statuses_to_datum(
        const std::map<std::string, std::pair<sindex_config_t, sindex_status_t> >
            &sindex_statuses) {
    ql::datum_array_builder_t builder(ql::configured_limits_t::unlimited);
    for (const auto &sindex_status : sindex_statuses) {
        builder.add(ql::sindex_status_to_datum(
            sindex_status.first,
            sindex_status.second.first,
            sindex_status.second.second));
    }
    return std::move(builder).to_datum();
}

ql::datum_t convert_debug_contract_ack_state_to_datum(
       const contract_ack_t::state_t &state) {
    switch (state) {
        case contract_ack_t::state_t::primary_need_branch:
            return convert_string_to_datum("primary_need_branch");
        case contract_ack_t::state_t::primary_in_progress:
            return convert_string_to_datum("primary_in_progress");
        case contract_ack_t::state_t::primary_ready:
            return convert_string_to_datum("primary_ready");
        case contract_ack_t::state_t::secondary_need_primary:
            return convert_string_to_datum("secondary_need_primary");
        case contract_ack_t::state_t::secondary_backfilling:
            return convert_string_to_datum("secondary_backfilling");
        case contract_ack_t::state_t::secondary_streaming:
            return convert_string_to_datum("secondary_streaming");
        case contract_ack_t::state_t::nothing:
            return convert_string_to_datum("nothing");
        default:
            unreachable();
    }
}

ql::datum_t convert_debug_version_to_datum(const version_t &version) {
    ql::datum_object_builder_t builder;
    builder.overwrite("branch", convert_uuid_to_datum(version.branch));
    builder.overwrite("timestamp", ql::datum_t(static_cast<double>(
        version.timestamp.to_repli_timestamp().longtime)));
    return std::move(builder).to_datum();
}

ql::datum_t convert_debug_version_map_to_datum(
        const region_map_t<version_t> &map) {
    ql::datum_array_builder_t builder(ql::configured_limits_t::unlimited);
    map.visit(
        map.get_domain(),
        [&](const region_t &region, const version_t &version) {
            ql::datum_object_builder_t pair_builder;
            pair_builder.overwrite("region",
                convert_debug_region_to_datum(region));
            pair_builder.overwrite("version",
                convert_debug_version_to_datum(version));
            builder.add(std::move(pair_builder).to_datum());
        });
    return std::move(builder).to_datum();
}

ql::datum_t convert_debug_branch_birth_certificate_to_datum(
        const branch_birth_certificate_t &birth_certificate) {
    ql::datum_object_builder_t builder;
    builder.overwrite("region", convert_debug_region_to_datum(birth_certificate.region));
    builder.overwrite("initial_timestamp", ql::datum_t(static_cast<double>(
        birth_certificate.initial_timestamp.to_repli_timestamp().longtime)));
    builder.overwrite(
        "origin", convert_debug_version_map_to_datum(birth_certificate.origin));
    return std::move(builder).to_datum();
}

ql::datum_t convert_debug_branch_history_to_datum(
        const branch_history_t &branch_history) {
    ql::datum_array_builder_t builder(ql::configured_limits_t::unlimited);
    for (const auto &branch : branch_history.branches) {
        ql::datum_object_builder_t branch_builder;
        branch_builder.overwrite("branch", convert_uuid_to_datum(branch.first));
        branch_builder.overwrite(
            "branch_birth_certificate",
            convert_debug_branch_birth_certificate_to_datum(branch.second));
        builder.add(std::move(branch_builder).to_datum());
    }
    return std::move(builder).to_datum();
}

ql::datum_t convert_debug_contract_acks_to_datum(
        const contracts_and_contract_acks_t::contract_acks_t &contract_acks) {
    ql::datum_array_builder_t builder(ql::configured_limits_t::unlimited);
    for (const auto &contract_ack : contract_acks) {
        ql::datum_object_builder_t contract_builder;
        contract_builder.overwrite(
            "contract", convert_uuid_to_datum(contract_ack.first));
        contract_builder.overwrite(
            "state",
            convert_debug_contract_ack_state_to_datum(contract_ack.second.state));
        contract_builder.overwrite(
            "version",
            static_cast<bool>(contract_ack.second.version)
                ? convert_debug_version_map_to_datum(
                        contract_ack.second.version.get())
                : ql::datum_t::null());
        /* RSI(raft) The branch history is append-only thus it grows without bound,
           printing it can be reinstated once it's garbage collected per #3879. For the
           time being we print the size instead.
        contract_builder.overwrite(
            "branch_history",
            convert_debug_branch_history_to_datum(contract_ack.second.branch_history)); */
        contract_builder.overwrite(
            "branch_history",
            ql::datum_t(static_cast<double>(
                contract_ack.second.branch_history.branches.size())));
        builder.add(std::move(contract_builder).to_datum());
    }
    return std::move(builder).to_datum();
}

ql::datum_t convert_debug_contracts_and_contrack_acks_to_datum(
        const std::map<peer_id_t, contracts_and_contract_acks_t> &contracts_and_acks,
        server_config_client_t *server_config_client) {
    ql::datum_array_builder_t builder(ql::configured_limits_t::unlimited);
    for (const auto &peer : contracts_and_acks) {
        boost::optional<server_id_t> server_id =
            server_config_client->get_server_id_for_peer_id(peer.first);

        ql::datum_object_builder_t peer_builder;
        peer_builder.overwrite("peer", convert_uuid_to_datum(peer.first.get_uuid()));
        peer_builder.overwrite(
            "server",
            static_cast<bool>(server_id)
                ? convert_uuid_to_datum(server_id.get())
                : ql::datum_t::null());
        peer_builder.overwrite(
            "timestamp",
            convert_debug_multi_table_manager_bcard_timestamp_to_datum(
                peer.second.timestamp));
        peer_builder.overwrite(
            "contracts", convert_debug_contracts_to_datum(peer.second.contracts));
        peer_builder.overwrite(
            "contract_acks",
            convert_debug_contract_acks_to_datum(peer.second.contract_acks));
        builder.add(std::move(peer_builder).to_datum());
    }
    return std::move(builder).to_datum();
}

void debug_table_status_artificial_table_backend_t::format_row(
        const namespace_id_t &table_id,
        const table_basic_config_t &,
        const ql::datum_t &db_name_or_uuid,
        signal_t *interruptor,
        ql::datum_t *row_out)
        THROWS_ONLY(interrupted_exc_t, no_such_table_exc_t, failed_table_op_exc_t,
            admin_op_exc_t) {
    assert_thread();

    table_config_and_shards_t config_and_shards;
    table_meta_client->get_config(table_id, interruptor, &config_and_shards);

    std::map<std::string, std::pair<sindex_config_t, sindex_status_t> > sindex_statuses;
    std::map<peer_id_t, contracts_and_contract_acks_t> contracts_and_acks;
    table_meta_client->get_status(
        table_id, interruptor, &sindex_statuses, &contracts_and_acks);

    ql::datum_object_builder_t builder;
    builder.overwrite("id", convert_uuid_to_datum(table_id));
    builder.overwrite("name",
        convert_name_to_datum(config_and_shards.config.basic.name));
    builder.overwrite("db", db_name_or_uuid);
    builder.overwrite(
        "config",
        convert_table_config_to_datum(
            table_id,
            db_name_or_uuid,
            config_and_shards.config,
            admin_identifier_format_t::uuid,
            server_config_client));
    builder.overwrite(
        "shard_scheme",
        convert_debug_table_shard_scheme_to_datum(config_and_shards.shard_scheme));
    builder.overwrite(
        "sindexes", convert_debug_sindex_statuses_to_datum(sindex_statuses));
    builder.overwrite(
        "contracts_and_contract_acks",
        convert_debug_contracts_and_contrack_acks_to_datum(
            contracts_and_acks, server_config_client));
    *row_out = std::move(builder).to_datum();
}
