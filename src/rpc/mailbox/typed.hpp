// Copyright 2010-2014 RethinkDB, all rights reserved.
#ifndef RPC_MAILBOX_TYPED_HPP_
#define RPC_MAILBOX_TYPED_HPP_

/* This file is automatically generated by 'scripts/generate_rpc_templates.py'.
Please modify 'scripts/generate_rpc_templates.py' instead of modifying this file.*/

#include <functional>
#include <tuple>

#include "containers/archive/versioned.hpp"
#include "rpc/serialize_macros.hpp"
#include "rpc/mailbox/mailbox.hpp"
#include "rpc/semilattice/joins/macros.hpp"

template <class> class mailbox_t;

template <class T>
class mailbox_addr_t {
public:
    bool operator<(const mailbox_addr_t<T> &other) const {
        return addr < other.addr;
    }
    bool is_nil() const { return addr.is_nil(); }
    peer_id_t get_peer() const { return addr.get_peer(); }

    friend class mailbox_t<T>;

    RDB_MAKE_ME_SERIALIZABLE_1(mailbox_addr_t, addr);
    RDB_MAKE_ME_EQUALITY_COMPARABLE_1(mailbox_addr_t<T>, addr);

private:
    friend void send(mailbox_manager_t *, mailbox_addr_t<void()>);
    template <class ...as_t>
    friend void send(mailbox_manager_t *,
                     typename mailbox_t< void(as_t...) >::address_t, const as_t&...);

    raw_mailbox_t::address_t addr;
};

template<>
class mailbox_t< void() > {
    class write_impl_t : public mailbox_write_callback_t {
    public:
        write_impl_t() { }
        void write(DEBUG_VAR cluster_version_t cluster_version, write_message_t *) {
            rassert(cluster_version == cluster_version_t::CLUSTER);
        }

#ifdef ENABLE_MESSAGE_PROFILER
        const char *message_profiler_tag() const {
            return "mailbox<>";
        }
#endif

    };

    class read_impl_t : public mailbox_read_callback_t {
    public:
        explicit read_impl_t(mailbox_t< void() > *_parent) : parent(_parent) { }
        void read(UNUSED read_stream_t *stream, signal_t *interruptor) {
            parent->fun(interruptor);
        }
    private:
        mailbox_t< void() > *parent;
    };

    read_impl_t reader;

public:
    typedef mailbox_addr_t< void() > address_t;

    mailbox_t(mailbox_manager_t *manager,
              const std::function< void(signal_t *)> &f) :
        reader(this), fun(f), mailbox(manager, &reader)
        { }

    void begin_shutdown() {
        mailbox.begin_shutdown();
    }

    address_t get_address() const {
        address_t a;
        a.addr = mailbox.get_address();
        return a;
    }

private:
    friend void send(mailbox_manager_t*, address_t);

    std::function< void(signal_t *) > fun;
    raw_mailbox_t mailbox;
};

inline
void send(mailbox_manager_t *src,
           mailbox_t< void() >::address_t dest) {
    mailbox_t< void() >::write_impl_t writer;
    send_write(src, dest.addr, &writer);
}


namespace mailbox_internal {

template <class T>
void _serialize(write_message_t *wm, const T& arg) {
    serialize<cluster_version_t::CLUSTER>(wm, arg);
}

template <class T, class ...Ts>
void _serialize(write_message_t *wm, const T& arg, const Ts& ...args) {
    serialize<cluster_version_t::CLUSTER>(wm, arg);
    _serialize(wm, args...);
}

template <class T>
archive_result_t _deserialize(read_stream_t *stream, T &arg) {
    return deserialize<cluster_version_t::CLUSTER>(stream, &arg);
}

template <class T, class ...Ts>
archive_result_t _deserialize(read_stream_t *stream, T& arg, Ts& ...args) {
    auto res = deserialize<cluster_version_t::CLUSTER>(stream, &arg);
    if (bad(res)) return res;
    return _deserialize(stream, args...);
}

template <std::size_t ...Is>
struct index_sequence{
};

template <size_t N, size_t... Is>
struct index_seq_generator  {
    typedef typename index_seq_generator<N-1,N-1,Is...>::type type;
};

template <size_t... Is>
struct index_seq_generator<0, Is...>  {
    typedef index_sequence<Is...> type;
};

template <size_t N>
using make_index_sequence = typename index_seq_generator<N>::type;

template <class... T>
using index_sequence_for = make_index_sequence<sizeof...(T)>;

template<typename ...Ts>
constexpr bool has_many() {
  return sizeof...(Ts) > 1;
}

template<bool>
struct element_typeid;

template<>
struct element_typeid<false> {
  template<typename T>
  static std::string to_string() {
    return strprintf("%s", typeid(T).name());
  }
};

template<>
struct element_typeid<true> {
  template<typename T, typename ...Ts>
  static std::string to_string() {
    return strprintf("%s, ", typeid(T).name()) + element_typeid<has_many<Ts...>()>::template to_string<Ts...>();
  }
};

template<typename ...Ts>
std::string typeid_string() {
    return element_typeid<has_many<Ts...>()>::template to_string<Ts...>();
}

}

template <class ...Ts, std::size_t ...Is>
void tuple_serialize(write_message_t *wm, const std::tuple<Ts...> &tuple,
                     mailbox_internal::index_sequence<Is...>)
{
    mailbox_internal::_serialize(wm, std::get<Is>(tuple)...);
}

template <class ...Ts, std::size_t ...Is>
archive_result_t tuple_deserialize(read_stream_t *stream, std::tuple<Ts...> &tuple,
                     mailbox_internal::index_sequence<Is...>)
{
   return mailbox_internal::_deserialize(stream, std::get<Is>(tuple)...);
}

template<class ...args_t>
class mailbox_t< void(args_t...) > {
    class write_impl_t : public mailbox_write_callback_t {
    private:
        std::tuple<const args_t&...> args;
    public:
        explicit write_impl_t(const args_t& ..._args) :
            args(std::forward_as_tuple(_args...))
        { }
        void write(DEBUG_VAR cluster_version_t cluster_version, write_message_t *wm) {
            rassert(cluster_version == cluster_version_t::CLUSTER);
            //std::apply(mailbox_internal::_serialize, std::tuple_cat(std::tie(wm), args));
            tuple_serialize(wm, args, mailbox_internal::index_sequence_for<args_t...>{});
        }

#ifdef ENABLE_MESSAGE_PROFILER
        const char *message_profiler_tag() const {
            static const std::string tag = 
                strprintf("mailbox<%s>", mailbox_internal::typeid_string<args_t...>().c_str() );
            return tag.c_str();
        }
#endif

    };

    class read_impl_t : public mailbox_read_callback_t {
    private:
        template <class ...Ts, std::size_t ...Is>
        void call (std::tuple<Ts...> &tuple,  signal_t *interruptor,
                             mailbox_internal::index_sequence<Is...>)
        {
           parent->fun(interruptor, std::get<Is>(tuple)...);
        }
    public:
        explicit read_impl_t(mailbox_t< void(args_t...) > *_parent) : parent(_parent) { }
        void read(read_stream_t *stream, signal_t *interruptor) {
            std::tuple<args_t...> args;
            //auto res = std::appy(mailbox_internal::_deserialize,
            //                     std::tuple_cat(std::tie(stream), args));
            auto res = tuple_deserialize(stream, args,
                                         mailbox_internal::index_sequence_for<args_t...>{});
            if (bad(res)) { throw fake_archive_exc_t(); }
            //std::appy(mailbox_t< void(args_t...) >::fun,
                //std::tuple_cat(std::tie(parent, interruptor), args));
            call(args, interruptor, mailbox_internal::index_sequence_for<args_t...>{});
        }
    private:
        mailbox_t< void(args_t...) > *parent;
    };

    read_impl_t reader;

public:
    typedef mailbox_addr_t< void(args_t...) > address_t;

    mailbox_t(mailbox_manager_t *manager,
              std::function< void(signal_t *, args_t...)> f) :
        reader(this), fun(std::move(f)), mailbox(manager, &reader)
        { }

    void begin_shutdown() {
        mailbox.begin_shutdown();
    }

    address_t get_address() const {
        address_t a;
        a.addr = mailbox.get_address();
        return a;
    }

private:
    template<class ...as_t>
    friend void send(mailbox_manager_t*,
                     typename mailbox_t< void(as_t...) >::address_t, const as_t&...);

    std::function< void(signal_t *, args_t...) > fun;
    raw_mailbox_t mailbox;
};

template<class ...args_t>
void send(mailbox_manager_t *src,
          typename mailbox_t< void(args_t...) >::address_t dest, const args_t& ...args) {
    typename mailbox_t< void(args_t...) >::write_impl_t writer(args...);
    send_write(src, dest.addr, &writer);
}

#endif // RPC_MAILBOX_TYPED_HPP_
