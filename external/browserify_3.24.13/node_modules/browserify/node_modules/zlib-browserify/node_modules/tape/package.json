{
  "name": "tape",
  "version": "0.2.2",
  "description": "tap-producing test harness for node and browsers",
  "main": "index.js",
  "bin": {},
  "directories": {
    "example": "example",
    "test": "test"
  },
  "dependencies": {
    "jsonify": "~0.0.0",
    "deep-equal": "~0.0.0",
    "defined": "~0.0.0"
  },
  "devDependencies": {
    "tap": "~0.3.0",
    "falafel": "~0.1.4"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/substack/tape.git"
  },
  "homepage": "https://github.com/substack/tape",
  "keywords": [
    "tap",
    "test",
    "harness",
    "assert",
    "browser"
  ],
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "license": "MIT",
  "readme": "# tape\n\ntap-producing test harness for node and browsers\n\n[![build status](https://secure.travis-ci.org/substack/tape.png)](http://travis-ci.org/substack/tape)\n\n![tape](http://substack.net/images/tape_drive.png)\n\n# browser compatibility\n\nchrome, firefox, opera, safari, IE6, IE7, IE8, IE9\n\nusing browserify@1.16.5\n\n# example\n\n``` js\nvar test = require('tape');\n\ntest('timing test', function (t) {\n    t.plan(2);\n    \n    t.equal(typeof Date.now, 'function');\n    var start = Date.now();\n    \n    setTimeout(function () {\n        t.equal(Date.now() - start, 100);\n    }, 100);\n});\n```\n\n```\n$ node example/timing.js\nTAP version 13\n# timing test\nok 1 should be equal\nnot ok 2 should be equal\n  ---\n    operator: equal\n    expected: 100\n    actual:   107\n  ...\n\n1..2\n# tests 2\n# pass  1\n# fail  1\n```\n\n# methods\n\nThe assertion methods in tape are heavily influenced or copied from the methods\nin [node-tap](https://github.com/isaacs/node-tap).\n\n```\nvar test = require('tape')\n```\n\n## test(name, cb)\n\nCreate a new test with an optional `name` string. `cb(t)` fires with the new\ntest object `t` once all preceeding tests have finished. Tests execute serially.\n\nIf you forget to `t.plan()` out how many assertions you are going to run and you\ndon't call `t.end()` explicitly, your test will hang.\n\n## t.plan(n)\n\nDeclare that `n` assertions should be run. `t.end()` will be called\nautomatically after the `n`th assertion. If there are any more assertions after\nthe `n`th, or after `t.end()` is called, they will generate errors.\n\n## t.end()\n\nDeclare the end of a test explicitly.\n\n## t.fail(msg)\n\nGenerate a failing assertion with a message `msg`.\n\n## t.pass(msg)\n\nGenerate a passing assertion with a message `msg`.\n\n## t.skip(msg)\n \nGenerate an assertion that will be skipped over.\n\n## t.ok(value, msg)\n\nAssert that `value` is truthy with an optional description message `msg`.\n\nAliases: `t.true()`, `t.assert()`\n\n## t.notOk(value, msg)\n\nAssert that `value` is falsy with an optional description message `msg`.\n\nAliases: `t.false()`, `t.notok()`\n\n## t.error(err, msg)\n\nAssert that `err` is falsy. If `err` is non-falsy, use its `err.message` as the\ndescription message.\n\nAliases: `t.ifError()`, `t.ifErr()`, `t.iferror()`\n\n## t.equal(a, b, msg)\n\nAssert that `a === b` with an optional description `msg`.\n\nAliases: `t.equals()`, `t.isEqual()`, `t.is()`, `t.strictEqual()`,\n`t.strictEquals()`\n\n## t.notEqual(a, b, msg)\n\nAssert that `a !== b` with an optional description `msg`.\n\nAliases: `t.notEquals()`, `t.notStrictEqual()`, `t.notStrictEquals()`,\n`t.isNotEqual()`, `t.isNot()`, `t.not()`, `t.doesNotEqual()`, `t.isInequal()`\n\n## t.deepEqual(a, b, msg)\n\nAssert that `a` and `b` have the same structure and nested values using\n[node's deepEqual() algorithm](https://github.com/substack/node-deep-equal)\nwith an optional description `msg`.\n\nAliases: `t.deepEquals()`, `t.isEquivalent()`, `t.looseEqual()`,\n`t.looseEquals()`, `t.same()`\n\n## t.notDeepEqual(a, b, msg)\n\nAssert that `a` and `b` do not have the same structure and nested values using\n[node's deepEqual() algorithm](https://github.com/substack/node-deep-equal)\nwith an optional description `msg`.\n\nAliases: `t.notEquivalent()`, `t.notDeeply()`, `t.notSame()`,\n`t.isNotDeepEqual()`, `t.isNotDeeply()`, `t.isNotEquivalent()`,\n`t.isInequivalent()`\n\n## t.throws(fn, expected, msg)\n\nAssert that the function call `fn()` throws an exception.\n\n## t.doesNotThrow(fn, expected, msg)\n\nAssert that the function call `fn()` does not throw an exception.\n\n## t.test(name, cb)\n\nCreate a subtest with a new test handle `st` from `cb(st)` inside the current\ntest `t`. `cb(st)` will only fire when `t` finishes. Additional tests queued up\nafter `t` will not be run until all subtests finish.\n\n## var htest = test.createHarness()\n\nCreate a new test harness instance, which is a function like `test()`, but with\na new pending stack and test state.\n\nBy default the TAP output goes to `process.stdout` or `console.log()` if the\nenvironment doesn't have `process.stdout`. You can pipe the output to someplace\nelse if you `test.stream.pipe()` to a destination stream on the first tick.\n\n## test.only(name, cb)\n\nLike `test(name, cb)` except if you use `.only` this is the only test case\nthat will run for the entire process, all other test cases using tape will\nbe ignored\n\n# install\n\nWith [npm](https://npmjs.org) do:\n\n```\nnpm install tape\n```\n\n# license\n\nMIT\n",
  "readmeFilename": "readme.markdown",
  "bugs": {
    "url": "https://github.com/substack/tape/issues"
  },
  "_id": "tape@0.2.2",
  "dist": {
    "shasum": "754ca5c9b4992a51eaff6e9b704d37d5b68a1e04"
  },
  "_from": "https://registry.npmjs.org/tape/-/tape-0.2.2.tgz",
  "_resolved": "https://registry.npmjs.org/tape/-/tape-0.2.2.tgz"
}
