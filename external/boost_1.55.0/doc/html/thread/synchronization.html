<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Synchronization</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../thread.html" title="Chapter&#160;31.&#160;Thread 4.2.0">
<link rel="prev" href="ScopedThreads.html" title="Scoped Threads">
<link rel="next" href="thread_local_storage.html" title="Thread Local Storage">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="ScopedThreads.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../thread.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="thread_local_storage.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="thread.synchronization"></a><a class="link" href="synchronization.html" title="Synchronization">Synchronization</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial">Tutorial</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts">Mutex Concepts</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_option">Lock Options</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_guard">Lock Guard</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_concepts">Lock Concepts</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks">Lock Types</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks">Other Lock Types
      - EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions">Lock functions</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_factories">Lock Factories
      - EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types">Mutex Types</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref">Condition Variables</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.once">One-time Initialization</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.barriers">Barriers -- EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures">Futures</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.tutorial"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial" title="Tutorial">Tutorial</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.internal_locking">Internal
        Locking</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes">External
        Locking -- <code class="computeroutput"><span class="identifier">strict_lock</span></code> and
        <code class="computeroutput"><span class="identifier">externally_locked</span></code> classes</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.with">Executing Around
        a Function</a></span></dt>
</dl></div>
<p>
        <a href="http://home.roadrunner.com/~hinnant/mutexes/locking.html" target="_top">Handling
        mutexes in C++</a> is an excellent tutorial. You need just replace std
        and ting by boost.
      </p>
<p>
        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html" target="_top">Mutex,
        Lock, Condition Variable Rationale</a> adds rationale for the design
        decisions made for mutexes, locks and condition variables.
      </p>
<p>
        In addition to the C++11 standard locks, Boost.Thread provides other locks
        and some utilities that help the user to make their code thread-safe.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.tutorial.internal_locking"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.internal_locking" title="Internal Locking">Internal
        Locking</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.internal_locking.concurrent_threads_of_execution">Concurrent
          threads of execution</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.internal_locking.internal_locking">Internal
          locking</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.internal_locking.internal_and_external_locking">Internal
          and external locking</a></span></dt>
</dl></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            This tutorial is an adaptation of chapter Concurrency of the Object-Oriented
            Programming in the BETA Programming Language and of the paper of Andrei
            Alexandrescu "Multithreading and the C++ Type System" to the
            Boost library.
          </p></td></tr>
</table></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.internal_locking.concurrent_threads_of_execution"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.internal_locking.concurrent_threads_of_execution" title="Concurrent threads of execution">Concurrent
          threads of execution</a>
</h5></div></div></div>
<p>
            Consider, for example, modeling a bank account class that supports simultaneous
            deposits and withdrawals from multiple locations (arguably the "Hello,
            World" of multithreaded programming).
          </p>
<p>
            From here a component is a model of the <code class="computeroutput"><span class="identifier">Callable</span></code>
            concept.
          </p>
<p>
            On C++11 (Boost) concurrent execution of a component is obtained by means
            of the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">thread</span></code>(<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code>):
          </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">thread1</span><span class="special">(</span><span class="identifier">S</span><span class="special">);</span>
</pre>
<p>
            where <code class="computeroutput"><span class="identifier">S</span></code> is a model of
            <code class="computeroutput"><span class="identifier">Callable</span></code>. The meaning
            of this expression is that execution of <code class="computeroutput"><span class="identifier">S</span><span class="special">()</span></code> will take place concurrently with the
            current thread of execution executing the expression.
          </p>
<p>
            The following example includes a bank account of a person (Joe) and two
            components, one corresponding to a bank agent depositing money in Joe's
            account, and one representing Joe. Joe will only be withdrawing money
            from the account:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span><span class="special">;</span>

<span class="identifier">BankAccount</span> <span class="identifier">JoesAccount</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">bankAgent</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span><span class="number">10</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&gt;</span><span class="number">0</span><span class="special">;</span> <span class="special">--</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">//...</span>
        <span class="identifier">JoesAccount</span><span class="special">.</span><span class="identifier">Deposit</span><span class="special">(</span><span class="number">500</span><span class="special">);</span>
        <span class="comment">//...</span>
    <span class="special">}</span>
<span class="special">}</span>

<span class="keyword">void</span> <span class="identifier">Joe</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span><span class="number">10</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&gt;</span><span class="number">0</span><span class="special">;</span> <span class="special">--</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">//...</span>
        <span class="keyword">int</span> <span class="identifier">myPocket</span> <span class="special">=</span> <span class="identifier">JoesAccount</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">100</span><span class="special">);</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">myPocket</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="comment">//...</span>
    <span class="special">}</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">//...</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">thread1</span><span class="special">(</span><span class="identifier">bankAgent</span><span class="special">);</span> <span class="comment">// start concurrent execution of bankAgent</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">thread2</span><span class="special">(</span><span class="identifier">Joe</span><span class="special">);</span> <span class="comment">// start concurrent execution of Joe</span>
    <span class="identifier">thread1</span><span class="special">.</span><span class="identifier">join</span><span class="special">();</span>
    <span class="identifier">thread2</span><span class="special">.</span><span class="identifier">join</span><span class="special">();</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
            From time to time, the <code class="computeroutput"><span class="identifier">bankAgent</span></code>
            will deposit $500 in <code class="computeroutput"><span class="identifier">JoesAccount</span></code>.
            Joe will similarly withdraw $100 from his account. These sentences describe
            that the bankAgent and Joe are executed concurrently.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.internal_locking.internal_locking"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.internal_locking.internal_locking" title="Internal locking">Internal
          locking</a>
</h5></div></div></div>
<p>
            The above example works well as long as the bankAgent and Joe doesn't
            access JoesAccount at the same time. There is, however, no guarantee
            that this will not happen. We may use a mutex to guarantee exclusive
            access to each bank.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">GetBalance</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
        <span class="keyword">int</span> <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">balance_</span><span class="special">;</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
        <span class="keyword">return</span> <span class="identifier">b</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Execution of the Deposit and Withdraw operations will no longer be able
            to make simultaneous access to balance.
          </p>
<p>
            Mutex is a simple and basic mechanism for obtaining synchronization.
            In the above example it is relatively easy to be convinced that the synchronization
            works correctly (in the absence of exception). In a system with several
            concurrent objects and several shared objects, it may be difficult to
            describe synchronization by means of mutexes. Programs that make heavy
            use of mutexes may be difficult to read and write. Instead, we shall
            introduce a number of generic classes for handling more complicated forms
            of synchronization and communication.
          </p>
<p>
            With the RAII idiom we can simplify a lot this using the scoped locks.
            In the code below, guard's constructor locks the passed-in object this,
            and guard's destructor unlocks this.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span> <span class="comment">// explicit mutex declaration </span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">GetBalance</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">balance_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            The object-level locking idiom doesn't cover the entire richness of a
            threading model. For example, the model above is quite deadlock-prone
            when you try to coordinate multi-object transactions. Nonetheless, object-level
            locking is useful in many cases, and in combination with other mechanisms
            can provide a satisfactory solution to many threaded access problems
            in object-oriented programs.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.internal_locking.internal_and_external_locking"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.internal_locking.internal_and_external_locking" title="Internal and external locking">Internal
          and external locking</a>
</h5></div></div></div>
<p>
            The BankAccount class above uses internal locking. Basically, a class
            that uses internal locking guarantees that any concurrent calls to its
            public member functions don't corrupt an instance of that class. This
            is typically ensured by having each public member function acquire a
            lock on the object upon entry. This way, for any given object of that
            class, there can be only one member function call active at any moment,
            so the operations are nicely serialized.
          </p>
<p>
            This approach is reasonably easy to implement and has an attractive simplicity.
            Unfortunately, "simple" might sometimes morph into "simplistic."
          </p>
<p>
            Internal locking is insufficient for many real-world synchronization
            tasks. Imagine that you want to implement an ATM withdrawal transaction
            with the BankAccount class. The requirements are simple. The ATM transaction
            consists of two withdrawals-one for the actual money and one for the
            $2 commission. The two withdrawals must appear in strict sequence; that
            is, no other transaction can exist between them.
          </p>
<p>
            The obvious implementation is erratic:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">);</span>
    <span class="comment">// preemption possible</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            The problem is that between the two calls above, another thread can perform
            another operation on the account, thus breaking the second design requirement.
          </p>
<p>
            In an attempt to solve this problem, let's lock the account from the
            outside during the two operations:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">acct</span><span class="special">.</span><span class="identifier">mtx_</span><span class="special">);</span> <span class="number">1</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            Notice that the code above doesn't compiles, the <code class="computeroutput"><span class="identifier">mtx_</span></code>
            field is private. We have two possibilities:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                make <code class="computeroutput"><span class="identifier">mtx_</span></code> public
                which seams odd
              </li>
<li class="listitem">
                make the <code class="computeroutput"><span class="identifier">BankAccount</span></code>
                lockable by adding the lock/unlock functions
              </li>
</ul></div>
<p>
            We can add these functions explicitly
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            or inheriting from a class which add these lockable functions.
          </p>
<p>
            The <code class="computeroutput"><span class="identifier">basic_lockable_adapter</span></code>
            class helps to define the <code class="computeroutput"><span class="identifier">BankAccount</span></code>
            class as
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">GetBalance</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">balance_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            and the code that doesn't compiles becomes
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">acct</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            Notice that now acct is being locked by Withdraw after it has already
            been locked by guard. When running such code, one of two things happens.
          </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                Your mutex implementation might support the so-called recursive mutex
                semantics. This means that the same thread can lock the same mutex
                several times successfully. In this case, the implementation works
                but has a performance overhead due to unnecessary locking. (The locking/unlocking
                sequence in the two Withdraw calls is not needed but performed anyway-and
                that costs time.)
              </li>
<li class="listitem">
                Your mutex implementation might not support recursive locking, which
                means that as soon as you try to acquire it the second time, it blocks-so
                the ATMWithdrawal function enters the dreaded deadlock.
              </li>
</ul></div>
<p>
            As <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span></code> is not recursive, we need to
            use its recursive version <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code>.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">recursive_mutex</span><span class="special">&gt;</span>
<span class="special">{</span>

    <span class="comment">// ...</span>
<span class="special">};</span>
</pre>
<p>
            The caller-ensured locking approach is more flexible and the most efficient,
            but very dangerous. In an implementation using caller-ensured locking,
            BankAccount still holds a mutex, but its member functions don't manipulate
            it at all. Deposit and Withdraw are not thread-safe anymore. Instead,
            the client code is responsible for locking BankAccount properly.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
    <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">:</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Obviously, the caller-ensured locking approach has a safety problem.
            BankAccount's implementation code is finite, and easy to reach and maintain,
            but there's an unbounded amount of client code that manipulates BankAccount
            objects. In designing applications, it's important to differentiate between
            requirements imposed on bounded code and unbounded code. If your class
            makes undue requirements on unbounded code, that's usually a sign that
            encapsulation is out the window.
          </p>
<p>
            To conclude, if in designing a multi-threaded class you settle on internal
            locking, you expose yourself to inefficiency or deadlocks. On the other
            hand, if you rely on caller-provided locking, you make your class error-prone
            and difficult to use. Finally, external locking completely avoids the
            issue by leaving it all to the client code.
          </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes" title="External Locking -- strict_lock and externally_locked classes">External
        Locking -- <code class="computeroutput"><span class="identifier">strict_lock</span></code> and
        <code class="computeroutput"><span class="identifier">externally_locked</span></code> classes</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.locks_as_permits">Locks
          as Permits</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.improving_external_locking">Improving
          External Locking</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.allowing_other_strict_locks">Allowing
          other strict locks</a></span></dt>
</dl></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            This tutorial is an adaptation of the paper of Andrei Alexandrescu "Multithreading
            and the C++ Type System" to the Boost library.
          </p></td></tr>
</table></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.locks_as_permits"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.locks_as_permits" title="Locks as Permits">Locks
          as Permits</a>
</h5></div></div></div>
<p>
            So what to do? Ideally, the BankAccount class should do the following:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                Support both locking models (internal and external).
              </li>
<li class="listitem">
                Be efficient; that is, use no unnecessary locking.
              </li>
<li class="listitem">
                Be safe; that is, BankAccount objects cannot be manipulated without
                appropriate locking.
              </li>
</ul></div>
<p>
            Let's make a worthwhile observation: Whenever you lock a BankAccount,
            you do so by using a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> object. Turning this statement around,
            wherever there's a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>, there's also a locked <code class="computeroutput"><span class="identifier">BankAccount</span></code> somewhere. Thus, you can
            think of-and use-a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> object as a permit. Owning a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            gives you rights to do certain things. The <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> object should not be copied or aliased
            (it's not a transmissible permit).
          </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                As long as a permit is still alive, the <code class="computeroutput"><span class="identifier">BankAccount</span></code>
                object stays locked.
              </li>
<li class="listitem">
                When the <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> is destroyed, the <code class="computeroutput"><span class="identifier">BankAccount</span></code>'s mutex is released.
              </li>
</ol></div>
<p>
            The net effect is that at any point in your code, having access to a
            <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            object guarantees that a <code class="computeroutput"><span class="identifier">BankAccount</span></code>
            is locked. (You don't know exactly which <code class="computeroutput"><span class="identifier">BankAccount</span></code>
            is locked, however-an issue that we'll address soon.)
          </p>
<p>
            For now, let's make a couple of enhancements to the <code class="computeroutput"><span class="identifier">lock_guard</span></code>
            class template defined in Boost.Thread. We'll call the enhanced version
            <code class="computeroutput"><span class="identifier">strict_lock</span></code>. Essentially,
            a <code class="computeroutput"><span class="identifier">strict_lock</span></code>'s role
            is only to live on the stack as an automatic variable. <code class="computeroutput"><span class="identifier">strict_lock</span></code> must adhere to a non-copy
            and non-alias policy. <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            disables copying by making the copy constructor and the assignment operator
            private. While we're at it, let's disable operator new and operator delete.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">strict_lock</span>  <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">lockable_type</span><span class="special">;</span>


    <span class="keyword">explicit</span> <span class="identifier">strict_lock</span><span class="special">(</span><span class="identifier">lockable_type</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">obj_</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">obj</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span> <span class="comment">// locks on construction</span>
    <span class="special">}</span>
    <span class="identifier">strict_lock</span><span class="special">()</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">strict_lock</span><span class="special">(</span><span class="identifier">strict_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">strict_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">strict_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="special">~</span><span class="identifier">strict_lock</span><span class="special">()</span> <span class="special">{</span> <span class="identifier">obj_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span> <span class="special">}</span> <span class="comment">//  unlocks on destruction </span>

    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">mutex_type</span> <span class="keyword">const</span><span class="special">*</span> <span class="identifier">l</span><span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="comment">// strict lockers specific function </span>
    <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">l</span> <span class="special">==</span> <span class="special">&amp;</span><span class="identifier">obj_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">lockable_type</span><span class="special">&amp;</span> <span class="identifier">obj_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            Silence can be sometimes louder than words-what's forbidden to do with
            a <code class="computeroutput"><span class="identifier">strict_lock</span></code> is as important
            as what you can do. Let's see what you can and what you cannot do with
            a <code class="computeroutput"><span class="identifier">strict_lock</span></code> instantiation:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                You can create a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> only starting from a valid T
                object. Notice that there is no other way you can create a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>.
              </li></ul></div>
<pre class="programlisting"><span class="identifier">BankAccount</span> <span class="identifier">myAccount</span><span class="special">(</span><span class="string">"John Doe"</span><span class="special">,</span> <span class="string">"123-45-6789"</span><span class="special">);</span>
<span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">myLock</span><span class="special">(</span><span class="identifier">myAccount</span><span class="special">);</span> <span class="comment">// ok</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                You cannot copy <code class="computeroutput"><span class="identifier">strict_lock</span></code>s
                to one another. In particular, you cannot pass <code class="computeroutput"><span class="identifier">strict_lock</span></code>s
                by value to functions or have them returned by functions:
              </li></ul></div>
<pre class="programlisting"><span class="keyword">extern</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">Foo</span><span class="special">();</span> <span class="comment">// compile-time error</span>
<span class="keyword">extern</span> <span class="keyword">void</span> <span class="identifier">Bar</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;);</span> <span class="comment">// compile-time error</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                However, you still can pass <code class="computeroutput"><span class="identifier">strict_lock</span></code>s
                by reference to and from functions:
              </li></ul></div>
<pre class="programlisting"><span class="comment">// ok, Foo returns a reference to strict_lock&lt;BankAccount&gt;</span>
<span class="keyword">extern</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;</span> <span class="identifier">Foo</span><span class="special">();</span>
<span class="comment">// ok, Bar takes a reference to strict_lock&lt;BankAccount&gt;</span>
<span class="keyword">extern</span> <span class="keyword">void</span> <span class="identifier">Bar</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;);</span>
</pre>
<p>
            All these rules were put in place with one purpose-enforcing that owning
            a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
            is a reasonably strong guarantee that
          </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                you locked a T object, and
              </li>
<li class="listitem">
                that object will be unlocked at a later point.
              </li>
</ol></div>
<p>
            Now that we have such a strict <code class="computeroutput"><span class="identifier">strict_lock</span></code>,
            how do we harness its power in defining a safe, flexible interface for
            BankAccount? The idea is as follows:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                Each of BankAccount's interface functions (in our case, Deposit and
                Withdraw) comes in two overloaded variants.
              </li>
<li class="listitem">
                One version keeps the same signature as before, and the other takes
                an additional argument of type <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>. The first version is internally
                locked; the second one requires external locking. External locking
                is enforced at compile time by requiring client code to create a
                <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
                object.
              </li>
<li class="listitem">
                BankAccount avoids code bloating by having the internal locked functions
                forward to the external locked functions, which do the actual job.
              </li>
</ul></div>
<p>
            A little code is worth 1,000 words, a (hacked into) saying goes, so here's
            the new BankAccount class:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">:</span><span class="identifier">recursive_mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">,</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span> <span class="special">{</span>
        <span class="comment">// Externally locked</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">:</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span> <span class="comment">// Internally locked</span>
        <span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">,</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span> <span class="special">{</span>
        <span class="comment">// Externally locked</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">:</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span> <span class="comment">// Internally locked</span>
        <span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Now, if you want the benefit of internal locking, you simply call Deposit(int)
            and Withdraw(int). If you want to use external locking, you lock the
            object by constructing a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> and then you call <code class="computeroutput"><span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span>
            <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span></code>
            and <code class="computeroutput"><span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span></code>.
            For example, here's the <code class="computeroutput"><span class="identifier">ATMWithdrawal</span></code>
            function implemented correctly:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">acct</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            This function has the best of both worlds-it's reasonably safe and efficient
            at the same time.
          </p>
<p>
            It's worth noting that <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            being a template gives extra safety compared to a straight polymorphic
            approach. In such a design, BankAccount would derive from a Lockable
            interface. <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            would manipulate Lockable references so there's no need for templates.
            This approach is sound; however, it provides fewer compile-time guarantees.
            Having a <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            object would only tell that some object derived from Lockable is currently
            locked. In the templated approach, having a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> gives a stronger guarantee-it's a
            <code class="computeroutput"><span class="identifier">BankAccount</span></code> that stays
            locked.
          </p>
<p>
            There's a weasel word in there-I mentioned that ATMWithdrawal is reasonably
            safe. It's not really safe because there's no enforcement that the <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            object locks the appropriate BankAccount object. The type system only
            ensures that some BankAccount object is locked. For example, consider
            the following phony implementation of ATMWithdrawal:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">BankAccount</span> <span class="identifier">fakeAcct</span><span class="special">(</span><span class="string">"John Doe"</span><span class="special">,</span> <span class="string">"123-45-6789"</span><span class="special">);</span>
    <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">fakeAcct</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            This code compiles warning-free but obviously doesn't do the right thing-it
            locks one account and uses another.
          </p>
<p>
            It's important to understand what can be enforced within the realm of
            the C++ type system and what needs to be enforced at runtime. The mechanism
            we've put in place so far ensures that some BankAccount object is locked
            during the call to <code class="computeroutput"><span class="identifier">BankAccount</span><span class="special">::</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span>
            <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span></code>.
            We must enforce at runtime exactly what object is locked.
          </p>
<p>
            If our scheme still needs runtime checks, how is it useful? An unwary
            or malicious programmer can easily lock the wrong object and manipulate
            any BankAccount without actually locking it.
          </p>
<p>
            First, let's get the malice issue out of the way. C is a language that
            requires a lot of attention and discipline from the programmer. C++ made
            some progress by asking a little less of those, while still fundamentally
            trusting the programmer. These languages are not concerned with malice
            (as Java is, for example). After all, you can break any C/C++ design
            simply by using casts "appropriately" (if appropriately is
            an, er, appropriate word in this context).
          </p>
<p>
            The scheme is useful because the likelihood of a programmer forgetting
            about any locking whatsoever is much greater than the likelihood of a
            programmer who does remember about locking, but locks the wrong object.
          </p>
<p>
            Using <code class="computeroutput"><span class="identifier">strict_lock</span></code> permits
            compile-time checking of the most common source of errors, and runtime
            checking of the less frequent problem.
          </p>
<p>
            Let's see how to enforce that the appropriate BankAccount object is locked.
            First, we need to add a member function to the <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            class template. The <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">Loclable</span><span class="special">*)</span></code>
            function returns a reference to the locked object.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="keyword">class</span> <span class="identifier">strict_lock</span> <span class="special">{</span>
    <span class="special">...</span> <span class="identifier">as</span> <span class="identifier">before</span> <span class="special">...</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">mtx</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">mtx</span><span class="special">==&amp;</span><span class="identifier">obj_</span><span class="special">;</span> <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Second, BankAccount needs to use this function compare the locked object
            against this:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span><span class="special">&gt;</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">,</span> <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;</span> <span class="identifier">guard</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// Externally locked</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">guard</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">(*</span><span class="keyword">this</span><span class="special">))</span>
            <span class="keyword">throw</span> <span class="string">"Locking Error: Wrong Object Locked"</span><span class="special">;</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
<span class="comment">// ...</span>
<span class="special">};</span>
</pre>
<p>
            The overhead incurred by the test above is much lower than locking a
            recursive mutex for the second time.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.improving_external_locking"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.improving_external_locking" title="Improving External Locking">Improving
          External Locking</a>
</h5></div></div></div>
<p>
            Now let's assume that BankAccount doesn't use its own locking at all,
            and has only a thread-neutral implementation:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Now you can use BankAccount in single-threaded and multi-threaded applications
            alike, but you need to provide your own synchronization in the latter
            case.
          </p>
<p>
            Say we have an AccountManager class that holds and manipulates a BankAccount
            object:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">AccountManager</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">BankAccount</span> <span class="identifier">checkingAcct_</span><span class="special">;</span>
    <span class="identifier">BankAccount</span> <span class="identifier">savingsAcct_</span><span class="special">;</span>
    <span class="special">...</span>
<span class="special">};</span>
</pre>
<p>
            Let's also assume that, by design, AccountManager must stay locked while
            accessing its BankAccount members. The question is, how can we express
            this design constraint using the C++ type system? How can we state "You
            have access to this BankAccount object only after locking its parent
            AccountManager object"?
          </p>
<p>
            The solution is to use a little bridge template <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            that controls access to a BankAccount.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span>  <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">externally_locked</span> <span class="special">{</span>
    <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">LockableConcept</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;));</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">obj_</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span>
        <span class="special">,</span> <span class="identifier">lockable_</span><span class="special">(</span><span class="identifier">lockable</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">obj_</span><span class="special">()</span>
        <span class="special">,</span> <span class="identifier">lockable_</span><span class="special">(</span><span class="identifier">lockable</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">)</span> <span class="special">{</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">lock</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">(&amp;</span><span class="identifier">lockable_</span><span class="special">))</span> <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span> <span class="identifier">run</span> <span class="identifier">time</span> <span class="identifier">check</span> <span class="keyword">throw</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="identifier">locks</span> <span class="identifier">the</span> <span class="identifier">same</span>
<span class="preprocessor">#endif</span>
        <span class="keyword">return</span> <span class="identifier">obj_</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">set</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">obj_</span> <span class="special">=</span> <span class="identifier">obj</span><span class="special">;</span>
        <span class="identifier">lockable_</span><span class="special">=</span><span class="identifier">lockable</span><span class="special">;</span>
    <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">T</span> <span class="identifier">obj_</span><span class="special">;</span>
    <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            <code class="computeroutput"><span class="identifier">externally_locked</span></code> cloaks
            an object of type T, and actually provides full access to that object
            through the get and set member functions, provided you pass a reference
            to a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">Owner</span><span class="special">&gt;</span></code>
            object.
          </p>
<p>
            Instead of making <code class="computeroutput"><span class="identifier">checkingAcct_</span></code>
            and <code class="computeroutput"><span class="identifier">savingsAcct_</span></code> of type
            <code class="computeroutput"><span class="identifier">BankAccount</span></code>, <code class="computeroutput"><span class="identifier">AccountManager</span></code> holds objects of type
            <code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">,</span>
            <span class="identifier">AccountManager</span><span class="special">&gt;</span></code>:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">AccountManager</span>
    <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">thread_mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">basic_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">thread_mutex</span><span class="special">&gt;</span> <span class="identifier">lockable_base_type</span><span class="special">;</span>
    <span class="identifier">AccountManager</span><span class="special">()</span>
        <span class="special">:</span> <span class="identifier">checkingAcct_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span>
        <span class="special">,</span> <span class="identifier">savingsAcct_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span>
    <span class="special">{}</span>
    <span class="keyword">inline</span> <span class="keyword">void</span> <span class="identifier">Checking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">);</span>
    <span class="keyword">inline</span> <span class="keyword">void</span> <span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">);</span>
<span class="keyword">private</span><span class="special">:</span>

    <span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">,</span> <span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">checkingAcct_</span><span class="special">;</span>
    <span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">,</span> <span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">savingsAcct_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            The pattern is the same as before - to access the BankAccount object
            cloaked by <code class="computeroutput"><span class="identifier">checkingAcct_</span></code>,
            you need to call <code class="computeroutput"><span class="identifier">get</span></code>.
            To call <code class="computeroutput"><span class="identifier">get</span></code>, you need
            to pass it a <code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span></code>. The one thing you have to take care
            of is to not hold pointers or references you obtained by calling <code class="computeroutput"><span class="identifier">get</span></code>. If you do that, make sure that
            you don't use them after the strict_lock has been destroyed. That is,
            if you alias the cloaked objects, you're back from "the compiler
            takes care of that" mode to "you must pay attention" mode.
          </p>
<p>
            Typically, you use <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            as shown below. Suppose you want to execute an atomic transfer from your
            checking account to your savings account:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">Checking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
    <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            We achieved two important goals. First, the declaration of <code class="computeroutput"><span class="identifier">checkingAcct_</span></code> and <code class="computeroutput"><span class="identifier">savingsAcct_</span></code>
            makes it clear to the code reader that that variable is protected by
            a lock on an AccountManager. Second, the design makes it impossible to
            manipulate the two accounts without actually locking a BankAccount.
            <code class="computeroutput"><span class="identifier">externally_locked</span></code> is
            what could be called active documentation.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.allowing_other_strict_locks"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.external_locking_____strict_lock__and__externally_locked__classes.allowing_other_strict_locks" title="Allowing other strict locks">Allowing
          other strict locks</a>
</h5></div></div></div>
<p>
            Now imagine that the AccountManager function needs to take a <code class="computeroutput"><span class="identifier">unique_lock</span></code> in order to reduce the
            critical regions. And at some time it needs to access to the <code class="computeroutput"><span class="identifier">checkingAcct_</span></code>. As <code class="computeroutput"><span class="identifier">unique_lock</span></code>
            is not a strict lock the following code doesn't compiles:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">defer_lock</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">some_condition</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">guard</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span> <span class="comment">// COMPILE ERROR</span>
    <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>  <span class="comment">// COMPILE ERROR</span>
    <span class="identifier">do_something_else</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
            We need a way to transfer the ownership from the <code class="computeroutput"><span class="identifier">unique_lock</span></code>
            to a <code class="computeroutput"><span class="identifier">strict_lock</span></code> the
            time we are working with <code class="computeroutput"><span class="identifier">savingsAcct_</span></code>
            and then restore the ownership on <code class="computeroutput"><span class="identifier">unique_lock</span></code>.
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard1</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">defer_lock</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">some_condition</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="special">{</span>
        <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">guard1</span><span class="special">);</span>
        <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
        <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
            In order to make this code compilable we need to store either a Lockable
            or a <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span></code>
            reference depending on the constructor. Store which kind of reference
            we have stored,and in the destructor call either to the Lockable <code class="computeroutput"><span class="identifier">unlock</span></code> or restore the ownership.
          </p>
<p>
            This seams too complicated to me. Another possibility is to define a
            nested strict lock class. The drawback is that instead of having only
            one strict lock we have two and we need either to duplicate every function
            taking a <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            or make these function templates functions. The problem with template
            functions is that we don't profit anymore of the C++ type system. We
            must add some static metafunction that check that the Locker parameter
            is a strict lock. The problem is that we can not really check this or
            can we?. The <code class="computeroutput"><span class="identifier">is_strict_lock</span></code>
            metafunction must be specialized by the strict lock developer. We need
            to belive it "sur parole". The advantage is that now we can
            manage with more than two strict locks without changing our code. This
            is really nice.
          </p>
<p>
            Now we need to state that both classes are <code class="computeroutput"><span class="identifier">strict_lock</span></code>s.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Locker</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_strict_lock</span> <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span> <span class="special">{};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_strict_lock</span><span class="special">&lt;</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span> <span class="special">{}</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Locker</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_strict_lock</span><span class="special">&lt;</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span> <span class="special">{}</span>
</pre>
<p>
            Well let me show how this <code class="computeroutput"><span class="identifier">nested_strict_lock</span></code>
            class looks like and the impacts on the <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            class and the <code class="computeroutput"><span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedFunction</span></code>
            function.
          </p>
<p>
            First <code class="computeroutput"><span class="identifier">nested_strict_lock</span></code>
            class will store on a temporary lock the <code class="computeroutput"><span class="identifier">Locker</span></code>,
            and transfer the lock ownership on the constructor. On destruction he
            will restore the ownership. Note also that the Locker needs to have already
            a reference to the mutex otherwise an exception is thrown and the use
            of the <code class="computeroutput"><span class="identifier">lock_traits</span></code>.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Locker</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">nested_strict_lock</span>
    <span class="special">{</span>
      <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">MovableLockerConcept</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;));</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lockable_type</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">lockable_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">syntactic_lock_traits</span><span class="special">&lt;</span><span class="identifier">lockable_type</span><span class="special">&gt;::</span><span class="identifier">lock_error</span> <span class="identifier">lock_error</span><span class="special">;</span>

    <span class="identifier">nested_strict_lock</span><span class="special">(</span><span class="identifier">Locker</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">lock_</span><span class="special">(</span><span class="identifier">lock</span><span class="special">)</span>  <span class="comment">// Store reference to locker</span>
        <span class="special">,</span> <span class="identifier">tmp_lock_</span><span class="special">(</span><span class="identifier">lock</span><span class="special">.</span><span class="identifier">move</span><span class="special">())</span> <span class="comment">// Move ownership to temporaty locker </span>
    <span class="special">{</span>
        <span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()==</span><span class="number">0</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">lock_</span><span class="special">=</span><span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">move</span><span class="special">();</span> <span class="comment">// Rollback for coherency purposes </span>
            <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span>
        <span class="special">}</span>
        <span class="preprocessor">#endif</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">tmp_lock_</span><span class="special">)</span> <span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span> <span class="comment">// ensures it is locked </span>
    <span class="special">}</span>
    <span class="special">~</span><span class="identifier">nested_strict_lock</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">lock_</span><span class="special">=</span><span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">move</span><span class="special">();</span> <span class="comment">// Move ownership to nesting locker </span>
    <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span> <span class="special">}</span>
    <span class="identifier">lockable_type</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">tmp_lock_</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">();</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">lockable_type</span><span class="special">*</span> <span class="identifier">l</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">l</span><span class="special">==</span><span class="identifier">mutex</span><span class="special">();</span> <span class="special">}</span>


<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">Locker</span><span class="special">&amp;</span> <span class="identifier">lock_</span><span class="special">;</span>
    <span class="identifier">Locker</span> <span class="identifier">tmp_lock_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            The <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            get function is now a template function taking a Locker as parameters
            instead of a <code class="computeroutput"><span class="identifier">strict_lock</span></code>.
            We can add test in debug mode that ensure that the Lockable object is
            locked.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span>  <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">externally_locked</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// ...</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Locker</span><span class="special">&gt;</span>
    <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">Locker</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">StrictLockerConcept</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;));</span>

        <span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span><span class="identifier">is_strict_lock</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">));</span> <span class="comment">// locker is a strict locker "sur parole" </span>
        <span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">,</span>
                <span class="keyword">typename</span> <span class="identifier">lockable_type</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">));</span> <span class="comment">// that locks the same type </span>
<span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_THREAD_EXTERNALLY_LOCKED_DONT_CHECK_OWNERSHIP</span>  <span class="comment">// define BOOST_THREAD_EXTERNALLY_LOCKED_NO_CHECK_OWNERSHIP if you don't want to check locker ownership</span>
        <span class="keyword">if</span> <span class="special">(!</span> <span class="identifier">lock</span> <span class="special">)</span> <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span> <span class="comment">// run time check throw if no locked </span>
<span class="preprocessor">#endif</span>
<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">lock</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">(&amp;</span><span class="identifier">lockable_</span><span class="special">))</span> <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span>
<span class="preprocessor">#endif</span>
        <span class="keyword">return</span> <span class="identifier">obj_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            The <code class="computeroutput"><span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedFunction</span></code> function needs
            only to replace the <code class="computeroutput"><span class="identifier">strict_lock</span></code>
            by a <code class="computeroutput"><span class="identifier">nested_strict_lock</span></code>.
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard1</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">some_condition</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="special">{</span>
        <span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">guard1</span><span class="special">);</span>
        <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
        <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
<span class="special">}</span>
</pre>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.tutorial.with"></a><a class="link" href="synchronization.html#thread.synchronization.tutorial.with" title="Executing Around a Function">Executing Around
        a Function</a>
</h4></div></div></div>
<p>
          In particular, the library provides some lock factories.
        </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lockable</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Function</span><span class="special">&gt;</span>
<span class="keyword">auto</span> <span class="identifier">with_lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span> <span class="identifier">Function</span> <span class="identifier">f</span><span class="special">)</span> <span class="special">-&gt;</span> <span class="keyword">decltype</span><span class="special">(</span><span class="identifier">f</span><span class="special">())</span>
<span class="special">{</span>
  <span class="keyword">auto</span><span class="special">&amp;&amp;</span> <span class="identifier">_</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_lock_guard</span><span class="special">(</span><span class="identifier">m</span><span class="special">);</span>
  <span class="identifier">f</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
          that can be used as
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">with_lock_guard</span><span class="special">(</span><span class="identifier">mtx</span><span class="special">,</span> <span class="special">[]()</span>
<span class="special">{</span>
  <span class="comment">// access the protected state </span>
  <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
<span class="special">});</span>
</pre>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.mutex_concepts"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts" title="Mutex Concepts">Mutex Concepts</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable"><code class="computeroutput"><span class="identifier">BasicLockable</span></code> Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.lockable"><code class="computeroutput"><span class="identifier">Lockable</span></code> Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.recursive">Recursive
        Lockable Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> Concept -- C++14</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> Concept -- EXTENSION</a></span></dt>
</dl></div>
<p>
        A mutex object facilitates protection against data races and allows thread-safe
        synchronization of data between threads. A thread obtains ownership of a
        mutex object by calling one of the lock functions and relinquishes ownership
        by calling the corresponding unlock function. Mutexes may be either recursive
        or non-recursive, and may grant simultaneous ownership to one or many threads.
        <span class="bold"><strong>Boost.Thread</strong></span> supplies recursive and non-recursive
        mutexes with exclusive ownership semantics, along with a shared ownership
        (multiple-reader / single-writer) mutex.
      </p>
<p>
        <span class="bold"><strong>Boost.Thread</strong></span> supports four basic concepts
        for lockable objects: <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code></a> and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept -- EXTENSION"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code></a>. Each mutex type
        implements one or more of these concepts, as do the various lock types.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.basic_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.is_basic_lockable"><code class="computeroutput"><span class="identifier">is_basic_lockable</span></code> trait -- EXTENSION</a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_concepts.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">BasicLockable</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
<span class="special">}</span>
</pre>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> concept models exclusive
          ownership. A type <code class="computeroutput"><span class="identifier">L</span></code> meets
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> requirements if
          the following expressions are well-formed and have the specified semantics
          (<code class="computeroutput"><span class="identifier">m</span></code> denotes a value of type
          <code class="computeroutput"><span class="identifier">L</span></code>):
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">();</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.basic_lockable.lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The calling thread doesn't owns the mutex if the mutex is not recursive.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The current thread blocks until ownership can be obtained for the
                  current thread.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  Prior <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code>
                  operations on the same object synchronizes with this operation.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread owns <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Return type:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">void</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd>
<p>
                  <span class="bold"><strong>operation_not_permitted</strong></span>: if the
                  thread does not have the privilege to perform the operation.
                </p>
<p>
                  <span class="bold"><strong>resource_deadlock_would_occur</strong></span>:
                  if the implementation detects that a deadlock would occur.
                </p>
<p>
                  <span class="bold"><strong>device_or_resource_busy</strong></span>: if the
                  mutex is already locked and blocking is not possible.
                </p>
</dd>
<dt><span class="term">Thread safety:</span></dt>
<dd><p>
                  If an exception is thrown then a lock shall not have been acquired
                  for the current thread.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.basic_lockable.unlock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The current thread owns <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with subsequent lock operations that
                  obtain ownership on the same object.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Releases a lock on <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread.
                </p></dd>
<dt><span class="term">Return type:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">void</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.basic_lockable.is_basic_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.is_basic_lockable" title="is_basic_lockable trait -- EXTENSION"><code class="computeroutput"><span class="identifier">is_basic_lockable</span></code> trait -- EXTENSION</a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_traits.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">sync</span>
  <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_basic_lockable</span><span class="special">;//</span> <span class="identifier">EXTENSION</span>
  <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
            Some of the algorithms on mutexes use this trait via SFINAE.
          </p>
<p>
            This trait is true_type if the parameter L meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> requirements.
          </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
              If BOOST_THREAD_NO_AUTO_DETECT_MUTEX_TYPES is defined you will need
              to specialize this traits for the models of BasicLockable you could
              build.
            </p></td></tr>
</table></div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.lockable.is_lockable"><code class="computeroutput"><span class="identifier">is_lockable</span></code> trait -- EXTENSION</a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_concepts.hpp&gt; </span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">Lockable</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          A type <code class="computeroutput"><span class="identifier">L</span></code> meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> requirements if it meets
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> requirements and
          the following expressions are well-formed and have the specified semantics
          (<code class="computeroutput"><span class="identifier">m</span></code> denotes a value of type
          <code class="computeroutput"><span class="identifier">L</span></code>):
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span></code></a><span class="special">()</span></code>
            </li></ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.lockable.try_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The calling thread doesn't owns the mutex if the mutex is not recursive.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain ownership for the current thread without blocking.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code>
                  returns true, prior <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                  Since <code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code>
                  does not synchronize with a failed subsequent <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code>, the visibility rules are weak
                  enough that little would be known about the state after a failure,
                  even in the absence of spurious failures.
                </p></dd>
<dt><span class="term">Return type:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">bool</span></code>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                  was obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread owns the <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.lockable.is_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.is_lockable" title="is_lockable trait -- EXTENSION"><code class="computeroutput"><span class="identifier">is_lockable</span></code> trait -- EXTENSION</a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_traits.hpp&gt; </span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">sync</span>
  <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_lockable</span><span class="special">;//</span> <span class="identifier">EXTENSION</span>
  <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
            Some of the algorithms on mutexes use this trait via SFINAE.
          </p>
<p>
            This trait is true_type if the parameter L meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> requirements.
          </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
              If BOOST_THREAD_NO_AUTO_DETECT_MUTEX_TYPES is defined you will need
              to specialize this traits for the models of Lockable you could build.
            </p></td></tr>
</table></div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.recursive"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.recursive" title="Recursive Lockable Concept">Recursive
        Lockable Concept</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.recursive.is_recursive_mutex_sur_parole"><code class="computeroutput"><span class="identifier">is_recursive_mutex_sur_parole</span></code> trait --
          EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.recursive.is_recursive_basic_lockable"><code class="computeroutput"><span class="identifier">is_recursive_basic_lockable</span></code> trait --
          EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.recursive.is_recursive_lockable"><code class="computeroutput"><span class="identifier">is_recursive_lockable</span></code> trait -- EXTENSION</a></span></dt>
</dl></div>
<p>
          The user could require that the mutex passed to an algorithm is a recursive
          one. Whether a lockable is recursive or not can not be checked using template
          meta-programming. This is the motivation for the following trait.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.recursive.is_recursive_mutex_sur_parole"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.recursive.is_recursive_mutex_sur_parole" title="is_recursive_mutex_sur_parole trait -- EXTENSION"><code class="computeroutput"><span class="identifier">is_recursive_mutex_sur_parole</span></code> trait --
          EXTENSION</a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_traits.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">sync</span>
  <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_recursive_mutex_sur_parole</span><span class="special">:</span> <span class="identifier">false_type</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
    <span class="keyword">template</span><span class="special">&lt;&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_recursive_mutex_sur_parole</span><span class="special">&lt;</span><span class="identifier">recursive_mutex</span><span class="special">&gt;:</span> <span class="identifier">true_type</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
    <span class="keyword">template</span><span class="special">&lt;&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_recursive_mutex_sur_parole</span><span class="special">&lt;</span><span class="identifier">timed_recursive_mutex</span><span class="special">&gt;:</span> <span class="identifier">true_type</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
  <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
            The trait <code class="computeroutput"><span class="identifier">is_recursive_mutex_sur_parole</span></code>
            is <code class="computeroutput"><span class="identifier">false_type</span></code> by default
            and is specialized for the provide <code class="computeroutput"><span class="identifier">recursive_mutex</span></code>
            and <code class="computeroutput"><span class="identifier">timed_recursive_mutex</span></code>.
          </p>
<p>
            It should be specialized by the user providing other model of recursive
            lockable.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.recursive.is_recursive_basic_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.recursive.is_recursive_basic_lockable" title="is_recursive_basic_lockable trait -- EXTENSION"><code class="computeroutput"><span class="identifier">is_recursive_basic_lockable</span></code> trait --
          EXTENSION</a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_traits.hpp&gt; </span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">sync</span>
  <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_recursive_basic_lockable</span><span class="special">;//</span> <span class="identifier">EXTENSION</span>
  <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
            This traits is true_type if is_basic_lockable and is_recursive_mutex_sur_parole.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.recursive.is_recursive_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.recursive.is_recursive_lockable" title="is_recursive_lockable trait -- EXTENSION"><code class="computeroutput"><span class="identifier">is_recursive_lockable</span></code> trait -- EXTENSION</a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_traits.hpp&gt; </span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">sync</span>
  <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
    <span class="keyword">class</span> <span class="identifier">is_recursive_lockable</span><span class="special">;//</span> <span class="identifier">EXTENSION</span>
  <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
            This traits is true_type if is_lockable and is_recursive_mutex_sur_parole.
          </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_concepts.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">TimedLockable</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
<span class="special">}</span>
</pre>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> refines
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> to add support
          for timeouts when trying to acquire the lock.
        </p>
<p>
          A type <code class="computeroutput"><span class="identifier">L</span></code> meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code></a> requirements if
          it meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> requirements and the
          following expressions are well-formed and have the specified semantics.
        </p>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span></code> denotes a value of
              type <code class="computeroutput"><span class="identifier">L</span></code>,
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">rel_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code>,
              and
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span></code>:
            </li>
</ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a> must be released
          through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.try_lock_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The calling thread doesn't owns the mutex if the mutex is not recursive.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain ownership for the current thread. Blocks until
                  ownership can be obtained, or the specified time is reached. If
                  the specified time has already passed, behaves as <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><span class="identifier">try_lock_until</span><span class="special">()</span></code> returns true, prior <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code>
                  operations on the same object synchronize with this operation.
                </p></dd>
<dt><span class="term">Return type:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">bool</span></code>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                  was obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread owns <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.try_lock_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The calling thread doesn't owns the mutex if the mutex is not recursive.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  As-if <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">(</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">steady_clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">rel_time</span><span class="special">)</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><span class="identifier">try_lock_for</span><span class="special">()</span></code> returns true, prior <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code>
                  operations on the same object synchronize with this operation.
                </p></dd>
</dl>
</div>
</div>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top">
<p>
            DEPRECATED since 4.00. The following expressions were required on version
            2, but are now deprecated.
          </p>
<p>
            Available only up to Boost 1.58.
          </p>
<p>
            Use instead <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a>.
          </p>
</td></tr>
</table></div>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">rel_time</span></code> denotes a
              value of an instantiation of an unspecified <code class="computeroutput"><span class="identifier">DurationType</span></code>
              arithmetic compatible with <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span></code>,
              and
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span></code>:
            </li>
</ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="m.timed_lock(rel_time)"><code class="computeroutput"><span class="identifier">timed_lock</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.timed_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain ownership for the current thread. Blocks until
                  ownership can be obtained, or the specified time is reached. If
                  the specified time has already passed, behaves as <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                  was obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread owns <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="m.timed_lock(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  As-if <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">get_system_time</span><span class="special">()+</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> Concept -- C++14</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">))</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_concepts.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">SharedLockable</span><span class="special">;</span>  <span class="comment">// C++14</span>
<span class="special">}</span>
</pre>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a> is a refinement
          of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> that allows
          for <span class="emphasis"><em>shared ownership</em></span> as well as <span class="emphasis"><em>exclusive
          ownership</em></span>. This is the standard multiple-reader / single-write
          model: at most one thread can have exclusive ownership, and if any thread
          does have exclusive ownership, no other threads can have shared or exclusive
          ownership. Alternatively, many threads may have shared ownership.
        </p>
<p>
          A type <code class="computeroutput"><span class="identifier">L</span></code> meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code></a> requirements if
          it meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code></a> requirements and
          the following expressions are well-formed and have the specified semantics.
        </p>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span></code> denotes a value of
              type <code class="computeroutput"><span class="identifier">L</span></code>,
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">rel_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code>,
              and
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span></code>:
            </li>
</ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_shared_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">try_lock_shared_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a><span class="special">();</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_shared_for</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">try_lock_shared_until</span></code></a> must be
          released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The current thread blocks until shared ownership can be obtained
                  for the current thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain shared ownership for the current thread without
                  blocking.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                  was obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain shared ownership for the current thread. Blocks
                  until shared ownership can be obtained, or the specified duration
                  is elapsed. If the specified duration is already elapsed, behaves
                  as <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">))</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain shared ownership for the current thread. Blocks
                  until shared ownership can be obtained, or the specified time is
                  reached. If the specified time has already passed, behaves as
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.unlock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Releases shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread no longer has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top">
<p>
            DEPRECATED since 3.00. The following expressions were required on version
            2, but are now deprecated.
          </p>
<p>
            Available only up to Boost 1.56.
          </p>
<p>
            Use instead <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_shared_for</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">try_lock_shared_until</span></code></a>.
          </p>
</td></tr>
</table></div>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span></code>:
            </li></ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">);</span></code>
            </li></ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock_shared</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempt to obtain shared ownership for the current thread. Blocks
                  until shared ownership can be obtained, or the specified time is
                  reached. If the specified time has already passed, behaves as
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept -- EXTENSION"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> Concept -- EXTENSION</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_and_lock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_and_lock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade_and_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_until"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lockable_concepts.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">L</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">UpgradeLockable</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
<span class="special">}</span>
</pre>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept -- EXTENSION"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> concept</a> is a refinement
          of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a> that allows
          for <span class="emphasis"><em>upgradable ownership</em></span> as well as <span class="emphasis"><em>shared
          ownership</em></span> and <span class="emphasis"><em>exclusive ownership</em></span>. This
          is an extension to the multiple-reader / single-write model provided by
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a>: a single
          thread may have <span class="emphasis"><em>upgradable ownership</em></span> at the same time
          as others have <span class="emphasis"><em>shared ownership</em></span>. The thread with
          <span class="emphasis"><em>upgradable ownership</em></span> may at any time attempt to upgrade
          that ownership to <span class="emphasis"><em>exclusive ownership</em></span>. If no other
          threads have shared ownership, the upgrade is completed immediately, and
          the thread now has <span class="emphasis"><em>exclusive ownership</em></span>, which must
          be relinquished by a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>,
          just as if it had been acquired by a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>.
        </p>
<p>
          If a thread with <span class="emphasis"><em>upgradable ownership</em></span> tries to upgrade
          whilst other threads have <span class="emphasis"><em>shared ownership</em></span>, the attempt
          will fail and the thread will block until <span class="emphasis"><em>exclusive ownership</em></span>
          can be acquired.
        </p>
<p>
          Ownership can also be <span class="emphasis"><em>downgraded</em></span> as well as <span class="emphasis"><em>upgraded</em></span>:
          exclusive ownership of an implementation of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept -- EXTENSION"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> concept</a> can be
          downgraded to upgradable ownership or shared ownership, and upgradable
          ownership can be downgraded to plain shared ownership.
        </p>
<p>
          A type <code class="computeroutput"><span class="identifier">L</span></code> meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept -- EXTENSION"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code></a> requirements if
          it meets the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code></a> requirements and
          the following expressions are well-formed and have the specified semantics.
        </p>
<p>
          <span class="bold"><strong>Variables:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span></code> denotes a value of
              type <code class="computeroutput"><span class="identifier">L</span></code>,
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">rel_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code>,
              and
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">abs_time</span></code> denotes a
              value of an instantiation of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span></code>:
            </li>
</ul></div>
<p>
          <span class="bold"><strong>Expressions:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade" title="m.lock_upgrade()"><code class="computeroutput"><span class="identifier">lock_upgrade</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_lock_upgrade</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for" title="m.try_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_upgrade_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until" title="m.try_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_upgrade_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_shared" title="m.unlock_and_lock_shared()"><code class="computeroutput"><span class="identifier">unlock_and_lock_shared</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade" title="m.unlock_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_and_lock_upgrade</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock" title="m.unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">unlock_upgrade_and_lock</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock</span></code></a><span class="special">()</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for" title="m.try_unlock_upgrade_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_until" title="m.try_unlock_upgrade_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared" title="m.unlock_upgrade_and_lock_shared()"><code class="computeroutput"><span class="identifier">unlock_upgrade_and_lock_shared</span></code></a><span class="special">();</span></code>
            </li>
</ul></div>
<p>
          If `BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION is defined the
          following expressions are also required:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock" title="m.try_unlock_shared_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">);</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">);</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade</span></code></a><span class="special">();</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for" title="m.try_unlock_shared_and_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">);</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until" title="m.try_unlock_shared_and_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">);</span></code>
            </li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade" title="m.lock_upgrade()"><code class="computeroutput"><span class="identifier">lock_upgrade</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a>.
          If the ownership type is changed through a call to one of the <code class="computeroutput"><span class="identifier">unlock_xxx_and_lock_yyy</span><span class="special">()</span></code>
          functions, ownership must be released through a call to the unlock function
          corresponding to the new level of ownership.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade" title="m.lock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread has no ownership of the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The current thread blocks until upgrade ownership can be obtained
                  for the current thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  Prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock_error</span></code> if an
                  error occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Releases upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread no longer has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with subsequent lock operations that
                  obtain ownership on the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread has no ownership of the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Attempts to obtain upgrade ownership of the mutex for the calling
                  thread without blocking. If upgrade ownership is not obtained,
                  there is no effect and try_lock_upgrade() immediately returns.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_lock_upgrade</span></code></a><span class="special">()</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for" title="m.try_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread has no ownership of the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If the tick period of <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is not exactly convertible to the native tick period, the duration
                  shall be rounded up to the nearest native tick period. Attempts
                  to obtain upgrade lock ownership for the calling thread within
                  the relative timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>.
                  If the time specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is less than or equal to <code class="computeroutput"><span class="identifier">rel_time</span><span class="special">.</span><span class="identifier">zero</span><span class="special">()</span></code>, the function attempts to obtain
                  ownership without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_lock_upgrade</span></code></a><span class="special">()</span></code>). The function returns within
                  the timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  only if it has obtained upgrade ownership of the mutex object.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_for" title="m.try_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_upgrade_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until" title="m.try_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_upgrade_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread has no ownership of the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to obtain upgrade ownership of the mutex.
                  If <code class="computeroutput"><span class="identifier">abs_time</span></code> has
                  already passed, the function attempts to obtain upgrade ownership
                  without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade" title="m.try_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_lock_upgrade</span></code></a><span class="special">()</span></code>). The function returns before
                  the absolute timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  only if it has obtained upgrade ownership of the mutex object.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_lock_upgrade_until" title="m.try_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_upgrade_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> operations on the same object
                  synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock" title="m.try_unlock_shared_and_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread must hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  shared to exclusive for the calling thread without blocking. For
                  this conversion to be successful, this thread must be the only
                  thread holding any ownership of the lock. If the conversion is
                  not successful, the shared ownership of m is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock" title="m.try_unlock_shared_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span></code></a><span class="special">()</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If the tick period of <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is not exactly convertible to the native tick period, the duration
                  shall be rounded up to the nearest native tick period. The function
                  attempts to atomically convert the ownership from shared to exclusive
                  for the calling thread within the relative timeout specified by
                  <code class="computeroutput"><span class="identifier">rel_time</span></code>. If the
                  time specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is less than or equal to <code class="computeroutput"><span class="identifier">rel_time</span><span class="special">.</span><span class="identifier">zero</span><span class="special">()</span></code>, the function attempts to obtain
                  exclusive ownership without blocking (as if by calling <code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code>).
                  The function shall return within the timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code> only if it has obtained
                  exclusive ownership of the mutex object. For this conversion to
                  be successful, this thread must be the only thread holding any
                  ownership of the lock at the moment of conversion. If the conversion
                  is not successful, the shared ownership of the mutex is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  shared to exclusive for the calling thread within the absolute
                  timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>.
                  If <code class="computeroutput"><span class="identifier">abs_time</span></code> has
                  already passed, the function attempts to obtain exclusive ownership
                  without blocking (as if by calling <code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code>). The function shall return before
                  the absolute timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  only if it has obtained exclusive ownership of the mutex object.
                  For this conversion to be successful, this thread must be the only
                  thread holding any ownership of the lock at the moment of conversion.
                  If the conversion is not successful, the shared ownership of the
                  mutex is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_shared" title="m.unlock_and_lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_and_lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold an exclusive lock on <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically converts the ownership from exclusive to shared for
                  the calling thread.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with subsequent lock operations that
                  obtain ownership of the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  shared to upgrade for the calling thread without blocking. For
                  this conversion to be successful, there must be no thread holding
                  upgrade ownership of this object. If the conversion is not successful,
                  the shared ownership of the mutex is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade</span></code></a><span class="special">()</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> and subsequent lock operations
                  on the same object synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for" title="m.try_unlock_shared_and_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If the tick period of <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is not exactly convertible to the native tick period, the duration
                  shall be rounded up to the nearest native tick period. The function
                  attempts to atomically convert the ownership from shared to upgrade
                  for the calling thread within the relative timeout specified by
                  <code class="computeroutput"><span class="identifier">rel_time</span></code>. If the
                  time specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is less than or equal to <code class="computeroutput"><span class="identifier">rel_time</span><span class="special">.</span><span class="identifier">zero</span><span class="special">()</span></code>, the function attempts to obtain
                  upgrade ownership without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade</span></code></a><span class="special">()</span></code>). The function shall return within
                  the timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  only if it has obtained exclusive ownership of the mutex object.
                  For this conversion to be successful, there must be no thread holding
                  upgrade ownership of this object at the moment of conversion. If
                  the conversion is not successful, the shared ownership of m is
                  retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_for" title="m.try_unlock_shared_and_lock_upgrade_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> and subsequent lock operations
                  on the same object synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until" title="m.try_unlock_shared_and_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_shared_and_lock_upgrade_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a shared lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  shared to upgrade for the calling thread within the absolute timeout
                  specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>.
                  If <code class="computeroutput"><span class="identifier">abs_time</span></code> has
                  already passed, the function attempts to obtain upgrade ownership
                  without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade" title="m.try_unlock_shared_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade</span></code></a><span class="special">()</span></code>). The function shall return before
                  the absolute timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  only if it has obtained upgrade ownership of the mutex object.
                  For this conversion to be successful, there must be no thread holding
                  upgrade ownership of this object at the moment of conversion. If
                  the conversion is not successful, the shared ownership of the mutex
                  is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if upgrade ownership
                  was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_upgrade_until" title="m.try_unlock_shared_and_lock_upgrade_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_upgrade_until</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span></code></a><span class="special">()</span></code> and subsequent lock operations
                  on the same object synchronize with this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade" title="m.unlock_and_lock_upgrade()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_and_lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically releases exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread and acquires upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code> without blocking.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with subsequent lock operations that
                  obtain ownership of the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock" title="m.unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade_and_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically releases upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread and acquires exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>. If any other threads have
                  shared ownership, blocks until exclusive ownership can be acquired.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a><span class="special">()</span></code> and subsequent lock operations
                  that obtain ownership of the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a upgrade lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  upgrade to exclusive for the calling thread without blocking. For
                  this conversion to be successful, this thread must be the only
                  thread holding any ownership of the lock. If the conversion is
                  not successful, the upgrade ownership of m is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock</span></code></a><span class="special">()</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for" title="m.try_unlock_upgrade_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock_for</span><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a upgrade lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If the tick period of <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is not exactly convertible to the native tick period, the duration
                  shall be rounded up to the nearest native tick period. The function
                  attempts to atomically convert the ownership from upgrade to exclusive
                  for the calling thread within the relative timeout specified by
                  <code class="computeroutput"><span class="identifier">rel_time</span></code>. If the
                  time specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  is less than or equal to <code class="computeroutput"><span class="identifier">rel_time</span><span class="special">.</span><span class="identifier">zero</span><span class="special">()</span></code>, the function attempts to obtain
                  exclusive ownership without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock</span></code></a><span class="special">()</span></code>). The function shall return within
                  the timeout specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  only if it has obtained exclusive ownership of the mutex object.
                  For this conversion to be successful, this thread shall be the
                  only thread holding any ownership of the lock at the moment of
                  conversion. If the conversion is not successful, the upgrade ownership
                  of m is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for" title="m.try_unlock_upgrade_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_until"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_until" title="m.try_unlock_upgrade_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_unlock_upgrade_and_lock_until</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The calling thread shall hold a upgrade lock on the mutex.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The function attempts to atomically convert the ownership from
                  upgrade to exclusive for the calling thread within the absolute
                  timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>.
                  If <code class="computeroutput"><span class="identifier">abs_time</span></code> has
                  already passed, the function attempts to obtain exclusive ownership
                  without blocking (as if by calling <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock" title="m.try_unlock_upgrade_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock</span></code></a><span class="special">()</span></code>). The function shall return before
                  the absolute timeout specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  only if it has obtained exclusive ownership of the mutex object.
                  For this conversion to be successful, this thread shall be the
                  only thread holding any ownership of the lock at the moment of
                  conversion. If the conversion is not successful, the upgrade ownership
                  of m is retained.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if exclusive
                  ownership was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  the current thread has exclusive ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  If <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_upgrade_and_lock_for" title="m.try_unlock_upgrade_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_upgrade_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns true, prior <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  and subsequent lock operations on the same object synchronize with
                  this operation.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared" title="m.unlock_upgrade_and_lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread has upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically releases upgrade ownership of <code class="computeroutput"><span class="identifier">m</span></code>
                  by the current thread and acquires shared ownership of <code class="computeroutput"><span class="identifier">m</span></code> without blocking.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  The current thread has shared ownership of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                  This operation synchronizes with prior <code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code> and subsequent lock operations
                  that obtain ownership of the same object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing
                </p></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.lock_option"></a><a class="link" href="synchronization.html#thread.synchronization.lock_option" title="Lock Options">Lock Options</a>
</h3></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_option.lock_tags">Lock
        option tags</a></span></dt></dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/locks.hpp&gt; </span>
<span class="comment">// #include &lt;boost/thread/locks_options.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">struct</span> <span class="identifier">defer_lock_t</span> <span class="special">{};</span>
  <span class="keyword">struct</span> <span class="identifier">try_to_lock_t</span> <span class="special">{};</span>
  <span class="keyword">struct</span> <span class="identifier">adopt_lock_t</span> <span class="special">{};</span>
  <span class="keyword">constexpr</span> <span class="identifier">defer_lock_t</span> <span class="identifier">defer_lock</span><span class="special">;</span>
  <span class="keyword">constexpr</span> <span class="identifier">try_to_lock_t</span> <span class="identifier">try_to_lock</span><span class="special">;</span>
  <span class="keyword">constexpr</span> <span class="identifier">adopt_lock_t</span> <span class="identifier">adopt_lock</span><span class="special">;</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_option.lock_tags"></a><a class="link" href="synchronization.html#thread.synchronization.lock_option.lock_tags" title="Lock option tags">Lock
        option tags</a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">locks</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">locks_options</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">struct</span> <span class="identifier">defer_lock_t</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">try_to_lock_t</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">adopt_lock_t</span> <span class="special">{};</span>
<span class="keyword">const</span> <span class="identifier">defer_lock_t</span> <span class="identifier">defer_lock</span><span class="special">;</span>
<span class="keyword">const</span> <span class="identifier">try_to_lock_t</span> <span class="identifier">try_to_lock</span><span class="special">;</span>
<span class="keyword">const</span> <span class="identifier">adopt_lock_t</span> <span class="identifier">adopt_lock</span><span class="special">;</span>
</pre>
<p>
          These tags are used in scoped locks constructors to specify a specific
          behavior.
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">defer_lock_t</span></code>: is used
              to construct the scoped lock without locking it.
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">try_to_lock_t</span></code>: is used
              to construct the scoped lock trying to lock it.
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">adopt_lock_t</span></code>: is used
              to construct the scoped lock without locking it but adopting ownership.
            </li>
</ul></div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.lock_guard"></a><a class="link" href="synchronization.html#thread.synchronization.lock_guard" title="Lock Guard">Lock Guard</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_guard.lock_guard">Class
        template <code class="computeroutput"><span class="identifier">lock_guard</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_guard.make_lock_guard">Non
        Member Function <code class="computeroutput"><span class="identifier">make_lock_guard</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_guard.make_lock_guard_adopt">Non
        Member Function <code class="computeroutput"><span class="identifier">make_lock_guard</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/locks.hpp&gt; </span>
<span class="comment">// #include &lt;boost/thread/lock_guard.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">lock_guard</span>
<span class="preprocessor">#if</span> <span class="special">!</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_NO_MAKE_LOCK_GUARD</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="identifier">adopt_lock_t</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
<span class="preprocessor">#endif</span>
<span class="special">}</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_guard.lock_guard"></a><a class="link" href="synchronization.html#thread.synchronization.lock_guard.lock_guard" title="Class template lock_guard">Class
        template <code class="computeroutput"><span class="identifier">lock_guard</span></code></a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_guard.lock_guard.constructor"><code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_guard.lock_guard.constructor_adopt"><code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_guard.lock_guard.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">lock_guard</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/locks.hpp&gt;</span>
<span class="comment">// #include &lt;boost/thread/lock_guard.hpp&gt; </span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">lock_guard</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">explicit</span> <span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>

    <span class="special">~</span><span class="identifier">lock_guard</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.lock_guard.lock_guard" title="Class template lock_guard"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span></code></a> is very simple: on
          construction it acquires ownership of the implementation of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> supplied as the
          constructor parameter. On destruction, the ownership is released. This
          provides simple RAII-style locking of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, to facilitate
          exception-safe locking and unlocking. In addition, the <a class="link" href="synchronization.html#thread.synchronization.lock_guard.lock_guard.constructor_adopt" title="lock_guard(Lockable &amp; m,boost::adopt_lock_t)"><code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code>
          constructor</a> allows the <a class="link" href="synchronization.html#thread.synchronization.lock_guard.lock_guard" title="Class template lock_guard"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span></code></a> object to take ownership
          of a lock already held by the current thread.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.lock_guard.lock_guard.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.lock_guard.lock_guard.constructor" title="lock_guard(Lockable &amp; m)"><code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.lock_guard.lock_guard.constructor_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.lock_guard.lock_guard.constructor_adopt" title="lock_guard(Lockable &amp; m,boost::adopt_lock_t)"><code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread owns a lock on <code class="computeroutput"><span class="identifier">m</span></code>
                  equivalent to one obtained by a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Takes ownership of the lock state of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.lock_guard.lock_guard.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.lock_guard.lock_guard.destructor" title="~lock_guard()"><code class="computeroutput"><span class="special">~</span><span class="identifier">lock_guard</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code></a>
                  on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object passed
                  to the constructor.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_guard.make_lock_guard"></a><a class="link" href="synchronization.html#thread.synchronization.lock_guard.make_lock_guard" title="Non Member Function make_lock_guard">Non
        Member Function <code class="computeroutput"><span class="identifier">make_lock_guard</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                a lock_guard as if initialized with <code class="computeroutput"><span class="special">{</span><span class="identifier">m</span><span class="special">}</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
              </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_guard.make_lock_guard_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.lock_guard.make_lock_guard_adopt" title="Non Member Function make_lock_guard">Non
        Member Function <code class="computeroutput"><span class="identifier">make_lock_guard</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span> <span class="identifier">adopt_lock_t</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                a lock_guard as if initialized with <code class="computeroutput"><span class="special">{</span><span class="identifier">m</span><span class="special">,</span> <span class="identifier">adopt_lock</span><span class="special">}</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.lock_concepts"></a><a class="link" href="synchronization.html#thread.synchronization.lock_concepts" title="Lock Concepts">Lock Concepts</a>
</h3></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_concepts.StrictLock">StrictLock
        -- EXTENSION</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_concepts.StrictLock"></a><a class="link" href="synchronization.html#thread.synchronization.lock_concepts.StrictLock" title="StrictLock -- EXTENSION">StrictLock
        -- EXTENSION</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_concepts.StrictLock.mutex_type"><code class="computeroutput"><span class="identifier">L</span><span class="special">::</span><span class="identifier">mutex_type</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_concepts.StrictLock.is_strict_lock_sur_parole"><code class="computeroutput"><span class="identifier">is_strict_lock_sur_parole</span><span class="special">&lt;</span><span class="identifier">L</span><span class="special">&gt;</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_concepts.StrictLock.owns_lock"><code class="computeroutput"><span class="identifier">cl</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">m</span><span class="special">);</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_concepts.StrictLock.models">Models</a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/lock_concepts.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">StrictLock</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          A StrictLock is a lock that ensures that the associated mutex is locked
          during the lifetime of the lock.
        </p>
<p>
          A type <code class="computeroutput"><span class="identifier">L</span></code> meets the StrictLock
          requirements if the following expressions are well-formed and have the
          specified semantics
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">L</span><span class="special">::</span><span class="identifier">mutex_type</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">is_strict_lock</span><span class="special">&lt;</span><span class="identifier">L</span><span class="special">&gt;</span></code>
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">cl</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">m</span><span class="special">);</span></code>
            </li>
</ul></div>
<p>
          and BasicLockable&lt;L::mutex_type&gt;
        </p>
<p>
          where
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">cl</span></code> denotes a value
              of type <code class="computeroutput"><span class="identifier">L</span> <span class="keyword">const</span><span class="special">&amp;</span></code>,
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">m</span></code> denotes a value of
              type <code class="computeroutput"><span class="identifier">L</span><span class="special">::</span><span class="identifier">mutex_type</span> <span class="keyword">const</span><span class="special">*</span></code>,
            </li>
</ul></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.lock_concepts.StrictLock.mutex_type"></a><a class="link" href="synchronization.html#thread.synchronization.lock_concepts.StrictLock.mutex_type" title="L::mutex_type"><code class="computeroutput"><span class="identifier">L</span><span class="special">::</span><span class="identifier">mutex_type</span></code></a>
</h5></div></div></div>
<p>
            The type L::mutex_type denotes the mutex that is locked by this lock.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.lock_concepts.StrictLock.is_strict_lock_sur_parole"></a><a class="link" href="synchronization.html#thread.synchronization.lock_concepts.StrictLock.is_strict_lock_sur_parole" title="is_strict_lock_sur_parole&lt;L&gt;"><code class="computeroutput"><span class="identifier">is_strict_lock_sur_parole</span><span class="special">&lt;</span><span class="identifier">L</span><span class="special">&gt;</span></code></a>
</h5></div></div></div>
<p>
            As the semantic "ensures that the associated mutex is locked during
            the lifetime of the lock. " can not be described by syntactic requirements
            a <code class="computeroutput"><span class="identifier">is_strict_lock_sur_parole</span></code>
            trait must be specialized by the user defining the lock so that the following
            assertion is true:
          </p>
<pre class="programlisting"><span class="identifier">is_strict_lock_sur_parole</span><span class="special">&lt;</span><span class="identifier">L</span><span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">==</span> <span class="keyword">true</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.lock_concepts.StrictLock.owns_lock"></a><a class="link" href="synchronization.html#thread.synchronization.lock_concepts.StrictLock.owns_lock" title="cl.owns_lock(m);"><code class="computeroutput"><span class="identifier">cl</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">m</span><span class="special">);</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Return Type:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">bool</span></code>
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  Whether the strict lock is locking the mutex <code class="computeroutput"><span class="identifier">m</span></code>
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.lock_concepts.StrictLock.models"></a><a class="link" href="synchronization.html#thread.synchronization.lock_concepts.StrictLock.models" title="Models">Models</a>
</h5></div></div></div>
<p>
            The following classes are models of <code class="computeroutput"><span class="identifier">StrictLock</span></code>:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                strict_lock: ensured by construction,
              </li>
<li class="listitem">
                nested_strict_lock: "sur parole" as the user could use
                adopt_lock_t on unique_lock constructor overload without having locked
                the mutex,
              </li>
<li class="listitem">
                <a class="link" href="synchronization.html#thread.synchronization.lock_guard.lock_guard" title="Class template lock_guard"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span></code></a>: "sur parole"
                as the user could use adopt_lock_t constructor overload without having
                locked the mutex.
              </li>
</ul></div>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.locks"></a><a class="link" href="synchronization.html#thread.synchronization.locks" title="Lock Types">Lock Types</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock">Class template
        <code class="computeroutput"><span class="identifier">unique_lock</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock">Class template
        <code class="computeroutput"><span class="identifier">shared_lock</span></code> - C++14</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.upgrade_lock">Class template
        <code class="computeroutput"><span class="identifier">upgrade_lock</span></code> - EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.upgrade_to_unique_lock">Class
        template <code class="computeroutput"><span class="identifier">upgrade_to_unique_lock</span></code>
        -- EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.scoped_try_lock">Mutex-specific
        class <code class="computeroutput"><span class="identifier">scoped_try_lock</span></code> --
        DEPRECATED</a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/locks.hpp&gt; </span>
<span class="comment">// #include &lt;boost/thread/lock_types.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">unique_lock</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Mutex</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">unique_lock</span> <span class="special">&lt;</span><span class="identifier">Mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lhs</span><span class="special">,</span> <span class="identifier">unique_lock</span> <span class="special">&lt;</span><span class="identifier">Mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">shared_lock</span><span class="special">;</span> <span class="comment">// C++14</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Mutex</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">Mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lhs</span><span class="special">,</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">Mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">rhs</span><span class="special">);</span> <span class="comment">// C++14</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">upgrade_lock</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Mutex</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">upgrade_lock</span> <span class="special">&lt;</span><span class="identifier">Mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lhs</span><span class="special">,</span> <span class="identifier">upgrade_lock</span> <span class="special">&lt;</span><span class="identifier">Mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">rhs</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Mutex</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">upgrade_to_unique_lock</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
<span class="special">}</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.unique_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock">Class template
        <code class="computeroutput"><span class="identifier">unique_lock</span></code></a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.defaultconstructor"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_adopt"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_defer"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">defer_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_try"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_sh_try"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span>
          <span class="identifier">sl</span><span class="special">,</span>
          <span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_sh_until"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_sh_for"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_abs_time"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_time_point"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
          <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_duration"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
          <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">unique_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.mutex"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.explicit_bool_conversion"><code class="computeroutput"><span class="keyword">explicit</span> <span class="keyword">operator</span>
          <span class="keyword">bool</span><span class="special">()</span>
          <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.release"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/locks.hpp&gt;</span>
<span class="comment">// #include &lt;boost/thread/lock_types.hpp&gt; </span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">unique_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">mutex_type</span><span class="special">;</span>
    <span class="identifier">unique_lock</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">explicit</span> <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">defer_lock_t</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">try_to_lock_t</span><span class="special">);</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span> <span class="identifier">try_to_lock_t</span><span class="special">);</span> <span class="comment">// C++14 </span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span> <span class="comment">// C++14</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span> <span class="comment">// C++14</span>
<span class="preprocessor">#endif</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Mutex</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Mutex</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">);</span>
    <span class="special">~</span><span class="identifier">unique_lock</span><span class="special">();</span>

    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">unique_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">unique_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">unique_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">explicit</span> <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span> <span class="comment">// EXTENSION</span>

    <span class="identifier">unique_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">unique_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="keyword">bool</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">mutex_type</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_USE_DATE_TIME</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">target_time</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TimeDuration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">TimeDuration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">relative_time</span><span class="special">);</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(::</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">absolute_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>

<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> is more complex than
          <a class="link" href="synchronization.html#thread.synchronization.lock_guard.lock_guard" title="Class template lock_guard"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span></code></a>: not only does it provide
          for RAII-style locking, it also allows for deferring acquiring the lock
          until the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          member function is called explicitly, or trying to acquire the lock in
          a non-blocking fashion, or with a timeout. Consequently, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          is only called in the destructor if the lock object has locked the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, or otherwise
          adopted a lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object.
        </p>
<p>
          Specializations of <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> model the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code></a> concept if the supplied
          <code class="computeroutput"><span class="identifier">Lockable</span></code> type itself models
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code></a> concept (e.g. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">timed_mutex</span><span class="special">&gt;</span></code>),
          or the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> concept if the supplied
          <code class="computeroutput"><span class="identifier">Lockable</span></code> type itself models
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> concept (e.g. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span></code>),
          or the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> concept if the supplied
          <code class="computeroutput"><span class="identifier">Lockable</span></code> type itself models
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> concept.
        </p>
<p>
          An instance of <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> is said to <span class="emphasis"><em>own</em></span>
          the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> <code class="computeroutput"><span class="identifier">m</span></code>
          if <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
          returns a pointer to <code class="computeroutput"><span class="identifier">m</span></code>
          and <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
          returns <code class="computeroutput"><span class="keyword">true</span></code>. If an object
          that <span class="emphasis"><em>owns</em></span> the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is destroyed,
          then the destructor will invoke <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()-&gt;</span><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<p>
          The member functions of <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> are not thread-safe.
          In particular, <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> is intended to model
          the ownership of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object by a particular
          thread, and the member functions that release ownership of the lock state
          (including the destructor) must be called by the same thread that acquired
          ownership of the lock state.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.defaultconstructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.defaultconstructor" title="unique_lock()"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Creates a lock object with no associated mutex.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="identifier">NULL</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor" title="unique_lock(Lockable &amp; m)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_adopt" title="unique_lock(Lockable &amp; m,boost::adopt_lock_t)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread owns an exclusive lock on <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Takes ownership of the lock state of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_defer"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_defer" title="unique_lock(Lockable &amp; m,boost::defer_lock_t)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">defer_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_try"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_try" title="unique_lock(Lockable &amp; m,boost::try_to_lock_t)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
                  and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                  If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                  returned <code class="computeroutput"><span class="keyword">true</span></code>, then
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_sh_try"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_sh_try" title="unique_lock(shared_lock&lt;mutex_type&gt;&amp;&amp; sl, try_to_lock_t)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span>
          <span class="identifier">sl</span><span class="special">,</span>
          <span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The supplied <code class="computeroutput"><span class="identifier">Mutex</span></code>
                  type must implement <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock" title="m.try_unlock_shared_and_lock()"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock</span></code></a><span class="special">()</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Constructs an object of type <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>. Let <code class="computeroutput"><span class="identifier">pm</span></code> be the pointer to the mutex
                  and <code class="computeroutput"><span class="identifier">owns</span></code> the ownership
                  state. Initializes <code class="computeroutput"><span class="identifier">pm</span></code>
                  with nullptr and <code class="computeroutput"><span class="identifier">owns</span></code>
                  with false. If <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">false</span></code>,
                  sets <code class="computeroutput"><span class="identifier">pm</span></code> to the
                  return value of <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code>. Else <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  and in this case if <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()-&gt;</span><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  sets <code class="computeroutput"><span class="identifier">pm</span></code> to the
                  value returned by <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code> and sets <code class="computeroutput"><span class="identifier">owns</span></code>
                  to <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                  If <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">()</span></code>
                  returns <code class="computeroutput"><span class="keyword">true</span></code> and
                  <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()-&gt;</span><span class="identifier">try_unlock_shared_and_lock</span><span class="special">()</span></code>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>, <code class="computeroutput"><span class="identifier">sl</span></code> is not modified.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_sh_until"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_sh_until" title="unique_lock(shared_lock&lt;mutex_type&gt;&amp;&amp;, const chrono::time_point&lt;Clock, Duration&gt;&amp;)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;)</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The supplied <code class="computeroutput"><span class="identifier">Mutex</span></code>
                  type shall implement <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Constructs an object of type <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a></code>, initializing
                  <code class="computeroutput"><span class="identifier">pm</span></code> with <code class="computeroutput"><span class="keyword">nullptr</span></code> and <code class="computeroutput"><span class="identifier">owns</span></code>
                  with <code class="computeroutput"><span class="keyword">false</span></code>. If <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">false</span></code>,
                  sets <code class="computeroutput"><span class="identifier">pm</span></code> to the
                  return value of <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code>. Else <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span> <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  and in this case if <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()-&gt;</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code> returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  sets <code class="computeroutput"><span class="identifier">pm</span></code> to the
                  value returned by <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code> and sets <code class="computeroutput"><span class="identifier">owns</span></code>
                  to <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                  If <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">()</span></code>
                  returns <code class="computeroutput"><span class="keyword">true</span></code> and
                  <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()-&gt;</span>
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_until" title="m.try_unlock_shared_and_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code> returns <code class="computeroutput"><span class="keyword">false</span></code>,
                  <code class="computeroutput"><span class="identifier">sl</span></code> is not modified.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_sh_for"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_sh_for" title="unique_lock(shared_lock&lt;mutex_type&gt;&amp;&amp;, const chrono::duration&lt;Rep, Period&gt;&amp;)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;)</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
<span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The supplied <code class="computeroutput"><span class="identifier">Mutex</span></code>
                  type shall implement <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Constructs an object of type <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a></code>, initializing
                  <code class="computeroutput"><span class="identifier">pm</span></code> with <code class="computeroutput"><span class="keyword">nullptr</span></code> and <code class="computeroutput"><span class="identifier">owns</span></code>
                  with <code class="computeroutput"><span class="keyword">false</span></code>. If <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">false</span></code>,
                  sets <code class="computeroutput"><span class="identifier">pm</span></code> to the
                  return value of <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code>. Else <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">()</span></code> returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  and in this case if <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()-&gt;</span> <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns <code class="computeroutput"><span class="keyword">true</span></code>,
                  sets <code class="computeroutput"><span class="identifier">pm</span></code> to the
                  value returned by <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code> and sets <code class="computeroutput"><span class="identifier">owns</span></code>
                  to <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                  If <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">owns_lock</span><span class="special">()</span></code>
                  returns <code class="computeroutput"><span class="keyword">true</span></code> and
                  <code class="computeroutput"><span class="identifier">sl</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()-&gt;</span>
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.try_unlock_shared_and_lock_for" title="m.try_unlock_shared_and_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_unlock_shared_and_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code> returns <code class="computeroutput"><span class="keyword">false</span></code>,
                  <code class="computeroutput"><span class="identifier">sl</span></code> is not modified.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  .
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  Available only if <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span></code>
                  and <code class="computeroutput"><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span></code>
                  is defined on Windows platform
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_abs_time"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_abs_time" title="unique_lock(Lockable &amp; m,boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>,
                  and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                  If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
                  returned <code class="computeroutput"><span class="keyword">true</span></code>, then
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exceptions thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_time_point"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_time_point" title="template &lt;class Clock, class Duration&gt; unique_lock(Lockable &amp; m,const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
          <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>, and takes ownership of the lock
                  state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                  If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a> returned
                  <code class="computeroutput"><span class="keyword">true</span></code>, then <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exceptions thrown by the call to <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_duration"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_duration" title="template &lt;class Rep, class Period&gt; unique_lock(Lockable &amp; m,const chrono::duration&lt;Rep, Period&gt;&amp; abs_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
          <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>,
                  and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                  If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a> returned
                  <code class="computeroutput"><span class="keyword">true</span></code>, then <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exceptions thrown by the call to <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a><span class="special">(</span><span class="identifier">rel_time</span><span class="special">)</span></code>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.destructor" title="~unique_lock()"><code class="computeroutput"><span class="special">~</span><span class="identifier">unique_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a><code class="computeroutput"><span class="special">-&gt;</span></code> <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
                  if <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.owns_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if the <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  owns the lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                  with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.mutex"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  A pointer to the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                  with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or <code class="computeroutput"><span class="identifier">NULL</span></code> if there
                  is no such object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.explicit_bool_conversion"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.explicit_bool_conversion" title="explicit operator bool() const"><code class="computeroutput"><span class="keyword">explicit</span> <span class="keyword">operator</span>
          <span class="keyword">bool</span><span class="special">()</span>
          <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.release"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.release" title="Lockable* release()"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The association between <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> and the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is removed,
                  without affecting the lock state of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object. If <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  would have returned <code class="computeroutput"><span class="keyword">true</span></code>,
                  it is the responsibility of the calling code to ensure that the
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> is correctly
                  unlocked.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  A pointer to the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                  with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  at the point of the call, or <code class="computeroutput"><span class="identifier">NULL</span></code>
                  if there is no such object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  is no longer associated with any <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="identifier">NULL</span></code> and
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.shared_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock - C++14">Class template
        <code class="computeroutput"><span class="identifier">shared_lock</span></code> - C++14</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.defaultconstructor"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_adopt"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_defer"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">defer_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_try"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_abs_time"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">shared_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.mutex"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.explicit_operator_bool"><code class="computeroutput"><span class="keyword">explicit</span> <span class="keyword">operator</span>
          <span class="keyword">bool</span><span class="special">()</span>
          <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.release"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/locks.hpp&gt;</span>
<span class="comment">// #include &lt;boost/thread/lock_types.hpp&gt; </span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">shared_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">mutex_type</span><span class="special">;</span>

    <span class="comment">// Shared locking</span>
    <span class="identifier">shared_lock</span><span class="special">();</span>
    <span class="keyword">explicit</span> <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">defer_lock_t</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">try_to_lock_t</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Mutex</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Mutex</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">);</span>
    <span class="special">~</span><span class="identifier">shared_lock</span><span class="special">();</span>

    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">shared_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">shared_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">shared_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="comment">// Conversion from upgrade locking</span>
    <span class="keyword">explicit</span> <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

    <span class="comment">// Conversion from exclusive locking</span>
    <span class="keyword">explicit</span> <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="comment">// Setters</span>
    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">mutex_type</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="comment">// Getters</span>
    <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="keyword">bool</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="identifier">mutex_type</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_USE_DATE_TIME</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">target_time</span><span class="special">);</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">target_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>
<span class="special">};</span>
</pre>
<p>
          Like <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock - C++14"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> models the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a>, but rather than
          acquiring unique ownership of the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, locking an instance
          of <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock - C++14"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> acquires shared ownership.
        </p>
<p>
          Like <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>, not only does it
          provide for RAII-style locking, it also allows for deferring acquiring
          the lock until the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          member function is called explicitly, or trying to acquire the lock in
          a non-blocking fashion, or with a timeout. Consequently, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          is only called in the destructor if the lock object has locked the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, or otherwise
          adopted a lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object.
        </p>
<p>
          An instance of <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock - C++14"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> is said to <span class="emphasis"><em>own</em></span>
          the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> <code class="computeroutput"><span class="identifier">m</span></code>
          if <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
          returns a pointer to <code class="computeroutput"><span class="identifier">m</span></code>
          and <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
          returns <code class="computeroutput"><span class="keyword">true</span></code>. If an object
          that <span class="emphasis"><em>owns</em></span> the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is destroyed,
          then the destructor will invoke <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()-&gt;</span><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>.
        </p>
<p>
          The member functions of <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock - C++14"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> are not thread-safe.
          In particular, <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock - C++14"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> is intended to model
          the shared ownership of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object by a particular
          thread, and the member functions that release ownership of the lock state
          (including the destructor) must be called by the same thread that acquired
          ownership of the lock state.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.defaultconstructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.defaultconstructor" title="shared_lock()"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Creates a lock object with no associated mutex.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="identifier">NULL</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor" title="shared_lock(Lockable &amp; m)"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_shared</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_shared</span><span class="special">()</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_adopt" title="shared_lock(Lockable &amp; m,boost::adopt_lock_t)"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread owns an exclusive lock on <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Takes ownership of the lock state of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor_defer"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_defer" title="shared_lock(Lockable &amp; m,boost::defer_lock_t)"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">defer_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor_try"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_try" title="shared_lock(Lockable &amp; m,boost::try_to_lock_t)"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>,
                  and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                  If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>
                  returned <code class="computeroutput"><span class="keyword">true</span></code>, then
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor_abs_time"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_abs_time" title="shared_lock(Lockable &amp; m,boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>,
                  and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                  If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock_shared</span><span class="special">()</span></code></a>
                  returned <code class="computeroutput"><span class="keyword">true</span></code>, then
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exceptions thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.destructor" title="~shared_lock()"><code class="computeroutput"><span class="special">~</span><span class="identifier">shared_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Invokes <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a><code class="computeroutput"><span class="special">-&gt;</span></code> <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>
                  if <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">true</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.owns_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> if the <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  owns the lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                  with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.mutex"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  A pointer to the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                  with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or <code class="computeroutput"><span class="identifier">NULL</span></code> if there
                  is no such object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.explicit_operator_bool"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.explicit_operator_bool" title="explicit operator bool() const"><code class="computeroutput"><span class="keyword">explicit</span> <span class="keyword">operator</span>
          <span class="keyword">bool</span><span class="special">()</span>
          <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.release"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.release" title="Lockable* release()"><code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The association between <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> and the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is removed,
                  without affecting the lock state of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object. If <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  would have returned <code class="computeroutput"><span class="keyword">true</span></code>,
                  it is the responsibility of the calling code to ensure that the
                  <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> is correctly
                  unlocked.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  A pointer to the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                  with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  at the point of the call, or <code class="computeroutput"><span class="identifier">NULL</span></code>
                  if there is no such object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  is no longer associated with any <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="identifier">NULL</span></code> and
                  <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                  returns <code class="computeroutput"><span class="keyword">false</span></code>.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.upgrade_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock - EXTENSION">Class template
        <code class="computeroutput"><span class="identifier">upgrade_lock</span></code> - EXTENSION</a>
</h4></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/locks.hpp&gt;</span>
<span class="comment">// #include &lt;boost/thread/lock_types.hpp&gt; </span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">upgrade_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">mutex_type</span><span class="special">;</span>

    <span class="comment">// Upgrade locking</span>

    <span class="identifier">upgrade_lock</span><span class="special">();</span>
    <span class="keyword">explicit</span> <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span> <span class="identifier">defer_lock_t</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span> <span class="identifier">try_to_lock_t</span><span class="special">);</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span> <span class="identifier">adopt_lock_t</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span>
                 <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span>
                 <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="special">~</span><span class="identifier">upgrade_lock</span><span class="special">();</span>

    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">upgrade_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">upgrade_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> <span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">upgrade_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSION</span>
   <span class="comment">// Conversion from shared locking</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span> <span class="identifier">try_to_lock_t</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span>
                   <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">sl</span><span class="special">,</span>
                   <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>

    <span class="comment">// Conversion from exclusive locking</span>
    <span class="keyword">explicit</span> <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="comment">// Setters</span>
    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">upgrade_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">mutex_type</span><span class="special">*</span> <span class="identifier">release</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="comment">// Getters</span>
    <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="keyword">bool</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="identifier">mutex_type</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          Like <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock - EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> models the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a>, but rather than
          acquiring unique ownership of the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, locking an instance
          of <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock - EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> acquires upgrade
          ownership.
        </p>
<p>
          Like <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>, not only does it
          provide for RAII-style locking, it also allows for deferring acquiring
          the lock until the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          member function is called explicitly, or trying to acquire the lock in
          a non-blocking fashion, or with a timeout. Consequently, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          is only called in the destructor if the lock object has locked the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, or otherwise
          adopted a lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object.
        </p>
<p>
          An instance of <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock - EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> is said to <span class="emphasis"><em>own</em></span>
          the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> <code class="computeroutput"><span class="identifier">m</span></code>
          if <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const noexcept"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
          returns a pointer to <code class="computeroutput"><span class="identifier">m</span></code>
          and <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
          returns <code class="computeroutput"><span class="keyword">true</span></code>. If an object
          that <span class="emphasis"><em>owns</em></span> the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is destroyed,
          then the destructor will invoke <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="m.unlock_upgrade()"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()-&gt;</span><span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a>.
        </p>
<p>
          The member functions of <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock - EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> are not thread-safe.
          In particular, <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock - EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> is intended to model
          the upgrade ownership of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept -- EXTENSION"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code></a> object by a particular
          thread, and the member functions that release ownership of the lock state
          (including the destructor) must be called by the same thread that acquired
          ownership of the lock state.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.upgrade_to_unique_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_to_unique_lock" title="Class template upgrade_to_unique_lock -- EXTENSION">Class
        template <code class="computeroutput"><span class="identifier">upgrade_to_unique_lock</span></code>
        -- EXTENSION</a>
</h4></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/locks.hpp&gt;</span>
<span class="comment">// #include &lt;boost/thread/lock_types.hpp&gt; </span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">upgrade_to_unique_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">mutex_type</span><span class="special">;</span>
    <span class="keyword">explicit</span> <span class="identifier">upgrade_to_unique_lock</span><span class="special">(</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="special">~</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">();</span>

    <span class="identifier">upgrade_to_unique_lock</span><span class="special">(</span><span class="identifier">upgrade_to_unique_lock</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">upgrade_to_unique_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">upgrade_to_unique_lock</span><span class="special">(</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">upgrade_to_unique_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="keyword">bool</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="identifier">mutex_type</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>

<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_to_unique_lock" title="Class template upgrade_to_unique_lock -- EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_to_unique_lock</span></code></a> allows
          for a temporary upgrade of an <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock - EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> to exclusive ownership.
          When constructed with a reference to an instance of <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock - EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a>, if that instance
          has upgrade ownership on some <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, that ownership
          is upgraded to exclusive ownership. When the <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_to_unique_lock" title="Class template upgrade_to_unique_lock -- EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_to_unique_lock</span></code></a> instance
          is destroyed, the ownership of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> is downgraded back to
          <span class="emphasis"><em>upgrade ownership</em></span>.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.scoped_try_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.scoped_try_lock" title="Mutex-specific class scoped_try_lock -- DEPRECATED">Mutex-specific
        class <code class="computeroutput"><span class="identifier">scoped_try_lock</span></code> --
        DEPRECATED</a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span>
<span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">();</span>
    <span class="keyword">explicit</span> <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">defer_lock_t</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">try_to_lock_t</span><span class="special">);</span>

    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="identifier">MutexType</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="identifier">MutexType</span><span class="special">*</span> <span class="identifier">release</span><span class="special">();</span>

    <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="keyword">bool</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          The member typedef <code class="computeroutput"><span class="identifier">scoped_try_lock</span></code>
          is provided for each distinct <code class="computeroutput"><span class="identifier">MutexType</span></code>
          as a typedef to a class with the preceding definition. The semantics of
          each constructor and member function are identical to those of <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;</span></code></a>
          for the same <code class="computeroutput"><span class="identifier">MutexType</span></code>,
          except that the constructor that takes a single reference to a mutex will
          call <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock</span><span class="special">()</span></code></a> rather than <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>.
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.other_locks"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks" title="Other Lock Types - EXTENSION">Other Lock Types
      - EXTENSION</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.strict_locks">Strict
        Locks</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.lock_ptrs">Locking
        pointers</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.externally_locked">Externally
        Locked</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard">Class
        template <code class="computeroutput"><span class="identifier">shared_lock_guard</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.reverse_lock">Class
        template <code class="computeroutput"><span class="identifier">reverse_lock</span></code></a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.other_locks.strict_locks"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks" title="Strict Locks">Strict
        Locks</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.strict_locks.strict_lock">Class
          template <code class="computeroutput"><span class="identifier">strict_lock</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.strict_locks.nested_strict_lock">Class
          template <code class="computeroutput"><span class="identifier">nested_strict_lock</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.strict_locks.make_strict_lock">Non
          Member Function <code class="computeroutput"><span class="identifier">make_strict_lock</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.strict_locks.make_nested_strict_lock">Non
          Member Function <code class="computeroutput"><span class="identifier">make_nested_strict_lock</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/locks.hpp&gt; </span>
<span class="comment">// #include &lt;boost/thread/strict_lock.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">strict_lock</span><span class="special">;</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">nested_strict_lock</span><span class="special">;</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="keyword">struct</span> <span class="identifier">is_strict_lock_sur_parole</span><span class="special">&lt;</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;;</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="keyword">struct</span> <span class="identifier">is_strict_lock_sur_parole</span><span class="special">&lt;</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;</span> <span class="special">&gt;;</span>

<span class="preprocessor">#if</span> <span class="special">!</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_NO_MAKE_STRICT_LOCK</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_strict_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">);</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor">#if</span> <span class="special">!</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_NO_MAKE_NESTED_STRICT_LOCK</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;</span> <span class="identifier">make_nested_strict_lock</span><span class="special">(</span><span class="identifier">Lock</span><span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="preprocessor">#endif</span>

<span class="special">}</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.strict_locks.strict_lock"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.strict_lock" title="Class template strict_lock">Class
          template <code class="computeroutput"><span class="identifier">strict_lock</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/locks.hpp&gt;</span>
<span class="comment">// #include &lt;boost/thread/strict_lock.hpp&gt; </span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">BasicLockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">strict_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">BasicLockable</span> <span class="identifier">mutex_type</span><span class="special">;</span>
    <span class="identifier">strict_lock</span><span class="special">(</span><span class="identifier">strict_lock</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">strict_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">strict_lock</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="keyword">explicit</span> <span class="identifier">strict_lock</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="special">~</span><span class="identifier">strict_lock</span><span class="special">();</span>

    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">mutex_type</span> <span class="keyword">const</span><span class="special">*</span> <span class="identifier">l</span><span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            <a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.strict_lock" title="Class template strict_lock"><code class="computeroutput"><span class="identifier">strict_lock</span></code></a> is a model of <a class="link" href="synchronization.html#thread.synchronization.lock_concepts.StrictLock" title="StrictLock -- EXTENSION"><code class="computeroutput"><span class="identifier">StrictLock</span></code></a>.
          </p>
<p>
            <a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.strict_lock" title="Class template strict_lock"><code class="computeroutput"><span class="identifier">strict_lock</span></code></a> is the simplest
            <a class="link" href="synchronization.html#thread.synchronization.lock_concepts.StrictLock" title="StrictLock -- EXTENSION"><code class="computeroutput"><span class="identifier">StrictLock</span></code></a>: on construction
            it acquires ownership of the implementation of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> concept supplied
            as the constructor parameter. On destruction, the ownership is released.
            This provides simple RAII-style locking of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable" title="BasicLockable Concept"><code class="computeroutput"><span class="identifier">BasicLockable</span></code></a> object, to facilitate
            exception-safe locking and unlocking.
          </p>
<h6>
<a name="thread.synchronization.other_locks.strict_locks.strict_lock.h0"></a>
            <span class="phrase"><a name="thread.synchronization.other_locks.strict_locks.strict_lock.see_also__link_linkend__thread_synchronization_lock_guard_lock_guard___code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__lock_guard__phrase___code___link_"></a></span><a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.strict_lock.see_also__link_linkend__thread_synchronization_lock_guard_lock_guard___code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__lock_guard__phrase___code___link_">See
            also <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span></code></a>
          </h6>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.strict_locks.strict_lock.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.strict_lock.constructor" title="strict_lock(Lockable &amp; m)"><code class="computeroutput"><span class="identifier">strict_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
            <span class="identifier">m</span><span class="special">)</span></code></a>
</h6></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                    Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.strict_locks.strict_lock.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.strict_lock.destructor" title="~strict_lock()"><code class="computeroutput"><span class="special">~</span><span class="identifier">strict_lock</span><span class="special">()</span></code></a>
</h6></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code></a>
                    on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object passed
                    to the constructor.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.strict_locks.nested_strict_lock"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.nested_strict_lock" title="Class template nested_strict_lock">Class
          template <code class="computeroutput"><span class="identifier">nested_strict_lock</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/locks.hpp&gt;</span>
<span class="comment">// #include &lt;boost/thread/strict_lock.hpp&gt; </span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">nested_strict_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">BasicLockable</span> <span class="identifier">mutex_type</span><span class="special">;</span>
    <span class="identifier">nested_strict_lock</span><span class="special">(</span><span class="identifier">nested_strict_lock</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">nested_strict_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">nested_strict_lock</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="keyword">explicit</span> <span class="identifier">nested_strict_lock</span><span class="special">(</span><span class="identifier">Lock</span><span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">),</span>
    <span class="special">~</span><span class="identifier">nested_strict_lock</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">mutex_type</span> <span class="keyword">const</span><span class="special">*</span> <span class="identifier">l</span><span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            <a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.nested_strict_lock" title="Class template nested_strict_lock"><code class="computeroutput"><span class="identifier">nested_strict_lock</span></code></a> is a model
            of <a class="link" href="synchronization.html#thread.synchronization.lock_concepts.StrictLock" title="StrictLock -- EXTENSION"><code class="computeroutput"><span class="identifier">StrictLock</span></code></a>.
          </p>
<p>
            A nested strict lock is a scoped lock guard ensuring a mutex is locked
            on its scope, by taking ownership of an nesting lock, locking the mutex
            on construction if not already locked and restoring the ownership to
            the nesting lock on destruction.
          </p>
<h6>
<a name="thread.synchronization.other_locks.strict_locks.nested_strict_lock.h0"></a>
            <span class="phrase"><a name="thread.synchronization.other_locks.strict_locks.nested_strict_lock.see_also__link_linkend__thread_synchronization_other_locks_strict_locks_strict_lock___code__phrase_role__identifier__strict_lock__phrase___code___link_____link_linkend__thread_synchronization_locks_unique_lock___code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__unique_lock__phrase___code___link_"></a></span><a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.nested_strict_lock.see_also__link_linkend__thread_synchronization_other_locks_strict_locks_strict_lock___code__phrase_role__identifier__strict_lock__phrase___code___link_____link_linkend__thread_synchronization_locks_unique_lock___code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__unique_lock__phrase___code___link_">See
            also <code class="computeroutput"><span class="identifier">strict_lock</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>
          </h6>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.strict_locks.nested_strict_lock.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.nested_strict_lock.constructor" title="nested_strict_lock(Lock &amp; lk)"><code class="computeroutput"><span class="identifier">nested_strict_lock</span><span class="special">(</span><span class="identifier">Lock</span> <span class="special">&amp;</span>
            <span class="identifier">lk</span><span class="special">)</span></code></a>
</h6></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()</span>
                    <span class="special">!=</span> <span class="identifier">null_ptr</span></code>.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Stores the reference to the lock parameter <code class="computeroutput"><span class="identifier">lk</span></code>
                    and takes ownership on it. If the lock doesn't owns the mutex
                    lock it.
                  </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">lk</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">())</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - lock_error when BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED
                    is defined and lk.mutex() == null_ptr
                  </p>
<p>
                    - Any exception that @c lk.lock() can throw.
                  </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.strict_locks.nested_strict_lock.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.nested_strict_lock.destructor" title="~nested_strict_lock() noexcept"><code class="computeroutput"><span class="special">~</span><span class="identifier">nested_strict_lock</span><span class="special">()</span> <span class="keyword">noexcept</span></code></a>
</h6></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Restores ownership to the nesting lock.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.strict_locks.nested_strict_lock.owns_lock"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.nested_strict_lock.owns_lock" title="bool owns_lock(mutex_type const* l) const noexcept"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">(</span><span class="identifier">mutex_type</span>
            <span class="keyword">const</span><span class="special">*</span>
            <span class="identifier">l</span><span class="special">)</span>
            <span class="keyword">const</span> <span class="keyword">noexcept</span></code></a>
</h6></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Return:</span></dt>
<dd><p>
                    Whether if this lock is locking that mutex.
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.strict_locks.make_strict_lock"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.make_strict_lock" title="Non Member Function make_strict_lock">Non
          Member Function <code class="computeroutput"><span class="identifier">make_strict_lock</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_strict_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  a strict_lock as if initialized with <code class="computeroutput"><span class="special">{</span><span class="identifier">m</span><span class="special">}</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.strict_locks.make_nested_strict_lock"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.strict_locks.make_nested_strict_lock" title="Non Member Function make_nested_strict_lock">Non
          Member Function <code class="computeroutput"><span class="identifier">make_nested_strict_lock</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
<span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;</span> <span class="identifier">make_nested_strict_lock</span><span class="special">(</span><span class="identifier">Lock</span><span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  a nested_strict_lock as if initialized with <code class="computeroutput"><span class="special">{</span><span class="identifier">lk</span><span class="special">}</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.other_locks.lock_ptrs"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.lock_ptrs" title="Locking pointers">Locking
        pointers</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.const_strict_lock_ptr">Class
          template <code class="computeroutput"><span class="identifier">const_strict_lock_ptr</span>
          </code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.strict_lock_ptr">Class
          template <code class="computeroutput"><span class="identifier">strict_lock_ptr</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/synchroniezd_value.hpp&gt; </span>
<span class="comment">// #include &lt;boost/thread/strict_lock_ptr.hpp&gt; </span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span> <span class="special">=</span> <span class="identifier">mutex</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">strict_lock_ptr</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span> <span class="special">=</span> <span class="identifier">mutex</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">const_strict_lock_ptr</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.lock_ptrs.const_strict_lock_ptr"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.const_strict_lock_ptr" title="Class template const_strict_lock_ptr">Class
          template <code class="computeroutput"><span class="identifier">const_strict_lock_ptr</span>
          </code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/synchroniezd_value.hpp&gt; </span>
<span class="comment">// #include &lt;boost/thread/strict_lock_ptr.hpp&gt; </span>


<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span> <span class="special">=</span> <span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">const_strict_lock_ptr</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
  <span class="keyword">typedef</span> <span class="identifier">T</span> <span class="identifier">value_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">mutex_type</span><span class="special">;</span>

  <span class="identifier">const_strict_lock_ptr</span><span class="special">(</span><span class="identifier">const_strict_lock_ptr</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
  <span class="identifier">const_strict_lock_ptr</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">const_strict_lock_ptr</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

  <span class="identifier">const_strict_lock_ptr</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">val</span><span class="special">,</span> <span class="identifier">Lockable</span> <span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">);</span>
  <span class="identifier">const_strict_lock_ptr</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">val</span><span class="special">,</span> <span class="identifier">Lockable</span> <span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="identifier">adopt_lock_t</span> <span class="identifier">tag</span><span class="special">);</span>

  <span class="special">~</span><span class="identifier">const_strict_lock_ptr</span><span class="special">();</span>

  <span class="keyword">const</span> <span class="identifier">T</span><span class="special">*</span> <span class="keyword">operator</span><span class="special">-&gt;()</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">*()</span> <span class="keyword">const</span><span class="special">;</span>

<span class="special">};</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.lock_ptrs.const_strict_lock_ptr.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.const_strict_lock_ptr.constructor" title="const_strict_lock_ptr(T const&amp;,Lockable&amp;)"><code class="computeroutput"><span class="identifier">const_strict_lock_ptr</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;,</span><span class="identifier">Lockable</span><span class="special">&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">const_strict_lock_ptr</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">val</span><span class="special">,</span> <span class="identifier">Lockable</span> <span class="special">&amp;</span> <span class="identifier">m</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>,
                    stores a reference to it and to the value type <code class="computeroutput"><span class="identifier">val</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.lock_ptrs.const_strict_lock_ptr.constructor_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.const_strict_lock_ptr.constructor_adopt" title="const_strict_lock_ptr(T const&amp;,Lockable&amp;,adopt_lock_t)"><code class="computeroutput"><span class="identifier">const_strict_lock_ptr</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;,</span><span class="identifier">Lockable</span><span class="special">&amp;,</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">const_strict_lock_ptr</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">val</span><span class="special">,</span> <span class="identifier">Lockable</span> <span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span> <span class="identifier">adopt_lock_t</span> <span class="identifier">tag</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Stores a reference to it and to the value type <code class="computeroutput"><span class="identifier">val</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.lock_ptrs.const_strict_lock_ptr.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.const_strict_lock_ptr.destructor" title="~const_strict_lock_ptr()"><code class="computeroutput"><span class="special">~</span><span class="identifier">const_strict_lock_ptr</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="special">~</span><span class="identifier">const_strict_lock_ptr</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code></a>
                    on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object passed
                    to the constructor.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.lock_ptrs.const_strict_lock_ptr.indir"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.const_strict_lock_ptr.indir" title="operator-&gt;() const"><code class="computeroutput"><span class="keyword">operator</span><span class="special">-&gt;()</span>
            <span class="keyword">const</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">T</span><span class="special">*</span> <span class="keyword">operator</span><span class="special">-&gt;()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Return:</span></dt>
<dd><p>
                    return a constant pointer to the protected value.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.lock_ptrs.const_strict_lock_ptr.deref"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.const_strict_lock_ptr.deref" title="operator*() const"><code class="computeroutput"><span class="keyword">operator</span><span class="special">*()</span>
            <span class="keyword">const</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">*()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Return:</span></dt>
<dd><p>
                    return a constant reference to the protected value.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.lock_ptrs.strict_lock_ptr"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.strict_lock_ptr" title="Class template strict_lock_ptr">Class
          template <code class="computeroutput"><span class="identifier">strict_lock_ptr</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/synchroniezd_value.hpp&gt; </span>
<span class="comment">// #include &lt;boost/thread/strict_lock_ptr.hpp&gt; </span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span> <span class="special">=</span> <span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">strict_lock_ptr</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">const_strict_lock_ptr</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span><span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
  <span class="identifier">strict_lock_ptr</span><span class="special">(</span><span class="identifier">strict_lock_ptr</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
  <span class="identifier">strict_lock_ptr</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">strict_lock_ptr</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

  <span class="identifier">strict_lock_ptr</span><span class="special">(</span><span class="identifier">T</span> <span class="special">&amp;</span> <span class="identifier">val</span><span class="special">,</span> <span class="identifier">Lockable</span> <span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">);</span>
  <span class="identifier">strict_lock_ptr</span><span class="special">(</span><span class="identifier">T</span> <span class="special">&amp;</span> <span class="identifier">val</span><span class="special">,</span> <span class="identifier">Lockable</span> <span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="identifier">adopt_lock_t</span> <span class="identifier">tag</span><span class="special">);</span>
  <span class="special">~</span><span class="identifier">strict_lock_ptr</span><span class="special">();</span>

  <span class="identifier">T</span><span class="special">*</span> <span class="keyword">operator</span><span class="special">-&gt;();</span>
  <span class="identifier">T</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">*();</span>

<span class="special">};</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.lock_ptrs.strict_lock_ptr.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.strict_lock_ptr.constructor" title="strict_lock_ptr(T const&amp;,Lockable&amp;)"><code class="computeroutput"><span class="identifier">strict_lock_ptr</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;,</span><span class="identifier">Lockable</span><span class="special">&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">strict_lock_ptr</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">val</span><span class="special">,</span> <span class="identifier">Lockable</span> <span class="special">&amp;</span> <span class="identifier">m</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>,
                    stores a reference to it and to the value type <code class="computeroutput"><span class="identifier">val</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.lock_ptrs.strict_lock_ptr.constructor_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.strict_lock_ptr.constructor_adopt" title="strict_lock_ptr(T const&amp;,Lockable&amp;,adopt_lock_t)"><code class="computeroutput"><span class="identifier">strict_lock_ptr</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;,</span><span class="identifier">Lockable</span><span class="special">&amp;,</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">strict_lock_ptr</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">val</span><span class="special">,</span> <span class="identifier">Lockable</span> <span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span> <span class="identifier">adopt_lock_t</span> <span class="identifier">tag</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Stores a reference to it and to the value type <code class="computeroutput"><span class="identifier">val</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.lock_ptrs.strict_lock_ptr.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.strict_lock_ptr.destructor" title="~strict_lock_ptr()"><code class="computeroutput"><span class="special">~</span><span class="identifier">strict_lock_ptr</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="special">~</span> <span class="identifier">strict_lock_ptr</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code></a>
                    on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object passed
                    to the constructor.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.lock_ptrs.strict_lock_ptr.indir"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.strict_lock_ptr.indir" title="operator-&gt;()"><code class="computeroutput"><span class="keyword">operator</span><span class="special">-&gt;()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">T</span><span class="special">*</span> <span class="keyword">operator</span><span class="special">-&gt;();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Return:</span></dt>
<dd><p>
                    return a pointer to the protected value.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.lock_ptrs.strict_lock_ptr.deref"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.lock_ptrs.strict_lock_ptr.deref" title="operator*()"><code class="computeroutput"><span class="keyword">operator</span><span class="special">*()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">T</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">*();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Return:</span></dt>
<dd><p>
                    return a reference to the protected value.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.other_locks.externally_locked"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked" title="Externally Locked">Externally
        Locked</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked">Template
          Class <code class="computeroutput"><span class="identifier">externally_locked</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked_ref">Template
          Class <code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&amp;&gt;</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.externally_locked.swap"><code class="computeroutput"><span class="identifier">swap</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;,</span>
          <span class="identifier">externally_locked</span><span class="special">&amp;)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/externally_locked.hpp&gt;</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">MutexType</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">externally_locked</span><span class="special">;</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">MutexType</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&amp;,</span> <span class="identifier">MutexType</span><span class="special">&gt;;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">MutexType</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MutexType</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">lhs</span><span class="special">,</span> <span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MutexType</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked" title="Template Class externally_locked">Template
          Class <code class="computeroutput"><span class="identifier">externally_locked</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/externally_locked.hpp&gt;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">MutexType</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">externally_locked</span>
<span class="special">{</span>
  <span class="comment">//BOOST_CONCEPT_ASSERT(( CopyConstructible&lt;T&gt; ));</span>
  <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span> <span class="identifier">BasicLockable</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;</span> <span class="special">));</span>

<span class="keyword">public</span><span class="special">:</span>
  <span class="keyword">typedef</span> <span class="identifier">MutexType</span> <span class="identifier">mutex_type</span><span class="special">;</span>

  <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">);</span>
  <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span><span class="identifier">T</span><span class="special">&amp;&amp;</span> <span class="identifier">obj</span><span class="special">);</span>
  <span class="keyword">explicit</span> <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">);</span>
  <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">externally_locked</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
  <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
  <span class="identifier">externally_locked</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">externally_locked</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
  <span class="identifier">externally_locked</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">externally_locked</span><span class="special">&amp;&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>

  <span class="comment">// observers</span>
  <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">);</span>
  <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">);</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">Lock</span><span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">);</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">Lock</span><span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

 <span class="identifier">mutex_type</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

  <span class="comment">// modifiers</span>
  <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
  <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>
  <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;);</span>
<span class="special">};</span>
</pre>
<p>
            <code class="computeroutput"><span class="identifier">externally_locked</span></code> is
            a model of <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a>, it cloaks an object
            of type <code class="computeroutput"><span class="identifier">T</span></code>, and actually
            provides full access to that object through the get and set member functions,
            provided you pass a reference to a strict lock object.
          </p>
<p>
            Only the specificities respect to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> are described here.
          </p>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked.constructor1"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked.constructor1" title="externally_locked(mutex_type&amp;, const T&amp;)"><code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;,</span>
            <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    T is a model of CopyConstructible.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs an externally locked object copying the cloaked type.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exception thrown by the call to <code class="computeroutput"><span class="identifier">T</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span></code>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked.constructor2"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked.constructor2" title="externally_locked(mutex_type&amp;, T&amp;&amp;)"><code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;,</span>
            <span class="identifier">T</span><span class="special">&amp;&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span><span class="identifier">T</span><span class="special">&amp;&amp;</span> <span class="identifier">obj</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    T is a model of Movable.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs an externally locked object by moving the cloaked
                    type.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exception thrown by the call to <code class="computeroutput"><span class="identifier">T</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span></code>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked.constructor3"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked.constructor3" title="externally_locked(mutex_type&amp;)"><code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    T is a model of DefaultConstructible.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs an externally locked object by default constructing
                    the cloaked type.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exception thrown by the call to <code class="computeroutput"><span class="identifier">T</span><span class="special">()</span></code>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked.constructor4"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked.constructor4" title="externally_locked(externally_locked&amp;&amp;)"><code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    T is a model of Movable.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Move constructs an externally locked object by moving the cloaked
                    type and copying the mutex reference
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exception thrown by the call to <code class="computeroutput"><span class="identifier">T</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;&amp;)</span></code>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked.constructor5"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked.constructor5" title="externally_locked(externally_locked&amp;)"><code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    T is a model of Copyable.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Copy constructs an externally locked object by copying the cloaked
                    type and copying the mutex reference
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exception thrown by the call to <code class="computeroutput"><span class="identifier">T</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;)</span></code>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked.assign4"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked.assign4" title="externally_locked(externally_locked&amp;&amp;)"><code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">externally_locked</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">externally_locked</span><span class="special">&amp;&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    T is a model of Movable.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Move assigns an externally locked object by moving the cloaked
                    type and copying the mutex reference
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exception thrown by the call to <code class="computeroutput"><span class="identifier">T</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="identifier">T</span><span class="special">&amp;&amp;)</span></code>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked.assign5"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked.assign5" title="externally_locked(externally_locked&amp;)"><code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">externally_locked</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">externally_locked</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    T is a model of Copyable.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Copy assigns an externally locked object by copying the cloaked
                    type and copying the mutex reference
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exception thrown by the call to <code class="computeroutput"><span class="identifier">T</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="identifier">T</span><span class="special">&amp;)</span></code>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked.get1"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked.get1" title="get(strict_lock&lt;mutex_type&gt;&amp;)"><code class="computeroutput"><span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    The <code class="computeroutput"><span class="identifier">lk</span></code> parameter
                    must be locking the associated mutex.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    A reference to the cloaked object
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code> if
                    <code class="computeroutput"><span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span></code>
                    is defined and the run-time preconditions are not satisfied .
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked.get2"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked.get2" title="get(strict_lock&lt;nested_strict_lock&lt;Lock&gt;&gt;&amp;)"><code class="computeroutput"><span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;&gt;&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
<span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
<span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">,</span>
                    <span class="keyword">typename</span> <span class="identifier">Lock</span><span class="special">::</span><span class="identifier">mutex_type</span><span class="special">&gt;</span></code> and the <code class="computeroutput"><span class="identifier">lk</span></code>
                    parameter must be locking the associated mutex.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    A reference to the cloaked object
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code> if
                    <code class="computeroutput"><span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span></code>
                    is defined and the run-time preconditions are not satisfied .
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked.get3"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked.get3" title="get(strict_lock&lt;nested_strict_lock&lt;Lock&gt;&gt;&amp;)"><code class="computeroutput"><span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;&gt;&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
<span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">Lock</span><span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">Lock</span><span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">Lock</span></code> is a model
                    of <a class="link" href="synchronization.html#thread.synchronization.lock_concepts.StrictLock" title="StrictLock -- EXTENSION"><code class="computeroutput"><span class="identifier">StrictLock</span></code></a>, <code class="computeroutput"><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">,</span>
                    <span class="keyword">typename</span> <span class="identifier">Lock</span><span class="special">::</span><span class="identifier">mutex_type</span><span class="special">&gt;</span></code> and the <code class="computeroutput"><span class="identifier">lk</span></code>
                    parameter must be locking the associated mutex.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    A reference to the cloaked object
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code> if
                    <code class="computeroutput"><span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span></code>
                    is defined and the run-time preconditions are not satisfied .
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked_ref"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked_ref" title="Template Class externally_locked&lt;T&amp;&gt;">Template
          Class <code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&amp;&gt;</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/externally_locked.hpp&gt;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">MutexType</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&amp;,</span> <span class="identifier">MutexType</span><span class="special">&gt;</span>
<span class="special">{</span>
  <span class="comment">//BOOST_CONCEPT_ASSERT(( CopyConstructible&lt;T&gt; ));</span>
  <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span> <span class="identifier">BasicLockable</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;</span> <span class="special">));</span>

<span class="keyword">public</span><span class="special">:</span>
  <span class="keyword">typedef</span> <span class="identifier">MutexType</span> <span class="identifier">mutex_type</span><span class="special">;</span>

  <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">);</span>
  <span class="keyword">explicit</span> <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">);</span>
  <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">externally_locked</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="identifier">externally_locked</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">externally_locked</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="identifier">externally_locked</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">externally_locked</span><span class="special">&amp;&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

  <span class="comment">// observers</span>
  <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">);</span>
  <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">);</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">Lock</span><span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">);</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">Lock</span><span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

 <span class="identifier">mutex_type</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

  <span class="comment">// modifiers</span>
  <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
  <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>
  <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;)</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            <code class="computeroutput"><span class="identifier">externally_locked</span></code> is
            a model of <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a>, it cloaks an object
            of type <code class="computeroutput"><span class="identifier">T</span></code>, and actually
            provides full access to that object through the get and set member functions,
            provided you pass a reference to a strict lock object.
          </p>
<p>
            Only the specificities respect to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> are described here.
          </p>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked_ref.constructor1"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked_ref.constructor1" title="externally_locked&lt;T&amp;&gt;(mutex_type&amp;, T&amp;)"><code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&amp;&gt;(</span><span class="identifier">mutex_type</span><span class="special">&amp;,</span>
            <span class="identifier">T</span><span class="special">&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&amp;&gt;(</span><span class="identifier">mutex_type</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs an externally locked object copying the cloaked reference.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked_ref.constructor4"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked_ref.constructor4" title="externally_locked&lt;T&amp;&gt;(externally_locked&amp;&amp;)"><code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&amp;&gt;(</span><span class="identifier">externally_locked</span><span class="special">&amp;&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Moves an externally locked object by moving the cloaked type
                    and copying the mutex reference
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked_ref.assign4"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked_ref.assign4" title="externally_locked(externally_locked&amp;&amp;)"><code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">externally_locked</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">externally_locked</span><span class="special">&amp;&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Move assigns an externally locked object by copying the cloaked
                    reference and copying the mutex reference
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked_ref.assign5"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked_ref.assign5" title="externally_locked(externally_locked&amp;)"><code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">externally_locked</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">externally_locked</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    T is a model of Copyable.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Copy assigns an externally locked object by copying the cloaked
                    reference and copying the mutex reference
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exception thrown by the call to <code class="computeroutput"><span class="identifier">T</span><span class="special">::</span><span class="keyword">operator</span><span class="special">=(</span><span class="identifier">T</span><span class="special">&amp;)</span></code>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked_ref.get1"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked_ref.get1" title="get(strict_lock&lt;mutex_type&gt;&amp;)"><code class="computeroutput"><span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    The <code class="computeroutput"><span class="identifier">lk</span></code> parameter
                    must be locking the associated mutex.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    A reference to the cloaked object
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code> if
                    <code class="computeroutput"><span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span></code>
                    is defined and the run-time preconditions are not satisfied .
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked_ref.get2"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked_ref.get2" title="get(strict_lock&lt;nested_strict_lock&lt;Lock&gt;&gt;&amp;)"><code class="computeroutput"><span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;&gt;&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
<span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
<span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;&amp;</span> <span class="identifier">lk</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">,</span>
                    <span class="keyword">typename</span> <span class="identifier">Lock</span><span class="special">::</span><span class="identifier">mutex_type</span><span class="special">&gt;</span></code> and the <code class="computeroutput"><span class="identifier">lk</span></code>
                    parameter must be locking the associated mutex.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    A reference to the cloaked object
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code> if
                    <code class="computeroutput"><span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span></code>
                    is defined and the run-time preconditions are not satisfied .
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.other_locks.externally_locked.externally_locked_ref.get3"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.externally_locked_ref.get3" title="get(strict_lock&lt;nested_strict_lock&lt;Lock&gt;&gt;&amp;)"><code class="computeroutput"><span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_lock</span><span class="special">&lt;</span><span class="identifier">nested_strict_lock</span><span class="special">&lt;</span><span class="identifier">Lock</span><span class="special">&gt;&gt;&amp;)</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
<span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">Lock</span><span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">Lock</span><span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">Lock</span></code> is a model
                    of <a class="link" href="synchronization.html#thread.synchronization.lock_concepts.StrictLock" title="StrictLock -- EXTENSION"><code class="computeroutput"><span class="identifier">StrictLock</span></code></a>, <code class="computeroutput"><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">,</span>
                    <span class="keyword">typename</span> <span class="identifier">Lock</span><span class="special">::</span><span class="identifier">mutex_type</span><span class="special">&gt;</span></code> and the <code class="computeroutput"><span class="identifier">lk</span></code>
                    parameter must be locking the associated mutex.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    A reference to the cloaked object
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code> if
                    <code class="computeroutput"><span class="identifier">BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED</span></code>
                    is defined and the run-time preconditions are not satisfied .
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.externally_locked.swap"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.externally_locked.swap" title="swap(externally_locked&amp;, externally_locked&amp;)"><code class="computeroutput"><span class="identifier">swap</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&amp;,</span>
          <span class="identifier">externally_locked</span><span class="special">&amp;)</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">MutexType</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MutexType</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">lhs</span><span class="special">,</span> <span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MutexType</span><span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span>
</pre>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.other_locks.shared_lock_guard"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard" title="Class template shared_lock_guard">Class
        template <code class="computeroutput"><span class="identifier">shared_lock_guard</span></code></a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard.constructor"><code class="computeroutput"><span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">SharedLockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard.constructor_adopt"><code class="computeroutput"><span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">SharedLockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">shared_lock_guard</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/shared_lock_guard.hpp&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">SharedLockable</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">shared_lock_guard</span>
  <span class="special">{</span>
  <span class="keyword">public</span><span class="special">:</span>
      <span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">shared_lock_guard</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
      <span class="identifier">shared_lock_guard</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">shared_lock_guard</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

      <span class="keyword">explicit</span> <span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">SharedLockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
      <span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">SharedLockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>

      <span class="special">~</span><span class="identifier">shared_lock_guard</span><span class="special">();</span>
  <span class="special">};</span>
<span class="special">}</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard" title="Class template shared_lock_guard"><code class="computeroutput"><span class="identifier">shared_lock_guard</span></code></a> is very simple:
          on construction it acquires shared ownership of the implementation of the
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a> supplied
          as the constructor parameter. On destruction, the ownership is released.
          This provides simple RAII-style locking of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code></a> object, to facilitate
          exception-safe shared locking and unlocking. In addition, the <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard" title="Class template shared_lock_guard"><code class="computeroutput"><span class="identifier">shared_lock_guard</span></code></a><span class="special">(</span><span class="identifier">SharedLockable</span> <span class="special">&amp;</span><span class="identifier">m</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code> constructor allows the <a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard" title="Class template shared_lock_guard"><code class="computeroutput"><span class="identifier">shared_lock_guard</span></code></a> object to take
          shared ownership of a lock already held by the current thread.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.shared_lock_guard.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard.constructor" title="shared_lock_guard(SharedLockable &amp; m)"><code class="computeroutput"><span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">SharedLockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a><span class="special">()</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exception thrown by the call to <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a><span class="special">()</span></code>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.shared_lock_guard.constructor_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard.constructor_adopt" title="shared_lock_guard(SharedLockable &amp; m,boost::adopt_lock_t)"><code class="computeroutput"><span class="identifier">shared_lock_guard</span><span class="special">(</span><span class="identifier">SharedLockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  The current thread owns a lock on <code class="computeroutput"><span class="identifier">m</span></code>
                  equivalent to one obtained by a call to <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a><span class="special">()</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Takes ownership of the lock state of <code class="computeroutput"><span class="identifier">m</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.shared_lock_guard.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.shared_lock_guard.destructor" title="~shared_lock_guard()"><code class="computeroutput"><span class="special">~</span><span class="identifier">shared_lock_guard</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Invokes <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="m.unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a><span class="special">()</span></code> on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code></a> object
                  passed to the constructor.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.other_locks.reverse_lock"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.reverse_lock" title="Class template reverse_lock">Class
        template <code class="computeroutput"><span class="identifier">reverse_lock</span></code></a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.reverse_lock.constructor"><code class="computeroutput"><span class="identifier">reverse_lock</span><span class="special">(</span><span class="identifier">Lock</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.other_locks.reverse_lock.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">reverse_lock</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/reverse_lock.hpp&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lock</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">reverse_lock</span>
  <span class="special">{</span>
  <span class="keyword">public</span><span class="special">:</span>
      <span class="identifier">reverse_lock</span><span class="special">(</span><span class="identifier">reverse_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
      <span class="identifier">reverse_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">reverse_lock</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

      <span class="keyword">explicit</span> <span class="identifier">reverse_lock</span><span class="special">(</span><span class="identifier">Lock</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
      <span class="special">~</span><span class="identifier">reverse_lock</span><span class="special">();</span>
  <span class="special">};</span>
<span class="special">}</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.other_locks.reverse_lock" title="Class template reverse_lock"><code class="computeroutput"><span class="identifier">reverse_lock</span></code></a> reverse the operations
          of a lock: it provide for RAII-style, that unlocks the lock at construction
          time and lock it at destruction time. In addition, it transfer ownership
          temporarily, so that the mutex can not be locked using the Lock.
        </p>
<p>
          An instance of <a class="link" href="synchronization.html#thread.synchronization.other_locks.reverse_lock" title="Class template reverse_lock"><code class="computeroutput"><span class="identifier">reverse_lock</span></code></a> doesn't <span class="emphasis"><em>own</em></span>
          the lock never.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.reverse_lock.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.reverse_lock.constructor" title="reverse_lock(Lock &amp; m)"><code class="computeroutput"><span class="identifier">reverse_lock</span><span class="special">(</span><span class="identifier">Lock</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                  Invokes <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>
                  if <code class="computeroutput"><span class="identifier">m</span></code> owns his lock
                  and then stores the mutex by calling <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">release</span><span class="special">()</span></code>.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="special">!</span><span class="identifier">m</span><span class="special">.</span> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a><span class="special">()</span> <span class="special">&amp;&amp;</span>
                  <span class="identifier">m</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()==</span><span class="number">0</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exception thrown by the call to <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span></code></a><span class="special">()</span></code>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.other_locks.reverse_lock.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.other_locks.reverse_lock.destructor" title="~reverse_lock()"><code class="computeroutput"><span class="special">~</span><span class="identifier">reverse_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Let be mtx the stored mutex*. If not 0 Invokes <code class="computeroutput"><span class="identifier">mtx</span><span class="special">-&gt;</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span></code></a><span class="special">()</span></code>
                  and gives again the <code class="computeroutput"><span class="identifier">mtx</span></code>
                  to the <code class="computeroutput"><span class="identifier">Lock</span></code> using
                  the <code class="computeroutput"><span class="identifier">adopt_lock_t</span></code>
                  overload.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exception thrown by <code class="computeroutput"><span class="identifier">mtx</span><span class="special">-&gt;</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span></code></a><span class="special">()</span></code>.
                </p></dd>
<dt><span class="term">Remarks:</span></dt>
<dd><p>
                  Note that if <code class="computeroutput"><span class="identifier">mtx</span><span class="special">-&gt;</span><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span></code></a><span class="special">()</span></code>
                  throws an exception while unwinding the program will terminate,
                  so don't use reverse_lock if an exception can be thrown.
                </p></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.lock_functions"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions" title="Lock functions">Lock functions</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions.lock_multiple">Non-member
        function <code class="computeroutput"><span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">,...)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions.lock_range">Non-member
        function <code class="computeroutput"><span class="identifier">lock</span><span class="special">(</span><span class="identifier">begin</span><span class="special">,</span><span class="identifier">end</span><span class="special">)</span></code> //
        EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions.try_lock_multiple">Non-member
        function <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">,...)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions.try_lock_range">Non-member
        function <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">begin</span><span class="special">,</span><span class="identifier">end</span><span class="special">)</span></code> //
        EXTENSION</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_functions.lock_multiple"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions.lock_multiple" title="Non-member function lock(Lockable1,Lockable2,...)">Non-member
        function <code class="computeroutput"><span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">,...)</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/locks.hpp&gt;</span>
<span class="comment">// #include &lt;boost/thread/lock_algorithms.hpp&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">);</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">);</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable4</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">,</span><span class="identifier">Lockable4</span><span class="special">&amp;</span> <span class="identifier">l4</span><span class="special">);</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable4</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable5</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">,</span><span class="identifier">Lockable4</span><span class="special">&amp;</span> <span class="identifier">l4</span><span class="special">,</span><span class="identifier">Lockable5</span><span class="special">&amp;</span> <span class="identifier">l5</span><span class="special">);</span>

<span class="special">}</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Locks the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects supplied
                as arguments in an unspecified and indeterminate order in a way that
                avoids deadlock. It is safe to call this function concurrently from
                multiple threads with the same mutexes (or other lockable objects)
                in different orders without risk of deadlock. If any of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
                or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                operations on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects throws
                an exception any locks acquired by the function will be released
                before the function exits.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exceptions thrown by calling <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
                or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                All the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects are locked
                by the calling thread.
              </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_functions.lock_range"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions.lock_range" title="Non-member function lock(begin,end) // EXTENSION">Non-member
        function <code class="computeroutput"><span class="identifier">lock</span><span class="special">(</span><span class="identifier">begin</span><span class="special">,</span><span class="identifier">end</span><span class="special">)</span></code> //
        EXTENSION</a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ForwardIterator</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">ForwardIterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">ForwardIterator</span> <span class="identifier">end</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                The <code class="computeroutput"><span class="identifier">value_type</span></code> of
                <code class="computeroutput"><span class="identifier">ForwardIterator</span></code> must
                implement the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a>
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Locks all the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the
                supplied range in an unspecified and indeterminate order in a way
                that avoids deadlock. It is safe to call this function concurrently
                from multiple threads with the same mutexes (or other lockable objects)
                in different orders without risk of deadlock. If any of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
                or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                operations on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the
                supplied range throws an exception any locks acquired by the function
                will be released before the function exits.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exceptions thrown by calling <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
                or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                All the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the
                supplied range are locked by the calling thread.
              </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_functions.try_lock_multiple"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions.try_lock_multiple" title="Non-member function try_lock(Lockable1,Lockable2,...)">Non-member
        function <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">,...)</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable4</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">,</span><span class="identifier">Lockable4</span><span class="special">&amp;</span> <span class="identifier">l4</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable4</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable5</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">,</span><span class="identifier">Lockable4</span><span class="special">&amp;</span> <span class="identifier">l4</span><span class="special">,</span><span class="identifier">Lockable5</span><span class="special">&amp;</span> <span class="identifier">l5</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                Calls <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                on each of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects supplied
                as arguments. If any of the calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code> then all
                locks acquired are released and the zero-based index of the failed
                lock is returned.
              </p>
<p>
                If any of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                operations on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects throws
                an exception any locks acquired by the function will be released
                before the function exits.
              </p>
</dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>
                if all the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects are now
                locked by the calling thread, the zero-based index of the object
                which could not be locked otherwise.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exceptions thrown by calling <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                If the function returns <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>, all the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects are locked
                by the calling thread. Otherwise any locks acquired by this function
                will have been released.
              </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_functions.try_lock_range"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions.try_lock_range" title="Non-member function try_lock(begin,end) // EXTENSION">Non-member
        function <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">begin</span><span class="special">,</span><span class="identifier">end</span><span class="special">)</span></code> //
        EXTENSION</a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ForwardIterator</span><span class="special">&gt;</span>
<span class="identifier">ForwardIterator</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">ForwardIterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">ForwardIterator</span> <span class="identifier">end</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                The <code class="computeroutput"><span class="identifier">value_type</span></code> of
                <code class="computeroutput"><span class="identifier">ForwardIterator</span></code> must
                implement the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a>
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                Calls <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                on each of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the
                supplied range. If any of the calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code> then all
                locks acquired are released and an iterator referencing the failed
                lock is returned.
              </p>
<p>
                If any of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                operations on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects throws
                an exception any locks acquired by the function will be released
                before the function exits.
              </p>
</dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">end</span></code> if all the supplied
                <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects are now
                locked by the calling thread, an iterator referencing the object
                which could not be locked otherwise.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exceptions thrown by calling <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                If the function returns <code class="computeroutput"><span class="identifier">end</span></code>
                then all the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the
                supplied range are locked by the calling thread, otherwise all locks
                acquired by the function have been released.
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.lock_factories"></a><a class="link" href="synchronization.html#thread.synchronization.lock_factories" title="Lock Factories - EXTENSION">Lock Factories
      - EXTENSION</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_factories.make_unique_lock">Non
        Member Function <code class="computeroutput"><span class="identifier">make_unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_factories.make_unique_lock_t">Non
        Member Function <code class="computeroutput"><span class="identifier">make_unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;,</span><span class="identifier">tag</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_factories.make_unique_locks">Non
        Member Function <code class="computeroutput"><span class="identifier">make_unique_locks</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="special">...)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="identifier">adopt_lock_t</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="identifier">defer_lock_t</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="identifier">try_to_lock_t</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

<span class="preprocessor">#if</span> <span class="special">!</span> <span class="identifier">defined</span><span class="special">(</span><span class="identifier">BOOST_THREAD_NO_MAKE_UNIQUE_LOCKS</span><span class="special">)</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="special">...</span><span class="identifier">Lockable</span><span class="special">&gt;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">...&gt;</span> <span class="identifier">make_unique_locks</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="special">...</span><span class="identifier">mtx</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
<span class="preprocessor">#endif</span>
<span class="special">}</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_factories.make_unique_lock"></a><a class="link" href="synchronization.html#thread.synchronization.lock_factories.make_unique_lock" title="Non Member Function make_unique_lock(Lockable&amp;)">Non
        Member Function <code class="computeroutput"><span class="identifier">make_unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;)</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                a <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> as if initialized
                with <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;(</span><span class="identifier">mtx</span><span class="special">)</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exception thrown by the call to <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;(</span><span class="identifier">mtx</span><span class="special">)</span></code>.
              </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_factories.make_unique_lock_t"></a><a class="link" href="synchronization.html#thread.synchronization.lock_factories.make_unique_lock_t" title="Non Member Function make_unique_lock(Lockable&amp;,tag)">Non
        Member Function <code class="computeroutput"><span class="identifier">make_unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;,</span><span class="identifier">tag</span><span class="special">)</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="identifier">adopt_lock_t</span> <span class="identifier">tag</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="identifier">defer_lock_t</span> <span class="identifier">tag</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="identifier">make_unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">,</span> <span class="identifier">try_to_lock_t</span> <span class="identifier">tag</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                a <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> as if initialized
                with <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;(</span><span class="identifier">mtx</span><span class="special">,</span> <span class="identifier">tag</span><span class="special">)</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exception thrown by the call to <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;(</span><span class="identifier">mtx</span><span class="special">,</span>
                <span class="identifier">tag</span><span class="special">)</span></code>.
              </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_factories.make_unique_locks"></a><a class="link" href="synchronization.html#thread.synchronization.lock_factories.make_unique_locks" title="Non Member Function make_unique_locks(Lockable&amp; ...)">Non
        Member Function <code class="computeroutput"><span class="identifier">make_unique_locks</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="special">...)</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="special">...</span><span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">...&gt;</span> <span class="identifier">make_unique_locks</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="special">...</span><span class="identifier">mtx</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effect:</span></dt>
<dd><p>
                Locks all the mutexes.
              </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                a std::tuple of unique <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> owning each
                one of the mutex.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exception thrown by <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock</span><span class="special">(</span><span class="identifier">mtx</span><span class="special">...)</span></code>.
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.mutex_types"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types" title="Mutex Types">Mutex Types</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.mutex">Class <code class="computeroutput"><span class="identifier">mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.try_mutex">Typedef
        <code class="computeroutput"><span class="identifier">try_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.timed_mutex">Class
        <code class="computeroutput"><span class="identifier">timed_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex">Class
        <code class="computeroutput"><span class="identifier">recursive_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_try_mutex">Typedef
        <code class="computeroutput"><span class="identifier">recursive_try_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex">Class
        <code class="computeroutput"><span class="identifier">recursive_timed_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.shared_mutex">Class
        <code class="computeroutput"><span class="identifier">shared_mutex</span></code> -- C++14</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.upgrade_mutex">Class
        <code class="computeroutput"><span class="identifier">upgrade_mutex</span></code> -- EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.null_mutex">Class
        <code class="computeroutput"><span class="identifier">null_mutex</span></code> -- EXTENSION</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex" title="Class mutex">Class <code class="computeroutput"><span class="identifier">mutex</span></code></a>
</h4></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.mutex.nativehandle">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a></span></dt></dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">mutex</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
    <span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">scoped_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">scoped_try_lock</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex" title="Class mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span></code></a> implements the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> to provide an
          exclusive-ownership mutex. At most one thread can own the lock on a given
          instance of <a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex" title="Class mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span></code></a> at any time. Multiple concurrent
          calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          shall be permitted.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_types.mutex.nativehandle"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex.nativehandle" title="Member function native_handle()">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
<span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Returns an instance of <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  that can be used with platform-specific APIs to manipulate the
                  underlying implementation. If no such instance exists, <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code>
                  and <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  are not present.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.try_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.try_mutex" title="Typedef try_mutex">Typedef
        <code class="computeroutput"><span class="identifier">try_mutex</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">typedef</span> <span class="identifier">mutex</span> <span class="identifier">try_mutex</span><span class="special">;</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.try_mutex" title="Typedef try_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_mutex</span></code></a> is a <code class="computeroutput"><span class="keyword">typedef</span></code>
          to <a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex" title="Class mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span></code></a>, provided for backwards
          compatibility with previous releases of boost.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.timed_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.timed_mutex" title="Class timed_mutex">Class
        <code class="computeroutput"><span class="identifier">timed_mutex</span></code></a>
</h4></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.timed_mutex.nativehandle">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a></span></dt></dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">timed_mutex</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">timed_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">timed_mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>

    <span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
    <span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">timed_mutex</span><span class="special">&gt;</span> <span class="identifier">scoped_timed_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">scoped_try_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">scoped_timed_lock</span> <span class="identifier">scoped_lock</span><span class="special">;</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DATE_TIME</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">system_time</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TimeDuration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">TimeDuration</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">relative_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>

<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.timed_mutex" title="Class timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">timed_mutex</span></code></a> implements the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> to provide
          an exclusive-ownership mutex. At most one thread can own the lock on a
          given instance of <a class="link" href="synchronization.html#thread.synchronization.mutex_types.timed_mutex" title="Class timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">timed_mutex</span></code></a> at any time. Multiple
          concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="m.timed_lock(rel_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          shall be permitted.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_types.timed_mutex.nativehandle"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.timed_mutex.nativehandle" title="Member function native_handle()">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
<span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Returns an instance of <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  that can be used with platform-specific APIs to manipulate the
                  underlying implementation. If no such instance exists, <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code>
                  and <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  are not present.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.recursive_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex">Class
        <code class="computeroutput"><span class="identifier">recursive_mutex</span></code></a>
</h4></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex.nativehandle">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a></span></dt></dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">recursive_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">recursive_mutex</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">recursive_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">recursive_mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
    <span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">recursive_mutex</span><span class="special">&gt;</span> <span class="identifier">scoped_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">scoped_try_lock</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code></a> implements the
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> to provide an
          exclusive-ownership recursive mutex. At most one thread can own the lock
          on a given instance of <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code></a> at any time. Multiple
          concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          shall be permitted. A thread that already has exclusive ownership of a
          given <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code></a> instance can call
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          to acquire an additional level of ownership of the mutex. <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          must be called once for each level of ownership acquired by a single thread
          before ownership can be acquired by another thread.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_types.recursive_mutex.nativehandle"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex.nativehandle" title="Member function native_handle()">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
<span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Returns an instance of <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  that can be used with platform-specific APIs to manipulate the
                  underlying implementation. If no such instance exists, <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code>
                  and <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  are not present.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.recursive_try_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_try_mutex" title="Typedef recursive_try_mutex">Typedef
        <code class="computeroutput"><span class="identifier">recursive_try_mutex</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">recursive_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">typedef</span> <span class="identifier">recursive_mutex</span> <span class="identifier">recursive_try_mutex</span><span class="special">;</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_try_mutex" title="Typedef recursive_try_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_try_mutex</span></code></a> is a <code class="computeroutput"><span class="keyword">typedef</span></code> to <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code></a>, provided for
          backwards compatibility with previous releases of boost.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.recursive_timed_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex" title="Class recursive_timed_mutex">Class
        <code class="computeroutput"><span class="identifier">recursive_timed_mutex</span></code></a>
</h4></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex.nativehandle">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a></span></dt></dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">recursive_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">recursive_timed_mutex</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">recursive_timed_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">recursive_timed_mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>


    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>

    <span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
    <span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">recursive_timed_mutex</span><span class="special">&gt;</span> <span class="identifier">scoped_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">scoped_try_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">scoped_lock</span> <span class="identifier">scoped_timed_lock</span><span class="special">;</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DATE_TIME</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">system_time</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TimeDuration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">TimeDuration</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">relative_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>

<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex" title="Class recursive_timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_timed_mutex</span></code></a> implements
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> to provide
          an exclusive-ownership recursive mutex. At most one thread can own the
          lock on a given instance of <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex" title="Class recursive_timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_timed_mutex</span></code></a> at any time.
          Multiple concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="m.timed_lock(rel_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          shall be permitted. A thread that already has exclusive ownership of a
          given <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex" title="Class recursive_timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_timed_mutex</span></code></a> instance
          can call <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="m.timed_lock(rel_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
          or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          to acquire an additional level of ownership of the mutex. <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.unlock" title="m.unlock();"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          must be called once for each level of ownership acquired by a single thread
          before ownership can be acquired by another thread.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_types.recursive_timed_mutex.nativehandle"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex.nativehandle" title="Member function native_handle()">Member
          function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
<span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Returns an instance of <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  that can be used with platform-specific APIs to manipulate the
                  underlying implementation. If no such instance exists, <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code>
                  and <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                  are not present.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.shared_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.shared_mutex" title="Class shared_mutex -- C++14">Class
        <code class="computeroutput"><span class="identifier">shared_mutex</span></code> -- C++14</a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">shared_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">shared_mutex</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">shared_mutex</span><span class="special">(</span><span class="identifier">shared_mutex</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">shared_mutex</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">shared_mutex</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">shared_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">shared_mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock_shared</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock_shared</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span>
    <span class="comment">// use upgrade_mutex instead.</span>
    <span class="keyword">void</span> <span class="identifier">lock_upgrade</span><span class="special">();</span> <span class="comment">// EXTENSION</span>
    <span class="keyword">void</span> <span class="identifier">unlock_upgrade</span><span class="special">();</span> <span class="comment">// EXTENSION</span>

    <span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock</span><span class="special">();</span> <span class="comment">// EXTENSION</span>
    <span class="keyword">void</span> <span class="identifier">unlock_and_lock_upgrade</span><span class="special">();</span> <span class="comment">// EXTENSION</span>
    <span class="keyword">void</span> <span class="identifier">unlock_and_lock_shared</span><span class="special">();</span> <span class="comment">// EXTENSION</span>
    <span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">();</span> <span class="comment">// EXTENSION</span>
<span class="preprocessor">#endif</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_USES_DATETIME</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout</span><span class="special">);</span> <span class="comment">// DEPRECATED</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout</span><span class="special">);</span> <span class="comment">// DEPRECATED</span>
<span class="preprocessor">#endif</span>

<span class="special">};</span>
</pre>
<p>
          The class <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_mutex</span></code> provides an implementation
          of a multiple-reader / single-writer mutex. It implements the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept -- C++14"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a>.
        </p>
<p>
          Multiple concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a><span class="special">()</span></code>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">()</span></code>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_shared_for</span></code></a><span class="special">()</span></code>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">try_lock_shared_until</span></code></a><span class="special">()</span></code>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock_shared</span><span class="special">()</span></code></a>
          are permitted.
        </p>
<p>
          Note the the lack of reader-writer priority policies in shared_mutex. This
          is due to an algorithm credited to Alexander Terekhov which lets the OS
          decide which thread is the next to get the lock without caring whether
          a unique lock or shared lock is being sought. This results in a complete
          lack of reader or writer starvation. It is simply fair.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.upgrade_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.upgrade_mutex" title="Class upgrade_mutex -- EXTENSION">Class
        <code class="computeroutput"><span class="identifier">upgrade_mutex</span></code> -- EXTENSION</a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">shared_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">upgrade_mutex</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">upgrade_mutex</span><span class="special">(</span><span class="identifier">upgrade_mutex</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">upgrade_mutex</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">upgrade_mutex</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">upgrade_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">upgrade_mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock_shared</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock_shared</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock_upgrade</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_upgrade_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_upgrade_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock_upgrade</span><span class="special">();</span>

    <span class="comment">// Shared &lt;-&gt; Exclusive</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSIONS</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>
    <span class="keyword">void</span> <span class="identifier">unlock_and_lock_shared</span><span class="special">();</span>

    <span class="comment">// Shared &lt;-&gt; Upgrade</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_PROVIDES_SHARED_MUTEX_UPWARDS_CONVERSIONS</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_upgrade</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_upgrade_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_upgrade_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>
    <span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">();</span>

    <span class="comment">// Upgrade &lt;-&gt; Exclusive</span>

    <span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock</span><span class="special">();</span>
<span class="preprocessor">#if</span>    <span class="identifier">defined</span><span class="special">(</span><span class="identifier">BOOST_THREAD_PLATFORM_PTHREAD</span><span class="special">)</span>
    <span class="special">||</span> <span class="identifier">defined</span><span class="special">(</span><span class="identifier">BOOST_THREAD_PROVIDES_GENERIC_SHARED_MUTEX_ON_WIN</span><span class="special">)</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_upgrade_and_lock</span><span class="special">();</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_upgrade_and_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_upgrade_and_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
<span class="preprocessor">#endif</span>
    <span class="keyword">void</span> <span class="identifier">unlock_and_lock_upgrade</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
          The class <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_mutex</span></code> provides an implementation
          of a multiple-reader / single-writer mutex. It implements the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept -- EXTENSION"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> concept</a>.
        </p>
<p>
          Multiple concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.basic_lockable.lock" title="m.lock();"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="m.try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_for" title="m.try_lock_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_for</span></code></a><span class="special">()</span></code>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.try_lock_until" title="m.try_lock_until(abs_time)"><code class="computeroutput"><span class="identifier">try_lock_until</span></code></a><span class="special">()</span></code>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="m.timed_lock(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="m.lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_for" title="m.try_lock_shared_for(rel_time)"><code class="computeroutput"><span class="identifier">try_lock_shared_for</span></code></a><span class="special">()</span></code>,
          <code class="computeroutput"><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared_until" title="m.try_lock_shared_until(abs_time))"><code class="computeroutput"><span class="identifier">try_lock_shared_until</span></code></a><span class="special">()</span></code>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="m.try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="m.timed_lock_shared(abs_time)"><code class="computeroutput"><span class="identifier">timed_lock_shared</span><span class="special">()</span></code></a>
          are permitted.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.null_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.null_mutex" title="Class null_mutex -- EXTENSION">Class
        <code class="computeroutput"><span class="identifier">null_mutex</span></code> -- EXTENSION</a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">null_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">null_mutex</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">null_mutex</span><span class="special">(</span><span class="identifier">null_mutex</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">null_mutex</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">null_mutex</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">null_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">null_mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock_shared</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared</span><span class="special">();</span>
 <span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_USES_CHRONO</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
 <span class="preprocessor">#endif</span>
    <span class="keyword">void</span> <span class="identifier">unlock_shared</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
 <span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_USES_CHRONO</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
 <span class="preprocessor">#endif</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock_upgrade</span><span class="special">();</span>
 <span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_USES_CHRONO</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_upgrade_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_upgrade_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
 <span class="preprocessor">#endif</span>
    <span class="keyword">void</span> <span class="identifier">unlock_upgrade</span><span class="special">();</span>

    <span class="comment">// Shared &lt;-&gt; Exclusive</span>

    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock</span><span class="special">();</span>
 <span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_USES_CHRONO</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
 <span class="preprocessor">#endif</span>
    <span class="keyword">void</span> <span class="identifier">unlock_and_lock_shared</span><span class="special">();</span>

    <span class="comment">// Shared &lt;-&gt; Upgrade</span>

    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_upgrade</span><span class="special">();</span>
 <span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_USES_CHRONO</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_upgrade_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_shared_and_lock_upgrade_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
 <span class="preprocessor">#endif</span>
    <span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">();</span>

    <span class="comment">// Upgrade &lt;-&gt; Exclusive</span>

    <span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_upgrade_and_lock</span><span class="special">();</span>
 <span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_USES_CHRONO</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_upgrade_and_lock_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_unlock_upgrade_and_lock_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
 <span class="preprocessor">#endif</span>
    <span class="keyword">void</span> <span class="identifier">unlock_and_lock_upgrade</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
          The class <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">null_mutex</span></code> provides a no-op implementation
          of a multiple-reader / single-writer mutex. It is a model of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept -- EXTENSION"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code></a> concept.
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.condvar_ref"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref" title="Condition Variables">Condition Variables</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable">Class
        <code class="computeroutput"><span class="identifier">condition_variable</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any">Class
        <code class="computeroutput"><span class="identifier">condition_variable_any</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition">Typedef
        <code class="computeroutput"><span class="identifier">condition</span></code> DEPRECATED V3</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.notify_all_at_thread_exit">Non-member
        Function <code class="computeroutput"><span class="identifier">notify_all_at_thread_exit</span></code>()</a></span></dt>
</dl></div>
<h5>
<a name="thread.synchronization.condvar_ref.h0"></a>
        <span class="phrase"><a name="thread.synchronization.condvar_ref.synopsis"></a></span><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.synopsis">Synopsis</a>
      </h5>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">cv_status</span><span class="special">;</span>
  <span class="special">{</span>
    <span class="identifier">no_timeout</span><span class="special">,</span>
    <span class="identifier">timeout</span>
  <span class="special">};</span>
  <span class="keyword">class</span> <span class="identifier">condition_variable</span><span class="special">;</span>
  <span class="keyword">class</span> <span class="identifier">condition_variable_any</span><span class="special">;</span>
  <span class="keyword">void</span> <span class="identifier">notify_all_at_thread_exit</span><span class="special">(</span><span class="identifier">condition_variable</span><span class="special">&amp;</span> <span class="identifier">cond</span><span class="special">,</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        The classes <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        and <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>
        provide a mechanism for one thread to wait for notification from another
        thread that a particular condition has become true. The general usage pattern
        is that one thread locks a mutex and then calls <code class="computeroutput"><span class="identifier">wait</span></code>
        on an instance of <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        or <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>.
        When the thread is woken from the wait, then it checks to see if the appropriate
        condition is now true, and continues if so. If the condition is not true,
        then the thread then calls <code class="computeroutput"><span class="identifier">wait</span></code>
        again to resume waiting. In the simplest case, this condition is just a boolean
        variable:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">condition_variable</span> <span class="identifier">cond</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mut</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">data_ready</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">process_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">wait_for_data_to_process</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mut</span><span class="special">);</span>
    <span class="keyword">while</span><span class="special">(!</span><span class="identifier">data_ready</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">cond</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">process_data</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        Notice that the <code class="computeroutput"><span class="identifier">lock</span></code> is passed
        to <code class="computeroutput"><span class="identifier">wait</span></code>: <code class="computeroutput"><span class="identifier">wait</span></code>
        will atomically add the thread to the set of threads waiting on the condition
        variable, and unlock the mutex. When the thread is woken, the mutex will
        be locked again before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
        returns. This allows other threads to acquire the mutex in order to update
        the shared data, and ensures that the data associated with the condition
        is correctly synchronized.
      </p>
<p>
        In the mean time, another thread sets the condition to <code class="computeroutput"><span class="keyword">true</span></code>,
        and then calls either <code class="computeroutput"><span class="identifier">notify_one</span></code>
        or <code class="computeroutput"><span class="identifier">notify_all</span></code> on the condition
        variable to wake one waiting thread or all the waiting threads respectively.
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">retrieve_data</span><span class="special">();</span>
<span class="keyword">void</span> <span class="identifier">prepare_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">prepare_data_for_processing</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">retrieve_data</span><span class="special">();</span>
    <span class="identifier">prepare_data</span><span class="special">();</span>
    <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mut</span><span class="special">);</span>
        <span class="identifier">data_ready</span><span class="special">=</span><span class="keyword">true</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="identifier">cond</span><span class="special">.</span><span class="identifier">notify_one</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        Note that the same mutex is locked before the shared data is updated, but
        that the mutex does not have to be locked across the call to <code class="computeroutput"><span class="identifier">notify_one</span></code>.
      </p>
<p>
        This example uses an object of type <code class="computeroutput"><span class="identifier">condition_variable</span></code>,
        but would work just as well with an object of type <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>:
        <code class="computeroutput"><span class="identifier">condition_variable_any</span></code> is
        more general, and will work with any kind of lock or mutex, whereas <code class="computeroutput"><span class="identifier">condition_variable</span></code> requires that the lock
        passed to <code class="computeroutput"><span class="identifier">wait</span></code> is an instance
        of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span></code>.
        This enables <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        to make optimizations in some cases, based on the knowledge of the mutex
        type; <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>
        typically has a more complex implementation than <code class="computeroutput"><span class="identifier">condition_variable</span></code>.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable" title="Class condition_variable">Class
        <code class="computeroutput"><span class="identifier">condition_variable</span></code></a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.constructor"><code class="computeroutput"><span class="identifier">condition_variable</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_one"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_all"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_rel"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_until"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_for"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_until_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_for_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">//#include &lt;boost/thread/condition_variable.hpp&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
    <span class="keyword">class</span> <span class="identifier">condition_variable</span>
    <span class="special">{</span>
    <span class="keyword">public</span><span class="special">:</span>
        <span class="identifier">condition_variable</span><span class="special">();</span>
        <span class="special">~</span><span class="identifier">condition_variable</span><span class="special">();</span>

        <span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
        <span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
        <span class="keyword">typename</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">type</span>
        <span class="identifier">wait_until</span><span class="special">(</span>
            <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
        <span class="keyword">bool</span>
        <span class="identifier">wait_until</span><span class="special">(</span>
            <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">,</span>
            <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
        <span class="keyword">typename</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">type</span>
        <span class="identifier">wait_for</span><span class="special">(</span>
            <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
        <span class="keyword">bool</span>
        <span class="identifier">wait_for</span><span class="special">(</span>
            <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">,</span>
            <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>

    <span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_USES_DATETIME</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
    <span class="preprocessor">#endif</span>

    <span class="special">};</span>
<span class="special">}</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.constructor" title="condition_variable()"><code class="computeroutput"><span class="identifier">condition_variable</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Constructs an object of class <code class="computeroutput"><span class="identifier">condition_variable</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.destructor" title="~condition_variable()"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  All threads waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> have been notified by a call
                  to <code class="computeroutput"><span class="identifier">notify_one</span></code> or
                  <code class="computeroutput"><span class="identifier">notify_all</span></code> (though
                  the respective calls to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code> need
                  not have returned).
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Destroys the object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.notify_one"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_one" title="void notify_one()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code>,
                  unblocks one of those threads.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.notify_all"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_all" title="void notify_all()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code>,
                  unblocks all of those threads.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait" title="void wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock)"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">timed_wait</span></code> in all
                  the threads currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_predicate" title="template&lt;typename predicate_type&gt; void wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, predicate_type pred)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.timed_wait"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait" title="bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock,boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">timed_wait</span></code> in all
                  the threads currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  when the time as reported by <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">get_system_time</span><span class="special">()</span></code> would be equal to or later than
                  the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">false</span></code> if the call
                  is returning because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="keyword">true</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.timed_wait_rel"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_rel" title="template&lt;typename duration_type&gt; bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock,duration_type const&amp; rel_time)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">timed_wait</span></code> in all
                  the threads currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  argument has elapsed, or spuriously. When the thread is unblocked
                  (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  if the function exits with an exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">false</span></code> if the call
                  is returning because the time period specified by <code class="computeroutput"><span class="identifier">rel_time</span></code> has elapsed, <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.timed_wait_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_predicate" title="template&lt;typename predicate_type&gt; bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, boost::system_time const&amp; abs_time, predicate_type pred)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_until"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_until" title="template &lt;class Clock, class Duration&gt; cv_status wait_until(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">wait_for</span></code> or <code class="computeroutput"><span class="identifier">wait_until</span></code> in all the threads
                  currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  when the time as reported by <code class="computeroutput"><span class="identifier">Clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span></code> would be equal to or later than
                  the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code> if the call is returning
                  because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_for"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_for" title="template &lt;class Rep, class Period&gt; cv_status wait_for(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
          <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread, and either no other thread is currently
                  waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                  or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the
                  calls to <code class="computeroutput"><span class="identifier">wait</span></code> or
                  <code class="computeroutput"><span class="identifier">wait_until</span></code> or
                  <code class="computeroutput"><span class="identifier">wait_for</span></code> in all
                  the threads currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                  as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                  for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  argument has elapsed, or spuriously. When the thread is unblocked
                  (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  if the function exits with an exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span> </code> if the call is returning
                  because the time period specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  has elapsed, <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span>
                  </code> otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_until_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_until_predicate" title="template &lt;class Clock, class Duration, class Predicate&gt; bool wait_until(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, Predicate pred)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_for_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_for_predicate" title="template &lt;class Rep, class Period, class Predicate&gt; bool wait_for(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span> <span class="identifier">Predicate</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">return</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">steady_clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">d</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">pred</span><span class="special">));</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any" title="Class condition_variable_any">Class
        <code class="computeroutput"><span class="identifier">condition_variable_any</span></code></a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.constructor"><code class="computeroutput"><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.destructor"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.notify_one"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.notify_all"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_rel"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_predicate"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for_predicate"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">//#include &lt;boost/thread/condition_variable.hpp&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
    <span class="keyword">class</span> <span class="identifier">condition_variable_any</span>
    <span class="special">{</span>
    <span class="keyword">public</span><span class="special">:</span>
        <span class="identifier">condition_variable_any</span><span class="special">();</span>
        <span class="special">~</span><span class="identifier">condition_variable_any</span><span class="special">();</span>

        <span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">();</span>
        <span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">();</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
        <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span>
            <span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span>
            <span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">t</span><span class="special">,</span>
            <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>


        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
        <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span>
            <span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">);</span>

        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span>
            <span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">d</span><span class="special">,</span>
            <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>

    <span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_USES_DATETIME</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
    <span class="preprocessor">#endif</span>
    <span class="special">};</span>
<span class="special">}</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.constructor" title="condition_variable_any()"><code class="computeroutput"><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Constructs an object of class <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.destructor" title="~condition_variable_any()"><code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  All threads waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> have been notified by a call
                  to <code class="computeroutput"><span class="identifier">notify_one</span></code> or
                  <code class="computeroutput"><span class="identifier">notify_all</span></code> (though
                  the respective calls to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code> need
                  not have returned).
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Destroys the object.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.notify_one"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.notify_one" title="void notify_one()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code>,
                  unblocks one of those threads.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.notify_all"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.notify_all" title="void notify_all()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                  in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">timed_wait</span></code>,
                  unblocks all of those threads.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait" title="template&lt;typename lock_type&gt; void wait(lock_type&amp; lock)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_predicate" title="template&lt;typename lock_type,typename predicate_type&gt; void wait(lock_type&amp; lock, predicate_type pred)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.timed_wait"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait" title="template&lt;typename lock_type&gt; bool timed_wait(lock_type&amp; lock,boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  when the time as reported by <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">get_system_time</span><span class="special">()</span></code> would be equal to or later than
                  the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">false</span></code> if the call
                  is returning because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="keyword">true</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.timed_wait_rel"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_rel" title="template&lt;typename lock_type,typename duration_type&gt; bool timed_wait(lock_type&amp; lock,duration_type const&amp; rel_time)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  argument has elapsed, or spuriously. When the thread is unblocked
                  (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  if the function exits with an exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">false</span></code> if the call
                  is returning because the time period specified by <code class="computeroutput"><span class="identifier">rel_time</span></code> has elapsed, <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.timed_wait_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_predicate" title="template&lt;typename lock_type,typename predicate_type&gt; bool timed_wait(lock_type&amp; lock, boost::system_time const&amp; abs_time, predicate_type pred)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_until"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until" title="template &lt;class lock_type, class Clock, class Duration&gt; cv_status wait_until(lock_type&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  when the time as reported by <code class="computeroutput"><span class="identifier">Clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span></code> would be equal to or later than
                  the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                  or spuriously. When the thread is unblocked (for whatever reason),
                  the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                  reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an
                  exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code> if the call is returning
                  because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_for"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for" title="template &lt;class lock_type, class Rep, class Period&gt; cv_status wait_for(lock_type&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span> <span class="identifier">cv_status</span>
          <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                  The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                  or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                  after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                  argument has elapsed, or spuriously. When the thread is unblocked
                  (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                  returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                  if the function exits with an exception.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code> if the call is returning
                  because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                  was reached, <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">lock</span></code> is locked
                  by the current thread.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_until_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until_predicate" title="template &lt;class lock_type, class Clock, class Duration, class Predicate&gt; bool wait_until(lock_type&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time, Predicate pred)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_until" title="template &lt;class lock_type, class Clock, class Duration&gt; cv_status wait_until(lock_type&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)"><code class="computeroutput"><span class="identifier">wait_until</span></code></a><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_for_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_for_predicate" title="template &lt;class lock_type, class Rep, class Period, class Predicate&gt; bool wait_for(lock_type&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred)"><code class="computeroutput"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">lock_type</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span>
          <span class="identifier">rel_time</span><span class="special">,</span>
          <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  As-if
</p>
<pre class="programlisting"><span class="keyword">return</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">steady_clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">d</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">pred</span><span class="special">));</span>
</pre>
<p>
                </p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.condition"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition" title="Typedef condition DEPRECATED V3">Typedef
        <code class="computeroutput"><span class="identifier">condition</span></code> DEPRECATED V3</a>
</h4></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/condition.hpp&gt;</span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

  <span class="keyword">typedef</span> <span class="identifier">condition_variable_any</span> <span class="identifier">condition</span><span class="special">;</span>

<span class="special">}</span>
</pre>
<p>
          The typedef <code class="computeroutput"><span class="identifier">condition</span></code> is
          provided for backwards compatibility with previous boost releases.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.notify_all_at_thread_exit"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.notify_all_at_thread_exit" title="Non-member Function notify_all_at_thread_exit()">Non-member
        Function <code class="computeroutput"><span class="identifier">notify_all_at_thread_exit</span></code>()</a>
</h4></div></div></div>
<pre class="programlisting"><span class="comment">// #include &lt;boost/thread/condition_variable.hpp&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">void</span> <span class="identifier">notify_all_at_thread_exit</span><span class="special">(</span><span class="identifier">condition_variable</span><span class="special">&amp;</span> <span class="identifier">cond</span><span class="special">,</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">lk</span></code> is locked by the
                calling thread and either no other thread is waiting on <code class="computeroutput"><span class="identifier">cond</span></code>, or <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()</span></code> returns the same value for each
                of the lock arguments supplied by all concurrently waiting (via
                <code class="computeroutput"><span class="identifier">wait</span></code>, <code class="computeroutput"><span class="identifier">wait_for</span></code>, or <code class="computeroutput"><span class="identifier">wait_until</span></code>)
                threads.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                transfers ownership of the lock associated with <code class="computeroutput"><span class="identifier">lk</span></code>
                into internal storage and schedules <code class="computeroutput"><span class="identifier">cond</span></code>
                to be notified when the current thread exits, after all objects of
                thread storage duration associated with the current thread have been
                destroyed. This notification shall be as if
              </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
<span class="identifier">cond</span><span class="special">.</span><span class="identifier">notify_all</span><span class="special">();</span>
</pre>
<p>
              </p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.once"></a><a class="link" href="synchronization.html#thread.synchronization.once" title="One-time Initialization">One-time Initialization</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.once.once_flag">Typedef <code class="computeroutput"><span class="identifier">once_flag</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.once.call_once">Non-member function
        <code class="computeroutput"><span class="identifier">call_once</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">once</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">struct</span> <span class="identifier">once_flag</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Function</span><span class="special">,</span> <span class="keyword">class</span> <span class="special">...</span><span class="identifier">ArgTypes</span><span class="special">&gt;</span>
  <span class="keyword">inline</span> <span class="keyword">void</span> <span class="identifier">call_once</span><span class="special">(</span><span class="identifier">once_flag</span><span class="special">&amp;</span> <span class="identifier">flag</span><span class="special">,</span> <span class="identifier">Function</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">ArgTypes</span><span class="special">&amp;&amp;...</span> <span class="identifier">args</span><span class="special">);</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_PROVIDES_DEPRECATED_FEATURES_SINCE_V3_0_0</span>
  <span class="keyword">void</span> <span class="identifier">call_once</span><span class="special">(</span><span class="keyword">void</span> <span class="special">(*</span><span class="identifier">func</span><span class="special">)(),</span><span class="identifier">once_flag</span><span class="special">&amp;</span> <span class="identifier">flag</span><span class="special">);</span>
<span class="preprocessor">#endif</span>

<span class="special">}</span>
</pre>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          the variadic prototype is provided only on C++11 compilers supporting variadic
          templates, otherwise the interface is limited up to 3 parameters.
        </p></td></tr>
</table></div>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          the move semantics is ensured only on C++11 compilers supporting SFINAE
          expression, decltype N3276 and auto. Waiting for a boost::bind that is
          move aware.
        </p></td></tr>
</table></div>
<p>
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">call_once</span></code> provides a mechanism for ensuring
        that an initialization routine is run exactly once without data races or
        deadlocks.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.once.once_flag"></a><a class="link" href="synchronization.html#thread.synchronization.once.once_flag" title="Typedef once_flag">Typedef <code class="computeroutput"><span class="identifier">once_flag</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_THREAD_PROVIDES_ONCE_CXX11</span>
<span class="keyword">struct</span> <span class="identifier">once_flag</span>
<span class="special">{</span>
  <span class="identifier">constexprr</span> <span class="identifier">once_flag</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="identifier">once_flag</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">once_flag</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
  <span class="identifier">once_flag</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> <span class="identifier">once_flag</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
<span class="special">};</span>
<span class="preprocessor">#else</span>
<span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">once_flag</span><span class="special">;</span>
<span class="preprocessor">#define</span> <span class="identifier">BOOST_ONCE_INIT</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">initializer</span>
<span class="preprocessor">#endif</span>
</pre>
<p>
          Objects of type <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">once_flag</span></code> shall be initialized with
          <code class="computeroutput"><span class="identifier">BOOST_ONCE_INIT</span></code> if BOOST_THREAD_PROVIDES_ONCE_CXX11
          is not defined
        </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">once_flag</span> <span class="identifier">f</span><span class="special">=</span><span class="identifier">BOOST_ONCE_INIT</span><span class="special">;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.once.call_once"></a><a class="link" href="synchronization.html#thread.synchronization.once.call_once" title="Non-member function call_once">Non-member function
        <code class="computeroutput"><span class="identifier">call_once</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Function</span><span class="special">,</span> <span class="keyword">class</span> <span class="special">...</span><span class="identifier">ArgTypes</span><span class="special">&gt;</span>
<span class="keyword">inline</span> <span class="keyword">void</span> <span class="identifier">call_once</span><span class="special">(</span><span class="identifier">once_flag</span><span class="special">&amp;</span> <span class="identifier">flag</span><span class="special">,</span> <span class="identifier">Function</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">ArgTypes</span><span class="special">&amp;&amp;...</span> <span class="identifier">args</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">Function</span></code> and each
                or the <code class="computeroutput"><span class="identifier">ArgTypes</span></code> are
                <code class="computeroutput"><span class="identifier">MoveConstructible</span></code>
                and <code class="computeroutput"><span class="identifier">invoke</span><span class="special">(</span><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Function</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">)),</span>
                <span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">ArgTypes</span><span class="special">&gt;(</span><span class="identifier">args</span><span class="special">))...)</span></code>
                shall be well formed.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Calls to <code class="computeroutput"><span class="identifier">call_once</span></code>
                on the same <code class="computeroutput"><span class="identifier">once_flag</span></code>
                object are serialized. If there has been no prior effective <code class="computeroutput"><span class="identifier">call_once</span></code> on the same <code class="computeroutput"><span class="identifier">once_flag</span></code> object, the argument
                <code class="computeroutput"><span class="identifier">func</span></code> is called as-if
                by invoking <code class="computeroutput"><span class="identifier">invoke</span><span class="special">(</span><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Function</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">)),</span> <span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">ArgTypes</span><span class="special">&gt;(</span><span class="identifier">args</span><span class="special">))...)</span></code>, and the invocation of <code class="computeroutput"><span class="identifier">call_once</span></code> is effective if and only
                if <code class="computeroutput"><span class="identifier">invoke</span><span class="special">(</span><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Function</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">)),</span>
                <span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">ArgTypes</span><span class="special">&gt;(</span><span class="identifier">args</span><span class="special">))...)</span></code>
                returns without exception. If an exception is thrown, the exception
                is propagated to the caller. If there has been a prior effective
                <code class="computeroutput"><span class="identifier">call_once</span></code> on the
                same <code class="computeroutput"><span class="identifier">once_flag</span></code> object,
                the <code class="computeroutput"><span class="identifier">call_once</span></code> returns
                without invoking <code class="computeroutput"><span class="identifier">func</span></code>.
              </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
                The completion of an effective <code class="computeroutput"><span class="identifier">call_once</span></code>
                invocation on a <code class="computeroutput"><span class="identifier">once_flag</span></code>
                object, synchronizes with all subsequent <code class="computeroutput"><span class="identifier">call_once</span></code>
                invocations on the same <code class="computeroutput"><span class="identifier">once_flag</span></code>
                object.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">thread_resource_error</span></code>
                when the effects cannot be achieved or any exception propagated from
                <code class="computeroutput"><span class="identifier">func</span></code>.
              </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                The function passed to <code class="computeroutput"><span class="identifier">call_once</span></code>
                must not also call <code class="computeroutput"><span class="identifier">call_once</span></code>
                passing the same <code class="computeroutput"><span class="identifier">once_flag</span></code>
                object. This may cause deadlock, or invoking the passed function
                a second time. The alternative is to allow the second call to return
                immediately, but that assumes the code knows it has been called recursively,
                and can proceed even though the call to <code class="computeroutput"><span class="identifier">call_once</span></code>
                didn't actually call the function, in which case it could also avoid
                calling <code class="computeroutput"><span class="identifier">call_once</span></code>
                recursively.
              </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                On some compilers this function has some restrictions, e.g. if variadic
                templates are not supported the number of arguments is limited to
                3; .
              </p></dd>
</dl>
</div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">call_once</span><span class="special">(</span><span class="keyword">void</span> <span class="special">(*</span><span class="identifier">func</span><span class="special">)(),</span><span class="identifier">once_flag</span><span class="special">&amp;</span> <span class="identifier">flag</span><span class="special">);</span>
</pre>
<p>
          This second overload is provided for backwards compatibility and is deprecated.
          The effects of <code class="computeroutput"><span class="identifier">call_once</span><span class="special">(</span><span class="identifier">func</span><span class="special">,</span><span class="identifier">flag</span><span class="special">)</span></code> shall be the same as those of <code class="computeroutput"><span class="identifier">call_once</span><span class="special">(</span><span class="identifier">flag</span><span class="special">,</span><span class="identifier">func</span><span class="special">)</span></code>.
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.barriers"></a><a class="link" href="synchronization.html#thread.synchronization.barriers" title="Barriers -- EXTENSION">Barriers -- EXTENSION</a>
</h3></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="synchronization.html#thread.synchronization.barriers.barrier">Class <code class="computeroutput"><span class="identifier">barrier</span></code></a></span></dt></dl></div>
<p>
        A barrier is a simple concept. Also known as a <span class="emphasis"><em>rendezvous</em></span>,
        it is a synchronization point between multiple threads. The barrier is configured
        for a particular number of threads (<code class="computeroutput"><span class="identifier">n</span></code>),
        and as threads reach the barrier they must wait until all <code class="computeroutput"><span class="identifier">n</span></code>
        threads have arrived. Once the <code class="computeroutput"><span class="identifier">n</span></code>-th
        thread has reached the barrier, all the waiting threads can proceed, and
        the barrier is reset.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.barriers.barrier"></a><a class="link" href="synchronization.html#thread.synchronization.barriers.barrier" title="Class barrier">Class <code class="computeroutput"><span class="identifier">barrier</span></code></a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.barriers.barrier.constructor__barrier_unsigned_int__">Constructor
          <code class="computeroutput"><span class="identifier">barrier</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.barriers.barrier.constructor__barrier_unsigned_int__f____">Constructor
          <code class="computeroutput"><span class="identifier">barrier</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.barriers.barrier.destructor___barrier___">Destructor
          <code class="computeroutput"><span class="special">~</span><span class="identifier">barrier</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.barriers.barrier.member_function__wait___">Member
          Function <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.barriers.barrier.member_function__count_down_and_wait___">Member
          Function <code class="computeroutput"><span class="identifier">count_down_and_wait</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">barrier</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">barrier</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">barrier</span><span class="special">(</span><span class="identifier">barrier</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">barrier</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">barrier</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">barrier</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">count</span><span class="special">);</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
    <span class="identifier">barrier</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">count</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;);</span>

    <span class="special">~</span><span class="identifier">barrier</span><span class="special">();</span>

    <span class="keyword">bool</span> <span class="identifier">wait</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">count_down_and_wait</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
          Instances of <a class="link" href="synchronization.html#thread.synchronization.barriers.barrier" title="Class barrier"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">barrier</span></code></a> are not copyable or movable.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.barriers.barrier.constructor__barrier_unsigned_int__"></a><a class="link" href="synchronization.html#thread.synchronization.barriers.barrier.constructor__barrier_unsigned_int__" title="Constructor barrier(unsigned int)">Constructor
          <code class="computeroutput"><span class="identifier">barrier</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span><span class="special">)</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="identifier">barrier</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">count</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Construct a barrier for <code class="computeroutput"><span class="identifier">count</span></code>
                  threads.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.barriers.barrier.constructor__barrier_unsigned_int__f____"></a><a class="link" href="synchronization.html#thread.synchronization.barriers.barrier.constructor__barrier_unsigned_int__f____" title="Constructor barrier(unsigned int, F&amp;&amp;)">Constructor
          <code class="computeroutput"><span class="identifier">barrier</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;)</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="identifier">barrier</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">count</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">completion</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  The result type of the completion function call <code class="computeroutput"><span class="identifier">completion</span><span class="special">()</span></code> is <code class="computeroutput"><span class="keyword">void</span></code>
                  or <code class="computeroutput"><span class="keyword">unsigned</span> <span class="keyword">int</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Construct a barrier for <code class="computeroutput"><span class="identifier">count</span></code>
                  threads and a completion function <code class="computeroutput"><span class="identifier">completion</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.barriers.barrier.destructor___barrier___"></a><a class="link" href="synchronization.html#thread.synchronization.barriers.barrier.destructor___barrier___" title="Destructor ~barrier()">Destructor
          <code class="computeroutput"><span class="special">~</span><span class="identifier">barrier</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="special">~</span><span class="identifier">barrier</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                  No threads are waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Destroys <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.barriers.barrier.member_function__wait___"></a><a class="link" href="synchronization.html#thread.synchronization.barriers.barrier.member_function__wait___" title="Member Function wait()">Member
          Function <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">wait</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Block until <code class="computeroutput"><span class="identifier">count</span></code>
                  threads have called <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">count_down_and_wait</span></code>
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  When the <code class="computeroutput"><span class="identifier">count</span></code>-th
                  thread calls <code class="computeroutput"><span class="identifier">wait</span></code>,
                  the barrier is reset and all waiting threads are unblocked. The
                  reset depends on whether the barrier was constructed with a completion
                  function or not. If there is no completion function or if the completion
                  function result is void, the reset consists in restoring the original
                  count. Otherwise the rest consist in assigning the result of the
                  completion function (which must not be 0).
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">true</span></code> for exactly one
                  thread from each batch of waiting threads, <code class="computeroutput"><span class="keyword">false</span></code>
                  otherwise.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                  - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p>
<p>
                  - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p>
</dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>
                  is an <span class="emphasis"><em>interruption point</em></span>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.barriers.barrier.member_function__count_down_and_wait___"></a><a class="link" href="synchronization.html#thread.synchronization.barriers.barrier.member_function__count_down_and_wait___" title="Member Function count_down_and_wait()">Member
          Function <code class="computeroutput"><span class="identifier">count_down_and_wait</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">count_down_and_wait</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Block until <code class="computeroutput"><span class="identifier">count</span></code>
                  threads have called <code class="computeroutput"><span class="identifier">wait</span></code>
                  or <code class="computeroutput"><span class="identifier">count_down_and_wait</span></code>
                  on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  When the <code class="computeroutput"><span class="identifier">count</span></code>-th
                  thread calls <code class="computeroutput"><span class="identifier">wait</span></code>,
                  the barrier is reset and all waiting threads are unblocked. The
                  reset depends on whether the barrier was constructed with a completion
                  function or not. If there is no completion function or if the completion
                  function result is void, the reset consists in restoring the original
                  count. Otherwise the rest consist in assigning the result of the
                  completion function (which must not be 0).
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                  - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                  occurs.
                </p>
<p>
                  - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                  was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt() EXTENSION"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                  on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                  with the current thread of execution.
                </p>
</dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">count_down_and_wait</span><span class="special">()</span></code> is an <span class="emphasis"><em>interruption
                  point</em></span>.
                </p></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.futures"></a><a class="link" href="synchronization.html#thread.synchronization.futures" title="Futures">Futures</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.overview">Overview</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.creating">Creating asynchronous
        values</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.lazy_futures">Wait Callbacks
        and Lazy Futures</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.at_thread_exit">Handling
        Detached Threads and Thread Specific Variables</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.async">Executing asynchronously</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.shared">Shared Futures</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.make_ready_future">Making
        immediate futures easier</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.then">Associating future
        continuations</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference">Futures Reference</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.futures.overview"></a><a class="link" href="synchronization.html#thread.synchronization.futures.overview" title="Overview">Overview</a>
</h4></div></div></div>
<p>
          The futures library provides a means of handling synchronous future values,
          whether those values are generated by another thread, or on a single thread
          in response to external stimuli, or on-demand.
        </p>
<p>
          This is done through the provision of four class templates: <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a> which are used to
          retrieve the asynchronous results, and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> which are used to
          generate the asynchronous results.
        </p>
<p>
          An instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> holds the one and only
          reference to a result. Ownership can be transferred between instances using
          the move constructor or move-assignment operator, but at most one instance
          holds a reference to a given asynchronous result. When the result is ready,
          it is returned from <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get" title="Member function get()"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">get</span><span class="special">()</span></code></a>
          by rvalue-reference to allow the result to be moved or copied as appropriate
          for the type.
        </p>
<p>
          On the other hand, many instances of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a> may reference the
          same result. Instances can be freely copied and assigned, and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get" title="Member function get()"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">get</span><span class="special">()</span></code></a>
          returns a non <code class="computeroutput"><span class="keyword">const</span></code> reference
          so that multiple calls to <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get" title="Member function get()"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">get</span><span class="special">()</span></code></a>
          are safe. You can move an instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> into an instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a>, thus transferring
          ownership of the associated asynchronous result, but not vice-versa.
        </p>
<p>
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">async</span></code> is a simple way of running asynchronous
          tasks. A call to <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">async</span></code>
          returns a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> that will contain the result
          of the task.
        </p>
<p>
          You can wait for futures either individually or with one of the <a class="link" href="synchronization.html#thread.synchronization.futures.reference.wait_for_any" title="Non-member function wait_for_any() - EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">wait_for_any</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.wait_for_all" title="Non-member function wait_for_all() - EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">wait_for_all</span><span class="special">()</span></code></a>
          functions.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.futures.creating"></a><a class="link" href="synchronization.html#thread.synchronization.futures.creating" title="Creating asynchronous values">Creating asynchronous
        values</a>
</h4></div></div></div>
<p>
          You can set the value in a future with either a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> or a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>. A <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> is a callable object
          that wraps a function or callable object. When the packaged task is invoked,
          it invokes the contained function in turn, and populates a future with
          the return value. This is an answer to the perennial question: "how
          do I return a value from a thread?": package the function you wish
          to run as a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> and pass the packaged
          task to the thread constructor. The future retrieved from the packaged
          task can then be used to obtain the return value. If the function throws
          an exception, that is stored in the future in place of the return value.
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">calculate_the_answer_to_life_the_universe_and_everything</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">42</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">pt</span><span class="special">(</span><span class="identifier">calculate_the_answer_to_life_the_universe_and_everything</span><span class="special">);</span>
<span class="identifier">boost</span><span class="special">::</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">fi</span><span class="special">=</span><span class="identifier">pt</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">();</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">task</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">pt</span><span class="special">));</span> <span class="comment">// launch task on a thread</span>

<span class="identifier">fi</span><span class="special">.</span><span class="identifier">wait</span><span class="special">();</span> <span class="comment">// wait for it to finish</span>

<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">has_value</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(!</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">has_exception</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">get_state</span><span class="special">()==</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">get</span><span class="special">()==</span><span class="number">42</span><span class="special">);</span>
</pre>
<p>
          A <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> is a bit more low level:
          it just provides explicit functions to store a value or an exception in
          the associated future. A promise can therefore be used where the value
          may come from more than one possible source, or where a single operation
          may produce multiple values.
        </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">pi</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">fi</span><span class="special">;</span>
<span class="identifier">fi</span><span class="special">=</span><span class="identifier">pi</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">();</span>

<span class="identifier">pi</span><span class="special">.</span><span class="identifier">set_value</span><span class="special">(</span><span class="number">42</span><span class="special">);</span>

<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">has_value</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(!</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">has_exception</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">get_state</span><span class="special">()==</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">get</span><span class="special">()==</span><span class="number">42</span><span class="special">);</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.futures.lazy_futures"></a><a class="link" href="synchronization.html#thread.synchronization.futures.lazy_futures" title="Wait Callbacks and Lazy Futures">Wait Callbacks
        and Lazy Futures</a>
</h4></div></div></div>
<p>
          Both <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> support <span class="emphasis"><em>wait
          callbacks</em></span> that are invoked when a thread blocks in a call to
          <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>
          or <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
          on a future that is waiting for the result from the <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>, in the thread that
          is doing the waiting. These can be set using the <code class="computeroutput"><span class="identifier">set_wait_callback</span><span class="special">()</span></code> member function on the <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> in question.
        </p>
<p>
          This allows <span class="emphasis"><em>lazy futures</em></span> where the result is not actually
          computed until it is needed by some thread. In the example below, the call
          to <code class="computeroutput"><span class="identifier">f</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span></code>
          invokes the callback <code class="computeroutput"><span class="identifier">invoke_lazy_task</span></code>,
          which runs the task to set the value. If you remove the call to <code class="computeroutput"><span class="identifier">f</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span></code>, the task is not ever run.
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">calculate_the_answer_to_life_the_universe_and_everything</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">42</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">void</span> <span class="identifier">invoke_lazy_task</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&amp;</span> <span class="identifier">task</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">try</span>
    <span class="special">{</span>
        <span class="identifier">task</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">catch</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_already_started</span><span class="special">&amp;)</span>
    <span class="special">{}</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">task</span><span class="special">(</span><span class="identifier">calculate_the_answer_to_life_the_universe_and_everything</span><span class="special">);</span>
    <span class="identifier">task</span><span class="special">.</span><span class="identifier">set_wait_callback</span><span class="special">(</span><span class="identifier">invoke_lazy_task</span><span class="special">);</span>
    <span class="identifier">boost</span><span class="special">::</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">task</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">());</span>

    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">f</span><span class="special">.</span><span class="identifier">get</span><span class="special">()==</span><span class="number">42</span><span class="special">);</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.futures.at_thread_exit"></a><a class="link" href="synchronization.html#thread.synchronization.futures.at_thread_exit" title="Handling Detached Threads and Thread Specific Variables">Handling
        Detached Threads and Thread Specific Variables</a>
</h4></div></div></div>
<p>
          Detached threads pose a problem for objects with thread storage duration.
          If we use a mechanism other than <code class="computeroutput"><span class="identifier">thread</span><span class="special">::</span><span class="identifier">__join</span></code>
          to wait for a <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">thread</span></code></a> to complete its work -
          such as waiting for a future to be ready - then the destructors of thread
          specific variables will still be running after the waiting thread has resumed.
          This section explain how the standard mechanism can be used to make such
          synchronization safe by ensuring that the objects with thread storage duration
          are destroyed prior to the future being made ready. e.g.
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">find_the_answer</span><span class="special">();</span> <span class="comment">// uses thread specific objects</span>
<span class="keyword">void</span> <span class="identifier">thread_func</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">p</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">p</span><span class="special">.</span><span class="identifier">set_value_at_thread_exit</span><span class="special">(</span><span class="identifier">find_the_answer</span><span class="special">());</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">p</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">t</span><span class="special">(</span><span class="identifier">thread_func</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">p</span><span class="special">));</span>
    <span class="identifier">t</span><span class="special">.</span><span class="identifier">detach</span><span class="special">();</span> <span class="comment">// we're going to wait on the future</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span><span class="special">&lt;&lt;</span><span class="identifier">p</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">().</span><span class="identifier">get</span><span class="special">()&lt;&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          When the call to <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code>
          returns, we know that not only is the future value ready, but the thread
          specific variables on the other thread have also been destroyed.
        </p>
<p>
          Such mechanisms are provided for <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">condition_variable</span></code>,
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code> and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code>.
          e.g.
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">task_executor</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">(</span><span class="keyword">int</span><span class="special">)&gt;</span> <span class="identifier">task</span><span class="special">,</span><span class="keyword">int</span> <span class="identifier">param</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">task</span><span class="special">.</span><span class="identifier">make_ready_at_thread_exit</span><span class="special">(</span><span class="identifier">param</span><span class="special">);</span> <span class="comment">// execute stored task</span>
<span class="special">}</span> <span class="comment">// destroy thread specific and wake threads waiting on futures from task</span>
</pre>
<p>
          Other threads can wait on a future obtained from the task without having
          to worry about races due to the execution of destructors of the thread
          specific objects from the task's thread.
        </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">condition_variable</span> <span class="identifier">cv</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">m</span><span class="special">;</span>
<span class="identifier">complex_type</span> <span class="identifier">the_data</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">data_ready</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">thread_func</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">(</span><span class="identifier">m</span><span class="special">);</span>
    <span class="identifier">the_data</span><span class="special">=</span><span class="identifier">find_the_answer</span><span class="special">();</span>
    <span class="identifier">data_ready</span><span class="special">=</span><span class="keyword">true</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">notify_all_at_thread_exit</span><span class="special">(</span><span class="identifier">cv</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">lk</span><span class="special">));</span>
<span class="special">}</span> <span class="comment">// destroy thread specific objects, notify cv, unlock mutex</span>

<span class="keyword">void</span> <span class="identifier">waiting_thread</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">(</span><span class="identifier">m</span><span class="special">);</span>
    <span class="keyword">while</span><span class="special">(!</span><span class="identifier">data_ready</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">cv</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span><span class="identifier">lk</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">process</span><span class="special">(</span><span class="identifier">the_data</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          The waiting thread is guaranteed that the thread specific objects used
          by <code class="computeroutput"><span class="identifier">thread_func</span><span class="special">()</span></code>
          have been destroyed by the time <code class="computeroutput"><span class="identifier">process</span><span class="special">(</span><span class="identifier">the_data</span><span class="special">)</span></code> is called. If the lock on <code class="computeroutput"><span class="identifier">m</span></code> is released and re-acquired after setting
          <code class="computeroutput"><span class="identifier">data_ready</span></code> and before calling
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">notify_all_at_thread_exit</span><span class="special">()</span></code>
          then this does NOT hold, since the thread may return from the wait due
          to a spurious wake-up.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.futures.async"></a><a class="link" href="synchronization.html#thread.synchronization.futures.async" title="Executing asynchronously">Executing asynchronously</a>
</h4></div></div></div>
<p>
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">async</span></code> is a simple way of running asynchronous
          tasks to make use of the available hardware concurrency. A call to <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">async</span></code> returns a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future</span></code>
          that will contain the result of the task. Depending on the launch policy,
          the task is either run asynchronously on its own thread or synchronously
          on whichever thread calls the <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code> member functions on that <code class="computeroutput"><span class="identifier">future</span></code>.
        </p>
<p>
          A launch policy of either boost::launch::async, which asks the runtime
          to create an asynchronous thread, or boost::launch::deferred, which indicates
          you simply want to defer the function call until a later time (lazy evaluation).
          This argument is optional - if you omit it your function will use the default
          policy.
        </p>
<p>
          For example, consider computing the sum of a very large array. The first
          task is to not compute asynchronously when the overhead would be significant.
          The second task is to split the work into two pieces, one executed by the
          host thread and one executed asynchronously.
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">parallel_sum</span><span class="special">(</span><span class="keyword">int</span><span class="special">*</span> <span class="identifier">data</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">size</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">int</span> <span class="identifier">sum</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
  <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">size</span> <span class="special">&lt;</span> <span class="number">1000</span> <span class="special">)</span>
    <span class="keyword">for</span> <span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">size</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span> <span class="special">)</span>
      <span class="identifier">sum</span> <span class="special">+=</span> <span class="identifier">data</span><span class="special">[</span><span class="identifier">i</span><span class="special">];</span>
  <span class="keyword">else</span> <span class="special">{</span>
    <span class="keyword">auto</span> <span class="identifier">handle</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span><span class="identifier">parallel_sum</span><span class="special">,</span> <span class="identifier">data</span><span class="special">+</span><span class="identifier">size</span><span class="special">/</span><span class="number">2</span><span class="special">,</span> <span class="identifier">size</span><span class="special">-</span><span class="identifier">size</span><span class="special">/</span><span class="number">2</span><span class="special">);</span>
    <span class="identifier">sum</span> <span class="special">+=</span> <span class="identifier">parallel_sum</span><span class="special">(</span><span class="identifier">data</span><span class="special">,</span> <span class="identifier">size</span><span class="special">/</span><span class="number">2</span><span class="special">);</span>
    <span class="identifier">sum</span> <span class="special">+=</span> <span class="identifier">handle</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
  <span class="special">}</span>
  <span class="keyword">return</span> <span class="identifier">sum</span><span class="special">;</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.futures.shared"></a><a class="link" href="synchronization.html#thread.synchronization.futures.shared" title="Shared Futures">Shared Futures</a>
</h4></div></div></div>
<p>
          <code class="computeroutput"><span class="identifier">shared_future</span></code> is designed
          to be shared between threads, that is to allow multiple concurrent get
          operations.
        </p>
<h6>
<a name="thread.synchronization.futures.shared.h0"></a>
          <span class="phrase"><a name="thread.synchronization.futures.shared.multiple_get"></a></span><a class="link" href="synchronization.html#thread.synchronization.futures.shared.multiple_get">Multiple get</a>
        </h6>
<p>
          The second <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code>
          call in the following example is undefined.
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">bad_second_use</span><span class="special">(</span> <span class="identifier">type</span> <span class="identifier">arg</span> <span class="special">)</span> <span class="special">{</span>

  <span class="keyword">auto</span> <span class="identifier">ftr</span> <span class="special">=</span> <span class="identifier">async</span><span class="special">(</span> <span class="special">[=]{</span> <span class="keyword">return</span> <span class="identifier">work</span><span class="special">(</span> <span class="identifier">arg</span> <span class="special">);</span> <span class="special">}</span> <span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">cond1</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">use1</span><span class="special">(</span> <span class="identifier">ftr</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">}</span> <span class="keyword">else</span>
    <span class="special">{</span>
        <span class="identifier">use2</span><span class="special">(</span> <span class="identifier">ftr</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">use3</span><span class="special">(</span> <span class="identifier">ftr</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span> <span class="comment">// second use is undefined</span>
<span class="special">}</span>
</pre>
<p>
          Using a <code class="computeroutput"><span class="identifier">shared_mutex</span></code> solves
          the issue
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">good_second_use</span><span class="special">(</span> <span class="identifier">type</span> <span class="identifier">arg</span> <span class="special">)</span> <span class="special">{</span>

   <span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="identifier">ftr</span> <span class="special">=</span> <span class="identifier">async</span><span class="special">(</span> <span class="special">[=]{</span> <span class="keyword">return</span> <span class="identifier">work</span><span class="special">(</span> <span class="identifier">arg</span> <span class="special">);</span> <span class="special">}</span> <span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">cond1</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">use1</span><span class="special">(</span> <span class="identifier">ftr</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">}</span> <span class="keyword">else</span>
    <span class="special">{</span>
        <span class="identifier">use2</span><span class="special">(</span>  <span class="identifier">ftr</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">use3</span><span class="special">(</span> <span class="identifier">ftr</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span> <span class="comment">// second use is defined</span>
<span class="special">}</span>
</pre>
<h6>
<a name="thread.synchronization.futures.shared.h1"></a>
          <span class="phrase"><a name="thread.synchronization.futures.shared.share__"></a></span><a class="link" href="synchronization.html#thread.synchronization.futures.shared.share__">share()</a>
        </h6>
<p>
          Namming the return type when declaring the <code class="computeroutput"><span class="identifier">shared_future</span></code>
          is needed; auto is not available within template argument lists. Here
          <code class="computeroutput"><span class="identifier">share</span><span class="special">()</span></code>
          could be used to simplify the code
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">better_second_use</span><span class="special">(</span> <span class="identifier">type</span> <span class="identifier">arg</span> <span class="special">)</span> <span class="special">{</span>

   <span class="keyword">auto</span> <span class="identifier">ftr</span> <span class="special">=</span> <span class="identifier">async</span><span class="special">(</span> <span class="special">[=]{</span> <span class="keyword">return</span> <span class="identifier">work</span><span class="special">(</span> <span class="identifier">arg</span> <span class="special">);</span> <span class="special">}</span> <span class="special">).</span><span class="identifier">share</span><span class="special">();</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">cond1</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">use1</span><span class="special">(</span> <span class="identifier">ftr</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">}</span> <span class="keyword">else</span>
    <span class="special">{</span>
        <span class="identifier">use2</span><span class="special">(</span>  <span class="identifier">ftr</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">use3</span><span class="special">(</span> <span class="identifier">ftr</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span> <span class="comment">// second use is defined</span>
<span class="special">}</span>
</pre>
<h6>
<a name="thread.synchronization.futures.shared.h2"></a>
          <span class="phrase"><a name="thread.synchronization.futures.shared.writting_on_get__"></a></span><a class="link" href="synchronization.html#thread.synchronization.futures.shared.writting_on_get__">Writting
          on get()</a>
        </h6>
<p>
          The user can either read or write the future avariable.
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">write_to_get</span><span class="special">(</span> <span class="identifier">type</span> <span class="identifier">arg</span> <span class="special">)</span> <span class="special">{</span>

   <span class="keyword">auto</span> <span class="identifier">ftr</span> <span class="special">=</span> <span class="identifier">async</span><span class="special">(</span> <span class="special">[=]{</span> <span class="keyword">return</span> <span class="identifier">work</span><span class="special">(</span> <span class="identifier">arg</span> <span class="special">);</span> <span class="special">}</span> <span class="special">).</span><span class="identifier">share</span><span class="special">();</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">cond1</span> <span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">use1</span><span class="special">(</span> <span class="identifier">ftr</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">}</span> <span class="keyword">else</span>
    <span class="special">{</span>
      <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">cond2</span> <span class="special">)</span>
        <span class="identifier">use2</span><span class="special">(</span>  <span class="identifier">ftr</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span>
      <span class="keyword">else</span>
        <span class="identifier">ftr</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">=</span> <span class="identifier">something</span><span class="special">();</span> <span class="comment">// assign to non-const reference.  </span>
    <span class="special">}</span>
    <span class="identifier">use3</span><span class="special">(</span> <span class="identifier">ftr</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span> <span class="comment">// second use is defined</span>
<span class="special">}</span>
</pre>
<p>
          This works because the <code class="computeroutput"><span class="identifier">shared_future</span><span class="special">&lt;&gt;::</span><span class="identifier">get</span><span class="special">()</span></code> function returns a non-const reference
          to the appropriate storage. Of course the access to this storage must be
          ensured by the user. The library doesn't ensure the access to the internal
          storage is thread safe.
        </p>
<p>
          There has been some work by the C++ standard committe on an <code class="computeroutput"><span class="identifier">atomic_future</span></code> that behaves as an <code class="computeroutput"><span class="identifier">atomic</span></code> variable, that is is thread_safe,
          and a <code class="computeroutput"><span class="identifier">shared_future</span></code> that
          can be shared between several threads, but there were not enough consensus
          and time to get it ready for C++11.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.futures.make_ready_future"></a><a class="link" href="synchronization.html#thread.synchronization.futures.make_ready_future" title="Making immediate futures easier">Making
        immediate futures easier</a>
</h4></div></div></div>
<p>
          Some functions may know the value at the point of construction. In these
          cases the value is immediately available, but needs to be returned as a
          future or shared_future. By using make_ready_future a future can be created
          which holds a pre-computed result in its shared state.
        </p>
<p>
          Without these features it is non-trivial to create a future directly from
          a value. First a promise must be created, then the promise is set, and
          lastly the future is retrieved from the promise. This can now be done with
          one operation.
        </p>
<h6>
<a name="thread.synchronization.futures.make_ready_future.h0"></a>
          <span class="phrase"><a name="thread.synchronization.futures.make_ready_future.make_ready_future"></a></span><a class="link" href="synchronization.html#thread.synchronization.futures.make_ready_future.make_ready_future">make_ready_future</a>
        </h6>
<p>
          This function creates a future for a given value. If no value is given
          then a future&lt;void&gt; is returned. This function is primarily useful
          in cases where sometimes, the return value is immediately available, but
          sometimes it is not. The example below illustrates, that in an error path
          the value is known immediately, however in other paths the function must
          return an eventual value represented as a future.
        </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">compute</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">if</span> <span class="special">(</span><span class="identifier">x</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_ready_future</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
  <span class="keyword">if</span> <span class="special">(</span><span class="identifier">x</span> <span class="special">&lt;</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_ready_future</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">logic_error</span><span class="special">(</span><span class="string">"Error"</span><span class="special">));</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">f1</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">async</span><span class="special">([]()</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">x</span><span class="special">+</span><span class="number">1</span><span class="special">;</span> <span class="special">});</span>
  <span class="keyword">return</span> <span class="identifier">f1</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          There are two variations of this function. The first takes a value of any
          type, and returns a future of that type. The input value is passed to the
          shared state of the returned future. The second version takes no input
          and returns a future&lt;void&gt;.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.futures.then"></a><a class="link" href="synchronization.html#thread.synchronization.futures.then" title="Associating future continuations">Associating future
        continuations</a>
</h4></div></div></div>
<p>
          In asynchronous programming, it is very common for one asynchronous operation,
          on completion, to invoke a second operation and pass data to it. The current
          C++ standard does not allow one to register a continuation to a future.
          With <code class="computeroutput"><span class="special">.</span><span class="identifier">then</span></code>,
          instead of waiting for the result, a continuation is "attached"
          to the asynchronous operation, which is invoked when the result is ready.
          Continuations registered using the <code class="computeroutput"><span class="special">.</span><span class="identifier">then</span></code> function will help to avoid blocking
          waits or wasting threads on polling, greatly improving the responsiveness
          and scalability of an application.
        </p>
<p>
          <code class="computeroutput"><span class="identifier">future</span><span class="special">.</span><span class="identifier">then</span><span class="special">()</span></code>
          provides the ability to sequentially compose two futures by declaring one
          to be the continuation of another. With <code class="computeroutput"><span class="special">.</span><span class="identifier">then</span><span class="special">()</span></code>
          the antecedent future is ready (has a value or exception stored in the
          shared state) before the continuation starts as instructed by the lambda
          function.
        </p>
<p>
          In the example below the <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> <code class="computeroutput"><span class="identifier">f2</span></code>
          is registered to be a continuation of <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> <code class="computeroutput"><span class="identifier">f1</span></code>
          using the <code class="computeroutput"><span class="special">.</span><span class="identifier">then</span><span class="special">()</span></code> member function. This operation takes
          a lambda function which describes how <code class="computeroutput"><span class="identifier">f2</span></code>
          should proceed after <code class="computeroutput"><span class="identifier">f1</span></code>
          is ready.
        </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">future</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">f1</span> <span class="special">=</span> <span class="identifier">async</span><span class="special">([]()</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">123</span><span class="special">;</span> <span class="special">});</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">f2</span> <span class="special">=</span> <span class="identifier">f1</span><span class="special">.</span><span class="identifier">then</span><span class="special">([](</span><span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">f</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">f</span><span class="special">.</span><span class="identifier">get</span><span class="special">().</span><span class="identifier">to_string</span><span class="special">();</span> <span class="comment">// here .get() won't block });</span>
<span class="special">}</span>
</pre>
<p>
          One key feature of this function is the ability to chain multiple asynchronous
          operations. In asynchronous programming, it's common to define a sequence
          of operations, in which each continuation executes only when the previous
          one completes. In some cases, the antecedent future produces a value that
          the continuation accepts as input. By using <code class="computeroutput"><span class="identifier">future</span><span class="special">.</span><span class="identifier">then</span><span class="special">()</span></code>, creating a chain of continuations becomes
          straightforward and intuitive:
        </p>
<pre class="programlisting"><span class="identifier">myFuture</span><span class="special">.</span><span class="identifier">then</span><span class="special">(...).</span><span class="identifier">then</span><span class="special">(...).</span><span class="identifier">then</span><span class="special">(...).</span>
</pre>
<p>
          Some points to note are:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              Each continuation will not begin until the preceding has completed.
            </li>
<li class="listitem">
              If an exception is thrown, the following continuation can handle it
              in a try-catch block
            </li>
</ul></div>
<p>
          Input Parameters:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              Lambda function: One option which can be considered is to take two
              functions, one for success and one for error handling. However this
              option has not been retained for the moment. The lambda function takes
              a future as its input which carries the exception through. This makes
              propagating exceptions straightforward. This approach also simplifies
              the chaining of continuations.
            </li>
<li class="listitem">
              Scheduler: Providing an overload to <code class="computeroutput"><span class="special">.</span><span class="identifier">then</span></code>, to take a scheduler reference
              places great flexibility over the execution of the future in the programmer's
              hand. As described above, often taking a launch policy is not sufficient
              for powerful asynchronous operations. The lifetime of the scheduler
              must outlive the continuation.
            </li>
<li class="listitem">
              Launch policy: if the additional flexibility that the scheduler provides
              is not required.
            </li>
</ul></div>
<p>
          Return values: The decision to return a future was based primarily on the
          ability to chain multiple continuations using <code class="computeroutput"><span class="special">.</span><span class="identifier">then</span><span class="special">()</span></code>.
          This benefit of composability gives the programmer incredible control and
          flexibility over their code. Returning a <code class="computeroutput"><span class="identifier">future</span></code>
          object rather than a <code class="computeroutput"><span class="identifier">shared_future</span></code>
          is also a much cheaper operation thereby improving performance. A <code class="computeroutput"><span class="identifier">shared_future</span></code> object is not necessary
          to take advantage of the chaining feature. It is also easy to go from a
          <code class="computeroutput"><span class="identifier">future</span></code> to a <code class="computeroutput"><span class="identifier">shared_future</span></code> when needed using future::share().
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.futures.reference"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference" title="Futures Reference">Futures Reference</a>
</h4></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.future_state">Enumeration
          <code class="computeroutput"><span class="identifier">state</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.future_errc">Enumeration
          <code class="computeroutput"><span class="identifier">future_errc</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.launch">Enumeration
          <code class="computeroutput"><span class="identifier">launch</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.is_error_code_enum">Specialization
          <code class="computeroutput"><span class="identifier">is_error_code_enum</span><span class="special">&lt;</span><span class="identifier">future_errc</span><span class="special">&gt;</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.make_error_code">Non-member
          function <code class="computeroutput"><span class="identifier">make_error_code</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.make_error_condition">Non-member
          function <code class="computeroutput"><span class="identifier">make_error_condition</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.future_category">Non-member
          function <code class="computeroutput"><span class="identifier">future_category</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.future_error">Class
          <code class="computeroutput"><span class="identifier">future_error</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.future_status">Enumeration
          <code class="computeroutput"><span class="identifier">future_status</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.unique_future"><code class="computeroutput"><span class="identifier">future</span></code> class template</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.shared_future"><code class="computeroutput"><span class="identifier">shared_future</span></code> class template</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.promise"><code class="computeroutput"><span class="identifier">promise</span></code> class template</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.packaged_task"><code class="computeroutput"><span class="identifier">packaged_task</span></code> class template</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.decay_copy">Non-member
          function <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.async">Non-member
          function <code class="computeroutput"><span class="identifier">async</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.wait_for_any">Non-member
          function <code class="computeroutput"><span class="identifier">wait_for_any</span><span class="special">()</span></code>
          - EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.wait_for_all">Non-member
          function <code class="computeroutput"><span class="identifier">wait_for_all</span><span class="special">()</span></code>
          - EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.make_ready_future">Non-member
          function <code class="computeroutput"><span class="identifier">make_ready_future</span><span class="special">()</span></code> EXTENSION</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.make_future">Non-member
          function <code class="computeroutput"><span class="identifier">make_future</span><span class="special">()</span></code>
          DEPRECATED</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.futures.reference.make_shared_future">Non-member
          function <code class="computeroutput"><span class="identifier">make_shared_future</span><span class="special">()</span></code> DEPRECATED</a></span></dt>
</dl></div>
<pre class="programlisting"><span class="comment">//#include &lt;boost/thread/futures.hpp&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">future_state</span>  <span class="comment">// EXTENSION</span>
  <span class="special">{</span>
    <span class="keyword">enum</span> <span class="identifier">state</span> <span class="special">{</span><span class="identifier">uninitialized</span><span class="special">,</span> <span class="identifier">waiting</span><span class="special">,</span> <span class="identifier">ready</span><span class="special">,</span> <span class="identifier">moved</span><span class="special">};</span>
  <span class="special">}</span>

  <span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">future_errc</span>
  <span class="special">{</span>
    <span class="identifier">broken_promise</span><span class="special">,</span>
    <span class="identifier">future_already_retrieved</span><span class="special">,</span>
    <span class="identifier">promise_already_satisfied</span><span class="special">,</span>
    <span class="identifier">no_state</span>
  <span class="special">};</span>

  <span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">launch</span>
  <span class="special">{</span>
    <span class="identifier">async</span> <span class="special">=</span> <span class="identifier">unspecified</span><span class="special">,</span>
    <span class="identifier">deferred</span> <span class="special">=</span> <span class="identifier">unspecified</span><span class="special">,</span>
    <span class="identifier">any</span> <span class="special">=</span> <span class="identifier">async</span> <span class="special">|</span> <span class="identifier">deferred</span>
  <span class="special">};</span>

  <span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">future_status</span> <span class="special">{</span>
    <span class="identifier">ready</span><span class="special">,</span>  <span class="identifier">timeout</span><span class="special">,</span> <span class="identifier">deferred</span>
  <span class="special">};</span>

  <span class="keyword">namespace</span> <span class="identifier">system</span>
  <span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">is_error_code_enum</span><span class="special">&lt;</span><span class="identifier">future_errc</span><span class="special">&gt;</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">true_type</span> <span class="special">{};</span>

    <span class="identifier">error_code</span> <span class="identifier">make_error_code</span><span class="special">(</span><span class="identifier">future_errc</span> <span class="identifier">e</span><span class="special">);</span>

    <span class="identifier">error_condition</span> <span class="identifier">make_error_condition</span><span class="special">(</span><span class="identifier">future_errc</span> <span class="identifier">e</span><span class="special">);</span>
  <span class="special">}</span>

  <span class="keyword">const</span> <span class="identifier">system</span><span class="special">::</span><span class="identifier">error_category</span><span class="special">&amp;</span> <span class="identifier">future_category</span><span class="special">();</span>

  <span class="keyword">class</span> <span class="identifier">future_error</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">promise</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">promise</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span><span class="special">,</span> <span class="identifier">promise</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;&amp;</span> <span class="identifier">y</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

  <span class="keyword">namespace</span> <span class="identifier">container</span> <span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">R</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Alloc</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">uses_allocator</span><span class="special">&lt;</span><span class="identifier">promise</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;,</span> <span class="identifier">Alloc</span><span class="special">&gt;::</span> <span class="identifier">true_type</span><span class="special">;</span>
  <span class="special">}</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">future</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">shared_future</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">S</span><span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">packaged_task</span><span class="special">;</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">S</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">packaged_task</span><span class="special">&lt;</span><span class="identifier">S</span><span class="special">&gt;&amp;,</span> <span class="identifier">packaged_task</span><span class="special">&lt;</span><span class="identifier">S</span><span class="special">&gt;&amp;)</span> <span class="keyword">noexcept</span><span class="special">;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">S</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Alloc</span><span class="special">&gt;</span>
  <span class="keyword">struct</span> <span class="identifier">uses_allocator</span><span class="special">&lt;</span><span class="identifier">packaged_task</span> <span class="special">&lt;</span><span class="identifier">S</span><span class="special">&gt;,</span> <span class="identifier">Alloc</span><span class="special">&gt;;</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">&gt;</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">()&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
  <span class="identifier">async</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">&gt;</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">()&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
  <span class="identifier">async</span><span class="special">(</span><span class="identifier">launch</span> <span class="identifier">policy</span><span class="special">,</span> <span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span><span class="special">...</span> <span class="identifier">Args</span><span class="special">&gt;</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">(</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">...)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
  <span class="identifier">async</span><span class="special">(</span><span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">Args</span><span class="special">&amp;&amp;...</span> <span class="identifier">args</span><span class="special">);</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span><span class="special">...</span> <span class="identifier">Args</span><span class="special">&gt;</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">(</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">...)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
  <span class="identifier">async</span><span class="special">(</span><span class="identifier">launch</span> <span class="identifier">policy</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">Args</span><span class="special">&amp;&amp;...</span> <span class="identifier">args</span><span class="special">);</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">Iterator</span> <span class="identifier">end</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span><span class="special">...</span> <span class="identifier">FS</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">Fs</span><span class="special">&amp;...</span> <span class="identifier">fs</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
  <span class="identifier">Iterator</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">Iterator</span> <span class="identifier">end</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span><span class="special">...</span> <span class="identifier">Fs</span><span class="special">&gt;</span>
  <span class="keyword">unsigned</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">Fs</span><span class="special">&amp;...</span> <span class="identifier">fs</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="identifier">make_future</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;&amp;</span> <span class="identifier">value</span><span class="special">);</span>  <span class="comment">// DEPRECATED</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span> <span class="identifier">make_future</span><span class="special">();</span>  <span class="comment">// DEPRECATED</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="identifier">make_ready_future</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;&amp;</span> <span class="identifier">value</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span> <span class="identifier">make_ready_future</span><span class="special">();</span>  <span class="comment">// EXTENSION</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">make_ready_future</span><span class="special">(</span><span class="identifier">exception_ptr</span> <span class="identifier">ex</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">E</span><span class="special">&gt;</span>
  <span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">make_ready_future</span><span class="special">(</span><span class="identifier">E</span> <span class="identifier">ex</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
  <span class="identifier">shared_future</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="identifier">make_shared_future</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;&amp;</span> <span class="identifier">value</span><span class="special">);</span>  <span class="comment">// DEPRECATED</span>
  <span class="identifier">shared_future</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span> <span class="identifier">make_shared_future</span><span class="special">();</span>  <span class="comment">// DEPRECATED</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.future_state"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state">Enumeration
          <code class="computeroutput"><span class="identifier">state</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">future_state</span>
<span class="special">{</span>
  <span class="keyword">enum</span> <span class="identifier">state</span> <span class="special">{</span><span class="identifier">uninitialized</span><span class="special">,</span> <span class="identifier">waiting</span><span class="special">,</span> <span class="identifier">ready</span><span class="special">,</span> <span class="identifier">moved</span><span class="special">};</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.future_errc"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_errc" title="Enumeration future_errc">Enumeration
          <code class="computeroutput"><span class="identifier">future_errc</span></code></a>
</h5></div></div></div>
<pre class="programlisting"> <span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">future_errc</span>
 <span class="special">{</span>
   <span class="identifier">broken_promise</span> <span class="special">=</span> <span class="identifier">implementation</span> <span class="identifier">defined</span><span class="special">,</span>
   <span class="identifier">future_already_retrieved</span> <span class="special">=</span> <span class="identifier">implementation</span> <span class="identifier">defined</span><span class="special">,</span>
   <span class="identifier">promise_already_satisfied</span> <span class="special">=</span> <span class="identifier">implementation</span> <span class="identifier">defined</span><span class="special">,</span>
   <span class="identifier">no_state</span> <span class="special">=</span> <span class="identifier">implementation</span> <span class="identifier">defined</span>
 <span class="special">}</span>


<span class="identifier">The</span> <span class="keyword">enum</span> <span class="identifier">values</span> <span class="identifier">of</span> <span class="identifier">future_errc</span> <span class="identifier">are</span> <span class="identifier">distinct</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="identifier">zero</span><span class="special">.</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.launch"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.launch" title="Enumeration launch">Enumeration
          <code class="computeroutput"><span class="identifier">launch</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">launch</span>
<span class="special">{</span>
  <span class="identifier">async</span> <span class="special">=</span> <span class="identifier">unspecified</span><span class="special">,</span>
  <span class="identifier">deferred</span> <span class="special">=</span> <span class="identifier">unspecified</span><span class="special">,</span>
  <span class="identifier">any</span> <span class="special">=</span> <span class="identifier">async</span> <span class="special">|</span> <span class="identifier">deferred</span>
<span class="special">};</span>
</pre>
<p>
            The enum type launch is a bitmask type with launch::async and launch::deferred
            denoting individual bits.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.is_error_code_enum"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.is_error_code_enum" title="Specialization is_error_code_enum&lt;future_errc&gt;">Specialization
          <code class="computeroutput"><span class="identifier">is_error_code_enum</span><span class="special">&lt;</span><span class="identifier">future_errc</span><span class="special">&gt;</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">system</span>
<span class="special">{</span>
  <span class="keyword">template</span> <span class="special">&lt;&gt;</span>
  <span class="keyword">struct</span> <span class="identifier">is_error_code_enum</span><span class="special">&lt;</span><span class="identifier">future_errc</span><span class="special">&gt;</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">true_type</span> <span class="special">{};</span>

<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.make_error_code"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.make_error_code" title="Non-member function make_error_code()">Non-member
          function <code class="computeroutput"><span class="identifier">make_error_code</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">system</span>
<span class="special">{</span>
  <span class="identifier">error_code</span> <span class="identifier">make_error_code</span><span class="special">(</span><span class="identifier">future_errc</span> <span class="identifier">e</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">error_code</span><span class="special">(</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">e</span><span class="special">),</span>
                  <span class="identifier">future_category</span><span class="special">())</span></code>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.make_error_condition"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.make_error_condition" title="Non-member function make_error_condition()">Non-member
          function <code class="computeroutput"><span class="identifier">make_error_condition</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">system</span>
<span class="special">{</span>
  <span class="identifier">error_condition</span> <span class="identifier">make_error_condition</span><span class="special">(</span><span class="identifier">future_errc</span> <span class="identifier">e</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">error_condition</span><span class="special">(</span><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">e</span><span class="special">),</span> <span class="identifier">future_category</span><span class="special">())</span></code>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.future_category"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_category" title="Non-member function future_category()">Non-member
          function <code class="computeroutput"><span class="identifier">future_category</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">system</span><span class="special">::</span><span class="identifier">error_category</span><span class="special">&amp;</span> <span class="identifier">future_category</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  A reference to an object of a type derived from class error_category.
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  The object's <code class="computeroutput"><span class="identifier">default_error_condition</span></code>
                  and equivalent virtual functions behave as specified for the class
                  <code class="computeroutput"><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_category</span></code>. The object's
                  <code class="computeroutput"><span class="identifier">name</span></code> virtual function
                  returns a pointer to the string "future".
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.future_error"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_error" title="Class future_error">Class
          <code class="computeroutput"><span class="identifier">future_error</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">future_error</span>
    <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">logic_error</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">future_error</span><span class="special">(</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">);</span>

    <span class="keyword">const</span> <span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">&amp;</span> <span class="identifier">code</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">no_except</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.future_error.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_error.constructor" title="Constructor">Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">future_error</span><span class="special">(</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a future_error.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">code</span><span class="special">()==</span><span class="identifier">ec</span></code>
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.future_error.code"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_error.code" title="Member function code()">Member
            function <code class="computeroutput"><span class="identifier">code</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">&amp;</span> <span class="identifier">code</span><span class="special">()</span> <span class="keyword">const</span> <span class="identifier">no_except</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    The value of <code class="computeroutput"><span class="identifier">ec</span></code>
                    that was passed to the object's constructor.
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.future_status"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_status" title="Enumeration future_status">Enumeration
          <code class="computeroutput"><span class="identifier">future_status</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">future_status</span> <span class="special">{</span>
  <span class="identifier">ready</span><span class="special">,</span>  <span class="identifier">timeout</span><span class="special">,</span> <span class="identifier">deferred</span>
<span class="special">};</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.unique_future"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code> class template</a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
<span class="keyword">class</span>  <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a>
<span class="special">{</span>

<span class="keyword">public</span><span class="special">:</span>
  <span class="keyword">typedef</span> <span class="identifier">R</span> <span class="identifier">value_type</span><span class="special">;</span>  <span class="comment">// EXTENSION</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="special">~</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">();</span>

  <span class="comment">// move support</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;&gt;&amp;&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

  <span class="comment">// factories</span>
  <span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="identifier">share</span><span class="special">();</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
  <span class="identifier">then</span><span class="special">(</span><span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">S</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
  <span class="identifier">then</span><span class="special">(</span><span class="identifier">S</span><span class="special">&amp;</span> <span class="identifier">scheduler</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">);</span> <span class="comment">// EXTENSION NOT_YET_IMPLEMENTED</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
  <span class="identifier">then</span><span class="special">(</span><span class="identifier">launch</span> <span class="identifier">policy</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

  <span class="identifier">see</span> <span class="identifier">below</span> <span class="identifier">unwrap</span><span class="special">();</span>  <span class="comment">// EXTENSION</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="identifier">fallback_to</span><span class="special">();</span>  <span class="comment">// EXTENSION</span>

  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

  <span class="comment">// retrieving the value</span>
  <span class="identifier">see</span> <span class="identifier">below</span> <span class="identifier">get</span><span class="special">();</span>
  <span class="identifier">see</span> <span class="identifier">below</span> <span class="identifier">get_or</span><span class="special">(</span><span class="identifier">see</span> <span class="identifier">below</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>

  <span class="identifier">exception_ptr</span> <span class="identifier">get_exception_ptr</span><span class="special">();</span> <span class="comment">// EXTENSION</span>

  <span class="comment">// functions to check state</span>
  <span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="keyword">bool</span> <span class="identifier">is_ready</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">bool</span> <span class="identifier">has_exception</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">bool</span> <span class="identifier">has_value</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span> <span class="comment">// EXTENSION</span>

  <span class="comment">// waiting for the result to be ready</span>
  <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
  <span class="identifier">future_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
  <span class="identifier">future_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_USES_DATE_TIME</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">Duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span> <span class="comment">// DEPRECATED SINCE V3.0.0</span>
  <span class="keyword">bool</span> <span class="identifier">timed_wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span> <span class="comment">// DEPRECATED SINCE V3.0.0</span>
<span class="preprocessor">#endif</span>
  <span class="keyword">typedef</span> <span class="identifier">future_state</span><span class="special">::</span><span class="identifier">state</span> <span class="identifier">state</span><span class="special">;</span>  <span class="comment">// EXTENSION</span>
  <span class="identifier">state</span> <span class="identifier">get_state</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>  <span class="comment">// EXTENSION</span>
<span class="special">};</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.default_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.default_constructor" title="Default Constructor">Default
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs an uninitialized <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a>.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span></code></a> returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">uninitialized</span></code></a>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.destructor" title="Destructor">Destructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="special">~</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Destroys <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.move_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.move_constructor" title="Move Constructor">Move
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a>, and transfers
                    ownership of the shared state associated with <code class="computeroutput"><span class="identifier">other</span></code>
                    to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns the value of <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code> prior to the call. <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">uninitialized</span></code></a>. If <code class="computeroutput"><span class="identifier">other</span></code> was associated with a
                    shared state, that result is now associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    <code class="computeroutput"><span class="identifier">other</span></code> is not
                    associated with any shared state.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    If the compiler does not support rvalue-references, this is implemented
                    using the boost.thread move emulation.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.unwrap_move_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.unwrap_move_constructor" title="Unwrap Move Constructor - EXTENSION">Unwrap
            Move Constructor - EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;&gt;&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>
</pre>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
                This constructor is experimental and subject to change in future
                versions. There are not too much tests yet, so it is possible that
                you can find out some trivial bugs :(
              </p></td></tr>
</table></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd>
<p>
                    <code class="computeroutput"><span class="identifier">other</span><span class="special">.</span><span class="identifier">valid</span><span class="special">()</span></code>.
                  </p>
<p>
                    [Effects:
                  </p>
<p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a>, and transfers
                    ownership of the shared state associated with <code class="computeroutput"><span class="identifier">other</span></code>
                    and unwrapping the inner future (see <code class="computeroutput"><span class="identifier">unwrap</span><span class="special">()</span></code>).
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns the value of <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code> prior to the call. <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">uninitialized</span></code></a>. The associated
                    shared state is now unwrapped and the inner future shared state
                    is associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>. <code class="computeroutput"><span class="identifier">other</span></code>
                    is not associated with any shared state, <code class="computeroutput"><span class="special">!</span>
                    <span class="identifier">other</span><span class="special">.</span><span class="identifier">valid</span><span class="special">()</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    If the compiler does not support rvalue-references, this is implemented
                    using the boost.thread move emulation.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.move_assignment"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.move_assignment" title="Move Assignment Operator">Move
            Assignment Operator</a>
</h6></div></div></div>
<pre class="programlisting"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Transfers ownership of the shared state associated with <code class="computeroutput"><span class="identifier">other</span></code> to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns the value of <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code> prior to the call. <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">uninitialized</span></code></a>. If <code class="computeroutput"><span class="identifier">other</span></code> was associated with a
                    shared state, that result is now associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    <code class="computeroutput"><span class="identifier">other</span></code> is not
                    associated with any shared state. If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> was associated with an asynchronous
                    result prior to the call, that result no longer has an associated
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> instance.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    If the compiler does not support rvalue-references, this is implemented
                    using the boost.thread move emulation.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.swap"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.swap" title="Member function swap()">Member
            function <code class="computeroutput"><span class="identifier">swap</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> <span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="identifier">no_except</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Swaps ownership of the shared states associated with <code class="computeroutput"><span class="identifier">other</span></code> and <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns the value of <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code> prior to the call. <code class="computeroutput"><span class="identifier">other</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code>
                    returns the value of <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code> prior to the call. If <code class="computeroutput"><span class="identifier">other</span></code> was associated with a
                    shared state, that result is now associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    otherwise <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    has no associated result. If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> was associated with a shared
                    state, that result is now associated with <code class="computeroutput"><span class="identifier">other</span></code>,
                    otherwise <code class="computeroutput"><span class="identifier">other</span></code>
                    has no associated result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.get"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get" title="Member function get()">Member
            function <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">R</span> <span class="identifier">get</span><span class="special">();</span>
<span class="identifier">R</span><span class="special">&amp;</span>  <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&amp;&gt;::</span><span class="identifier">get</span><span class="special">();</span>
<span class="keyword">void</span>  <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;::</span><span class="identifier">get</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready as-if by a call to <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.wait" title="Member function wait()"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">wait</span><span class="special">()</span></code></a>,
                    and retrieves the result (whether that is a value or an exception).
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&amp;&gt;::</span><span class="identifier">get</span><span class="special">()</span></code>
                    return the stored reference.
                  </p>
<p>
                    - <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;::</span><span class="identifier">get</span><span class="special">()</span></code>,
                    there is no return value.
                  </p>
<p>
                    - <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">get</span><span class="special">()</span></code>
                    returns an rvalue-reference to the value stored in the shared
                    state.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted.
                  </p>
<p>
                    - Any exception stored in the shared state in place of a value.
                  </p>
</dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.get_or"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_or" title="Member function get_or() - EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">get_or</span><span class="special">()</span></code>
            - EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">R</span> <span class="identifier">get_or</span><span class="special">(</span><span class="identifier">R</span><span class="special">&amp;&amp;</span> <span class="identifier">v</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
<span class="identifier">R</span> <span class="identifier">get_or</span><span class="special">(</span><span class="identifier">R</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">v</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>
<span class="identifier">R</span><span class="special">&amp;</span>  <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&amp;&gt;::</span><span class="identifier">get_or</span><span class="special">(</span><span class="identifier">R</span><span class="special">&amp;</span> <span class="identifier">v</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>
<span class="keyword">void</span>  <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;::</span><span class="identifier">get_or</span><span class="special">();</span>  <span class="comment">// EXTENSION</span>
</pre>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
                These functions are experimental and subject to change in future
                versions. There are not too much tests yet, so it is possible that
                you can find out some trivial bugs :(
              </p></td></tr>
</table></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready as-if by a call to <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.wait" title="Member function wait()"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">wait</span><span class="special">()</span></code></a>,
                    and depending on whether the shared state <code class="computeroutput"><span class="identifier">has_value</span><span class="special">()</span></code> the retrieves the result.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&amp;&gt;::</span><span class="identifier">get_or</span><span class="special">(</span><span class="identifier">v</span><span class="special">)</span></code>
                    return the stored reference if has_value() and the passes parameter
                    otherwise.
                  </p>
<p>
                    - <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;::</span><span class="identifier">get_or</span><span class="special">()</span></code>,
                    there is no return value, but the function doesn't throws even
                    if the shared state contained an exception.
                  </p>
<p>
                    - <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">get_or</span><span class="special">(</span><span class="identifier">v</span><span class="special">)</span></code>
                    returns an rvalue-reference to the value stored in the shared
                    state if <code class="computeroutput"><span class="identifier">has_value</span><span class="special">()</span></code> and an rvalue-reference build
                    with the parameter <code class="computeroutput"><span class="identifier">v</span></code>.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">get_or</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.wait"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.wait" title="Member function wait()">Member
            function <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready. If the result is not ready on entry, and the result has
                    a <span class="emphasis"><em>wait callback</em></span> set, that callback is invoked
                    prior to waiting.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted.
                  </p>
<p>
                    - Any exception thrown by the <span class="emphasis"><em>wait callback</em></span>
                    if such a callback is called.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.timed_wait_duration"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.timed_wait_duration" title="Member function timed_wait() DEPRECATED SINCE V3.0.0">Member
            function <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
            DEPRECATED SINCE V3.0.0</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">Duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">wait_duration</span><span class="special">);</span>
</pre>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top">
<p>
                DEPRECATED since 3.00.
              </p>
<p>
                Available only up to Boost 1.56.
              </p>
<p>
                Use instead <a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_for" title="template &lt;class Rep, class Period&gt; cv_status wait_for(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time)"><code class="computeroutput"><span class="identifier">wait_for</span></code></a>.
              </p>
</td></tr>
</table></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready, or the time specified by <code class="computeroutput"><span class="identifier">wait_duration</span></code>
                    has elapsed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, and that result is ready before
                    the specified time has elapsed, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted.
                  </p>
<p>
                    - Any exception thrown by the <span class="emphasis"><em>wait callback</em></span>
                    if such a callback is called.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>. <code class="computeroutput"><span class="identifier">Duration</span></code> must be a type that
                    meets the Boost.DateTime time duration requirements.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.timed_wait_absolute"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.timed_wait_absolute" title="Member function timed_wait() DEPRECATED SINCE V3.0.0">Member
            function <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
            DEPRECATED SINCE V3.0.0</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">wait_timeout</span><span class="special">);</span>
</pre>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top">
<p>
                DEPRECATED since 3.00.
              </p>
<p>
                Available only up to Boost 1.56.
              </p>
<p>
                Use instead <a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_until" title="template &lt;class Clock, class Duration&gt; cv_status wait_until(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)"><code class="computeroutput"><span class="identifier">wait_until</span></code></a>.
              </p>
</td></tr>
</table></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready, or the time point specified by <code class="computeroutput"><span class="identifier">wait_timeout</span></code>
                    has passed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, and that result is ready before
                    the specified time has passed, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted.
                  </p>
<p>
                    - Any exception thrown by the <span class="emphasis"><em>wait callback</em></span>
                    if such a callback is called.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.wait_for"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.wait_for" title="Member function wait_for()">Member
            function <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
<span class="identifier">future_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready, or the time specified by <code class="computeroutput"><span class="identifier">wait_duration</span></code>
                    has elapsed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">deferred</span></code>
                    if the shared state contains a deferred function. (Not implemented
                    yet)
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">ready</span></code>
                    if the shared state is ready.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">timeout</span></code>
                    if the function is returning because the relative timeout specified
                    by <code class="computeroutput"><span class="identifier">rel_time</span></code> has
                    expired.
                  </p>
</dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted.
                  </p>
<p>
                    - Any exception thrown by the <span class="emphasis"><em>wait callback</em></span>
                    if such a callback is called.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>. <code class="computeroutput"><span class="identifier">Duration</span></code> must be a type that
                    meets the Boost.DateTime time duration requirements.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.wait_until"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.wait_until" title="Member function wait_until()">Member
            function <code class="computeroutput"><span class="identifier">wait_until</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="identifier">future_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready, or the time point specified by <code class="computeroutput"><span class="identifier">wait_timeout</span></code>
                    has passed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">deferred</span></code>
                    if the shared state contains a deferred function. (Not implemented
                    yet)
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">ready</span></code>
                    if the shared state is ready.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">timeout</span></code>
                    if the function is returning because the absolute timeout specified
                    by <code class="computeroutput"><span class="identifier">absl_time</span></code>
                    has reached.
                  </p>
</dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted.
                  </p>
<p>
                    - Any exception thrown by the <span class="emphasis"><em>wait callback</em></span>
                    if such a callback is called.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">wait_until</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.valid"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.valid" title="Member function valid()">Member
            function <code class="computeroutput"><span class="identifier">valid</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.is_ready"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.is_ready" title="Member function is_ready() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">is_ready</span><span class="special">()</span></code>
            EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">is_ready</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state and that result is ready for
                    retrieval, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.has_value"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.has_value" title="Member function has_value() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">has_value</span><span class="special">()</span></code>
            EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">has_value</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, that result is ready for retrieval,
                    and the result is a stored value, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.has_exception"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.has_exception" title="Member function has_exception() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">has_exception</span><span class="special">()</span></code> EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">has_exception</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, that result is ready for retrieval,
                    and the result is a stored exception, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.get_exception_ptr"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_exception_ptr" title="Member function get_exception_ptr() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">get_exception_ptr</span><span class="special">()</span></code> EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">exception_ptr</span> <span class="identifier">get_exception_ptr</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready. If the result is not ready on entry, and the result has
                    a <span class="emphasis"><em>wait callback</em></span> set, that callback is invoked
                    prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    a exception_ptr, storring or not an exception.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Whatever <code class="computeroutput"><span class="identifier">mutex</span><span class="special">::</span><span class="identifier">lock</span><span class="special">()/</span><span class="identifier">mutex</span><span class="special">::</span><span class="identifier">unlock</span><span class="special">()</span></code> can throw.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.get_state"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.get_state" title="Member function get_state() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">get_state</span><span class="special">()</span></code>
            EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">state</span> <span class="identifier">get_state</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Determine the state of the shared state associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    if any.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">uninitialized</span></code></a> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a> if the shared
                    state associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is ready for retrieval,
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">waiting</span></code></a> otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.share"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.share" title="Member function share()">Member
            function <code class="computeroutput"><span class="identifier">share</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="identifier">share</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(*</span><span class="keyword">this</span><span class="special">))</span></code>.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">valid</span><span class="special">()</span>
                    <span class="special">==</span> <span class="keyword">false</span></code>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.then"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.then" title="Member function then() - EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">then</span><span class="special">()</span></code>
            - EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="identifier">then</span><span class="special">(</span><span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">S</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="identifier">then</span><span class="special">(</span><span class="identifier">S</span><span class="special">&amp;</span> <span class="identifier">scheduler</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">);</span> <span class="comment">// EXTENSION NOT_YET_IMPLEMENTED</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&amp;)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="identifier">then</span><span class="special">(</span><span class="identifier">launch</span> <span class="identifier">policy</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
</pre>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
                These functions are experimental and subject to change in future
                versions. There are not too much tests yet, so it is possible that
                you can find out some trivial bugs :(
              </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
                These functions are based on the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3634.pdf" target="_top"><span class="bold"><strong>N3634 - Improvements to std::future&lt;T&gt; and related
                APIs</strong></span></a> C++1y proposal by N. Gustafsson, A. Laksberg,
                H. Sutter, S. Mithani.
              </p></td></tr>
</table></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    The three functions differ only by input parameters. The first
                    only takes a callable object which accepts a future object as
                    a parameter. The second function takes a scheduler as the first
                    parameter and a callable object as the second parameter. The
                    third function takes a launch policy as the first parameter and
                    a callable object as the second parameter.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                    - The continuation is called when the object's shared state is
                    ready (has a value or exception stored).
                  </p>
<p>
                    - The continuation launches according to the specified policy
                    or scheduler.
                  </p>
<p>
                    - When the scheduler or launch policy is not provided the continuation
                    inherits the parent's launch policy or scheduler.
                  </p>
<p>
                    - If the parent was created with <code class="computeroutput"><span class="identifier">promise</span><span class="special">&lt;&lt;</span></code> or with a <code class="computeroutput"><span class="identifier">packaged_task</span><span class="special">&lt;&gt;</span></code>
                    (has no associated launch policy), the continuation behaves the
                    same as the third overload with a policy argument of <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span> <span class="special">|</span>
                    <span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code> and the same argument
                    for func.
                  </p>
<p>
                    - If the parent has a policy of <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code>
                    and the continuation does not have a specified launch policy
                    or scheduler, then the parent is filled by immediately calling
                    <code class="computeroutput"><span class="special">.</span><span class="identifier">wait</span><span class="special">()</span></code>, and the policy of the antecedent
                    is <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code>.
                  </p>
</dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    An object of type <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">)&gt;</span></code>
                    that refers to the shared state created by the continuation.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd>
<p>
                    - The <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a></code> object
                    passed to the parameter of the continuation function is a copy
                    of the original <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a></code>.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">valid</span><span class="special">()</span>
                    <span class="special">==</span> <span class="keyword">false</span></code>
                    on original future object immediately after it returns.
                  </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.unique_future.unwrap"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.unwrap" title="Member function unwrap() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">unwrap</span><span class="special">()</span></code>
            EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R2</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R2</span><span class="special">&gt;</span>  <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R2</span><span class="special">&gt;&gt;::</span><span class="identifier">unwrap</span><span class="special">();</span>  <span class="comment">// EXTENSION</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R2</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a><span class="special">&lt;</span><span class="identifier">R2</span><span class="special">&gt;</span>  <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a><span class="special">&lt;</span><span class="identifier">R2</span><span class="special">&gt;&gt;::</span><span class="identifier">unwrap</span><span class="special">();</span>  <span class="comment">// EXTENSION</span>
</pre>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
                These functions are experimental and subject to change in future
                versions. There are not too much tests yet, so it is possible that
                you can find out some trivial bugs :(
              </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
                These functions are based on the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3634.pdf" target="_top"><span class="bold"><strong>N3634 - Improvements to std::future&lt;T&gt; and related
                APIs</strong></span></a> C++1y proposal by N. Gustafsson, A. Laksberg,
                H. Sutter, S. Mithani.
              </p></td></tr>
</table></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    Removes the outermost future and returns a future with the associated
                    state been a proxy of inner future.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    - Returns a future that becomes ready when the shared state of
                    the inner future is ready.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    An object of type future with the associated state been a proxy
                    of inner future.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    - The returned future has <code class="computeroutput"><span class="identifier">valid</span><span class="special">()</span> <span class="special">==</span>
                    <span class="keyword">true</span></code> regardless of the
                    validity of the inner future.
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.shared_future"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">shared_future</span></code> class template</a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">shared_future</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
  <span class="keyword">typedef</span> <span class="identifier">future_state</span><span class="special">::</span><span class="identifier">state</span> <span class="identifier">state</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">typedef</span> <span class="identifier">R</span> <span class="identifier">value_type</span><span class="special">;</span>  <span class="comment">// EXTENSION</span>

  <span class="identifier">shared_future</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="special">~</span><span class="identifier">shared_future</span><span class="special">();</span>

  <span class="comment">// copy support</span>
  <span class="identifier">shared_future</span><span class="special">(</span><span class="identifier">shared_future</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>
  <span class="identifier">shared_future</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">shared_future</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>

  <span class="comment">// move support</span>
  <span class="identifier">shared_future</span><span class="special">(</span><span class="identifier">shared_future</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="identifier">shared_future</span><span class="special">(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="identifier">shared_future</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">shared_future</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="identifier">shared_future</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

  <span class="comment">// factories</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">shared_future</span><span class="special">&amp;)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
  <span class="identifier">then</span><span class="special">(</span><span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">S</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">shared_future</span><span class="special">&amp;)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
  <span class="identifier">then</span><span class="special">(</span><span class="identifier">S</span><span class="special">&amp;</span> <span class="identifier">scheduler</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">);</span> <span class="comment">// EXTENSION NOT_YET_IMPLEMENTED</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">shared_future</span><span class="special">&amp;)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
  <span class="identifier">then</span><span class="special">(</span><span class="identifier">launch</span> <span class="identifier">policy</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">shared_future</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>

  <span class="comment">// retrieving the value</span>
  <span class="identifier">see</span> <span class="identifier">below</span> <span class="identifier">get</span><span class="special">();</span>

  <span class="identifier">exception_ptr</span> <span class="identifier">get_exception_ptr</span><span class="special">();</span> <span class="comment">// EXTENSION</span>

  <span class="comment">// functions to check state, and wait for ready</span>
  <span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="keyword">bool</span> <span class="identifier">is_ready</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">bool</span> <span class="identifier">has_exception</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span> <span class="comment">// EXTENSION</span>
  <span class="keyword">bool</span> <span class="identifier">has_value</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span> <span class="comment">// EXTENSION</span>

  <span class="comment">// waiting for the result to be ready</span>
  <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
  <span class="identifier">future_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
  <span class="identifier">future_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

<span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_USES_DATE_TIME</span> <span class="special">||</span> <span class="identifier">defined</span> <span class="identifier">BOOST_THREAD_DONT_USE_CHRONO</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
  <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">Duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>  <span class="comment">// DEPRECATED SINCE V3.0.0</span>
  <span class="keyword">bool</span> <span class="identifier">timed_wait_until</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>  <span class="comment">// DEPRECATED SINCE V3.0.0</span>
<span class="preprocessor">#endif</span>
  <span class="identifier">state</span> <span class="identifier">get_state</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>  <span class="comment">// EXTENSION</span>

<span class="special">};</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.default_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.default_constructor" title="Default Constructor">Default
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">shared_future</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs an uninitialized shared_future.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span></code></a> returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">uninitialized</span></code></a>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.get"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get" title="Member function get()">Member
            function <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">const</span> <span class="identifier">R</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">();</span>
<span class="identifier">R</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">();</span>
<span class="keyword">void</span> <span class="identifier">get</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready as-if by a call to <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.wait" title="Member function wait()"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">wait</span><span class="special">()</span></code></a>,
                    and returns a <code class="computeroutput"><span class="keyword">const</span></code>
                    reference to the result.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&amp;&gt;::</span><span class="identifier">get</span><span class="special">()</span></code> return the stored reference.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;::</span><span class="identifier">get</span><span class="special">()</span></code>, there is no return value.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">get</span><span class="special">()</span></code> returns a <code class="computeroutput"><span class="keyword">const</span></code>
                    reference to the value stored in the shared state.
                  </p>
</dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted.
                  </p>
</dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.wait"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.wait" title="Member function wait()">Member
            function <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready. If the result is not ready on entry, and the result has
                    a <span class="emphasis"><em>wait callback</em></span> set, that callback is invoked
                    prior to waiting.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted.
                  </p>
<p>
                    - Any exception thrown by the <span class="emphasis"><em>wait callback</em></span>
                    if such a callback is called.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.timed_wait_duration"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.timed_wait_duration" title="Member function timed_wait()">Member
            function <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">Duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">wait_duration</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready, or the time specified by <code class="computeroutput"><span class="identifier">wait_duration</span></code>
                    has elapsed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, and that result is ready before
                    the specified time has elapsed, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted.
                  </p>
<p>
                    - Any exception thrown by the <span class="emphasis"><em>wait callback</em></span>
                    if such a callback is called.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>. <code class="computeroutput"><span class="identifier">Duration</span></code> must be a type that
                    meets the Boost.DateTime time duration requirements.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.timed_wait_absolute"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.timed_wait_absolute" title="Member function timed_wait()">Member
            function <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">wait_timeout</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready, or the time point specified by <code class="computeroutput"><span class="identifier">wait_timeout</span></code>
                    has passed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, and that result is ready before
                    the specified time has passed, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted.
                  </p>
<p>
                    - Any exception thrown by the <span class="emphasis"><em>wait callback</em></span>
                    if such a callback is called.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.wait_for"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.wait_for" title="Member function wait_for()">Member
            function <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span><span class="special">&gt;</span>
<span class="identifier">future_status</span> <span class="identifier">wait_for</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready, or the time specified by <code class="computeroutput"><span class="identifier">wait_duration</span></code>
                    has elapsed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">deferred</span></code>
                    if the shared state contains a deferred function. (Not implemented
                    yet)
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">ready</span></code>
                    if the shared state is ready.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">timeout</span></code>
                    if the function is returning because the relative timeout specified
                    by <code class="computeroutput"><span class="identifier">rel_time</span></code> has
                    expired.
                  </p>
</dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted.
                  </p>
<p>
                    - Any exception thrown by the <span class="emphasis"><em>wait callback</em></span>
                    if such a callback is called.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>. <code class="computeroutput"><span class="identifier">Duration</span></code> must be a type that
                    meets the Boost.DateTime time duration requirements.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.wait_until"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.wait_until" title="Member function wait_until()">Member
            function <code class="computeroutput"><span class="identifier">wait_until</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="identifier">future_status</span> <span class="identifier">wait_until</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready, or the time point specified by <code class="computeroutput"><span class="identifier">wait_timeout</span></code>
                    has passed. If the result is not ready on entry, and the result
                    has a <span class="emphasis"><em>wait callback</em></span> set, that callback is
                    invoked prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">deferred</span></code>
                    if the shared state contains a deferred function. (Not implemented
                    yet)
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">ready</span></code>
                    if the shared state is ready.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">future_status</span><span class="special">::</span><span class="identifier">timeout</span></code>
                    if the function is returning because the absolute timeout specified
                    by <code class="computeroutput"><span class="identifier">absl_time</span></code>
                    has reached.
                  </p>
</dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_uninitialized</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the result
                    associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is not ready at the point
                    of the call, and the current thread is interrupted.
                  </p>
<p>
                    - Any exception thrown by the <span class="emphasis"><em>wait callback</em></span>
                    if such a callback is called.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    If this call returned <code class="computeroutput"><span class="keyword">true</span></code>,
                    then <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">is_ready</span><span class="special">()</span></code></a>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> and
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state() EXTENSION"><code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get_state</span><span class="special">()</span></code></a>
                    returns <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">timed_wait</span><span class="special">()</span></code>
                    is an <span class="emphasis"><em>interruption point</em></span>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.valid"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.valid" title="Member function valid()">Member
            function <code class="computeroutput"><span class="identifier">valid</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.is_ready"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.is_ready" title="Member function is_ready() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">is_ready</span><span class="special">()</span></code>
            EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">is_ready</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, and that result is ready for
                    retrieval, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Whatever <code class="computeroutput"><span class="identifier">mutex</span><span class="special">::</span><span class="identifier">lock</span><span class="special">()/</span><span class="identifier">mutex</span><span class="special">::</span><span class="identifier">unlock</span><span class="special">()</span></code> can throw.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.has_value"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.has_value" title="Member function has_value() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">has_value</span><span class="special">()</span></code>
            EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">has_value</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, that result is ready for retrieval,
                    and the result is a stored value, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Whatever <code class="computeroutput"><span class="identifier">mutex</span><span class="special">::</span><span class="identifier">lock</span><span class="special">()/</span><span class="identifier">mutex</span><span class="special">::</span><span class="identifier">unlock</span><span class="special">()</span></code> can throw.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.has_exception"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.has_exception" title="Member function has_exception() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">has_exception</span><span class="special">()</span></code> EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">has_exception</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, that result is ready for retrieval,
                    and the result is a stored exception, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Whatever <code class="computeroutput"><span class="identifier">mutex</span><span class="special">::</span><span class="identifier">lock</span><span class="special">()/</span><span class="identifier">mutex</span><span class="special">::</span><span class="identifier">unlock</span><span class="special">()</span></code> can throw.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.get_exception_ptr"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_exception_ptr" title="Member function get_exception_ptr() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">get_exception_ptr</span><span class="special">()</span></code> EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">exception_ptr</span> <span class="identifier">get_exception_ptr</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is associated with a shared state, waits until the result is
                    ready. If the result is not ready on entry, and the result has
                    a <span class="emphasis"><em>wait callback</em></span> set, that callback is invoked
                    prior to waiting.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    a exception_ptr, storring or not an exception.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Whatever <code class="computeroutput"><span class="identifier">mutex</span><span class="special">::</span><span class="identifier">lock</span><span class="special">()/</span><span class="identifier">mutex</span><span class="special">::</span><span class="identifier">unlock</span><span class="special">()</span></code> can throw.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.get_state"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.get_state" title="Member function get_state() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">get_state</span><span class="special">()</span></code>
            EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">state</span> <span class="identifier">get_state</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Determine the state of the shared state associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    if any.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">uninitialized</span></code></a> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is not associated with a shared state. <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">ready</span></code></a> if the shared
                    state associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is ready for retrieval,
                    <a class="link" href="synchronization.html#thread.synchronization.futures.reference.future_state" title="Enumeration state"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_state</span><span class="special">::</span><span class="identifier">waiting</span></code></a> otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Whatever <code class="computeroutput"><span class="identifier">mutex</span><span class="special">::</span><span class="identifier">lock</span><span class="special">()/</span><span class="identifier">mutex</span><span class="special">::</span><span class="identifier">unlock</span><span class="special">()</span></code> can throw.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.shared_future.then"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.then" title="Member function then() EXTENSION">Member
            function <code class="computeroutput"><span class="identifier">then</span><span class="special">()</span></code>
            EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">shared_future</span><span class="special">&amp;)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="identifier">then</span><span class="special">(</span><span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">S</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">shared_future</span><span class="special">&amp;)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="identifier">then</span><span class="special">(</span><span class="identifier">S</span><span class="special">&amp;</span> <span class="identifier">scheduler</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">);</span> <span class="comment">// EXTENSION NOT_YET_IMPLEMENTED</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">shared_future</span><span class="special">&amp;)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="identifier">then</span><span class="special">(</span><span class="identifier">launch</span> <span class="identifier">policy</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
</pre>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
                These functions are experimental and subject to change in future
                versions. There are not too much tests yet, so it is possible that
                you can find out some trivial bugs :(
              </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
                These functions are based on the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3634.pdf" target="_top"><span class="bold"><strong>N3634 - Improvements to std::future&lt;T&gt; and related
                APIs</strong></span></a> C++1y proposal by N. Gustafsson, A. Laksberg,
                H. Sutter, S. Mithani.
              </p></td></tr>
</table></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    The three functions differ only by input parameters. The first
                    only takes a callable object which accepts a shared_future object
                    as a parameter. The second function takes a scheduler as the
                    first parameter and a callable object as the second parameter.
                    The third function takes a launch policy as the first parameter
                    and a callable object as the second parameter.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                    - The continuation is called when the object's shared state is
                    ready (has a value or exception stored).
                  </p>
<p>
                    - The continuation launches according to the specified policy
                    or scheduler.
                  </p>
<p>
                    - When the scheduler or launch policy is not provided the continuation
                    inherits the parent's launch policy or scheduler.
                  </p>
<p>
                    - If the parent was created with <code class="computeroutput"><span class="identifier">promise</span></code>
                    or with a <code class="computeroutput"><span class="identifier">packaged_task</span></code>
                    (has no associated launch policy), the continuation behaves the
                    same as the third overload with a policy argument of <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span> <span class="special">|</span>
                    <span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code> and the same argument
                    for func.
                  </p>
<p>
                    - If the parent has a policy of <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code>
                    and the continuation does not have a specified launch policy
                    or scheduler, then the parent is filled by immediately calling
                    <code class="computeroutput"><span class="special">.</span><span class="identifier">wait</span><span class="special">()</span></code>, and the policy of the antecedent
                    is <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code>
                  </p>
</dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    An object of type <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">shared_future</span><span class="special">)&gt;</span></code> that refers to the shared
                    state created by the continuation.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd>
<p>
                    - The future object is moved to the parameter of the continuation
                    function .
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">valid</span><span class="special">()</span>
                    <span class="special">==</span> <span class="keyword">false</span></code>
                    on original future object immediately after it returns.
                  </p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.promise"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">promise</span></code> class template</a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">promise</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
  <span class="keyword">typedef</span> <span class="identifier">R</span> <span class="identifier">value_type</span><span class="special">;</span>  <span class="comment">// EXTENSION</span>

  <span class="identifier">promise</span><span class="special">();</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
  <span class="identifier">promise</span><span class="special">(</span><span class="identifier">allocator_arg_t</span><span class="special">,</span> <span class="identifier">Allocator</span> <span class="identifier">a</span><span class="special">);</span>
  <span class="identifier">promise</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">promise</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
  <span class="identifier">promise</span><span class="special">(</span><span class="identifier">promise</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
  <span class="special">~</span><span class="identifier">promise</span><span class="special">();</span>

  <span class="comment">// Move support</span>
  <span class="identifier">promise</span><span class="special">(</span><span class="identifier">promise</span> <span class="special">&amp;&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;;</span>
  <span class="identifier">promise</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">promise</span><span class="special">&amp;&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;;</span>

  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">promise</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="comment">// Result retrieval</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="identifier">get_future</span><span class="special">();</span>

  <span class="comment">// Set the value</span>
  <span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">(</span><span class="identifier">see</span> <span class="identifier">below</span><span class="special">);</span>
  <span class="keyword">void</span> <span class="identifier">set_exception</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">e</span><span class="special">);</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">E</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">set_exception</span><span class="special">(</span><span class="identifier">E</span> <span class="identifier">e</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

  <span class="comment">// setting the result with deferred notification</span>
  <span class="keyword">void</span> <span class="identifier">set_value_at_thread_exit</span><span class="special">(</span><span class="identifier">see</span> <span class="identifier">below</span><span class="special">);</span>
  <span class="keyword">void</span> <span class="identifier">set_exception_at_thread_exit</span><span class="special">(</span><span class="identifier">exception_ptr</span> <span class="identifier">p</span><span class="special">);</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">E</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">set_exception_at_thread_exit</span><span class="special">(</span><span class="identifier">E</span> <span class="identifier">p</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">set_wait_callback</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
<span class="special">};</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.default_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.default_constructor" title="Default Constructor">Default
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">promise</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> with no associated
                    result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.alloc_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.alloc_constructor" title="Allocator Constructor">Allocator
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
<span class="identifier">promise</span><span class="special">(</span><span class="identifier">allocator_arg_t</span><span class="special">,</span> <span class="identifier">Allocator</span> <span class="identifier">a</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> with no associated
                    result using the allocator <code class="computeroutput"><span class="identifier">a</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    Available only if BOOST_THREAD_FUTURE_USES_ALLOCATORS is defined.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.move_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.move_constructor" title="Move Constructor">Move
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">promise</span><span class="special">(</span><span class="identifier">promise</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a>, and transfers
                    ownership of the result associated with <code class="computeroutput"><span class="identifier">other</span></code>
                    to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    leaving <code class="computeroutput"><span class="identifier">other</span></code>
                    with no associated result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    If the compiler does not support rvalue-references, this is implemented
                    using the boost.thread move emulation.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.move_assignment"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.move_assignment" title="Move Assignment Operator">Move
            Assignment Operator</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">promise</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">promise</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Transfers ownership of the result associated with <code class="computeroutput"><span class="identifier">other</span></code> to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>, leaving <code class="computeroutput"><span class="identifier">other</span></code>
                    with no associated result. If there was already a result associated
                    with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    and that result was not <span class="emphasis"><em>ready</em></span>, sets any
                    futures associated with that result to <span class="emphasis"><em>ready</em></span>
                    with a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">broken_promise</span></code>
                    exception as the result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    If the compiler does not support rvalue-references, this is implemented
                    using the boost.thread move emulation.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.destructor" title="Destructor">Destructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="special">~</span><span class="identifier">promise</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Destroys <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    If there was a result associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>, and that result is not
                    <span class="emphasis"><em>ready</em></span>, sets any futures associated with
                    that task to <span class="emphasis"><em>ready</em></span> with a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">broken_promise</span></code> exception as
                    the result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.get_future"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.get_future" title="Member Function get_future()">Member
            Function <code class="computeroutput"><span class="identifier">get_future</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="identifier">get_future</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    was not associated with a result, allocate storage for a new
                    shared state and associate it with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>. Returns a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> associated with
                    the result associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_already_retrieved</span></code> if
                    the future associated with the task has already been retrieved.
                    <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> if any memory necessary
                    could not be allocated.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.set_value"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.set_value" title="Member Function set_value()">Member
            Function <code class="computeroutput"><span class="identifier">set_value</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">(</span><span class="identifier">R</span><span class="special">&amp;&amp;</span> <span class="identifier">r</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">R</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">promise</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&amp;&gt;::</span><span class="identifier">set_value</span><span class="special">(</span><span class="identifier">R</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">promise</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;::</span><span class="identifier">set_value</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                    - If BOOST_THREAD_PROVIDES_PROMISE_LAZY is defined and if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    was not associated with a result, allocate storage for a new
                    shared state and associate it with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p>
<p>
                    - Store the value <code class="computeroutput"><span class="identifier">r</span></code>
                    in the shared state associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>. Any threads blocked waiting
                    for the asynchronous result are woken.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    All futures waiting on the shared state are <span class="emphasis"><em>ready</em></span>
                    and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.has_value" title="Member function has_value() EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">has_value</span><span class="special">()</span></code></a>
                    or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.has_value" title="Member function has_value() EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">has_value</span><span class="special">()</span></code></a>
                    for those futures shall return <code class="computeroutput"><span class="keyword">true</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise_already_satisfied</span></code> if
                    the result associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is already <span class="emphasis"><em>ready</em></span>.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">broken_promise</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    has no shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> if the memory required
                    for storage of the result cannot be allocated.
                  </p>
<p>
                    - Any exception thrown by the copy or move-constructor of <code class="computeroutput"><span class="identifier">R</span></code>.
                  </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.set_exception"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.set_exception" title="Member Function set_exception()">Member
            Function <code class="computeroutput"><span class="identifier">set_exception</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">set_exception</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">e</span><span class="special">);</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">E</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">set_exception</span><span class="special">(</span><span class="identifier">E</span> <span class="identifier">e</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                    - If BOOST_THREAD_PROVIDES_PROMISE_LAZY is defined and if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    was not associated with a result, allocate storage for a new
                    shared state and associate it with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p>
<p>
                    - Store the exception <code class="computeroutput"><span class="identifier">e</span></code>
                    in the shared state associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>. Any threads blocked waiting
                    for the asynchronous result are woken.
                  </p>
</dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    All futures waiting on the shared state are <span class="emphasis"><em>ready</em></span>
                    and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.has_exception" title="Member function has_exception() EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">has_exception</span><span class="special">()</span></code></a>
                    or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.has_exception" title="Member function has_exception() EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">has_exception</span><span class="special">()</span></code></a>
                    for those futures shall return <code class="computeroutput"><span class="keyword">true</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise_already_satisfied</span></code> if
                    the result associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is already <span class="emphasis"><em>ready</em></span>.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">broken_promise</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    has no shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> if the memory required
                    for storage of the result cannot be allocated.
                  </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.set_value_at_thread_exit"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.set_value_at_thread_exit" title="Member Function set_value_at_thread_exit()">Member
            Function <code class="computeroutput"><span class="identifier">set_value_at_thread_exit</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">set_value_at_thread_exit</span><span class="special">(</span><span class="identifier">R</span><span class="special">&amp;&amp;</span> <span class="identifier">r</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">set_value_at_thread_exit</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">R</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">promise</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&amp;&gt;::</span><span class="identifier">set_value_at_thread_exit</span><span class="special">(</span><span class="identifier">R</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">promise</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;::</span><span class="identifier">set_value_at_thread_exit</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Stores the value r in the shared state without making that state
                    ready immediately. Schedules that state to be made ready when
                    the current thread exits, after all objects of thread storage
                    duration associated with the current thread have been destroyed.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise_already_satisfied</span></code> if
                    the result associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is already <span class="emphasis"><em>ready</em></span>.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">broken_promise</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    has no shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> if the memory required
                    for storage of the result cannot be allocated.
                  </p>
<p>
                    - Any exception thrown by the copy or move-constructor of <code class="computeroutput"><span class="identifier">R</span></code>.
                  </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.set_exception_at_thread_exit"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.set_exception_at_thread_exit" title="Member Function set_exception_at_thread_exit()">Member
            Function <code class="computeroutput"><span class="identifier">set_exception_at_thread_exit</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">set_exception_at_thread_exit</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">e</span><span class="special">);</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">E</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">set_exception_at_thread_exit</span><span class="special">(</span><span class="identifier">E</span> <span class="identifier">p</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Stores the exception pointer p in the shared state without making
                    that state ready immediately. Schedules that state to be made
                    ready when the current thread exits, after all objects of thread
                    storage duration associated with the current thread have been
                    destroyed.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    All futures waiting on the shared state are <span class="emphasis"><em>ready</em></span>
                    and <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future.has_exception" title="Member function has_exception() EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">has_exception</span><span class="special">()</span></code></a>
                    or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future.has_exception" title="Member function has_exception() EXTENSION"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;::</span><span class="identifier">has_exception</span><span class="special">()</span></code></a>
                    for those futures shall return <code class="computeroutput"><span class="keyword">true</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise_already_satisfied</span></code> if
                    the result associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> is already <span class="emphasis"><em>ready</em></span>.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">broken_promise</span></code> if <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    has no shared state.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> if the memory required
                    for storage of the result cannot be allocated.
                  </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.promise.set_wait_callback"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise.set_wait_callback" title="Member Function set_wait_callback() EXTENSION">Member
            Function <code class="computeroutput"><span class="identifier">set_wait_callback</span><span class="special">()</span></code> EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">set_wait_callback</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                    The expression <code class="computeroutput"><span class="identifier">f</span><span class="special">(</span><span class="identifier">t</span><span class="special">)</span></code> where <code class="computeroutput"><span class="identifier">t</span></code>
                    is a lvalue of type <a class="link" href="synchronization.html#thread.synchronization.futures.reference.promise" title="promise class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">promise</span></code></a> shall be well-formed.
                    Invoking a copy of <code class="computeroutput"><span class="identifier">f</span></code>
                    shall have the same effect as invoking <code class="computeroutput"><span class="identifier">f</span></code>
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Store a copy of <code class="computeroutput"><span class="identifier">f</span></code>
                    with the shared state associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> as a <span class="emphasis"><em>wait callback</em></span>.
                    This will replace any existing wait callback store alongside
                    that result. If a thread subsequently calls one of the wait functions
                    on a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a> associated
                    with this result, and the result is not <span class="emphasis"><em>ready</em></span>,
                    <code class="computeroutput"><span class="identifier">f</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span></code>
                    shall be invoked.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> if memory cannot
                    be allocated for the required storage.
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.packaged_task"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">packaged_task</span></code> class template</a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">S</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">packaged_task</span><span class="special">;</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">R</span>
  <span class="special">,</span> <span class="keyword">class</span><span class="special">...</span> <span class="identifier">ArgTypes</span>
<span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">packaged_task</span><span class="special">&lt;</span><span class="identifier">R</span><span class="special">(</span><span class="identifier">ArgTypes</span><span class="special">)&gt;</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
  <span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">packaged_task</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
  <span class="identifier">packaged_task</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">packaged_task</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

  <span class="comment">// construction and destruction</span>
  <span class="identifier">packaged_task</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

  <span class="keyword">explicit</span> <span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">R</span><span class="special">(*</span><span class="identifier">f</span><span class="special">)(</span><span class="identifier">ArgTypes</span><span class="special">...));</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">&gt;</span>
  <span class="keyword">explicit</span> <span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">);</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
  <span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">allocator_arg_t</span><span class="special">,</span> <span class="identifier">Allocator</span> <span class="identifier">a</span><span class="special">,</span> <span class="identifier">R</span><span class="special">(*</span><span class="identifier">f</span><span class="special">)(</span><span class="identifier">ArgTypes</span><span class="special">...));</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
  <span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">allocator_arg_t</span><span class="special">,</span> <span class="identifier">Allocator</span> <span class="identifier">a</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">);</span>

  <span class="special">~</span><span class="identifier">packaged_task</span><span class="special">()</span>
  <span class="special">{}</span>

  <span class="comment">// move support</span>
  <span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">packaged_task</span><span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="identifier">packaged_task</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">packaged_task</span><span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

  <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">packaged_task</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

  <span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="comment">// result retrieval</span>
   <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="identifier">get_future</span><span class="special">();</span>

  <span class="comment">// execution</span>
  <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">ArgTypes</span><span class="special">...</span> <span class="special">);</span>
  <span class="keyword">void</span> <span class="identifier">make_ready_at_thread_exit</span><span class="special">(</span><span class="identifier">ArgTypes</span><span class="special">...);</span>

  <span class="keyword">void</span> <span class="identifier">reset</span><span class="special">();</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
  <span class="keyword">void</span> <span class="identifier">set_wait_callback</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>
<span class="special">};</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.task_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.task_constructor" title="Task Constructor">Task
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">R</span><span class="special">(*</span><span class="identifier">f</span><span class="special">)(</span><span class="identifier">ArgTypes</span><span class="special">...));</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
<span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">F</span><span class="special">&amp;&amp;</span><span class="identifier">f</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">f</span><span class="special">()</span></code>
                    is a valid expression with a return type convertible to <code class="computeroutput"><span class="identifier">R</span></code>. Invoking a copy of <code class="computeroutput"><span class="identifier">f</span></code> must behave the same as invoking
                    <code class="computeroutput"><span class="identifier">f</span></code>.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> with
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">)</span></code>
                    stored as the associated task.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - Any exceptions thrown by the copy (or move) constructor of
                    <code class="computeroutput"><span class="identifier">f</span></code>.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> if memory for the
                    internal data structures could not be allocated.
                  </p>
</dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    The R(*f)(ArgTypes...)) overload to allow passing a function
                    without needing to use <code class="computeroutput"><span class="special">&amp;</span></code>.
                  </p></dd>
<dt><span class="term">Remark:</span></dt>
<dd><p>
                    This constructor doesn't participate in overload resolution if
                    decay&lt;F&gt;::type is the same type as boost::packaged_task&lt;R&gt;.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.alloc_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.alloc_constructor" title="Allocator Constructor">Allocator
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
<span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">allocator_arg_t</span><span class="special">,</span> <span class="identifier">Allocator</span> <span class="identifier">a</span><span class="special">,</span> <span class="identifier">R</span><span class="special">(*</span><span class="identifier">f</span><span class="special">)(</span><span class="identifier">ArgTypes</span><span class="special">...));</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Allocator</span><span class="special">&gt;</span>
<span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">allocator_arg_t</span><span class="special">,</span> <span class="identifier">Allocator</span> <span class="identifier">a</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">f</span><span class="special">()</span></code>
                    is a valid expression with a return type convertible to <code class="computeroutput"><span class="identifier">R</span></code>. Invoking a copy of <code class="computeroutput"><span class="identifier">f</span></code> shall behave the same as
                    invoking <code class="computeroutput"><span class="identifier">f</span></code>.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> with
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">)</span></code>
                    stored as the associated task using the allocator <code class="computeroutput"><span class="identifier">a</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Any exceptions thrown by the copy (or move) constructor of <code class="computeroutput"><span class="identifier">f</span></code>. <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code>
                    if memory for the internal data structures could not be allocated.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    Available only if BOOST_THREAD_FUTURE_USES_ALLOCATORS is defined.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    The R(*f)(ArgTypes...)) overload to allow passing a function
                    without needing to use <code class="computeroutput"><span class="special">&amp;</span></code>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.move_constructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.move_constructor" title="Move Constructor">Move
            Constructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">packaged_task</span><span class="special">(</span><span class="identifier">packaged_task</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs a new <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>, and transfers
                    ownership of the task associated with <code class="computeroutput"><span class="identifier">other</span></code>
                    to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    leaving <code class="computeroutput"><span class="identifier">other</span></code>
                    with no associated task.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    If the compiler does not support rvalue-references, this is implemented
                    using the boost.thread move emulation.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.move_assignment"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.move_assignment" title="Move Assignment Operator">Move
            Assignment Operator</a>
</h6></div></div></div>
<pre class="programlisting"><span class="identifier">packaged_task</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">packaged_task</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Transfers ownership of the task associated with <code class="computeroutput"><span class="identifier">other</span></code> to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>, leaving <code class="computeroutput"><span class="identifier">other</span></code>
                    with no associated task. If there was already a task associated
                    with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    and that task has not been invoked, sets any futures associated
                    with that task to <span class="emphasis"><em>ready</em></span> with a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">broken_promise</span></code> exception as
                    the result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    If the compiler does not support rvalue-references, this is implemented
                    using the boost.thread move emulation.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.destructor" title="Destructor">Destructor</a>
</h6></div></div></div>
<pre class="programlisting"><span class="special">~</span><span class="identifier">packaged_task</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Destroys <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    If there was a task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>, and that task has not been
                    invoked, sets any futures associated with that task to <span class="emphasis"><em>ready</em></span>
                    with a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">broken_promise</span></code>
                    exception as the result.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.get_future"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.get_future" title="Member Function get_future()">Member
            Function <code class="computeroutput"><span class="identifier">get_future</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="identifier">R</span><span class="special">&gt;</span> <span class="identifier">get_future</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Returns a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> associated with
                    the result of the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_moved</span></code> if ownership of
                    the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> has been moved to another
                    instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_already_retrieved</span></code> if
                    the future associated with the task has already been retrieved.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.call_operator"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.call_operator" title="Member Function operator()()">Member
            Function <code class="computeroutput"><span class="keyword">operator</span><span class="special">()()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Invoke the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> and store the result in the
                    corresponding future. If the task returns normally, the return
                    value is stored as the shared state, otherwise the exception
                    thrown is stored. Any threads blocked waiting for the shared
                    state associated with this task are woken.
                  </p></dd>
<dt><span class="term">Postconditions:</span></dt>
<dd><p>
                    All futures waiting on the shared state are <span class="emphasis"><em>ready</em></span>
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_moved</span></code> if ownership of
                    the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> has been moved to another
                    instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_already_started</span></code> if the
                    task has already been invoked.
                  </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.make_ready_at_thread_exit"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.make_ready_at_thread_exit" title="Member Function make_ready_at_thread_exit()">Member
            Function <code class="computeroutput"><span class="identifier">make_ready_at_thread_exit</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">make_ready_at_thread_exit</span><span class="special">(</span><span class="identifier">ArgTypes</span><span class="special">...);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Invoke the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> and store the result in the
                    corresponding future. If the task returns normally, the return
                    value is stored as the shared state, otherwise the exception
                    thrown is stored. In either case, this is done without making
                    that state ready immediately. Schedules the shared state to be
                    made ready when the current thread exits, after all objects of
                    thread storage duration associated with the current thread have
                    been destroyed.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_moved</span></code> if ownership of
                    the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> has been moved to another
                    instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>.
                  </p>
<p>
                    - <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_already_started</span></code> if the
                    task has already been invoked.
                  </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.reset"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.reset" title="Member Function reset()">Member
            Function <code class="computeroutput"><span class="identifier">reset</span><span class="special">()</span></code></a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">reset</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Reset the state of the packaged_task so that it can be called
                    again.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_moved</span></code> if ownership of
                    the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> has been moved to another
                    instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="thread.synchronization.futures.reference.packaged_task.set_wait_callback"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task.set_wait_callback" title="Member Function set_wait_callback() EXTENSION">Member
            Function <code class="computeroutput"><span class="identifier">set_wait_callback</span><span class="special">()</span></code> EXTENSION</a>
</h6></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">set_wait_callback</span><span class="special">(</span><span class="identifier">F</span> <span class="identifier">f</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                    The expression <code class="computeroutput"><span class="identifier">f</span><span class="special">(</span><span class="identifier">t</span><span class="special">)</span></code> where <code class="computeroutput"><span class="identifier">t</span></code>
                    is a lvalue of type <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a> shall
                    be well-formed. Invoking a copy of <code class="computeroutput"><span class="identifier">f</span></code>
                    shall have the same effect as invoking <code class="computeroutput"><span class="identifier">f</span></code>
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Store a copy of <code class="computeroutput"><span class="identifier">f</span></code>
                    with the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> as a <span class="emphasis"><em>wait callback</em></span>.
                    This will replace any existing wait callback store alongside
                    that task. If a thread subsequently calls one of the wait functions
                    on a <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a> associated
                    with this task, and the result of the task is not <span class="emphasis"><em>ready</em></span>,
                    <code class="computeroutput"><span class="identifier">f</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span></code>
                    shall be invoked.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_moved</span></code> if ownership of
                    the task associated with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> has been moved to another
                    instance of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.packaged_task" title="packaged_task class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">packaged_task</span></code></a>.
                  </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.decay_copy"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.decay_copy" title="Non-member function decay_copy()">Non-member
          function <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;&amp;</span> <span class="identifier">v</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">v</span><span class="special">);</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.async"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.async" title="Non-member function async()">Non-member
          function <code class="computeroutput"><span class="identifier">async</span><span class="special">()</span></code></a>
</h5></div></div></div>
<p>
            The function template async provides a mechanism to launch a function
            potentially in a new thread and provides the result of the function in
            a future object with which it shares a shared state.
          </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
              <code class="computeroutput"><span class="identifier">async</span><span class="special">(</span><span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span><span class="special">,</span>
              <span class="identifier">F</span><span class="special">)</span></code>
              is NOT YET IMPLEMENTED!
            </p></td></tr>
</table></div>
<h6>
<a name="thread.synchronization.futures.reference.async.h0"></a>
            <span class="phrase"><a name="thread.synchronization.futures.reference.async.non_variadic_variant"></a></span><a class="link" href="synchronization.html#thread.synchronization.futures.reference.async.non_variadic_variant">Non-Variadic
            variant</a>
          </h6>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">()&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="identifier">async</span><span class="special">(</span><span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">);</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">()&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="identifier">async</span><span class="special">(</span><span class="identifier">launch</span> <span class="identifier">policy</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd>
<p>
</p>
<pre class="programlisting"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">))()</span>
</pre>
<p>
                </p>
<p>
                  shall be a valid expression.
                </p>
</dd>
<dt><span class="term">Effects</span></dt>
<dd>
<p>
                  The first function behaves the same as a call to the second function
                  with a policy argument of <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span>
                  <span class="special">|</span> <span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code>
                  and the same arguments for <code class="computeroutput"><span class="identifier">F</span></code>.
                </p>
<p>
                  The second function creates a shared state that is associated with
                  the returned future object.
                </p>
<p>
                  The further behavior of the second function depends on the policy
                  argument as follows (if more than one of these conditions applies,
                  the implementation may choose any of the corresponding policies):
                </p>
<p>
                  - if <code class="computeroutput"><span class="identifier">policy</span> <span class="special">&amp;</span>
                  <span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span></code> is non-zero - calls <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">))()</span></code>
                  as if in a new thread of execution represented by a thread object
                  with the calls to <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">()</span></code> being evaluated in the thread
                  that called <code class="computeroutput"><span class="identifier">async</span></code>.
                  Any return value is stored as the result in the shared state. Any
                  exception propagated from the execution of <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">))()</span></code> is stored as the exceptional
                  result in the shared state. The thread object is stored in the
                  shared state and affects the behavior of any asynchronous return
                  objects that reference that state.
                </p>
<p>
                  - if <code class="computeroutput"><span class="identifier">policy</span> <span class="special">&amp;</span>
                  <span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code> is non-zero - Stores
                  <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">))</span></code>
                  in the shared state. This copy of <code class="computeroutput"><span class="identifier">f</span></code>
                  constitute a deferred function. Invocation of the deferred function
                  evaluates <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">g</span><span class="special">)()</span></code> where <code class="computeroutput"><span class="identifier">g</span></code>
                  is the stored value of <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">))</span></code>. The shared state is not made
                  ready until the function has completed. The first call to a non-timed
                  waiting function on an asynchronous return object referring to
                  this shared state shall invoke the deferred function in the thread
                  that called the waiting function. Once evaluation of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">g</span><span class="special">)()</span></code>
                  begins, the function is no longer considered deferred. (Note: If
                  this policy is specified together with other policies, such as
                  when using a policy value of <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span>
                  <span class="special">|</span> <span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code>,
                  implementations should defer invocation or the selection of the
                  policy when no more concurrency can be effectively exploited.)
                </p>
<p>
                  - if no valid launch policy is provided the behaviour is undefined.
                </p>
</dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  An object of type <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span>
                  <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">()&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span></code>
                  that refers to the shared state created by this call to <code class="computeroutput"><span class="identifier">async</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd>
<p>
                  Regardless of the provided policy argument,
                </p>
<p>
                  - the invocation of <code class="computeroutput"><span class="identifier">async</span></code>
                  synchronizes with the invocation of <code class="computeroutput"><span class="identifier">f</span></code>.
                  (Note: This statement applies even when the corresponding future
                  object is moved to another thread.); and
                </p>
<p>
                  - the completion of the function <code class="computeroutput"><span class="identifier">f</span></code>
                  is sequenced before the shared state is made ready. (Note: <code class="computeroutput"><span class="identifier">f</span></code> might not be called at all,
                  so its completion might never happen.)
                </p>
<p>
                  If the implementation chooses the <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span></code>
                  policy,
                </p>
<p>
                  - a call to a non-timed waiting function on an asynchronous return
                  object that shares the shared state created by this async call
                  shall block until the associated thread has completed, as if joined,
                  or else time out;
                </p>
<p>
                  - the associated thread completion synchronizes with the return
                  from the first function that successfully detects the ready status
                  of the shared state or with the return from the last function that
                  releases the shared state, whichever happens first.
                </p>
</dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">system_error</span></code> if
                  policy is <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span></code>
                  and the implementation is unable to start a new thread.
                </p></dd>
<dt><span class="term">Error conditions:</span></dt>
<dd><p>
                  - <code class="computeroutput"><span class="identifier">resource_unavailable_try_again</span></code>
                  - if policy is <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span></code>
                  and the system is unable to start a new thread.
                </p></dd>
<dt><span class="term">Remarks:</span></dt>
<dd><p>
                  The first signature shall not participate in overload resolution
                  if decay&lt;F&gt;::type is boost::launch.
                </p></dd>
</dl>
</div>
<h6>
<a name="thread.synchronization.futures.reference.async.h1"></a>
            <span class="phrase"><a name="thread.synchronization.futures.reference.async.variadic_variant"></a></span><a class="link" href="synchronization.html#thread.synchronization.futures.reference.async.variadic_variant">Variadic
            variant</a>
          </h6>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span><span class="special">...</span> <span class="identifier">Args</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">(</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">...)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="identifier">async</span><span class="special">(</span><span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">Args</span><span class="special">&amp;&amp;...</span> <span class="identifier">args</span><span class="special">);</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span><span class="special">...</span> <span class="identifier">Args</span><span class="special">&gt;</span>
 <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">(</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">...)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="identifier">async</span><span class="special">(</span><span class="identifier">launch</span> <span class="identifier">policy</span><span class="special">,</span> <span class="identifier">F</span><span class="special">&amp;&amp;</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">Args</span><span class="special">&amp;&amp;...</span> <span class="identifier">args</span><span class="special">);</span>
</pre>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
              the variadic prototype is provided only on C++11 compilers supporting
              rvalue references, variadic templates, decltype and a standard library
              providing &lt;tuple&gt; (waiting for a boost::tuple that is move aware),
              and BOOST_THREAD_PROVIDES_SIGNATURE_PACKAGED_TASK is defined.
            </p></td></tr>
</table></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Requires:</span></dt>
<dd>
<p>
                  <code class="computeroutput"><span class="identifier">F</span></code> and each <code class="computeroutput"><span class="identifier">Ti</span></code> in <code class="computeroutput"><span class="identifier">Args</span></code>
                  shall satisfy the <code class="computeroutput"><span class="identifier">MoveConstructible</span></code>
                  requirements.
                </p>
<p>
                  invoke (decay_copy (boost::forward&lt;F&gt;(f)), decay_copy (boost::forward&lt;Args&gt;(args))...)
                </p>
<p>
                  shall be a valid expression.
                </p>
</dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  - The first function behaves the same as a call to the second function
                  with a policy argument of <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span>
                  <span class="special">|</span> <span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code>
                  and the same arguments for <code class="computeroutput"><span class="identifier">F</span></code>
                  and <code class="computeroutput"><span class="identifier">Args</span></code>.
                </p>
<p>
                  - The second function creates a shared state that is associated
                  with the returned future object. The further behavior of the second
                  function depends on the policy argument as follows (if more than
                  one of these conditions applies, the implementation may choose
                  any of the corresponding policies):
                </p>
<p>
                  - if <code class="computeroutput"><span class="identifier">policy</span> <span class="special">&amp;</span>
                  <span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span></code> is non-zero - calls <code class="computeroutput"><span class="identifier">invoke</span><span class="special">(</span><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">)),</span>
                  <span class="identifier">decay_copy</span> <span class="special">(</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;(</span><span class="identifier">args</span><span class="special">))...)</span></code>
                  as if in a new thread of execution represented by a thread object
                  with the calls to <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">()</span></code> being evaluated in the thread
                  that called <code class="computeroutput"><span class="identifier">async</span></code>.
                  Any return value is stored as the result in the shared state. Any
                  exception propagated from the execution of <code class="computeroutput"><span class="identifier">invoke</span><span class="special">(</span><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">)),</span> <span class="identifier">decay_copy</span>
                  <span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;(</span><span class="identifier">args</span><span class="special">))...)</span></code> is stored as the exceptional
                  result in the shared state. The thread object is stored in the
                  shared state and affects the behavior of any asynchronous return
                  objects that reference that state.
                </p>
<p>
                  - if <code class="computeroutput"><span class="identifier">policy</span> <span class="special">&amp;</span>
                  <span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code> is non-zero - Stores
                  <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">))</span></code>
                  and <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;(</span><span class="identifier">args</span><span class="special">))...</span></code> in the shared state. These
                  copies of <code class="computeroutput"><span class="identifier">f</span></code> and
                  <code class="computeroutput"><span class="identifier">args</span></code> constitute
                  a deferred function. Invocation of the deferred function evaluates
                  <code class="computeroutput"><span class="identifier">invoke</span><span class="special">(</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">g</span><span class="special">),</span>
                  <span class="identifier">move</span><span class="special">(</span><span class="identifier">xyz</span><span class="special">))</span></code>
                  where <code class="computeroutput"><span class="identifier">g</span></code> is the
                  stored value of <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;(</span><span class="identifier">f</span><span class="special">))</span></code> and <code class="computeroutput"><span class="identifier">xyz</span></code>
                  is the stored copy of <code class="computeroutput"><span class="identifier">decay_copy</span><span class="special">(</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;(</span><span class="identifier">args</span><span class="special">))...</span></code>. The shared state is not made
                  ready until the function has completed. The first call to a non-timed
                  waiting function on an asynchronous return object referring to
                  this shared state shall invoke the deferred function in the thread
                  that called the waiting function. Once evaluation of <code class="computeroutput"><span class="identifier">invoke</span><span class="special">(</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">g</span><span class="special">),</span>
                  <span class="identifier">move</span><span class="special">(</span><span class="identifier">xyz</span><span class="special">))</span></code>
                  begins, the function is no longer considered deferred.
                </p>
<p>
                  - if no valid launch policy is provided the behaviour is undefined.
                </p>
</dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                  If this policy is specified together with other policies, such
                  as when using a policy value of <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span>
                  <span class="special">|</span> <span class="identifier">launch</span><span class="special">::</span><span class="identifier">deferred</span></code>,
                  implementations should defer invocation or the selection of the
                  policy when no more concurrency can be effectively exploited.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  An object of type <code class="computeroutput"> <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">result_of</span><span class="special">&lt;</span><span class="keyword">typename</span>
                  <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">(</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">Args</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">...)&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span></code> that refers to the shared state
                  created by this call to <code class="computeroutput"><span class="identifier">async</span></code>.
                </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd>
<p>
                  Regardless of the provided policy argument,
                </p>
<p>
                  - the invocation of async synchronizes with the invocation of
                  <code class="computeroutput"><span class="identifier">f</span></code>. (Note: This
                  statement applies even when the corresponding future object is
                  moved to another thread.); and
                </p>
<p>
                  - the completion of the function <code class="computeroutput"><span class="identifier">f</span></code>
                  is sequenced before the shared state is made ready. (Note: f might
                  not be called at all, so its completion might never happen.)
                </p>
<p>
                  If the implementation chooses the <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span></code>
                  policy,
                </p>
<p>
                  - a call to a waiting function on an asynchronous return object
                  that shares the shared state created by this async call shall block
                  until the associated thread has completed, as if joined, or else
                  time out;
                </p>
<p>
                  - the associated thread completion synchronizes with the return
                  from the first function that successfully detects the ready status
                  of the shared state or with the return from the last function that
                  releases the shared state, whichever happens first.
                </p>
</dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">system_error</span></code> if
                  policy is <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span></code>
                  and the implementation is unable to start a new thread.
                </p></dd>
<dt><span class="term">Error conditions:</span></dt>
<dd><p>
                  - <code class="computeroutput"><span class="identifier">resource_unavailable_try_again</span></code>
                  - if policy is <code class="computeroutput"><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span></code>
                  and the system is unable to start a new thread.
                </p></dd>
<dt><span class="term">Remarks:</span></dt>
<dd><p>
                  The first signature shall not participate in overload resolution
                  if decay&lt;F&gt;::type is boost::launch.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.wait_for_any"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.wait_for_any" title="Non-member function wait_for_any() - EXTENSION">Non-member
          function <code class="computeroutput"><span class="identifier">wait_for_any</span><span class="special">()</span></code>
          - EXTENSION</a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="identifier">Iterator</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">Iterator</span> <span class="identifier">end</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">&gt;</span>
<span class="keyword">unsigned</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F3</span><span class="special">&gt;</span>
<span class="keyword">unsigned</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">,</span><span class="identifier">F3</span><span class="special">&amp;</span> <span class="identifier">f3</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F4</span><span class="special">&gt;</span>
<span class="keyword">unsigned</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">,</span><span class="identifier">F3</span><span class="special">&amp;</span> <span class="identifier">f3</span><span class="special">,</span><span class="identifier">F4</span><span class="special">&amp;</span> <span class="identifier">f4</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F4</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F5</span><span class="special">&gt;</span>
<span class="keyword">unsigned</span> <span class="identifier">wait_for_any</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">,</span><span class="identifier">F3</span><span class="special">&amp;</span> <span class="identifier">f3</span><span class="special">,</span><span class="identifier">F4</span><span class="special">&amp;</span> <span class="identifier">f4</span><span class="special">,</span><span class="identifier">F5</span><span class="special">&amp;</span> <span class="identifier">f5</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                  The types <code class="computeroutput"><span class="identifier">Fn</span></code> shall
                  be specializations of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a>, and <code class="computeroutput"><span class="identifier">Iterator</span></code> shall be a forward iterator
                  with a <code class="computeroutput"><span class="identifier">value_type</span></code>
                  which is a specialization of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Waits until at least one of the specified futures is <span class="emphasis"><em>ready</em></span>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  The range-based overload returns an <code class="computeroutput"><span class="identifier">Iterator</span></code>
                  identifying the first future in the range that was detected as
                  <span class="emphasis"><em>ready</em></span>. The remaining overloads return the
                  zero-based index of the first future that was detected as <span class="emphasis"><em>ready</em></span>
                  (first parameter =&gt; 0, second parameter =&gt; 1, etc.).
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the current
                  thread is interrupted. Any exception thrown by the <span class="emphasis"><em>wait
                  callback</em></span> associated with any of the futures being waited
                  for. <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> if memory could not
                  be allocated for the internal wait structures.
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">wait_for_any</span><span class="special">()</span></code>
                  is an <span class="emphasis"><em>interruption point</em></span>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.wait_for_all"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.wait_for_all" title="Non-member function wait_for_all() - EXTENSION">Non-member
          function <code class="computeroutput"><span class="identifier">wait_for_all</span><span class="special">()</span></code>
          - EXTENSION</a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iterator</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">Iterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">Iterator</span> <span class="identifier">end</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F3</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">,</span><span class="identifier">F3</span><span class="special">&amp;</span> <span class="identifier">f3</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F4</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">,</span><span class="identifier">F3</span><span class="special">&amp;</span> <span class="identifier">f3</span><span class="special">,</span><span class="identifier">F4</span><span class="special">&amp;</span> <span class="identifier">f4</span><span class="special">);</span> <span class="comment">// EXTENSION</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">F1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F4</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">F5</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_for_all</span><span class="special">(</span><span class="identifier">F1</span><span class="special">&amp;</span> <span class="identifier">f1</span><span class="special">,</span><span class="identifier">F2</span><span class="special">&amp;</span> <span class="identifier">f2</span><span class="special">,</span><span class="identifier">F3</span><span class="special">&amp;</span> <span class="identifier">f3</span><span class="special">,</span><span class="identifier">F4</span><span class="special">&amp;</span> <span class="identifier">f4</span><span class="special">,</span><span class="identifier">F5</span><span class="special">&amp;</span> <span class="identifier">f5</span><span class="special">);</span> <span class="comment">// EXTENSION</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                  The types <code class="computeroutput"><span class="identifier">Fn</span></code> shall
                  be specializations of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a>, and <code class="computeroutput"><span class="identifier">Iterator</span></code> shall be a forward iterator
                  with a <code class="computeroutput"><span class="identifier">value_type</span></code>
                  which is a specialization of <a class="link" href="synchronization.html#thread.synchronization.futures.reference.unique_future" title="future class template"><code class="computeroutput"><span class="identifier">future</span></code></a> or <a class="link" href="synchronization.html#thread.synchronization.futures.reference.shared_future" title="shared_future class template"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code></a>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Waits until all of the specified futures are <span class="emphasis"><em>ready</em></span>.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Any exceptions thrown by a call to <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code> on the specified futures.
                </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">wait_for_all</span><span class="special">()</span></code>
                  is an <span class="emphasis"><em>interruption point</em></span>.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.make_ready_future"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.make_ready_future" title="Non-member function make_ready_future() EXTENSION">Non-member
          function <code class="computeroutput"><span class="identifier">make_ready_future</span><span class="special">()</span></code> EXTENSION</a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="identifier">make_ready_future</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;&amp;</span> <span class="identifier">value</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>
<span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span> <span class="identifier">make_ready_future</span><span class="special">();</span>  <span class="comment">// EXTENSION</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">make_ready_future</span><span class="special">(</span><span class="identifier">exception_ptr</span> <span class="identifier">ex</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">E</span><span class="special">&gt;</span>
<span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">make_ready_future</span><span class="special">(</span><span class="identifier">E</span> <span class="identifier">ex</span><span class="special">);</span>  <span class="comment">// EXTENSION</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                  - value prototype: The value that is passed into the function is
                  moved to the shared state of the returned function if it is an
                  rvalue. Otherwise the value is copied to the shared state of the
                  returned function.
                </p>
<p>
                  - exception: The exception that is passed into the function is
                  copied to the shared state of the returned function.
                </p>
<p>
                  .
                </p>
</dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                  - a ready future with the value set with <code class="computeroutput"><span class="identifier">value</span></code>
                </p>
<p>
                  - a ready future with the exception set with <code class="computeroutput"><span class="identifier">ex</span></code>
                </p>
<p>
                  - a ready future&lt;void&gt; with the value set (void).
                </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd>
<p>
                  - Returned future, valid() == true
                </p>
<p>
                  - Returned future, is_ready() = true
                </p>
<p>
                  - Returned future, has_value() = true or has_exception() depending
                  on the prototype.
                </p>
</dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.make_future"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.make_future" title="Non-member function make_future() DEPRECATED">Non-member
          function <code class="computeroutput"><span class="identifier">make_future</span><span class="special">()</span></code>
          DEPRECATED</a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="identifier">make_future</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;&amp;</span> <span class="identifier">value</span><span class="special">);</span>  <span class="comment">// DEPRECATED</span>
<span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span> <span class="identifier">make_future</span><span class="special">();</span>  <span class="comment">// DEPRECATED</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The value that is passed into the function is moved to the shared
                  state of the returned function if it is an rvalue. Otherwise the
                  value is copied to the shared state of the returned function. .
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                  - future&lt;T&gt;, if function is given a value of type T
                </p>
<p>
                  - future&lt;void&gt;, if the function is not given any inputs.
                </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd>
<p>
                  - Returned future&lt;T&gt;, valid() == true
                </p>
<p>
                  - Returned future&lt;T&gt;, is_ready() = true
                </p>
</dd>
<dt><span class="term">See:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">make_ready_future</span><span class="special">()</span></code>
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.futures.reference.make_shared_future"></a><a class="link" href="synchronization.html#thread.synchronization.futures.reference.make_shared_future" title="Non-member function make_shared_future() DEPRECATED">Non-member
          function <code class="computeroutput"><span class="identifier">make_shared_future</span><span class="special">()</span></code> DEPRECATED</a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">shared_future</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">decay</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span> <span class="identifier">make_shared_future</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;&amp;</span> <span class="identifier">value</span><span class="special">);</span>  <span class="comment">// DEPRECATED</span>
<span class="identifier">shared_future</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span> <span class="identifier">make_shared_future</span><span class="special">();</span>  <span class="comment">// DEPRECATED</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  The value that is passed in to the function is moved to the shared
                  state of the returned function if it is an rvalue. Otherwise the
                  value is copied to the shared state of the returned function. .
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd>
<p>
                  - shared_future&lt;T&gt;, if function is given a value of type
                  T
                </p>
<p>
                  - shared_future&lt;void&gt;, if the function is not given any inputs.
                </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd>
<p>
                  - Returned shared_future&lt;T&gt;, valid() == true
                </p>
<p>
                  - Returned shared_future&lt;T&gt;, is_ready() = true
                </p>
</dd>
<dt><span class="term">See:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">make_ready_future</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;::</span><span class="identifier">share</span><span class="special">()</span></code>
                </p></dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2007 -11 Anthony Williams<br>Copyright &#169; 2011 -13 Vicente J. Botet Escriba<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="ScopedThreads.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../thread.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="thread_local_storage.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
