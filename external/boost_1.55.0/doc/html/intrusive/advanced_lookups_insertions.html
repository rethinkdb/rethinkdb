<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Advanced lookup and insertion functions for associative containers</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../intrusive.html" title="Chapter&#160;15.&#160;Boost.Intrusive">
<link rel="prev" href="treap_set_multiset.html" title="Intrusive treap based associative containers: treap_set, treap_multiset and treap">
<link rel="next" href="erasing_and_disposing.html" title="Erasing and disposing values from Boost.Intrusive containers">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="treap_set_multiset.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../intrusive.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="erasing_and_disposing.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="intrusive.advanced_lookups_insertions"></a><a class="link" href="advanced_lookups_insertions.html" title="Advanced lookup and insertion functions for associative containers">Advanced lookup
    and insertion functions for associative containers</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.advanced_lookups">Advanced
      lookups</a></span></dt>
<dt><span class="section"><a href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.advanced_insertions">Advanced
      insertions</a></span></dt>
<dt><span class="section"><a href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.positional_insertions">Positional
      insertions</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="intrusive.advanced_lookups_insertions.advanced_lookups"></a><a class="link" href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.advanced_lookups" title="Advanced lookups">Advanced
      lookups</a>
</h3></div></div></div>
<p>
        <span class="bold"><strong>Boost.Intrusive</strong></span> associative containers offer
        the same interface as STL associative containers. However, STL and TR1 ordered
        and unordered simple associative containers (<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span></code>,
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">multiset</span></code>, <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_set</span></code> and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_multiset</span></code>) have some inefficiencies
        caused by the interface: the user can only operate with <code class="computeroutput"><span class="identifier">value_type</span></code>
        objects. When using these containers we must use <code class="computeroutput"><span class="identifier">iterator</span>
        <span class="identifier">find</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">value_type</span>
        <span class="special">&amp;</span><span class="identifier">value</span><span class="special">)</span></code> to find a value. The same happens in other
        functions like <code class="computeroutput"><span class="identifier">equal_range</span></code>,
        <code class="computeroutput"><span class="identifier">lower_bound</span></code>, <code class="computeroutput"><span class="identifier">upper_bound</span></code>, etc.
      </p>
<p>
        However, sometimes the object to be searched is quite expensive to construct:
      </p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">intrusive</span><span class="special">/</span><span class="identifier">set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">intrusive</span><span class="special">/</span><span class="identifier">unordered_set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cstring</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">intrusive</span><span class="special">;</span>

<span class="comment">// Hash function for strings</span>
<span class="keyword">struct</span> <span class="identifier">StrHasher</span>
<span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">seed</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
      <span class="keyword">for</span><span class="special">(;</span> <span class="special">*</span><span class="identifier">str</span><span class="special">;</span> <span class="special">++</span><span class="identifier">str</span><span class="special">)</span>   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash_combine</span><span class="special">(</span><span class="identifier">seed</span><span class="special">,</span> <span class="special">*</span><span class="identifier">str</span><span class="special">);</span>
      <span class="keyword">return</span> <span class="identifier">seed</span><span class="special">;</span>
   <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">Expensive</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">set_base_hook</span><span class="special">&lt;&gt;,</span> <span class="keyword">public</span> <span class="identifier">unordered_set_base_hook</span><span class="special">&lt;&gt;</span>
<span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">key_</span><span class="special">;</span>
   <span class="comment">// Other members...</span>

   <span class="keyword">public</span><span class="special">:</span>
   <span class="identifier">Expensive</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">key</span><span class="special">)</span>
      <span class="special">:</span>  <span class="identifier">key_</span><span class="special">(</span><span class="identifier">key</span><span class="special">)</span>
      <span class="special">{}</span>  <span class="comment">//other expensive initializations...</span>

   <span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&amp;</span> <span class="identifier">get_key</span><span class="special">()</span> <span class="keyword">const</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">key_</span><span class="special">;</span>   <span class="special">}</span>

   <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> <span class="special">&lt;</span>  <span class="special">(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">a</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">b</span><span class="special">)</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">a</span><span class="special">.</span><span class="identifier">key_</span> <span class="special">&lt;</span> <span class="identifier">b</span><span class="special">.</span><span class="identifier">key_</span><span class="special">;</span>  <span class="special">}</span>

   <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> <span class="special">==</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">a</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">b</span><span class="special">)</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">a</span><span class="special">.</span><span class="identifier">key_</span> <span class="special">==</span> <span class="identifier">b</span><span class="special">.</span><span class="identifier">key_</span><span class="special">;</span>  <span class="special">}</span>

   <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">hash_value</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">object</span><span class="special">)</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">StrHasher</span><span class="special">()(</span><span class="identifier">object</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">());</span>  <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// A set and unordered_set that store Expensive objects</span>
<span class="keyword">typedef</span> <span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">Expensive</span><span class="special">&gt;</span>           <span class="identifier">Set</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">unordered_set</span><span class="special">&lt;</span><span class="identifier">Expensive</span><span class="special">&gt;</span> <span class="identifier">UnorderedSet</span><span class="special">;</span>

<span class="comment">// Search functions</span>
<span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">get_from_set</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">Set</span> <span class="special">&amp;</span><span class="identifier">set_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Set</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">));</span>
   <span class="keyword">if</span><span class="special">(</span> <span class="identifier">it</span> <span class="special">==</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>     <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="special">&amp;*</span><span class="identifier">it</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">get_from_uset</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">UnorderedSet</span> <span class="special">&amp;</span><span class="identifier">uset_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">UnorderedSet</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">Expensive</span> <span class="special">(</span><span class="identifier">key</span><span class="special">));</span>
   <span class="keyword">if</span><span class="special">(</span> <span class="identifier">it</span> <span class="special">==</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>  <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="special">&amp;*</span><span class="identifier">it</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        <code class="computeroutput"><span class="identifier">Expensive</span></code> is an expensive
        object to construct. If "key" c-string is quite long <code class="computeroutput"><span class="identifier">Expensive</span></code> has to construct a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
        using heap memory. Like <code class="computeroutput"><span class="identifier">Expensive</span></code>,
        many times the only member taking part in ordering issues is just a small
        part of the class. For example, with <code class="computeroutput"><span class="identifier">Expensive</span></code>,
        only the internal <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> is needed to compare the object.
      </p>
<p>
        In both containers, if we call <code class="computeroutput"><span class="identifier">get_from_set</span><span class="special">/</span><span class="identifier">get_from_unordered_set</span></code>
        in a loop, we might get a performance penalty, because we are forced to create
        a whole <code class="computeroutput"><span class="identifier">Expensive</span></code> object
        to be able to find an equivalent one.
      </p>
<p>
        Sometimes this interface limitation is severe, because we <span class="bold"><strong>might
        not have enough information to construct the object</strong></span> but we might
        <span class="bold"><strong>have enough information to find the object</strong></span>.
        In this case, a name is enough to search <code class="computeroutput"><span class="identifier">Expensive</span></code>
        in the container but constructing an <code class="computeroutput"><span class="identifier">Expensive</span></code>
        might require more information that the user might not have.
      </p>
<p>
        To solve this, <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code>/<code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code> offer alternative functions,
        which take any type comparable with the value and a functor that should be
        compatible with the ordering function of the associative container. <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>/<code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
        offers functions that take any key type and compatible hash and equality
        functions. Now, let's see the optimized search function:
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// These compare Expensive and a c-string</span>
<span class="keyword">struct</span> <span class="identifier">StrExpComp</span>
<span class="special">{</span>
   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">c</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">())</span> <span class="special">&lt;</span> <span class="number">0</span><span class="special">;</span>  <span class="special">}</span>

   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">c</span><span class="special">,</span> <span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">)</span> <span class="special">&lt;</span> <span class="number">0</span><span class="special">;</span>  <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">StrExpEqual</span>
<span class="special">{</span>
   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">c</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">())</span> <span class="special">==</span> <span class="number">0</span><span class="special">;</span>  <span class="special">}</span>

   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">c</span><span class="special">,</span> <span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">)</span> <span class="special">==</span> <span class="number">0</span><span class="special">;</span>  <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Optimized search functions</span>
<span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">get_from_set_optimized</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">Set</span> <span class="special">&amp;</span><span class="identifier">set_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Set</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">StrExpComp</span><span class="special">());</span>
   <span class="keyword">if</span><span class="special">(</span> <span class="identifier">it</span> <span class="special">==</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>   <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="special">&amp;*</span><span class="identifier">it</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">get_from_uset_optimized</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">UnorderedSet</span> <span class="special">&amp;</span><span class="identifier">uset_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">UnorderedSet</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">StrHasher</span><span class="special">(),</span> <span class="identifier">StrExpEqual</span><span class="special">());</span>
   <span class="keyword">if</span><span class="special">(</span> <span class="identifier">it</span> <span class="special">==</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>  <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="special">&amp;*</span><span class="identifier">it</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        This new arbitrary key overload is also available for other functions taking
        values as arguments:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            equal_range
          </li>
<li class="listitem">
            lower_bound
          </li>
<li class="listitem">
            upper_bound
          </li>
<li class="listitem">
            count
          </li>
<li class="listitem">
            find
          </li>
<li class="listitem">
            erase
          </li>
</ul></div>
<p>
        Check <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code>, <code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code>, <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>,
        <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
        references to know more about those functions.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="intrusive.advanced_lookups_insertions.advanced_insertions"></a><a class="link" href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.advanced_insertions" title="Advanced insertions">Advanced
      insertions</a>
</h3></div></div></div>
<p>
        A similar issue happens with insertions in simple ordered and unordered associative
        containers with unique keys (<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span></code> and
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_set</span></code>).
        In these containers, if a value is already present, the value to be inserted
        is discarded. With expensive values, if the value is already present, we
        can suffer efficiency problems.
      </p>
<p>
        <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code> and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>
        have insertion functions to check efficiently, without constructing the value,
        if a value is present or not and if it's not present, a function to insert
        it immediately without any further lookup. For example, using the same <code class="computeroutput"><span class="identifier">Expensive</span></code> class, this function can be inefficient:
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Insertion functions</span>
<span class="keyword">bool</span> <span class="identifier">insert_to_set</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">Set</span> <span class="special">&amp;</span><span class="identifier">set_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">pobject</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">);</span>
   <span class="keyword">bool</span> <span class="identifier">success</span> <span class="special">=</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(*</span><span class="identifier">pobject</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
   <span class="keyword">if</span><span class="special">(!</span><span class="identifier">success</span><span class="special">)</span>   <span class="keyword">delete</span> <span class="identifier">pobject</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="identifier">success</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">bool</span> <span class="identifier">insert_to_uset</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">UnorderedSet</span> <span class="special">&amp;</span><span class="identifier">uset_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">pobject</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">);</span>
   <span class="keyword">bool</span> <span class="identifier">success</span> <span class="special">=</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(*</span><span class="identifier">pobject</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
   <span class="keyword">if</span><span class="special">(!</span><span class="identifier">success</span><span class="special">)</span>   <span class="keyword">delete</span> <span class="identifier">pobject</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="identifier">success</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        If the object is already present, we are constructing an <code class="computeroutput"><span class="identifier">Expensive</span></code>
        that will be discarded, and this is a waste of resources. Instead of that,
        let's use <code class="computeroutput"><span class="identifier">insert_check</span></code> and
        <code class="computeroutput"><span class="identifier">insert_commit</span></code> functions:
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Optimized insertion functions</span>
<span class="keyword">bool</span> <span class="identifier">insert_to_set_optimized</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">Set</span> <span class="special">&amp;</span><span class="identifier">set_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Set</span><span class="special">::</span><span class="identifier">insert_commit_data</span> <span class="identifier">insert_data</span><span class="special">;</span>
   <span class="keyword">bool</span> <span class="identifier">success</span> <span class="special">=</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">insert_check</span><span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">StrExpComp</span><span class="special">(),</span> <span class="identifier">insert_data</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
   <span class="keyword">if</span><span class="special">(</span><span class="identifier">success</span><span class="special">)</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">insert_commit</span><span class="special">(*</span><span class="keyword">new</span> <span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">),</span> <span class="identifier">insert_data</span><span class="special">);</span>
   <span class="keyword">return</span> <span class="identifier">success</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">bool</span> <span class="identifier">insert_to_uset_optimized</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">UnorderedSet</span> <span class="special">&amp;</span><span class="identifier">uset_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">UnorderedSet</span><span class="special">::</span><span class="identifier">insert_commit_data</span> <span class="identifier">insert_data</span><span class="special">;</span>
   <span class="keyword">bool</span> <span class="identifier">success</span> <span class="special">=</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">insert_check</span>
      <span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">StrHasher</span><span class="special">(),</span> <span class="identifier">StrExpEqual</span><span class="special">(),</span> <span class="identifier">insert_data</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
   <span class="keyword">if</span><span class="special">(</span><span class="identifier">success</span><span class="special">)</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">insert_commit</span><span class="special">(*</span><span class="keyword">new</span> <span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">),</span> <span class="identifier">insert_data</span><span class="special">);</span>
   <span class="keyword">return</span> <span class="identifier">success</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        <code class="computeroutput"><span class="identifier">insert_check</span></code> is similar to
        a normal <code class="computeroutput"><span class="identifier">insert</span></code> but:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><span class="identifier">insert_check</span></code> can be used
            with arbitrary keys
          </li>
<li class="listitem">
            if the insertion is possible (there is no equivalent value) <code class="computeroutput"><span class="identifier">insert_check</span></code> collects all the needed
            information in an <code class="computeroutput"><span class="identifier">insert_commit_data</span></code>
            structure, so that <code class="computeroutput"><span class="identifier">insert_commit</span></code>:
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                  <span class="bold"><strong>does not execute</strong></span> further comparisons
                </li>
<li class="listitem">
                  can be executed with <span class="bold"><strong>constant-time complexity</strong></span>
                </li>
<li class="listitem">
                  has <span class="bold"><strong>no-throw guarantee</strong></span>.
                </li>
</ul></div>
          </li>
</ul></div>
<p>
        These functions must be used with care, since no other insertion or erasure
        must be executed between an <code class="computeroutput"><span class="identifier">insert_check</span></code>
        and an <code class="computeroutput"><span class="identifier">insert_commit</span></code> pair.
        Otherwise, the behaviour is undefined. <code class="computeroutput"><span class="identifier">insert_check</span></code>
        and <code class="computeroutput"><span class="identifier">insert_commit</span></code> will come
        in handy for developers programming efficient non-intrusive associative containers.
        See <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code> and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code> reference
        for more information about <code class="computeroutput"><span class="identifier">insert_check</span></code>
        and <code class="computeroutput"><span class="identifier">insert_commit</span></code>.
      </p>
<p>
        With multiple ordered and unordered associative containers (<code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code>
        and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>)
        there is no need for these advanced insertion functions, since insertions
        are always successful.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="intrusive.advanced_lookups_insertions.positional_insertions"></a><a class="link" href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.positional_insertions" title="Positional insertions">Positional
      insertions</a>
</h3></div></div></div>
<p>
        Some ordered associative containers offer low-level functions to bypass ordering
        checks and insert nodes directly in desired tree positions. These functions
        are provided for performance reasons when values to be inserted in the container
        are known to fulfill order (sets and multisets) and uniqueness (sets) invariants.
        A typical usage of these functions is when intrusive associative containers
        are used to build non-intrusive containers and the programmer wants to speed
        up assignments from other associative containers: if the ordering and uniqueness
        properties are the same, there is no need to waste time checking the position
        of each source value, because values are already ordered: back insertions
        will be much more efficient.
      </p>
<p>
        <span class="bold"><strong>Note:</strong></span> These functions <span class="bold"><strong>don't
        check preconditions</strong></span> so they must used with care. These are functions
        are low-level operations <span class="bold"><strong>will break container invariants
        if ordering and uniqueness preconditions are not assured by the caller.</strong></span>
      </p>
<p>
        Let's see an example:
      </p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">intrusive</span><span class="special">/</span><span class="identifier">set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">algorithm</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">intrusive</span><span class="special">;</span>

<span class="comment">//A simple class with a set hook</span>
<span class="keyword">class</span> <span class="identifier">MyClass</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">set_base_hook</span><span class="special">&lt;&gt;</span>
<span class="special">{</span>
   <span class="keyword">public</span><span class="special">:</span>
   <span class="keyword">int</span> <span class="identifier">int_</span><span class="special">;</span>

   <span class="identifier">MyClass</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span><span class="special">)</span> <span class="special">:</span>  <span class="identifier">int_</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{}</span>
   <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">MyClass</span> <span class="special">&amp;</span><span class="identifier">a</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">MyClass</span> <span class="special">&amp;</span><span class="identifier">b</span><span class="special">)</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">a</span><span class="special">.</span><span class="identifier">int_</span> <span class="special">&lt;</span> <span class="identifier">b</span><span class="special">.</span><span class="identifier">int_</span><span class="special">;</span>  <span class="special">}</span>
   <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">MyClass</span> <span class="special">&amp;</span><span class="identifier">a</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">MyClass</span> <span class="special">&amp;</span><span class="identifier">b</span><span class="special">)</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">a</span><span class="special">.</span><span class="identifier">int_</span> <span class="special">&gt;</span> <span class="identifier">b</span><span class="special">.</span><span class="identifier">int_</span><span class="special">;</span>  <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
   <span class="comment">//Create some ORDERED elements</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;</span> <span class="identifier">values</span><span class="special">;</span>
   <span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="number">100</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>  <span class="identifier">values</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">MyClass</span><span class="special">(</span><span class="identifier">i</span><span class="special">));</span>

   <span class="special">{</span>  <span class="comment">//Data is naturally ordered in the vector with the same criteria</span>
      <span class="comment">//as multiset's comparison predicate, so we can just push back</span>
      <span class="comment">//all elements, which is more efficient than normal insertion</span>
      <span class="identifier">multiset</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;</span> <span class="identifier">mset</span><span class="special">;</span>
      <span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="number">100</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>  <span class="identifier">mset</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">values</span><span class="special">[</span><span class="identifier">i</span><span class="special">]);</span>

      <span class="comment">//Now check orderd invariant</span>
      <span class="identifier">multiset</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span> <span class="identifier">next</span><span class="special">(</span><span class="identifier">mset</span><span class="special">.</span><span class="identifier">cbegin</span><span class="special">()),</span> <span class="identifier">it</span><span class="special">(</span><span class="identifier">next</span><span class="special">++);</span>
      <span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="number">99</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">,</span> <span class="special">++</span><span class="identifier">it</span><span class="special">,</span> <span class="special">++</span><span class="identifier">next</span><span class="special">)</span> <span class="identifier">assert</span><span class="special">(*</span><span class="identifier">it</span> <span class="special">&lt;</span> <span class="special">*</span><span class="identifier">next</span><span class="special">);</span>
   <span class="special">}</span>
   <span class="special">{</span>  <span class="comment">//Now the correct order for the set is the reverse order</span>
      <span class="comment">//so let's push front all elements</span>
      <span class="identifier">multiset</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">,</span> <span class="identifier">compare</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">greater</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">mset</span><span class="special">;</span>
      <span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="number">100</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>  <span class="identifier">mset</span><span class="special">.</span><span class="identifier">push_front</span><span class="special">(</span><span class="identifier">values</span><span class="special">[</span><span class="identifier">i</span><span class="special">]);</span>

      <span class="comment">//Now check orderd invariant</span>
      <span class="identifier">multiset</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">,</span> <span class="identifier">compare</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">greater</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;::</span>
         <span class="identifier">const_iterator</span> <span class="identifier">next</span><span class="special">(</span><span class="identifier">mset</span><span class="special">.</span><span class="identifier">cbegin</span><span class="special">()),</span> <span class="identifier">it</span><span class="special">(</span><span class="identifier">next</span><span class="special">++);</span>
      <span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="number">99</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">,</span> <span class="special">++</span><span class="identifier">it</span><span class="special">,</span> <span class="special">++</span><span class="identifier">next</span><span class="special">)</span> <span class="identifier">assert</span><span class="special">(*</span><span class="identifier">it</span> <span class="special">&gt;</span> <span class="special">*</span><span class="identifier">next</span><span class="special">);</span>
   <span class="special">}</span>
   <span class="special">{</span>  <span class="comment">//Now push the first and the last and insert the rest</span>
      <span class="comment">//before the last position using "insert_before"</span>
      <span class="identifier">multiset</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;</span> <span class="identifier">mset</span><span class="special">;</span>
      <span class="identifier">mset</span><span class="special">.</span><span class="identifier">insert_before</span><span class="special">(</span><span class="identifier">mset</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">values</span><span class="special">[</span><span class="number">0</span><span class="special">]);</span>
      <span class="identifier">multiset</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span> <span class="identifier">pos</span> <span class="special">=</span>
         <span class="identifier">mset</span><span class="special">.</span><span class="identifier">insert_before</span><span class="special">(</span><span class="identifier">mset</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">values</span><span class="special">[</span><span class="number">99</span><span class="special">]);</span>
      <span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="number">99</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>  <span class="identifier">mset</span><span class="special">.</span><span class="identifier">insert_before</span><span class="special">(</span><span class="identifier">pos</span><span class="special">,</span> <span class="identifier">values</span><span class="special">[</span><span class="identifier">i</span><span class="special">]);</span>

      <span class="comment">//Now check orderd invariant</span>
      <span class="identifier">multiset</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span> <span class="identifier">next</span><span class="special">(</span><span class="identifier">mset</span><span class="special">.</span><span class="identifier">cbegin</span><span class="special">()),</span> <span class="identifier">it</span><span class="special">(</span><span class="identifier">next</span><span class="special">++);</span>
      <span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="number">99</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">,</span> <span class="special">++</span><span class="identifier">it</span><span class="special">,</span> <span class="special">++</span><span class="identifier">next</span><span class="special">)</span> <span class="identifier">assert</span><span class="special">(*</span><span class="identifier">it</span> <span class="special">&lt;</span> <span class="special">*</span><span class="identifier">next</span><span class="special">);</span>
   <span class="special">}</span>

   <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<p>
      For more information about advanced lookup and insertion functions see associative
      containers' documentation (e.g. <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code>,
      <code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code>, <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code> and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code> references).
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2005 Olaf Krzikalla<br>Copyright &#169; 2006-2013 Ion Gaztanaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="treap_set_multiset.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../intrusive.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="erasing_and_disposing.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
