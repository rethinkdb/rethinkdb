<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ublas: banded.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>banded.hpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00002"></a>00002 <span class="comment">//  Copyright (c) 2000-2002</span>
<a name="l00003"></a>00003 <span class="comment">//  Joerg Walter, Mathias Koch</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">//  Distributed under the Boost Software License, Version 1.0. (See</span>
<a name="l00006"></a>00006 <span class="comment">//  accompanying file LICENSE_1_0.txt or copy at</span>
<a name="l00007"></a>00007 <span class="comment">//  http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">//  The authors gratefully acknowledge the support of</span>
<a name="l00010"></a>00010 <span class="comment">//  GeNeSys mbH &amp; Co. KG in producing this work.</span>
<a name="l00011"></a>00011 <span class="comment">//</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="preprocessor">#ifndef _BOOST_UBLAS_BANDED_</span>
<a name="l00014"></a>00014 <span class="preprocessor"></span><span class="preprocessor">#define _BOOST_UBLAS_BANDED_</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;boost/numeric/ublas/matrix.hpp&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;boost/numeric/ublas/detail/temporary.hpp&gt;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="comment">// Iterators based on ideas of Jeremy Siek</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="keyword">namespace </span>boost { <span class="keyword">namespace </span>numeric { <span class="keyword">namespace </span>ublas {
<a name="l00022"></a>00022 
<a name="l00035"></a>00035     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> L, <span class="keyword">class</span> A&gt;
<a name="l00036"></a><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html">00036</a>     <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">banded_matrix</a>:
<a name="l00037"></a>00037         <span class="keyword">public</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__container.html" title="Base class for Matrix container models.">matrix_container</a>&lt;banded_matrix&lt;T, L, A&gt; &gt; {
<a name="l00038"></a>00038 
<a name="l00039"></a>00039         <span class="keyword">typedef</span> T *pointer;
<a name="l00040"></a>00040         <span class="keyword">typedef</span> L layout_type;
<a name="l00041"></a>00041         <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">banded_matrix&lt;T, L, A&gt;</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>;
<a name="l00042"></a>00042     <span class="keyword">public</span>:
<a name="l00043"></a>00043 <span class="preprocessor">#ifdef BOOST_UBLAS_ENABLE_PROXY_SHORTCUTS</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>        <span class="keyword">using</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__container.html" title="Base class for Matrix container models.">matrix_container&lt;self_type&gt;::operator </a>();
<a name="l00045"></a>00045 <span class="preprocessor">#endif</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span>        <span class="keyword">typedef</span> <span class="keyword">typename</span> A::size_type size_type;
<a name="l00047"></a>00047         <span class="keyword">typedef</span> <span class="keyword">typename</span> A::difference_type difference_type;
<a name="l00048"></a>00048         <span class="keyword">typedef</span> T value_type;
<a name="l00049"></a>00049         <span class="keyword">typedef</span> <span class="keyword">const</span> T &amp;const_reference;
<a name="l00050"></a>00050         <span class="keyword">typedef</span> T &amp;reference;
<a name="l00051"></a>00051         <span class="keyword">typedef</span> A array_type;
<a name="l00052"></a>00052         <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__reference.html">matrix_reference&lt;const self_type&gt;</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__reference.html">const_closure_type</a>;
<a name="l00053"></a>00053         <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__reference.html">matrix_reference&lt;self_type&gt;</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__reference.html">closure_type</a>;
<a name="l00054"></a>00054         <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1vector.html" title="A dense vector of values of type T.">vector&lt;T, A&gt;</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1vector.html" title="A dense vector of values of type T.">vector_temporary_type</a>;
<a name="l00055"></a>00055         <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix.html" title="A dense matrix of values of type T.">matrix&lt;T, L, A&gt;</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix.html" title="A dense matrix of values of type T.">matrix_temporary_type</a>;  <span class="comment">// general sub-matrix</span>
<a name="l00056"></a>00056         <span class="keyword">typedef</span> <a class="code" href="structboost_1_1numeric_1_1ublas_1_1packed__tag.html">packed_tag</a> <a class="code" href="structboost_1_1numeric_1_1ublas_1_1packed__tag.html">storage_category</a>;
<a name="l00057"></a>00057         <span class="keyword">typedef</span> <span class="keyword">typename</span> L::orientation_category orientation_category;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059         <span class="comment">// Construction and destruction</span>
<a name="l00060"></a>00060         BOOST_UBLAS_INLINE
<a name="l00061"></a>00061         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">banded_matrix</a> ():
<a name="l00062"></a>00062             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__container.html" title="Base class for Matrix container models.">matrix_container&lt;self_type&gt;</a> (),
<a name="l00063"></a>00063             size1_ (0), size2_ (0),
<a name="l00064"></a>00064             lower_ (0), upper_ (0), data_ (0) {}
<a name="l00065"></a>00065         BOOST_UBLAS_INLINE
<a name="l00066"></a>00066         banded_matrix (size_type size1, size_type size2, size_type <a class="code" href="structboost_1_1numeric_1_1ublas_1_1basic__lower.html">lower</a> = 0, size_type <a class="code" href="structboost_1_1numeric_1_1ublas_1_1basic__upper.html">upper</a> = 0):
<a name="l00067"></a>00067             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__container.html" title="Base class for Matrix container models.">matrix_container&lt;self_type&gt;</a> (),
<a name="l00068"></a>00068             size1_ (size1), size2_ (size2),
<a name="l00069"></a>00069             lower_ (<a class="code" href="structboost_1_1numeric_1_1ublas_1_1basic__lower.html">lower</a>), upper_ (<a class="code" href="structboost_1_1numeric_1_1ublas_1_1basic__upper.html">upper</a>), data_ ((std::max) (size1, size2) * (<a class="code" href="structboost_1_1numeric_1_1ublas_1_1basic__lower.html">lower</a> + 1 + <a class="code" href="structboost_1_1numeric_1_1ublas_1_1basic__upper.html">upper</a>)) {
<a name="l00070"></a>00070         }
<a name="l00071"></a>00071         BOOST_UBLAS_INLINE
<a name="l00072"></a>00072         banded_matrix (size_type size1, size_type size2, size_type <a class="code" href="structboost_1_1numeric_1_1ublas_1_1basic__lower.html">lower</a>, size_type <a class="code" href="structboost_1_1numeric_1_1ublas_1_1basic__upper.html">upper</a>, <span class="keyword">const</span> array_type &amp;data):
<a name="l00073"></a>00073             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__container.html" title="Base class for Matrix container models.">matrix_container&lt;self_type&gt;</a> (),
<a name="l00074"></a>00074             size1_ (size1), size2_ (size2),
<a name="l00075"></a>00075             lower_ (lower), upper_ (upper), data_ (data) {}
<a name="l00076"></a>00076         BOOST_UBLAS_INLINE
<a name="l00077"></a>00077         banded_matrix (<span class="keyword">const</span> banded_matrix &amp;m):
<a name="l00078"></a>00078             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__container.html" title="Base class for Matrix container models.">matrix_container&lt;self_type&gt;</a> (),
<a name="l00079"></a>00079             size1_ (m.size1_), size2_ (m.size2_),
<a name="l00080"></a>00080             lower_ (m.lower_), upper_ (m.upper_), data_ (m.data_) {}
<a name="l00081"></a>00081         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l00082"></a>00082         BOOST_UBLAS_INLINE
<a name="l00083"></a>00083         banded_matrix (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae, size_type lower = 0, size_type upper = 0):
<a name="l00084"></a>00084             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__container.html" title="Base class for Matrix container models.">matrix_container&lt;self_type&gt;</a> (),
<a name="l00085"></a>00085             size1_ (ae ().size1 ()), size2_ (ae ().size2 ()),
<a name="l00086"></a>00086             lower_ (lower), upper_ (upper),
<a name="l00087"></a>00087             data_ ((std::max) (size1_, size2_) * (lower_ + 1 + upper_)) {
<a name="l00088"></a>00088             matrix_assign&lt;scalar_assign&gt; (*<span class="keyword">this</span>, ae);
<a name="l00089"></a>00089         }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091         <span class="comment">// Accessors</span>
<a name="l00092"></a>00092         BOOST_UBLAS_INLINE
<a name="l00093"></a>00093         size_type size1 ()<span class="keyword"> const </span>{
<a name="l00094"></a>00094             <span class="keywordflow">return</span> size1_;
<a name="l00095"></a>00095         }
<a name="l00096"></a>00096         BOOST_UBLAS_INLINE
<a name="l00097"></a>00097         size_type size2 ()<span class="keyword"> const </span>{
<a name="l00098"></a>00098             <span class="keywordflow">return</span> size2_;
<a name="l00099"></a>00099         }
<a name="l00100"></a>00100         BOOST_UBLAS_INLINE
<a name="l00101"></a>00101         size_type lower ()<span class="keyword"> const </span>{
<a name="l00102"></a>00102             <span class="keywordflow">return</span> lower_;
<a name="l00103"></a>00103         }
<a name="l00104"></a>00104         BOOST_UBLAS_INLINE
<a name="l00105"></a>00105         size_type upper ()<span class="keyword"> const </span>{
<a name="l00106"></a>00106             <span class="keywordflow">return</span> upper_;
<a name="l00107"></a>00107         }
<a name="l00108"></a>00108 
<a name="l00109"></a>00109         <span class="comment">// Storage accessors</span>
<a name="l00110"></a>00110         BOOST_UBLAS_INLINE
<a name="l00111"></a>00111         <span class="keyword">const</span> array_type &amp;data ()<span class="keyword"> const </span>{
<a name="l00112"></a>00112             <span class="keywordflow">return</span> data_;
<a name="l00113"></a>00113         }
<a name="l00114"></a>00114         BOOST_UBLAS_INLINE
<a name="l00115"></a>00115         array_type &amp;data () {
<a name="l00116"></a>00116             <span class="keywordflow">return</span> data_;
<a name="l00117"></a>00117         }
<a name="l00118"></a>00118 
<a name="l00119"></a>00119         <span class="comment">// Resizing</span>
<a name="l00120"></a>00120         BOOST_UBLAS_INLINE
<a name="l00121"></a>00121         <span class="keywordtype">void</span> resize (size_type size1, size_type size2, size_type lower = 0, size_type upper = 0, <span class="keywordtype">bool</span> preserve = <span class="keyword">true</span>) {
<a name="l00122"></a>00122             <span class="keywordflow">if</span> (preserve) {
<a name="l00123"></a>00123                 <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a> temporary (size1, size2, lower, upper);
<a name="l00124"></a>00124                 detail::matrix_resize_preserve&lt;layout_type&gt; (*<span class="keyword">this</span>, temporary);
<a name="l00125"></a>00125             }
<a name="l00126"></a>00126             <span class="keywordflow">else</span> {
<a name="l00127"></a>00127                 data ().resize ((std::max) (size1, size2) * (lower + 1 + upper));
<a name="l00128"></a>00128                 size1_ = size1;
<a name="l00129"></a>00129                 size2_ = size2;
<a name="l00130"></a>00130                 lower_ = lower;
<a name="l00131"></a>00131                 upper_ = upper;
<a name="l00132"></a>00132             }
<a name="l00133"></a>00133         }
<a name="l00134"></a>00134 
<a name="l00135"></a>00135         BOOST_UBLAS_INLINE
<a name="l00136"></a>00136         <span class="keywordtype">void</span> resize_packed_preserve (size_type size1, size_type size2, size_type lower = 0, size_type upper = 0) {
<a name="l00137"></a>00137             size1_ = size1;
<a name="l00138"></a>00138             size2_ = size2;
<a name="l00139"></a>00139             lower_ = lower;
<a name="l00140"></a>00140             upper_ = upper;
<a name="l00141"></a>00141             data ().resize ((std::max) (size1, size2) * (lower + 1 + upper), value_type ());
<a name="l00142"></a>00142         }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144         <span class="comment">// Element access</span>
<a name="l00145"></a>00145         BOOST_UBLAS_INLINE
<a name="l00146"></a>00146         const_reference operator () (size_type i, size_type j)<span class="keyword"> const </span>{
<a name="l00147"></a>00147             BOOST_UBLAS_CHECK (i &lt; size1_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l00148"></a>00148             BOOST_UBLAS_CHECK (j &lt; size2_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l00149"></a>00149 <span class="preprocessor">#ifdef BOOST_UBLAS_OWN_BANDED</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span>            <span class="keyword">const</span> size_type k = (std::max) (i, j);
<a name="l00151"></a>00151             <span class="keyword">const</span> size_type l = lower_ + j - i;
<a name="l00152"></a>00152             <span class="keywordflow">if</span> (k &lt; (std::max) (size1_, size2_) &amp;&amp;
<a name="l00153"></a>00153                 l &lt; lower_ + 1 + upper_)
<a name="l00154"></a>00154                 <span class="keywordflow">return</span> data () [layout_type::element (k, (std::max) (size1_, size2_),
<a name="l00155"></a>00155                                                        l, lower_ + 1 + upper_)];
<a name="l00156"></a>00156 <span class="preprocessor">#else</span>
<a name="l00157"></a>00157 <span class="preprocessor"></span>            <span class="keyword">const</span> size_type k = j;
<a name="l00158"></a>00158             <span class="keyword">const</span> size_type l = upper_ + i - j;
<a name="l00159"></a>00159             <span class="keywordflow">if</span> (k &lt; size2_ &amp;&amp;
<a name="l00160"></a>00160                 l &lt; lower_ + 1 + upper_)
<a name="l00161"></a>00161                 <span class="keywordflow">return</span> data () [layout_type::element (k, size2_,
<a name="l00162"></a>00162                                                        l, lower_ + 1 + upper_)];
<a name="l00163"></a>00163 <span class="preprocessor">#endif</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span>            <span class="keywordflow">return</span> zero_;
<a name="l00165"></a>00165         }
<a name="l00166"></a>00166         BOOST_UBLAS_INLINE
<a name="l00167"></a>00167         reference at_element (size_type i, size_type j) {
<a name="l00168"></a>00168             BOOST_UBLAS_CHECK (i &lt; size1_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l00169"></a>00169             BOOST_UBLAS_CHECK (j &lt; size2_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l00170"></a>00170 <span class="preprocessor">#ifdef BOOST_UBLAS_OWN_BANDED</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span>            <span class="keyword">const</span> size_type k = (std::max) (i, j);
<a name="l00172"></a>00172             <span class="keyword">const</span> size_type l = lower_ + j - i;
<a name="l00173"></a>00173             <span class="keywordflow">return</span> data () [layout_type::element (k, (std::max) (size1_, size2_),
<a name="l00174"></a>00174                                                    l, lower_ + 1 + upper_)];
<a name="l00175"></a>00175 <span class="preprocessor">#else</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span>            <span class="keyword">const</span> size_type k = j;
<a name="l00177"></a>00177             <span class="keyword">const</span> size_type l = upper_ + i - j;
<a name="l00178"></a>00178             <span class="keywordflow">return</span> data () [layout_type::element (k, size2_,
<a name="l00179"></a>00179                                                    l, lower_ + 1 + upper_)];
<a name="l00180"></a>00180 <span class="preprocessor">#endif</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span>        }
<a name="l00182"></a>00182         BOOST_UBLAS_INLINE
<a name="l00183"></a>00183         reference operator () (size_type i, size_type j) {
<a name="l00184"></a>00184             BOOST_UBLAS_CHECK (i &lt; size1_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l00185"></a>00185             BOOST_UBLAS_CHECK (j &lt; size2_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l00186"></a>00186 <span class="preprocessor">#ifdef BOOST_UBLAS_OWN_BANDED</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span>            <span class="keyword">const</span> size_type k = (std::max) (i, j);
<a name="l00188"></a>00188             <span class="keyword">const</span> size_type l = lower_ + j - i;
<a name="l00189"></a>00189             <span class="keywordflow">if</span> (! (k &lt; (std::max) (size1_, size2_) &amp;&amp;
<a name="l00190"></a>00190                   l &lt; lower_ + 1 + upper_) ) {
<a name="l00191"></a>00191                 <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ().raise ();
<a name="l00192"></a>00192                 <span class="comment">// NEVER reached</span>
<a name="l00193"></a>00193             }
<a name="l00194"></a>00194             <span class="keywordflow">return</span> data () [layout_type::element (k, (std::max) (size1_, size2_),
<a name="l00195"></a>00195                                                        l, lower_ + 1 + upper_)];
<a name="l00196"></a>00196 <span class="preprocessor">#else</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span>            <span class="keyword">const</span> size_type k = j;
<a name="l00198"></a>00198             <span class="keyword">const</span> size_type l = upper_ + i - j;
<a name="l00199"></a>00199             <span class="keywordflow">if</span> (! (k &lt; size2_ &amp;&amp;
<a name="l00200"></a>00200                    l &lt; lower_ + 1 + upper_) ) {
<a name="l00201"></a>00201                 <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ().raise ();
<a name="l00202"></a>00202                 <span class="comment">// NEVER reached</span>
<a name="l00203"></a>00203             }
<a name="l00204"></a>00204             <span class="keywordflow">return</span> data () [layout_type::element (k, size2_,
<a name="l00205"></a>00205                                                        l, lower_ + 1 + upper_)];
<a name="l00206"></a>00206 <span class="preprocessor">#endif</span>
<a name="l00207"></a>00207 <span class="preprocessor"></span>        }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209         <span class="comment">// Element assignment</span>
<a name="l00210"></a>00210         BOOST_UBLAS_INLINE
<a name="l00211"></a>00211         reference insert_element (size_type i, size_type j, const_reference t) {
<a name="l00212"></a>00212             <span class="keywordflow">return</span> (<span class="keyword">operator</span> () (i, j) = t);
<a name="l00213"></a>00213         }
<a name="l00214"></a>00214         BOOST_UBLAS_INLINE
<a name="l00215"></a>00215         <span class="keywordtype">void</span> erase_element (size_type i, size_type j) {
<a name="l00216"></a>00216             operator () (i, j) = value_type<span class="comment">/*zero*/</span>();
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         <span class="comment">// Zeroing</span>
<a name="l00220"></a>00220         BOOST_UBLAS_INLINE
<a name="l00221"></a>00221         <span class="keywordtype">void</span> clear () {
<a name="l00222"></a>00222             std::fill (data ().begin (), data ().end (), value_type<span class="comment">/*zero*/</span>());
<a name="l00223"></a>00223         }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225         <span class="comment">// Assignment</span>
<a name="l00226"></a>00226         BOOST_UBLAS_INLINE
<a name="l00227"></a>00227         banded_matrix &amp;operator = (<span class="keyword">const</span> banded_matrix &amp;m) {
<a name="l00228"></a>00228             size1_ = m.size1_;
<a name="l00229"></a>00229             size2_ = m.size2_;
<a name="l00230"></a>00230             lower_ = m.lower_;
<a name="l00231"></a>00231             upper_ = m.upper_;
<a name="l00232"></a>00232             data () = m.data ();
<a name="l00233"></a>00233             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00234"></a>00234         }
<a name="l00235"></a>00235         BOOST_UBLAS_INLINE
<a name="l00236"></a>00236         banded_matrix &amp;assign_temporary (banded_matrix &amp;m) {
<a name="l00237"></a>00237             swap (m);
<a name="l00238"></a>00238             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00239"></a>00239         }
<a name="l00240"></a>00240         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l00241"></a>00241         BOOST_UBLAS_INLINE
<a name="l00242"></a>00242         banded_matrix &amp;operator = (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l00243"></a>00243             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a> temporary (ae, lower_, upper_);
<a name="l00244"></a>00244             <span class="keywordflow">return</span> assign_temporary (temporary);
<a name="l00245"></a>00245         }
<a name="l00246"></a>00246         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l00247"></a>00247         BOOST_UBLAS_INLINE
<a name="l00248"></a>00248         banded_matrix &amp;assign (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l00249"></a>00249             matrix_assign&lt;scalar_assign&gt; (*<span class="keyword">this</span>, ae);
<a name="l00250"></a>00250             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00251"></a>00251         }
<a name="l00252"></a>00252         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l00253"></a>00253         BOOST_UBLAS_INLINE
<a name="l00254"></a>00254         banded_matrix&amp; operator += (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l00255"></a>00255             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a> temporary (*<span class="keyword">this</span> + ae, lower_, upper_);
<a name="l00256"></a>00256             <span class="keywordflow">return</span> assign_temporary (temporary);
<a name="l00257"></a>00257         }
<a name="l00258"></a>00258         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l00259"></a>00259         BOOST_UBLAS_INLINE
<a name="l00260"></a>00260         banded_matrix &amp;plus_assign (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l00261"></a>00261             matrix_assign&lt;scalar_plus_assign&gt; (*<span class="keyword">this</span>, ae);
<a name="l00262"></a>00262             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00263"></a>00263         }
<a name="l00264"></a>00264         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l00265"></a>00265         BOOST_UBLAS_INLINE
<a name="l00266"></a>00266         banded_matrix&amp; operator -= (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l00267"></a>00267             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a> temporary (*<span class="keyword">this</span> - ae, lower_, upper_);
<a name="l00268"></a>00268             <span class="keywordflow">return</span> assign_temporary (temporary);
<a name="l00269"></a>00269         }
<a name="l00270"></a>00270         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l00271"></a>00271         BOOST_UBLAS_INLINE
<a name="l00272"></a>00272         banded_matrix &amp;minus_assign (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l00273"></a>00273             matrix_assign&lt;scalar_minus_assign&gt; (*<span class="keyword">this</span>, ae);
<a name="l00274"></a>00274             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AT&gt;
<a name="l00277"></a>00277         BOOST_UBLAS_INLINE
<a name="l00278"></a>00278         banded_matrix&amp; operator *= (<span class="keyword">const</span> AT &amp;at) {
<a name="l00279"></a>00279             matrix_assign_scalar&lt;scalar_multiplies_assign&gt; (*<span class="keyword">this</span>, at);
<a name="l00280"></a>00280             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00281"></a>00281         }
<a name="l00282"></a>00282         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AT&gt;
<a name="l00283"></a>00283         BOOST_UBLAS_INLINE
<a name="l00284"></a>00284         banded_matrix&amp; operator /= (<span class="keyword">const</span> AT &amp;at) {
<a name="l00285"></a>00285             matrix_assign_scalar&lt;scalar_divides_assign&gt; (*<span class="keyword">this</span>, at);
<a name="l00286"></a>00286             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00287"></a>00287         }
<a name="l00288"></a>00288 
<a name="l00289"></a>00289         <span class="comment">// Swapping</span>
<a name="l00290"></a>00290         BOOST_UBLAS_INLINE
<a name="l00291"></a>00291         <span class="keywordtype">void</span> swap (banded_matrix &amp;m) {
<a name="l00292"></a>00292             <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;m) {
<a name="l00293"></a>00293                 std::swap (size1_, m.size1_);
<a name="l00294"></a>00294                 std::swap (size2_, m.size2_);
<a name="l00295"></a>00295                 std::swap (lower_, m.lower_);
<a name="l00296"></a>00296                 std::swap (upper_, m.upper_);
<a name="l00297"></a>00297                 data ().swap (m.data ());
<a name="l00298"></a>00298             }
<a name="l00299"></a>00299         }
<a name="l00300"></a>00300         BOOST_UBLAS_INLINE
<a name="l00301"></a>00301         <span class="keyword">friend</span> <span class="keywordtype">void</span> swap (banded_matrix &amp;m1, banded_matrix &amp;m2) {
<a name="l00302"></a>00302             m1.swap (m2);
<a name="l00303"></a>00303         }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305         <span class="comment">// Iterator types</span>
<a name="l00306"></a>00306 <span class="preprocessor">#ifdef BOOST_UBLAS_USE_INDEXED_ITERATOR</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span>        <span class="keyword">typedef</span> indexed_iterator1&lt;self_type, packed_random_access_iterator_tag&gt; <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator1.html">iterator1</a>;
<a name="l00308"></a>00308         <span class="keyword">typedef</span> indexed_iterator2&lt;self_type, packed_random_access_iterator_tag&gt; <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator2.html">iterator2</a>;
<a name="l00309"></a>00309         <span class="keyword">typedef</span> indexed_const_iterator1&lt;self_type, packed_random_access_iterator_tag&gt; <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator1.html">const_iterator1</a>;
<a name="l00310"></a>00310         <span class="keyword">typedef</span> indexed_const_iterator2&lt;self_type, packed_random_access_iterator_tag&gt; <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator2.html">const_iterator2</a>;
<a name="l00311"></a>00311 <span class="preprocessor">#else</span>
<a name="l00312"></a>00312 <span class="preprocessor"></span>        <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator1.html">const_iterator1</a>;
<a name="l00313"></a>00313         <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator1.html">iterator1</a>;
<a name="l00314"></a>00314         <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator2.html">const_iterator2</a>;
<a name="l00315"></a>00315         <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator2.html">iterator2</a>;
<a name="l00316"></a>00316 <span class="preprocessor">#endif</span>
<a name="l00317"></a>00317 <span class="preprocessor"></span>        <span class="keyword">typedef</span> reverse_iterator_base1&lt;const_iterator1&gt; const_reverse_iterator1;
<a name="l00318"></a>00318         <span class="keyword">typedef</span> reverse_iterator_base1&lt;iterator1&gt; reverse_iterator1;
<a name="l00319"></a>00319         <span class="keyword">typedef</span> reverse_iterator_base2&lt;const_iterator2&gt; const_reverse_iterator2;
<a name="l00320"></a>00320         <span class="keyword">typedef</span> reverse_iterator_base2&lt;iterator2&gt; reverse_iterator2;
<a name="l00321"></a>00321 
<a name="l00322"></a>00322         <span class="comment">// Element lookup</span>
<a name="l00323"></a>00323         BOOST_UBLAS_INLINE
<a name="l00324"></a>00324         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator1.html">const_iterator1</a> find1 (<span class="keywordtype">int</span> rank, size_type i, size_type j)<span class="keyword"> const </span>{
<a name="l00325"></a>00325             <span class="keywordflow">if</span> (rank == 1) {
<a name="l00326"></a>00326                 size_type lower_i = (std::max) (difference_type (j - upper_), difference_type (0));
<a name="l00327"></a>00327                 i = (std::max) (i, lower_i);
<a name="l00328"></a>00328                 size_type upper_i = (std::min) (j + 1 + lower_, size1_);
<a name="l00329"></a>00329                 i = (std::min) (i, upper_i);
<a name="l00330"></a>00330             }
<a name="l00331"></a>00331             <span class="keywordflow">return</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator1.html">const_iterator1</a> (*<span class="keyword">this</span>, i, j);
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333         BOOST_UBLAS_INLINE
<a name="l00334"></a>00334         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator1.html">iterator1</a> find1 (<span class="keywordtype">int</span> rank, size_type i, size_type j) {
<a name="l00335"></a>00335             <span class="keywordflow">if</span> (rank == 1) {
<a name="l00336"></a>00336                 size_type lower_i = (std::max) (difference_type (j - upper_), difference_type (0));
<a name="l00337"></a>00337                 i = (std::max) (i, lower_i);
<a name="l00338"></a>00338                 size_type upper_i = (std::min) (j + 1 + lower_, size1_);
<a name="l00339"></a>00339                 i = (std::min) (i, upper_i);
<a name="l00340"></a>00340             }
<a name="l00341"></a>00341             <span class="keywordflow">return</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator1.html">iterator1</a> (*<span class="keyword">this</span>, i, j);
<a name="l00342"></a>00342         }
<a name="l00343"></a>00343         BOOST_UBLAS_INLINE
<a name="l00344"></a>00344         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator2.html">const_iterator2</a> find2 (<span class="keywordtype">int</span> rank, size_type i, size_type j)<span class="keyword"> const </span>{
<a name="l00345"></a>00345             <span class="keywordflow">if</span> (rank == 1) {
<a name="l00346"></a>00346                 size_type lower_j = (std::max) (difference_type (i - lower_), difference_type (0));
<a name="l00347"></a>00347                 j = (std::max) (j, lower_j);
<a name="l00348"></a>00348                 size_type upper_j = (std::min) (i + 1 + upper_, size2_);
<a name="l00349"></a>00349                 j = (std::min) (j, upper_j);
<a name="l00350"></a>00350             }
<a name="l00351"></a>00351             <span class="keywordflow">return</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator2.html">const_iterator2</a> (*<span class="keyword">this</span>, i, j);
<a name="l00352"></a>00352         }
<a name="l00353"></a>00353         BOOST_UBLAS_INLINE
<a name="l00354"></a>00354         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator2.html">iterator2</a> find2 (<span class="keywordtype">int</span> rank, size_type i, size_type j) {
<a name="l00355"></a>00355             <span class="keywordflow">if</span> (rank == 1) {
<a name="l00356"></a>00356                 size_type lower_j = (std::max) (difference_type (i - lower_), difference_type (0));
<a name="l00357"></a>00357                 j = (std::max) (j, lower_j);
<a name="l00358"></a>00358                 size_type upper_j = (std::min) (i + 1 + upper_, size2_);
<a name="l00359"></a>00359                 j = (std::min) (j, upper_j);
<a name="l00360"></a>00360             }
<a name="l00361"></a>00361             <span class="keywordflow">return</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator2.html">iterator2</a> (*<span class="keyword">this</span>, i, j);
<a name="l00362"></a>00362         }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364         <span class="comment">// Iterators simply are indices.</span>
<a name="l00365"></a>00365 
<a name="l00366"></a>00366 <span class="preprocessor">#ifndef BOOST_UBLAS_USE_INDEXED_ITERATOR</span>
<a name="l00367"></a><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator1.html">00367</a> <span class="preprocessor"></span>        <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator1.html">const_iterator1</a>:
<a name="l00368"></a>00368             <span class="keyword">public</span> container_const_reference&lt;banded_matrix&gt;,
<a name="l00369"></a>00369             <span class="keyword">public</span> random_access_iterator_base&lt;packed_random_access_iterator_tag,
<a name="l00370"></a>00370                                                const_iterator1, value_type&gt; {
<a name="l00371"></a>00371         <span class="keyword">public</span>:
<a name="l00372"></a>00372             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::value_type value_type;
<a name="l00373"></a>00373             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::difference_type difference_type;
<a name="l00374"></a>00374             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::const_reference reference;
<a name="l00375"></a>00375             <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">typename</span> banded_matrix::pointer pointer;
<a name="l00376"></a>00376 
<a name="l00377"></a>00377             <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator2.html">const_iterator2</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator2.html">dual_iterator_type</a>;
<a name="l00378"></a>00378             <span class="keyword">typedef</span> const_reverse_iterator2 dual_reverse_iterator_type;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380             <span class="comment">// Construction and destruction</span>
<a name="l00381"></a>00381             BOOST_UBLAS_INLINE
<a name="l00382"></a>00382             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator1.html">const_iterator1</a> ():
<a name="l00383"></a>00383                 container_const_reference&lt;self_type&gt; (), it1_ (), it2_ () {}
<a name="l00384"></a>00384             BOOST_UBLAS_INLINE
<a name="l00385"></a>00385             const_iterator1 (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a> &amp;m, size_type it1, size_type it2):
<a name="l00386"></a>00386                 container_const_reference&lt;self_type&gt; (m), it1_ (it1), it2_ (it2) {}
<a name="l00387"></a>00387             BOOST_UBLAS_INLINE
<a name="l00388"></a>00388             const_iterator1 (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator1.html">iterator1</a> &amp;it):
<a name="l00389"></a>00389                 container_const_reference&lt;self_type&gt; (it ()), it1_ (it.it1_), it2_ (it.it2_) {}
<a name="l00390"></a>00390 
<a name="l00391"></a>00391             <span class="comment">// Arithmetic</span>
<a name="l00392"></a>00392             BOOST_UBLAS_INLINE
<a name="l00393"></a>00393             const_iterator1 &amp;operator ++ () {
<a name="l00394"></a>00394                 ++ it1_;
<a name="l00395"></a>00395                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00396"></a>00396             }
<a name="l00397"></a>00397             BOOST_UBLAS_INLINE
<a name="l00398"></a>00398             const_iterator1 &amp;operator -- () {
<a name="l00399"></a>00399                 -- it1_;
<a name="l00400"></a>00400                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00401"></a>00401             }
<a name="l00402"></a>00402             BOOST_UBLAS_INLINE
<a name="l00403"></a>00403             const_iterator1 &amp;operator += (difference_type n) {
<a name="l00404"></a>00404                 it1_ += n;
<a name="l00405"></a>00405                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00406"></a>00406             }
<a name="l00407"></a>00407             BOOST_UBLAS_INLINE
<a name="l00408"></a>00408             const_iterator1 &amp;operator -= (difference_type n) {
<a name="l00409"></a>00409                 it1_ -= n;
<a name="l00410"></a>00410                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00411"></a>00411             }
<a name="l00412"></a>00412             BOOST_UBLAS_INLINE
<a name="l00413"></a>00413             difference_type operator - (<span class="keyword">const</span> const_iterator1 &amp;it)<span class="keyword"> const </span>{
<a name="l00414"></a>00414                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00415"></a>00415                 BOOST_UBLAS_CHECK (it2_ == it.it2_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00416"></a>00416                 <span class="keywordflow">return</span> it1_ - it.it1_;
<a name="l00417"></a>00417             }
<a name="l00418"></a>00418 
<a name="l00419"></a>00419             <span class="comment">// Dereference</span>
<a name="l00420"></a>00420             BOOST_UBLAS_INLINE
<a name="l00421"></a>00421             const_reference operator * ()<span class="keyword"> const </span>{
<a name="l00422"></a>00422                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) () (it1_, it2_);
<a name="l00423"></a>00423             }
<a name="l00424"></a>00424             BOOST_UBLAS_INLINE
<a name="l00425"></a>00425             const_reference operator [] (difference_type n)<span class="keyword"> const </span>{
<a name="l00426"></a>00426                 <span class="keywordflow">return</span> *(*<span class="keyword">this</span> + n);
<a name="l00427"></a>00427             }
<a name="l00428"></a>00428 
<a name="l00429"></a>00429 <span class="preprocessor">#ifndef BOOST_UBLAS_NO_NESTED_CLASS_RELATION</span>
<a name="l00430"></a>00430 <span class="preprocessor"></span>            BOOST_UBLAS_INLINE
<a name="l00431"></a>00431 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00432"></a>00432 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00433"></a>00433 <span class="preprocessor">#endif</span>
<a name="l00434"></a>00434 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator2.html">const_iterator2</a> begin ()<span class="keyword"> const </span>{
<a name="l00435"></a>00435                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find2 (1, it1_, 0);
<a name="l00436"></a>00436             }
<a name="l00437"></a>00437             BOOST_UBLAS_INLINE
<a name="l00438"></a>00438 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00439"></a>00439 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00440"></a>00440 <span class="preprocessor">#endif</span>
<a name="l00441"></a>00441 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator2.html">const_iterator2</a> end ()<span class="keyword"> const </span>{
<a name="l00442"></a>00442                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find2 (1, it1_, (*<span class="keyword">this</span>) ().size2 ());
<a name="l00443"></a>00443             }
<a name="l00444"></a>00444             BOOST_UBLAS_INLINE
<a name="l00445"></a>00445 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00446"></a>00446 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00447"></a>00447 <span class="preprocessor">#endif</span>
<a name="l00448"></a>00448 <span class="preprocessor"></span>            const_reverse_iterator2 rbegin ()<span class="keyword"> const </span>{
<a name="l00449"></a>00449                 <span class="keywordflow">return</span> const_reverse_iterator2 (end ());
<a name="l00450"></a>00450             }
<a name="l00451"></a>00451             BOOST_UBLAS_INLINE
<a name="l00452"></a>00452 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00453"></a>00453 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00454"></a>00454 <span class="preprocessor">#endif</span>
<a name="l00455"></a>00455 <span class="preprocessor"></span>            const_reverse_iterator2 rend ()<span class="keyword"> const </span>{
<a name="l00456"></a>00456                 <span class="keywordflow">return</span> const_reverse_iterator2 (begin ());
<a name="l00457"></a>00457             }
<a name="l00458"></a>00458 <span class="preprocessor">#endif</span>
<a name="l00459"></a>00459 <span class="preprocessor"></span>
<a name="l00460"></a>00460             <span class="comment">// Indices</span>
<a name="l00461"></a>00461             BOOST_UBLAS_INLINE
<a name="l00462"></a>00462             size_type index1 ()<span class="keyword"> const </span>{
<a name="l00463"></a>00463                 <span class="keywordflow">return</span> it1_;
<a name="l00464"></a>00464             }
<a name="l00465"></a>00465             BOOST_UBLAS_INLINE
<a name="l00466"></a>00466             size_type index2 ()<span class="keyword"> const </span>{
<a name="l00467"></a>00467                 <span class="keywordflow">return</span> it2_;
<a name="l00468"></a>00468             }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470             <span class="comment">// Assignment</span>
<a name="l00471"></a>00471             BOOST_UBLAS_INLINE
<a name="l00472"></a>00472             const_iterator1 &amp;operator = (<span class="keyword">const</span> const_iterator1 &amp;it) {
<a name="l00473"></a>00473                 container_const_reference&lt;self_type&gt;::assign (&amp;it ());
<a name="l00474"></a>00474                 it1_ = it.it1_;
<a name="l00475"></a>00475                 it2_ = it.it2_;
<a name="l00476"></a>00476                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00477"></a>00477             }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479             <span class="comment">// Comparison</span>
<a name="l00480"></a>00480             BOOST_UBLAS_INLINE
<a name="l00481"></a>00481             <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> const_iterator1 &amp;it)<span class="keyword"> const </span>{
<a name="l00482"></a>00482                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00483"></a>00483                 BOOST_UBLAS_CHECK (it2_ == it.it2_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00484"></a>00484                 <span class="keywordflow">return</span> it1_ == it.it1_;
<a name="l00485"></a>00485             }
<a name="l00486"></a>00486             BOOST_UBLAS_INLINE
<a name="l00487"></a>00487             <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> const_iterator1 &amp;it)<span class="keyword"> const </span>{
<a name="l00488"></a>00488                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00489"></a>00489                 BOOST_UBLAS_CHECK (it2_ == it.it2_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00490"></a>00490                 <span class="keywordflow">return</span> it1_ &lt; it.it1_;
<a name="l00491"></a>00491             }
<a name="l00492"></a>00492 
<a name="l00493"></a>00493         <span class="keyword">private</span>:
<a name="l00494"></a>00494             size_type it1_;
<a name="l00495"></a>00495             size_type it2_;
<a name="l00496"></a>00496         };
<a name="l00497"></a>00497 <span class="preprocessor">#endif</span>
<a name="l00498"></a>00498 <span class="preprocessor"></span>
<a name="l00499"></a>00499         BOOST_UBLAS_INLINE
<a name="l00500"></a>00500         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator1.html">const_iterator1</a> begin1 ()<span class="keyword"> const </span>{
<a name="l00501"></a>00501             <span class="keywordflow">return</span> find1 (0, 0, 0);
<a name="l00502"></a>00502         }
<a name="l00503"></a>00503         BOOST_UBLAS_INLINE
<a name="l00504"></a>00504         const_iterator1 end1 ()<span class="keyword"> const </span>{
<a name="l00505"></a>00505             <span class="keywordflow">return</span> find1 (0, size1_, 0);
<a name="l00506"></a>00506         }
<a name="l00507"></a>00507 
<a name="l00508"></a>00508 <span class="preprocessor">#ifndef BOOST_UBLAS_USE_INDEXED_ITERATOR</span>
<a name="l00509"></a><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator1.html">00509</a> <span class="preprocessor"></span>        <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator1.html">iterator1</a>:
<a name="l00510"></a>00510             <span class="keyword">public</span> container_reference&lt;banded_matrix&gt;,
<a name="l00511"></a>00511             <span class="keyword">public</span> random_access_iterator_base&lt;packed_random_access_iterator_tag,
<a name="l00512"></a>00512                                                iterator1, value_type&gt; {
<a name="l00513"></a>00513         <span class="keyword">public</span>:
<a name="l00514"></a>00514             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::value_type value_type;
<a name="l00515"></a>00515             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::difference_type difference_type;
<a name="l00516"></a>00516             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::reference reference;
<a name="l00517"></a>00517             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::pointer pointer;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519             <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator2.html">iterator2</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator2.html">dual_iterator_type</a>;
<a name="l00520"></a>00520             <span class="keyword">typedef</span> reverse_iterator2 dual_reverse_iterator_type;
<a name="l00521"></a>00521 
<a name="l00522"></a>00522             <span class="comment">// Construction and destruction</span>
<a name="l00523"></a>00523             BOOST_UBLAS_INLINE
<a name="l00524"></a>00524             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator1.html">iterator1</a> ():
<a name="l00525"></a>00525                 container_reference&lt;self_type&gt; (), it1_ (), it2_ () {}
<a name="l00526"></a>00526             BOOST_UBLAS_INLINE
<a name="l00527"></a>00527             iterator1 (<a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a> &amp;m, size_type it1, size_type it2):
<a name="l00528"></a>00528                 container_reference&lt;self_type&gt; (m), it1_ (it1), it2_ (it2) {}
<a name="l00529"></a>00529 
<a name="l00530"></a>00530             <span class="comment">// Arithmetic</span>
<a name="l00531"></a>00531             BOOST_UBLAS_INLINE
<a name="l00532"></a>00532             iterator1 &amp;operator ++ () {
<a name="l00533"></a>00533                 ++ it1_;
<a name="l00534"></a>00534                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00535"></a>00535             }
<a name="l00536"></a>00536             BOOST_UBLAS_INLINE
<a name="l00537"></a>00537             iterator1 &amp;operator -- () {
<a name="l00538"></a>00538                 -- it1_;
<a name="l00539"></a>00539                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00540"></a>00540             }
<a name="l00541"></a>00541             BOOST_UBLAS_INLINE
<a name="l00542"></a>00542             iterator1 &amp;operator += (difference_type n) {
<a name="l00543"></a>00543                 it1_ += n;
<a name="l00544"></a>00544                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00545"></a>00545             }
<a name="l00546"></a>00546             BOOST_UBLAS_INLINE
<a name="l00547"></a>00547             iterator1 &amp;operator -= (difference_type n) {
<a name="l00548"></a>00548                 it1_ -= n;
<a name="l00549"></a>00549                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00550"></a>00550             }
<a name="l00551"></a>00551             BOOST_UBLAS_INLINE
<a name="l00552"></a>00552             difference_type operator - (<span class="keyword">const</span> iterator1 &amp;it)<span class="keyword"> const </span>{
<a name="l00553"></a>00553                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00554"></a>00554                 BOOST_UBLAS_CHECK (it2_ == it.it2_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00555"></a>00555                 <span class="keywordflow">return</span> it1_ - it.it1_;
<a name="l00556"></a>00556             }
<a name="l00557"></a>00557 
<a name="l00558"></a>00558             <span class="comment">// Dereference</span>
<a name="l00559"></a>00559             BOOST_UBLAS_INLINE
<a name="l00560"></a>00560             reference operator * ()<span class="keyword"> const </span>{
<a name="l00561"></a>00561                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().at_element (it1_, it2_);
<a name="l00562"></a>00562             }
<a name="l00563"></a>00563             BOOST_UBLAS_INLINE
<a name="l00564"></a>00564             reference operator [] (difference_type n)<span class="keyword"> const </span>{
<a name="l00565"></a>00565                 <span class="keywordflow">return</span> *(*<span class="keyword">this</span> + n);
<a name="l00566"></a>00566             }
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 <span class="preprocessor">#ifndef BOOST_UBLAS_NO_NESTED_CLASS_RELATION</span>
<a name="l00569"></a>00569 <span class="preprocessor"></span>            BOOST_UBLAS_INLINE
<a name="l00570"></a>00570 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00571"></a>00571 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00572"></a>00572 <span class="preprocessor">#endif</span>
<a name="l00573"></a>00573 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator2.html">iterator2</a> begin ()<span class="keyword"> const </span>{
<a name="l00574"></a>00574                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find2 (1, it1_, 0);
<a name="l00575"></a>00575             }
<a name="l00576"></a>00576             BOOST_UBLAS_INLINE
<a name="l00577"></a>00577 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00578"></a>00578 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00579"></a>00579 <span class="preprocessor">#endif</span>
<a name="l00580"></a>00580 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator2.html">iterator2</a> end ()<span class="keyword"> const </span>{
<a name="l00581"></a>00581                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find2 (1, it1_, (*<span class="keyword">this</span>) ().size2 ());
<a name="l00582"></a>00582             }
<a name="l00583"></a>00583             BOOST_UBLAS_INLINE
<a name="l00584"></a>00584 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00585"></a>00585 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00586"></a>00586 <span class="preprocessor">#endif</span>
<a name="l00587"></a>00587 <span class="preprocessor"></span>            reverse_iterator2 rbegin ()<span class="keyword"> const </span>{
<a name="l00588"></a>00588                 <span class="keywordflow">return</span> reverse_iterator2 (end ());
<a name="l00589"></a>00589             }
<a name="l00590"></a>00590             BOOST_UBLAS_INLINE
<a name="l00591"></a>00591 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00592"></a>00592 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00593"></a>00593 <span class="preprocessor">#endif</span>
<a name="l00594"></a>00594 <span class="preprocessor"></span>            reverse_iterator2 rend ()<span class="keyword"> const </span>{
<a name="l00595"></a>00595                 <span class="keywordflow">return</span> reverse_iterator2 (begin ());
<a name="l00596"></a>00596             }
<a name="l00597"></a>00597 <span class="preprocessor">#endif</span>
<a name="l00598"></a>00598 <span class="preprocessor"></span>
<a name="l00599"></a>00599             <span class="comment">// Indices</span>
<a name="l00600"></a>00600             BOOST_UBLAS_INLINE
<a name="l00601"></a>00601             size_type index1 ()<span class="keyword"> const </span>{
<a name="l00602"></a>00602                 <span class="keywordflow">return</span> it1_;
<a name="l00603"></a>00603             }
<a name="l00604"></a>00604             BOOST_UBLAS_INLINE
<a name="l00605"></a>00605             size_type index2 ()<span class="keyword"> const </span>{
<a name="l00606"></a>00606                 <span class="keywordflow">return</span> it2_;
<a name="l00607"></a>00607             }
<a name="l00608"></a>00608 
<a name="l00609"></a>00609             <span class="comment">// Assignment</span>
<a name="l00610"></a>00610             BOOST_UBLAS_INLINE
<a name="l00611"></a>00611             iterator1 &amp;operator = (<span class="keyword">const</span> iterator1 &amp;it) {
<a name="l00612"></a>00612                 container_reference&lt;self_type&gt;::assign (&amp;it ());
<a name="l00613"></a>00613                 it1_ = it.it1_;
<a name="l00614"></a>00614                 it2_ = it.it2_;
<a name="l00615"></a>00615                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00616"></a>00616             }
<a name="l00617"></a>00617 
<a name="l00618"></a>00618             <span class="comment">// Comparison</span>
<a name="l00619"></a>00619             BOOST_UBLAS_INLINE
<a name="l00620"></a>00620             <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> iterator1 &amp;it)<span class="keyword"> const </span>{
<a name="l00621"></a>00621                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00622"></a>00622                 BOOST_UBLAS_CHECK (it2_ == it.it2_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00623"></a>00623                 <span class="keywordflow">return</span> it1_ == it.it1_;
<a name="l00624"></a>00624             }
<a name="l00625"></a>00625             BOOST_UBLAS_INLINE
<a name="l00626"></a>00626             <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> iterator1 &amp;it)<span class="keyword"> const </span>{
<a name="l00627"></a>00627                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00628"></a>00628                 BOOST_UBLAS_CHECK (it2_ == it.it2_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00629"></a>00629                 <span class="keywordflow">return</span> it1_ &lt; it.it1_;
<a name="l00630"></a>00630             }
<a name="l00631"></a>00631 
<a name="l00632"></a>00632         <span class="keyword">private</span>:
<a name="l00633"></a>00633             size_type it1_;
<a name="l00634"></a>00634             size_type it2_;
<a name="l00635"></a>00635 
<a name="l00636"></a>00636             <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator1.html">const_iterator1</a>;
<a name="l00637"></a>00637         };
<a name="l00638"></a>00638 <span class="preprocessor">#endif</span>
<a name="l00639"></a>00639 <span class="preprocessor"></span>
<a name="l00640"></a>00640         BOOST_UBLAS_INLINE
<a name="l00641"></a>00641         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator1.html">iterator1</a> begin1 () {
<a name="l00642"></a>00642             <span class="keywordflow">return</span> find1 (0, 0, 0);
<a name="l00643"></a>00643         }
<a name="l00644"></a>00644         BOOST_UBLAS_INLINE
<a name="l00645"></a>00645         iterator1 end1 () {
<a name="l00646"></a>00646             <span class="keywordflow">return</span> find1 (0, size1_, 0);
<a name="l00647"></a>00647         }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 <span class="preprocessor">#ifndef BOOST_UBLAS_USE_INDEXED_ITERATOR</span>
<a name="l00650"></a><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator2.html">00650</a> <span class="preprocessor"></span>        <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator2.html">const_iterator2</a>:
<a name="l00651"></a>00651             <span class="keyword">public</span> container_const_reference&lt;banded_matrix&gt;,
<a name="l00652"></a>00652             <span class="keyword">public</span> random_access_iterator_base&lt;packed_random_access_iterator_tag,
<a name="l00653"></a>00653                                                const_iterator2, value_type&gt; {
<a name="l00654"></a>00654         <span class="keyword">public</span>:
<a name="l00655"></a>00655             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::value_type value_type;
<a name="l00656"></a>00656             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::difference_type difference_type;
<a name="l00657"></a>00657             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::const_reference reference;
<a name="l00658"></a>00658             <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">typename</span> banded_matrix::pointer pointer;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660             <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator1.html">const_iterator1</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator1.html">dual_iterator_type</a>;
<a name="l00661"></a>00661             <span class="keyword">typedef</span> const_reverse_iterator1 dual_reverse_iterator_type;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663             <span class="comment">// Construction and destruction</span>
<a name="l00664"></a>00664             BOOST_UBLAS_INLINE
<a name="l00665"></a>00665             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator2.html">const_iterator2</a> ():
<a name="l00666"></a>00666                 container_const_reference&lt;self_type&gt; (), it1_ (), it2_ () {}
<a name="l00667"></a>00667             BOOST_UBLAS_INLINE
<a name="l00668"></a>00668             const_iterator2 (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a> &amp;m, size_type it1, size_type it2):
<a name="l00669"></a>00669                 container_const_reference&lt;self_type&gt; (m), it1_ (it1), it2_ (it2) {}
<a name="l00670"></a>00670             BOOST_UBLAS_INLINE
<a name="l00671"></a>00671             const_iterator2 (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator2.html">iterator2</a> &amp;it):
<a name="l00672"></a>00672                 container_const_reference&lt;self_type&gt; (it ()), it1_ (it.it1_), it2_ (it.it2_) {}
<a name="l00673"></a>00673 
<a name="l00674"></a>00674             <span class="comment">// Arithmetic</span>
<a name="l00675"></a>00675             BOOST_UBLAS_INLINE
<a name="l00676"></a>00676             const_iterator2 &amp;operator ++ () {
<a name="l00677"></a>00677                 ++ it2_;
<a name="l00678"></a>00678                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00679"></a>00679             }
<a name="l00680"></a>00680             BOOST_UBLAS_INLINE
<a name="l00681"></a>00681             const_iterator2 &amp;operator -- () {
<a name="l00682"></a>00682                 -- it2_;
<a name="l00683"></a>00683                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00684"></a>00684             }
<a name="l00685"></a>00685             BOOST_UBLAS_INLINE
<a name="l00686"></a>00686             const_iterator2 &amp;operator += (difference_type n) {
<a name="l00687"></a>00687                 it2_ += n;
<a name="l00688"></a>00688                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00689"></a>00689             }
<a name="l00690"></a>00690             BOOST_UBLAS_INLINE
<a name="l00691"></a>00691             const_iterator2 &amp;operator -= (difference_type n) {
<a name="l00692"></a>00692                 it2_ -= n;
<a name="l00693"></a>00693                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00694"></a>00694             }
<a name="l00695"></a>00695             BOOST_UBLAS_INLINE
<a name="l00696"></a>00696             difference_type operator - (<span class="keyword">const</span> const_iterator2 &amp;it)<span class="keyword"> const </span>{
<a name="l00697"></a>00697                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00698"></a>00698                 BOOST_UBLAS_CHECK (it1_ == it.it1_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00699"></a>00699                 <span class="keywordflow">return</span> it2_ - it.it2_;
<a name="l00700"></a>00700             }
<a name="l00701"></a>00701 
<a name="l00702"></a>00702             <span class="comment">// Dereference</span>
<a name="l00703"></a>00703             BOOST_UBLAS_INLINE
<a name="l00704"></a>00704             const_reference operator * ()<span class="keyword"> const </span>{
<a name="l00705"></a>00705                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) () (it1_, it2_);
<a name="l00706"></a>00706             }
<a name="l00707"></a>00707             BOOST_UBLAS_INLINE
<a name="l00708"></a>00708             const_reference operator [] (difference_type n)<span class="keyword"> const </span>{
<a name="l00709"></a>00709                 <span class="keywordflow">return</span> *(*<span class="keyword">this</span> + n);
<a name="l00710"></a>00710             }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712 <span class="preprocessor">#ifndef BOOST_UBLAS_NO_NESTED_CLASS_RELATION</span>
<a name="l00713"></a>00713 <span class="preprocessor"></span>            BOOST_UBLAS_INLINE
<a name="l00714"></a>00714 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00715"></a>00715 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00716"></a>00716 <span class="preprocessor">#endif</span>
<a name="l00717"></a>00717 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator1.html">const_iterator1</a> begin ()<span class="keyword"> const </span>{
<a name="l00718"></a>00718                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find1 (1, 0, it2_);
<a name="l00719"></a>00719             }
<a name="l00720"></a>00720             BOOST_UBLAS_INLINE
<a name="l00721"></a>00721 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00722"></a>00722 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00723"></a>00723 <span class="preprocessor">#endif</span>
<a name="l00724"></a>00724 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator1.html">const_iterator1</a> end ()<span class="keyword"> const </span>{
<a name="l00725"></a>00725                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find1 (1, (*<span class="keyword">this</span>) ().size1 (), it2_);
<a name="l00726"></a>00726             }
<a name="l00727"></a>00727             BOOST_UBLAS_INLINE
<a name="l00728"></a>00728 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00729"></a>00729 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00730"></a>00730 <span class="preprocessor">#endif</span>
<a name="l00731"></a>00731 <span class="preprocessor"></span>            const_reverse_iterator1 rbegin ()<span class="keyword"> const </span>{
<a name="l00732"></a>00732                 <span class="keywordflow">return</span> const_reverse_iterator1 (end ());
<a name="l00733"></a>00733             }
<a name="l00734"></a>00734             BOOST_UBLAS_INLINE
<a name="l00735"></a>00735 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00736"></a>00736 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00737"></a>00737 <span class="preprocessor">#endif</span>
<a name="l00738"></a>00738 <span class="preprocessor"></span>            const_reverse_iterator1 rend ()<span class="keyword"> const </span>{
<a name="l00739"></a>00739                 <span class="keywordflow">return</span> const_reverse_iterator1 (begin ());
<a name="l00740"></a>00740             }
<a name="l00741"></a>00741 <span class="preprocessor">#endif</span>
<a name="l00742"></a>00742 <span class="preprocessor"></span>
<a name="l00743"></a>00743             <span class="comment">// Indices</span>
<a name="l00744"></a>00744             BOOST_UBLAS_INLINE
<a name="l00745"></a>00745             size_type index1 ()<span class="keyword"> const </span>{
<a name="l00746"></a>00746                 <span class="keywordflow">return</span> it1_;
<a name="l00747"></a>00747             }
<a name="l00748"></a>00748             BOOST_UBLAS_INLINE
<a name="l00749"></a>00749             size_type index2 ()<span class="keyword"> const </span>{
<a name="l00750"></a>00750                 <span class="keywordflow">return</span> it2_;
<a name="l00751"></a>00751             }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753             <span class="comment">// Assignment</span>
<a name="l00754"></a>00754             BOOST_UBLAS_INLINE
<a name="l00755"></a>00755             const_iterator2 &amp;operator = (<span class="keyword">const</span> const_iterator2 &amp;it) {
<a name="l00756"></a>00756                 container_const_reference&lt;self_type&gt;::assign (&amp;it ());
<a name="l00757"></a>00757                 it1_ = it.it1_;
<a name="l00758"></a>00758                 it2_ = it.it2_;
<a name="l00759"></a>00759                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00760"></a>00760             }
<a name="l00761"></a>00761 
<a name="l00762"></a>00762             <span class="comment">// Comparison</span>
<a name="l00763"></a>00763             BOOST_UBLAS_INLINE
<a name="l00764"></a>00764             <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> const_iterator2 &amp;it)<span class="keyword"> const </span>{
<a name="l00765"></a>00765                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00766"></a>00766                 BOOST_UBLAS_CHECK (it1_ == it.it1_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00767"></a>00767                 <span class="keywordflow">return</span> it2_ == it.it2_;
<a name="l00768"></a>00768             }
<a name="l00769"></a>00769             BOOST_UBLAS_INLINE
<a name="l00770"></a>00770             <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> const_iterator2 &amp;it)<span class="keyword"> const </span>{
<a name="l00771"></a>00771                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00772"></a>00772                 BOOST_UBLAS_CHECK (it1_ == it.it1_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00773"></a>00773                 <span class="keywordflow">return</span> it2_ &lt; it.it2_;
<a name="l00774"></a>00774             }
<a name="l00775"></a>00775 
<a name="l00776"></a>00776         <span class="keyword">private</span>:
<a name="l00777"></a>00777             size_type it1_;
<a name="l00778"></a>00778             size_type it2_;
<a name="l00779"></a>00779         };
<a name="l00780"></a>00780 <span class="preprocessor">#endif</span>
<a name="l00781"></a>00781 <span class="preprocessor"></span>
<a name="l00782"></a>00782         BOOST_UBLAS_INLINE
<a name="l00783"></a>00783         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator2.html">const_iterator2</a> begin2 ()<span class="keyword"> const </span>{
<a name="l00784"></a>00784             <span class="keywordflow">return</span> find2 (0, 0, 0);
<a name="l00785"></a>00785         }
<a name="l00786"></a>00786         BOOST_UBLAS_INLINE
<a name="l00787"></a>00787         const_iterator2 end2 ()<span class="keyword"> const </span>{
<a name="l00788"></a>00788             <span class="keywordflow">return</span> find2 (0, 0, size2_);
<a name="l00789"></a>00789         }
<a name="l00790"></a>00790 
<a name="l00791"></a>00791 <span class="preprocessor">#ifndef BOOST_UBLAS_USE_INDEXED_ITERATOR</span>
<a name="l00792"></a><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator2.html">00792</a> <span class="preprocessor"></span>        <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator2.html">iterator2</a>:
<a name="l00793"></a>00793             <span class="keyword">public</span> container_reference&lt;banded_matrix&gt;,
<a name="l00794"></a>00794             <span class="keyword">public</span> random_access_iterator_base&lt;packed_random_access_iterator_tag,
<a name="l00795"></a>00795                                                iterator2, value_type&gt; {
<a name="l00796"></a>00796         <span class="keyword">public</span>:
<a name="l00797"></a>00797             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::value_type value_type;
<a name="l00798"></a>00798             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::difference_type difference_type;
<a name="l00799"></a>00799             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::reference reference;
<a name="l00800"></a>00800             <span class="keyword">typedef</span> <span class="keyword">typename</span> banded_matrix::pointer pointer;
<a name="l00801"></a>00801 
<a name="l00802"></a>00802             <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator1.html">iterator1</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator1.html">dual_iterator_type</a>;
<a name="l00803"></a>00803             <span class="keyword">typedef</span> reverse_iterator1 dual_reverse_iterator_type;
<a name="l00804"></a>00804 
<a name="l00805"></a>00805             <span class="comment">// Construction and destruction</span>
<a name="l00806"></a>00806             BOOST_UBLAS_INLINE
<a name="l00807"></a>00807             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator2.html">iterator2</a> ():
<a name="l00808"></a>00808                 container_reference&lt;self_type&gt; (), it1_ (), it2_ () {}
<a name="l00809"></a>00809             BOOST_UBLAS_INLINE
<a name="l00810"></a>00810             iterator2 (<a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a> &amp;m, size_type it1, size_type it2):
<a name="l00811"></a>00811                 container_reference&lt;self_type&gt; (m), it1_ (it1), it2_ (it2) {}
<a name="l00812"></a>00812 
<a name="l00813"></a>00813             <span class="comment">// Arithmetic</span>
<a name="l00814"></a>00814             BOOST_UBLAS_INLINE
<a name="l00815"></a>00815             iterator2 &amp;operator ++ () {
<a name="l00816"></a>00816                 ++ it2_;
<a name="l00817"></a>00817                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00818"></a>00818             }
<a name="l00819"></a>00819             BOOST_UBLAS_INLINE
<a name="l00820"></a>00820             iterator2 &amp;operator -- () {
<a name="l00821"></a>00821                 -- it2_;
<a name="l00822"></a>00822                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00823"></a>00823             }
<a name="l00824"></a>00824             BOOST_UBLAS_INLINE
<a name="l00825"></a>00825             iterator2 &amp;operator += (difference_type n) {
<a name="l00826"></a>00826                 it2_ += n;
<a name="l00827"></a>00827                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00828"></a>00828             }
<a name="l00829"></a>00829             BOOST_UBLAS_INLINE
<a name="l00830"></a>00830             iterator2 &amp;operator -= (difference_type n) {
<a name="l00831"></a>00831                 it2_ -= n;
<a name="l00832"></a>00832                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00833"></a>00833             }
<a name="l00834"></a>00834             BOOST_UBLAS_INLINE
<a name="l00835"></a>00835             difference_type operator - (<span class="keyword">const</span> iterator2 &amp;it)<span class="keyword"> const </span>{
<a name="l00836"></a>00836                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00837"></a>00837                 BOOST_UBLAS_CHECK (it1_ == it.it1_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00838"></a>00838                 <span class="keywordflow">return</span> it2_ - it.it2_;
<a name="l00839"></a>00839             }
<a name="l00840"></a>00840 
<a name="l00841"></a>00841             <span class="comment">// Dereference</span>
<a name="l00842"></a>00842             BOOST_UBLAS_INLINE
<a name="l00843"></a>00843             reference operator * ()<span class="keyword"> const </span>{
<a name="l00844"></a>00844                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().at_element (it1_, it2_);
<a name="l00845"></a>00845             }
<a name="l00846"></a>00846             BOOST_UBLAS_INLINE
<a name="l00847"></a>00847             reference operator [] (difference_type n)<span class="keyword"> const </span>{
<a name="l00848"></a>00848                 <span class="keywordflow">return</span> *(*<span class="keyword">this</span> + n);
<a name="l00849"></a>00849             }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851 <span class="preprocessor">#ifndef BOOST_UBLAS_NO_NESTED_CLASS_RELATION</span>
<a name="l00852"></a>00852 <span class="preprocessor"></span>            BOOST_UBLAS_INLINE
<a name="l00853"></a>00853 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00854"></a>00854 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00855"></a>00855 <span class="preprocessor">#endif</span>
<a name="l00856"></a>00856 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator1.html">iterator1</a> begin ()<span class="keyword"> const </span>{
<a name="l00857"></a>00857                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find1 (1, 0, it2_);
<a name="l00858"></a>00858             }
<a name="l00859"></a>00859             BOOST_UBLAS_INLINE
<a name="l00860"></a>00860 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00861"></a>00861 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00862"></a>00862 <span class="preprocessor">#endif</span>
<a name="l00863"></a>00863 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator1.html">iterator1</a> end ()<span class="keyword"> const </span>{
<a name="l00864"></a>00864                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find1 (1, (*<span class="keyword">this</span>) ().size1 (), it2_);
<a name="l00865"></a>00865             }
<a name="l00866"></a>00866             BOOST_UBLAS_INLINE
<a name="l00867"></a>00867 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00868"></a>00868 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00869"></a>00869 <span class="preprocessor">#endif</span>
<a name="l00870"></a>00870 <span class="preprocessor"></span>            reverse_iterator1 rbegin ()<span class="keyword"> const </span>{
<a name="l00871"></a>00871                 <span class="keywordflow">return</span> reverse_iterator1 (end ());
<a name="l00872"></a>00872             }
<a name="l00873"></a>00873             BOOST_UBLAS_INLINE
<a name="l00874"></a>00874 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l00875"></a>00875 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">self_type</a>::
<a name="l00876"></a>00876 <span class="preprocessor">#endif</span>
<a name="l00877"></a>00877 <span class="preprocessor"></span>            reverse_iterator1 rend ()<span class="keyword"> const </span>{
<a name="l00878"></a>00878                 <span class="keywordflow">return</span> reverse_iterator1 (begin ());
<a name="l00879"></a>00879             }
<a name="l00880"></a>00880 <span class="preprocessor">#endif</span>
<a name="l00881"></a>00881 <span class="preprocessor"></span>
<a name="l00882"></a>00882             <span class="comment">// Indices</span>
<a name="l00883"></a>00883             BOOST_UBLAS_INLINE
<a name="l00884"></a>00884             size_type index1 ()<span class="keyword"> const </span>{
<a name="l00885"></a>00885                 <span class="keywordflow">return</span> it1_;
<a name="l00886"></a>00886             }
<a name="l00887"></a>00887             BOOST_UBLAS_INLINE
<a name="l00888"></a>00888             size_type index2 ()<span class="keyword"> const </span>{
<a name="l00889"></a>00889                 <span class="keywordflow">return</span> it2_;
<a name="l00890"></a>00890             }
<a name="l00891"></a>00891 
<a name="l00892"></a>00892             <span class="comment">// Assignment</span>
<a name="l00893"></a>00893             BOOST_UBLAS_INLINE
<a name="l00894"></a>00894             iterator2 &amp;operator = (<span class="keyword">const</span> iterator2 &amp;it) {
<a name="l00895"></a>00895                 container_reference&lt;self_type&gt;::assign (&amp;it ());
<a name="l00896"></a>00896                 it1_ = it.it1_;
<a name="l00897"></a>00897                 it2_ = it.it2_;
<a name="l00898"></a>00898                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00899"></a>00899             }
<a name="l00900"></a>00900 
<a name="l00901"></a>00901             <span class="comment">// Comparison</span>
<a name="l00902"></a>00902             BOOST_UBLAS_INLINE
<a name="l00903"></a>00903             <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> iterator2 &amp;it)<span class="keyword"> const </span>{
<a name="l00904"></a>00904                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00905"></a>00905                 BOOST_UBLAS_CHECK (it1_ == it.it1_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00906"></a>00906                 <span class="keywordflow">return</span> it2_ == it.it2_;
<a name="l00907"></a>00907             }
<a name="l00908"></a>00908             BOOST_UBLAS_INLINE
<a name="l00909"></a>00909             <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> iterator2 &amp;it)<span class="keyword"> const </span>{
<a name="l00910"></a>00910                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00911"></a>00911                 BOOST_UBLAS_CHECK (it1_ == it.it1_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l00912"></a>00912                 <span class="keywordflow">return</span> it2_ &lt; it.it2_;
<a name="l00913"></a>00913             }
<a name="l00914"></a>00914 
<a name="l00915"></a>00915         <span class="keyword">private</span>:
<a name="l00916"></a>00916             size_type it1_;
<a name="l00917"></a>00917             size_type it2_;
<a name="l00918"></a>00918 
<a name="l00919"></a>00919             <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1const__iterator2.html">const_iterator2</a>;
<a name="l00920"></a>00920         };
<a name="l00921"></a>00921 <span class="preprocessor">#endif</span>
<a name="l00922"></a>00922 <span class="preprocessor"></span>
<a name="l00923"></a>00923         BOOST_UBLAS_INLINE
<a name="l00924"></a>00924         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix_1_1iterator2.html">iterator2</a> begin2 () {
<a name="l00925"></a>00925             <span class="keywordflow">return</span> find2 (0, 0, 0);
<a name="l00926"></a>00926         }
<a name="l00927"></a>00927         BOOST_UBLAS_INLINE
<a name="l00928"></a>00928         iterator2 end2 () {
<a name="l00929"></a>00929             <span class="keywordflow">return</span> find2 (0, 0, size2_);
<a name="l00930"></a>00930         }
<a name="l00931"></a>00931 
<a name="l00932"></a>00932         <span class="comment">// Reverse iterators</span>
<a name="l00933"></a>00933 
<a name="l00934"></a>00934         BOOST_UBLAS_INLINE
<a name="l00935"></a>00935         const_reverse_iterator1 rbegin1 ()<span class="keyword"> const </span>{
<a name="l00936"></a>00936             <span class="keywordflow">return</span> const_reverse_iterator1 (end1 ());
<a name="l00937"></a>00937         }
<a name="l00938"></a>00938         BOOST_UBLAS_INLINE
<a name="l00939"></a>00939         const_reverse_iterator1 rend1 ()<span class="keyword"> const </span>{
<a name="l00940"></a>00940             <span class="keywordflow">return</span> const_reverse_iterator1 (begin1 ());
<a name="l00941"></a>00941         }
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         BOOST_UBLAS_INLINE
<a name="l00944"></a>00944         reverse_iterator1 rbegin1 () {
<a name="l00945"></a>00945             <span class="keywordflow">return</span> reverse_iterator1 (end1 ());
<a name="l00946"></a>00946         }
<a name="l00947"></a>00947         BOOST_UBLAS_INLINE
<a name="l00948"></a>00948         reverse_iterator1 rend1 () {
<a name="l00949"></a>00949             <span class="keywordflow">return</span> reverse_iterator1 (begin1 ());
<a name="l00950"></a>00950         }
<a name="l00951"></a>00951 
<a name="l00952"></a>00952         BOOST_UBLAS_INLINE
<a name="l00953"></a>00953         const_reverse_iterator2 rbegin2 ()<span class="keyword"> const </span>{
<a name="l00954"></a>00954             <span class="keywordflow">return</span> const_reverse_iterator2 (end2 ());
<a name="l00955"></a>00955         }
<a name="l00956"></a>00956         BOOST_UBLAS_INLINE
<a name="l00957"></a>00957         const_reverse_iterator2 rend2 ()<span class="keyword"> const </span>{
<a name="l00958"></a>00958             <span class="keywordflow">return</span> const_reverse_iterator2 (begin2 ());
<a name="l00959"></a>00959         }
<a name="l00960"></a>00960 
<a name="l00961"></a>00961         BOOST_UBLAS_INLINE
<a name="l00962"></a>00962         reverse_iterator2 rbegin2 () {
<a name="l00963"></a>00963             <span class="keywordflow">return</span> reverse_iterator2 (end2 ());
<a name="l00964"></a>00964         }
<a name="l00965"></a>00965         BOOST_UBLAS_INLINE
<a name="l00966"></a>00966         reverse_iterator2 rend2 () {
<a name="l00967"></a>00967             <span class="keywordflow">return</span> reverse_iterator2 (begin2 ());
<a name="l00968"></a>00968         }
<a name="l00969"></a>00969 
<a name="l00970"></a>00970     <span class="keyword">private</span>:
<a name="l00971"></a>00971         size_type size1_;
<a name="l00972"></a>00972         size_type size2_;
<a name="l00973"></a>00973         size_type lower_;
<a name="l00974"></a>00974         size_type upper_;
<a name="l00975"></a>00975         array_type data_;
<a name="l00976"></a>00976         <span class="keyword">typedef</span> <span class="keyword">const</span> value_type const_value_type;
<a name="l00977"></a>00977         <span class="keyword">static</span> const_value_type zero_;
<a name="l00978"></a>00978     };
<a name="l00979"></a>00979 
<a name="l00980"></a>00980     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> L, <span class="keyword">class</span> A&gt;
<a name="l00981"></a>00981     <span class="keyword">typename</span> banded_matrix&lt;T, L, A&gt;::const_value_type banded_matrix&lt;T, L, A&gt;::zero_ = value_type<span class="comment">/*zero*/</span>();
<a name="l00982"></a>00982 
<a name="l00983"></a>00983 
<a name="l00999"></a>00999     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> L, <span class="keyword">class</span> A&gt;
<a name="l01000"></a><a class="code" href="classboost_1_1numeric_1_1ublas_1_1diagonal__matrix.html">01000</a>     <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1diagonal__matrix.html" title="A diagonal matrix of values of type T, which is a specialization of a banded matrix...">diagonal_matrix</a>:
<a name="l01001"></a>01001         <span class="keyword">public</span> banded_matrix&lt;T, L, A&gt; {
<a name="l01002"></a>01002     <span class="keyword">public</span>:
<a name="l01003"></a>01003         <span class="keyword">typedef</span> <span class="keyword">typename</span> A::size_type size_type;
<a name="l01004"></a>01004         <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">banded_matrix&lt;T, L, A&gt;</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">matrix_type</a>;
<a name="l01005"></a>01005         <span class="keyword">typedef</span> A array_type;
<a name="l01006"></a>01006 
<a name="l01007"></a>01007         <span class="comment">// Construction and destruction</span>
<a name="l01008"></a>01008         BOOST_UBLAS_INLINE
<a name="l01009"></a>01009         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1diagonal__matrix.html" title="A diagonal matrix of values of type T, which is a specialization of a banded matrix...">diagonal_matrix</a> ():
<a name="l01010"></a>01010             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">matrix_type</a> () {}
<a name="l01011"></a>01011         BOOST_UBLAS_INLINE
<a name="l01012"></a>01012         diagonal_matrix (size_type size):
<a name="l01013"></a>01013             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">matrix_type</a> (size, size) {}
<a name="l01014"></a>01014         BOOST_UBLAS_INLINE
<a name="l01015"></a>01015         diagonal_matrix (size_type size, <span class="keyword">const</span> array_type&amp; data):
<a name="l01016"></a>01016             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">matrix_type</a> (size, size, 0, 0, data) {}
<a name="l01017"></a>01017         BOOST_UBLAS_INLINE
<a name="l01018"></a>01018         diagonal_matrix (size_type size1, size_type size2):
<a name="l01019"></a>01019             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">matrix_type</a> (size1, size2) {}
<a name="l01020"></a>01020         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l01021"></a>01021         BOOST_UBLAS_INLINE
<a name="l01022"></a>01022         diagonal_matrix (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae):
<a name="l01023"></a>01023             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__matrix.html" title="A banded matrix of values of type T.">matrix_type</a> (ae) {}
<a name="l01024"></a>01024         BOOST_UBLAS_INLINE
<a name="l01025"></a>01025         ~diagonal_matrix () {}
<a name="l01026"></a>01026 
<a name="l01027"></a>01027         <span class="comment">// Assignment</span>
<a name="l01028"></a>01028         BOOST_UBLAS_INLINE
<a name="l01029"></a>01029         diagonal_matrix &amp;operator = (<span class="keyword">const</span> diagonal_matrix &amp;m) {
<a name="l01030"></a>01030             matrix_type::operator = (m);
<a name="l01031"></a>01031             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01032"></a>01032         }
<a name="l01033"></a>01033         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l01034"></a>01034         BOOST_UBLAS_INLINE
<a name="l01035"></a>01035         diagonal_matrix &amp;operator = (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l01036"></a>01036             matrix_type::operator = (ae);
<a name="l01037"></a>01037             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01038"></a>01038         }
<a name="l01039"></a>01039     };
<a name="l01040"></a>01040 
<a name="l01053"></a>01053     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M&gt;
<a name="l01054"></a><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html">01054</a>     <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">banded_adaptor</a>:
<a name="l01055"></a>01055         <span class="keyword">public</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression</a>&lt;banded_adaptor&lt;M&gt; &gt; {
<a name="l01056"></a>01056 
<a name="l01057"></a>01057         <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">banded_adaptor&lt;M&gt;</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>;
<a name="l01058"></a>01058     <span class="keyword">public</span>:
<a name="l01059"></a>01059 <span class="preprocessor">#ifdef BOOST_UBLAS_ENABLE_PROXY_SHORTCUTS</span>
<a name="l01060"></a>01060 <span class="preprocessor"></span>        <span class="keyword">using</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;self_type&gt;::operator </a>();
<a name="l01061"></a>01061 <span class="preprocessor">#endif</span>
<a name="l01062"></a>01062 <span class="preprocessor"></span>        <span class="keyword">typedef</span> <span class="keyword">const</span> M const_matrix_type;
<a name="l01063"></a>01063         <span class="keyword">typedef</span> M matrix_type;
<a name="l01064"></a>01064         <span class="keyword">typedef</span> <span class="keyword">typename</span> M::size_type size_type;
<a name="l01065"></a>01065         <span class="keyword">typedef</span> <span class="keyword">typename</span> M::difference_type difference_type;
<a name="l01066"></a>01066         <span class="keyword">typedef</span> <span class="keyword">typename</span> M::value_type value_type;
<a name="l01067"></a>01067         <span class="keyword">typedef</span> <span class="keyword">typename</span> M::const_reference const_reference;
<a name="l01068"></a>01068         <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::if_&lt;boost::is_const&lt;M&gt;,
<a name="l01069"></a>01069                                           <span class="keyword">typename</span> M::const_reference,
<a name="l01070"></a>01070                                           <span class="keyword">typename</span> M::reference&gt;::type reference;
<a name="l01071"></a>01071         <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::if_&lt;boost::is_const&lt;M&gt;,
<a name="l01072"></a>01072                                           <span class="keyword">typename</span> M::const_closure_type,
<a name="l01073"></a>01073                                           <span class="keyword">typename</span> M::closure_type&gt;::type matrix_closure_type;
<a name="l01074"></a>01074         <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">const_closure_type</a>;
<a name="l01075"></a>01075         <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">closure_type</a>;
<a name="l01076"></a>01076         <span class="comment">// Replaced by _temporary_traits to avoid type requirements on M</span>
<a name="l01077"></a>01077         <span class="comment">//typedef typename M::vector_temporary_type vector_temporary_type;</span>
<a name="l01078"></a>01078         <span class="comment">//typedef typename M::matrix_temporary_type matrix_temporary_type;</span>
<a name="l01079"></a>01079         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1numeric_1_1ublas_1_1storage__restrict__traits.html">storage_restrict_traits</a>&lt;<span class="keyword">typename</span> M::storage_category,
<a name="l01080"></a>01080                                                  <a class="code" href="structboost_1_1numeric_1_1ublas_1_1packed__proxy__tag.html">packed_proxy_tag</a>&gt;::storage_category storage_category;
<a name="l01081"></a>01081         <span class="keyword">typedef</span> <span class="keyword">typename</span> M::orientation_category orientation_category;
<a name="l01082"></a>01082 
<a name="l01083"></a>01083         <span class="comment">// Construction and destruction</span>
<a name="l01084"></a>01084         BOOST_UBLAS_INLINE
<a name="l01085"></a>01085         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">banded_adaptor</a> (matrix_type &amp;data, size_type lower = 0, size_type upper = 0):
<a name="l01086"></a>01086             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;self_type&gt;</a> (),
<a name="l01087"></a>01087             data_ (data), lower_ (lower), upper_ (upper) {}
<a name="l01088"></a>01088         BOOST_UBLAS_INLINE
<a name="l01089"></a>01089         banded_adaptor (<span class="keyword">const</span> banded_adaptor &amp;m):
<a name="l01090"></a>01090             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;self_type&gt;</a> (),
<a name="l01091"></a>01091             data_ (m.data_), lower_ (m.lower_), upper_ (m.upper_) {}
<a name="l01092"></a>01092 
<a name="l01093"></a>01093         <span class="comment">// Accessors</span>
<a name="l01094"></a>01094         BOOST_UBLAS_INLINE
<a name="l01095"></a>01095         size_type size1 ()<span class="keyword"> const </span>{
<a name="l01096"></a>01096             <span class="keywordflow">return</span> data_.size1 ();
<a name="l01097"></a>01097         }
<a name="l01098"></a>01098         BOOST_UBLAS_INLINE
<a name="l01099"></a>01099         size_type size2 ()<span class="keyword"> const </span>{
<a name="l01100"></a>01100             <span class="keywordflow">return</span> data_.size2 ();
<a name="l01101"></a>01101         }
<a name="l01102"></a>01102         BOOST_UBLAS_INLINE
<a name="l01103"></a>01103         size_type lower ()<span class="keyword"> const </span>{
<a name="l01104"></a>01104             <span class="keywordflow">return</span> lower_;
<a name="l01105"></a>01105         }
<a name="l01106"></a>01106         BOOST_UBLAS_INLINE
<a name="l01107"></a>01107         size_type upper ()<span class="keyword"> const </span>{
<a name="l01108"></a>01108             <span class="keywordflow">return</span> upper_;
<a name="l01109"></a>01109         }
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         <span class="comment">// Storage accessors</span>
<a name="l01112"></a>01112         BOOST_UBLAS_INLINE
<a name="l01113"></a>01113         <span class="keyword">const</span> matrix_closure_type &amp;data ()<span class="keyword"> const </span>{
<a name="l01114"></a>01114             <span class="keywordflow">return</span> data_;
<a name="l01115"></a>01115         }
<a name="l01116"></a>01116         BOOST_UBLAS_INLINE
<a name="l01117"></a>01117         matrix_closure_type &amp;data () {
<a name="l01118"></a>01118             <span class="keywordflow">return</span> data_;
<a name="l01119"></a>01119         }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121         <span class="comment">// Element access</span>
<a name="l01122"></a>01122 <span class="preprocessor">#ifndef BOOST_UBLAS_PROXY_CONST_MEMBER</span>
<a name="l01123"></a>01123 <span class="preprocessor"></span>        BOOST_UBLAS_INLINE
<a name="l01124"></a>01124         const_reference operator () (size_type i, size_type j)<span class="keyword"> const </span>{
<a name="l01125"></a>01125             BOOST_UBLAS_CHECK (i &lt; size1 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01126"></a>01126             BOOST_UBLAS_CHECK (j &lt; size2 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01127"></a>01127 <span class="preprocessor">#ifdef BOOST_UBLAS_OWN_BANDED</span>
<a name="l01128"></a>01128 <span class="preprocessor"></span>            size_type k = (std::max) (i, j);
<a name="l01129"></a>01129             size_type l = lower_ + j - i;
<a name="l01130"></a>01130             <span class="keywordflow">if</span> (k &lt; (std::max) (size1 (), size2 ()) &amp;&amp;
<a name="l01131"></a>01131                 l &lt; lower_ + 1 + upper_)
<a name="l01132"></a>01132                 <span class="keywordflow">return</span> data () (i, j);
<a name="l01133"></a>01133 <span class="preprocessor">#else</span>
<a name="l01134"></a>01134 <span class="preprocessor"></span>            size_type k = j;
<a name="l01135"></a>01135             size_type l = upper_ + i - j;
<a name="l01136"></a>01136             <span class="keywordflow">if</span> (k &lt; size2 () &amp;&amp;
<a name="l01137"></a>01137                 l &lt; lower_ + 1 + upper_)
<a name="l01138"></a>01138                 <span class="keywordflow">return</span> data () (i, j);
<a name="l01139"></a>01139 <span class="preprocessor">#endif</span>
<a name="l01140"></a>01140 <span class="preprocessor"></span>            <span class="keywordflow">return</span> zero_;
<a name="l01141"></a>01141         }
<a name="l01142"></a>01142         BOOST_UBLAS_INLINE
<a name="l01143"></a>01143         reference operator () (size_type i, size_type j) {
<a name="l01144"></a>01144             BOOST_UBLAS_CHECK (i &lt; size1 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01145"></a>01145             BOOST_UBLAS_CHECK (j &lt; size2 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01146"></a>01146 <span class="preprocessor">#ifdef BOOST_UBLAS_OWN_BANDED</span>
<a name="l01147"></a>01147 <span class="preprocessor"></span>            size_type k = (std::max) (i, j);
<a name="l01148"></a>01148             size_type l = lower_ + j - i;
<a name="l01149"></a>01149             <span class="keywordflow">if</span> (k &lt; (std::max) (size1 (), size2 ()) &amp;&amp;
<a name="l01150"></a>01150                 l &lt; lower_ + 1 + upper_)
<a name="l01151"></a>01151                 <span class="keywordflow">return</span> data () (i, j);
<a name="l01152"></a>01152 <span class="preprocessor">#else</span>
<a name="l01153"></a>01153 <span class="preprocessor"></span>            size_type k = j;
<a name="l01154"></a>01154             size_type l = upper_ + i - j;
<a name="l01155"></a>01155             <span class="keywordflow">if</span> (k &lt; size2 () &amp;&amp;
<a name="l01156"></a>01156                 l &lt; lower_ + 1 + upper_)
<a name="l01157"></a>01157                 <span class="keywordflow">return</span> data () (i, j);
<a name="l01158"></a>01158 <span class="preprocessor">#endif</span>
<a name="l01159"></a>01159 <span class="preprocessor"></span><span class="preprocessor">#ifndef BOOST_UBLAS_REFERENCE_CONST_MEMBER</span>
<a name="l01160"></a>01160 <span class="preprocessor"></span>            <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ().raise ();
<a name="l01161"></a>01161 <span class="preprocessor">#endif</span>
<a name="l01162"></a>01162 <span class="preprocessor"></span>            <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>reference<span class="keyword">&gt;</span>(zero_);
<a name="l01163"></a>01163         }
<a name="l01164"></a>01164 <span class="preprocessor">#else</span>
<a name="l01165"></a>01165 <span class="preprocessor"></span>        BOOST_UBLAS_INLINE
<a name="l01166"></a>01166         reference operator () (size_type i, size_type j)<span class="keyword"> const </span>{
<a name="l01167"></a>01167             BOOST_UBLAS_CHECK (i &lt; size1 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01168"></a>01168             BOOST_UBLAS_CHECK (j &lt; size2 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01169"></a>01169 <span class="preprocessor">#ifdef BOOST_UBLAS_OWN_BANDED</span>
<a name="l01170"></a>01170 <span class="preprocessor"></span>            size_type k = (std::max) (i, j);
<a name="l01171"></a>01171             size_type l = lower_ + j - i;
<a name="l01172"></a>01172             <span class="keywordflow">if</span> (k &lt; (std::max) (size1 (), size2 ()) &amp;&amp;
<a name="l01173"></a>01173                 l &lt; lower_ + 1 + upper_)
<a name="l01174"></a>01174                 <span class="keywordflow">return</span> data () (i, j);
<a name="l01175"></a>01175 <span class="preprocessor">#else</span>
<a name="l01176"></a>01176 <span class="preprocessor"></span>            size_type k = j;
<a name="l01177"></a>01177             size_type l = upper_ + i - j;
<a name="l01178"></a>01178             <span class="keywordflow">if</span> (k &lt; size2 () &amp;&amp;
<a name="l01179"></a>01179                 l &lt; lower_ + 1 + upper_)
<a name="l01180"></a>01180                 <span class="keywordflow">return</span> data () (i, j);
<a name="l01181"></a>01181 <span class="preprocessor">#endif</span>
<a name="l01182"></a>01182 <span class="preprocessor"></span><span class="preprocessor">#ifndef BOOST_UBLAS_REFERENCE_CONST_MEMBER</span>
<a name="l01183"></a>01183 <span class="preprocessor"></span>            <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ().raise ();
<a name="l01184"></a>01184 <span class="preprocessor">#endif</span>
<a name="l01185"></a>01185 <span class="preprocessor"></span>            <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>reference<span class="keyword">&gt;</span>(zero_);
<a name="l01186"></a>01186         }
<a name="l01187"></a>01187 <span class="preprocessor">#endif</span>
<a name="l01188"></a>01188 <span class="preprocessor"></span>
<a name="l01189"></a>01189         <span class="comment">// Assignment</span>
<a name="l01190"></a>01190         BOOST_UBLAS_INLINE
<a name="l01191"></a>01191         banded_adaptor &amp;operator = (<span class="keyword">const</span> banded_adaptor &amp;m) {
<a name="l01192"></a>01192             matrix_assign&lt;scalar_assign&gt; (*<span class="keyword">this</span>, m);
<a name="l01193"></a>01193             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01194"></a>01194         }
<a name="l01195"></a>01195         BOOST_UBLAS_INLINE
<a name="l01196"></a>01196         banded_adaptor &amp;assign_temporary (banded_adaptor &amp;m) {
<a name="l01197"></a>01197             *<span class="keyword">this</span> = m;
<a name="l01198"></a>01198             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01199"></a>01199         }
<a name="l01200"></a>01200         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l01201"></a>01201         BOOST_UBLAS_INLINE
<a name="l01202"></a>01202         banded_adaptor &amp;operator = (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l01203"></a>01203             matrix_assign&lt;scalar_assign&gt; (*<span class="keyword">this</span>, <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix.html" title="A dense matrix of values of type T.">matrix&lt;value_type&gt;</a> (ae));
<a name="l01204"></a>01204             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01205"></a>01205         }
<a name="l01206"></a>01206         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l01207"></a>01207         BOOST_UBLAS_INLINE
<a name="l01208"></a>01208         banded_adaptor &amp;assign (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l01209"></a>01209             matrix_assign&lt;scalar_assign&gt; (*<span class="keyword">this</span>, ae);
<a name="l01210"></a>01210             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01211"></a>01211         }
<a name="l01212"></a>01212         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l01213"></a>01213         BOOST_UBLAS_INLINE
<a name="l01214"></a>01214         banded_adaptor&amp; operator += (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l01215"></a>01215             matrix_assign&lt;scalar_assign&gt; (*<span class="keyword">this</span>, <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix.html" title="A dense matrix of values of type T.">matrix&lt;value_type&gt;</a> (*<span class="keyword">this</span> + ae));
<a name="l01216"></a>01216             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01217"></a>01217         }
<a name="l01218"></a>01218         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l01219"></a>01219         BOOST_UBLAS_INLINE
<a name="l01220"></a>01220         banded_adaptor &amp;plus_assign (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l01221"></a>01221             matrix_assign&lt;scalar_plus_assign&gt; (*<span class="keyword">this</span>, ae);
<a name="l01222"></a>01222             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01223"></a>01223         }
<a name="l01224"></a>01224         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l01225"></a>01225         BOOST_UBLAS_INLINE
<a name="l01226"></a>01226         banded_adaptor&amp; operator -= (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l01227"></a>01227             matrix_assign&lt;scalar_assign&gt; (*<span class="keyword">this</span>, <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix.html" title="A dense matrix of values of type T.">matrix&lt;value_type&gt;</a> (*<span class="keyword">this</span> - ae));
<a name="l01228"></a>01228             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01229"></a>01229         }
<a name="l01230"></a>01230         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l01231"></a>01231         BOOST_UBLAS_INLINE
<a name="l01232"></a>01232         banded_adaptor &amp;minus_assign (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l01233"></a>01233             matrix_assign&lt;scalar_minus_assign&gt; (*<span class="keyword">this</span>, ae);
<a name="l01234"></a>01234             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01235"></a>01235         }
<a name="l01236"></a>01236         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AT&gt;
<a name="l01237"></a>01237         BOOST_UBLAS_INLINE
<a name="l01238"></a>01238         banded_adaptor&amp; operator *= (<span class="keyword">const</span> AT &amp;at) {
<a name="l01239"></a>01239             matrix_assign_scalar&lt;scalar_multiplies_assign&gt; (*<span class="keyword">this</span>, at);
<a name="l01240"></a>01240             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01241"></a>01241         }
<a name="l01242"></a>01242         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AT&gt;
<a name="l01243"></a>01243         BOOST_UBLAS_INLINE
<a name="l01244"></a>01244         banded_adaptor&amp; operator /= (<span class="keyword">const</span> AT &amp;at) {
<a name="l01245"></a>01245             matrix_assign_scalar&lt;scalar_divides_assign&gt; (*<span class="keyword">this</span>, at);
<a name="l01246"></a>01246             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01247"></a>01247         }
<a name="l01248"></a>01248 
<a name="l01249"></a>01249         <span class="comment">// Closure comparison</span>
<a name="l01250"></a>01250         BOOST_UBLAS_INLINE
<a name="l01251"></a>01251         <span class="keywordtype">bool</span> same_closure (<span class="keyword">const</span> banded_adaptor &amp;ba)<span class="keyword"> const </span>{
<a name="l01252"></a>01252             <span class="keywordflow">return</span> (*this).data ().same_closure (ba.data ());
<a name="l01253"></a>01253         }
<a name="l01254"></a>01254 
<a name="l01255"></a>01255         <span class="comment">// Swapping</span>
<a name="l01256"></a>01256         BOOST_UBLAS_INLINE
<a name="l01257"></a>01257         <span class="keywordtype">void</span> swap (banded_adaptor &amp;m) {
<a name="l01258"></a>01258             <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;m) {
<a name="l01259"></a>01259                 BOOST_UBLAS_CHECK (lower_ == m.lower_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__size.html">bad_size</a> ());
<a name="l01260"></a>01260                 BOOST_UBLAS_CHECK (upper_ == m.upper_, <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__size.html">bad_size</a> ());
<a name="l01261"></a>01261                 matrix_swap&lt;scalar_swap&gt; (*<span class="keyword">this</span>, m);
<a name="l01262"></a>01262             }
<a name="l01263"></a>01263         }
<a name="l01264"></a>01264         BOOST_UBLAS_INLINE
<a name="l01265"></a>01265         <span class="keyword">friend</span> <span class="keywordtype">void</span> swap (banded_adaptor &amp;m1, banded_adaptor &amp;m2) {
<a name="l01266"></a>01266             m1.swap (m2);
<a name="l01267"></a>01267         }
<a name="l01268"></a>01268 
<a name="l01269"></a>01269         <span class="comment">// Iterator types</span>
<a name="l01270"></a>01270     <span class="keyword">private</span>:
<a name="l01271"></a>01271         <span class="comment">// Use the matrix iterator</span>
<a name="l01272"></a>01272         <span class="keyword">typedef</span> <span class="keyword">typename</span> M::const_iterator1 const_subiterator1_type;
<a name="l01273"></a>01273         <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::if_&lt;boost::is_const&lt;M&gt;,
<a name="l01274"></a>01274                                           <span class="keyword">typename</span> M::const_iterator1,
<a name="l01275"></a>01275                                           <span class="keyword">typename</span> M::iterator1&gt;::type subiterator1_type;
<a name="l01276"></a>01276         <span class="keyword">typedef</span> <span class="keyword">typename</span> M::const_iterator2 const_subiterator2_type;
<a name="l01277"></a>01277         <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::if_&lt;boost::is_const&lt;M&gt;,
<a name="l01278"></a>01278                                           <span class="keyword">typename</span> M::const_iterator2,
<a name="l01279"></a>01279                                           <span class="keyword">typename</span> M::iterator2&gt;::type subiterator2_type;
<a name="l01280"></a>01280 
<a name="l01281"></a>01281     <span class="keyword">public</span>:
<a name="l01282"></a>01282 <span class="preprocessor">#ifdef BOOST_UBLAS_USE_INDEXED_ITERATOR</span>
<a name="l01283"></a>01283 <span class="preprocessor"></span>        <span class="keyword">typedef</span> indexed_iterator1&lt;self_type, packed_random_access_iterator_tag&gt; <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator1.html">iterator1</a>;
<a name="l01284"></a>01284         <span class="keyword">typedef</span> indexed_iterator2&lt;self_type, packed_random_access_iterator_tag&gt; <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator2.html">iterator2</a>;
<a name="l01285"></a>01285         <span class="keyword">typedef</span> indexed_const_iterator1&lt;self_type, packed_random_access_iterator_tag&gt; <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator1.html">const_iterator1</a>;
<a name="l01286"></a>01286         <span class="keyword">typedef</span> indexed_const_iterator2&lt;self_type, packed_random_access_iterator_tag&gt; <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator2.html">const_iterator2</a>;
<a name="l01287"></a>01287 <span class="preprocessor">#else</span>
<a name="l01288"></a>01288 <span class="preprocessor"></span>        <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator1.html">const_iterator1</a>;
<a name="l01289"></a>01289         <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator1.html">iterator1</a>;
<a name="l01290"></a>01290         <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator2.html">const_iterator2</a>;
<a name="l01291"></a>01291         <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator2.html">iterator2</a>;
<a name="l01292"></a>01292 <span class="preprocessor">#endif</span>
<a name="l01293"></a>01293 <span class="preprocessor"></span>        <span class="keyword">typedef</span> reverse_iterator_base1&lt;const_iterator1&gt; const_reverse_iterator1;
<a name="l01294"></a>01294         <span class="keyword">typedef</span> reverse_iterator_base1&lt;iterator1&gt; reverse_iterator1;
<a name="l01295"></a>01295         <span class="keyword">typedef</span> reverse_iterator_base2&lt;const_iterator2&gt; const_reverse_iterator2;
<a name="l01296"></a>01296         <span class="keyword">typedef</span> reverse_iterator_base2&lt;iterator2&gt; reverse_iterator2;
<a name="l01297"></a>01297 
<a name="l01298"></a>01298         <span class="comment">// Element lookup</span>
<a name="l01299"></a>01299         BOOST_UBLAS_INLINE
<a name="l01300"></a>01300         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator1.html">const_iterator1</a> find1 (<span class="keywordtype">int</span> rank, size_type i, size_type j)<span class="keyword"> const </span>{
<a name="l01301"></a>01301             <span class="keywordflow">if</span> (rank == 1) {
<a name="l01302"></a>01302                 size_type lower_i = (std::max) (difference_type (j - upper_), difference_type (0));
<a name="l01303"></a>01303                 i = (std::max) (i, lower_i);
<a name="l01304"></a>01304                 size_type upper_i = (std::min) (j + 1 + lower_, size1 ());
<a name="l01305"></a>01305                 i = (std::min) (i, upper_i);
<a name="l01306"></a>01306             }
<a name="l01307"></a>01307             <span class="keywordflow">return</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator1.html">const_iterator1</a> (*<span class="keyword">this</span>, data ().find1 (rank, i, j));
<a name="l01308"></a>01308         }
<a name="l01309"></a>01309         BOOST_UBLAS_INLINE
<a name="l01310"></a>01310         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator1.html">iterator1</a> find1 (<span class="keywordtype">int</span> rank, size_type i, size_type j) {
<a name="l01311"></a>01311             <span class="keywordflow">if</span> (rank == 1) {
<a name="l01312"></a>01312                 size_type lower_i = (std::max) (difference_type (j - upper_), difference_type (0));
<a name="l01313"></a>01313                 i = (std::max) (i, lower_i);
<a name="l01314"></a>01314                 size_type upper_i = (std::min) (j + 1 + lower_, size1 ());
<a name="l01315"></a>01315                 i = (std::min) (i, upper_i);
<a name="l01316"></a>01316             }
<a name="l01317"></a>01317             <span class="keywordflow">return</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator1.html">iterator1</a> (*<span class="keyword">this</span>, data ().find1 (rank, i, j));
<a name="l01318"></a>01318         }
<a name="l01319"></a>01319         BOOST_UBLAS_INLINE
<a name="l01320"></a>01320         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator2.html">const_iterator2</a> find2 (<span class="keywordtype">int</span> rank, size_type i, size_type j)<span class="keyword"> const </span>{
<a name="l01321"></a>01321             <span class="keywordflow">if</span> (rank == 1) {
<a name="l01322"></a>01322                 size_type lower_j = (std::max) (difference_type (i - lower_), difference_type (0));
<a name="l01323"></a>01323                 j = (std::max) (j, lower_j);
<a name="l01324"></a>01324                 size_type upper_j = (std::min) (i + 1 + upper_, size2 ());
<a name="l01325"></a>01325                 j = (std::min) (j, upper_j);
<a name="l01326"></a>01326             }
<a name="l01327"></a>01327             <span class="keywordflow">return</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator2.html">const_iterator2</a> (*<span class="keyword">this</span>, data ().find2 (rank, i, j));
<a name="l01328"></a>01328         }
<a name="l01329"></a>01329         BOOST_UBLAS_INLINE
<a name="l01330"></a>01330         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator2.html">iterator2</a> find2 (<span class="keywordtype">int</span> rank, size_type i, size_type j) {
<a name="l01331"></a>01331             <span class="keywordflow">if</span> (rank == 1) {
<a name="l01332"></a>01332                 size_type lower_j = (std::max) (difference_type (i - lower_), difference_type (0));
<a name="l01333"></a>01333                 j = (std::max) (j, lower_j);
<a name="l01334"></a>01334                 size_type upper_j = (std::min) (i + 1 + upper_, size2 ());
<a name="l01335"></a>01335                 j = (std::min) (j, upper_j);
<a name="l01336"></a>01336             }
<a name="l01337"></a>01337             <span class="keywordflow">return</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator2.html">iterator2</a> (*<span class="keyword">this</span>, data ().find2 (rank, i, j));
<a name="l01338"></a>01338         }
<a name="l01339"></a>01339 
<a name="l01340"></a>01340         <span class="comment">// Iterators simply are indices.</span>
<a name="l01341"></a>01341 
<a name="l01342"></a>01342 <span class="preprocessor">#ifndef BOOST_UBLAS_USE_INDEXED_ITERATOR</span>
<a name="l01343"></a><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator1.html">01343</a> <span class="preprocessor"></span>        <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator1.html">const_iterator1</a>:
<a name="l01344"></a>01344             <span class="keyword">public</span> container_const_reference&lt;banded_adaptor&gt;,
<a name="l01345"></a>01345             <span class="keyword">public</span> random_access_iterator_base&lt;typename iterator_restrict_traits&lt;
<a name="l01346"></a>01346                                                    typename const_subiterator1_type::iterator_category, packed_random_access_iterator_tag&gt;::iterator_category,
<a name="l01347"></a>01347                                                const_iterator1, value_type&gt; {
<a name="l01348"></a>01348         <span class="keyword">public</span>:
<a name="l01349"></a>01349             <span class="keyword">typedef</span> <span class="keyword">typename</span> const_subiterator1_type::value_type value_type;
<a name="l01350"></a>01350             <span class="keyword">typedef</span> <span class="keyword">typename</span> const_subiterator1_type::difference_type difference_type;
<a name="l01351"></a>01351             <span class="keyword">typedef</span> <span class="keyword">typename</span> const_subiterator1_type::reference reference;
<a name="l01352"></a>01352             <span class="keyword">typedef</span> <span class="keyword">typename</span> const_subiterator1_type::pointer pointer;
<a name="l01353"></a>01353 
<a name="l01354"></a>01354             <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator2.html">const_iterator2</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator2.html">dual_iterator_type</a>;
<a name="l01355"></a>01355             <span class="keyword">typedef</span> const_reverse_iterator2 dual_reverse_iterator_type;
<a name="l01356"></a>01356 
<a name="l01357"></a>01357             <span class="comment">// Construction and destruction</span>
<a name="l01358"></a>01358             BOOST_UBLAS_INLINE
<a name="l01359"></a>01359             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator1.html">const_iterator1</a> ():
<a name="l01360"></a>01360                 container_const_reference&lt;self_type&gt; (), it1_ () {}
<a name="l01361"></a>01361             BOOST_UBLAS_INLINE
<a name="l01362"></a>01362             const_iterator1 (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a> &amp;m, <span class="keyword">const</span> const_subiterator1_type &amp;it1):
<a name="l01363"></a>01363                 container_const_reference&lt;self_type&gt; (m), it1_ (it1) {}
<a name="l01364"></a>01364             BOOST_UBLAS_INLINE
<a name="l01365"></a>01365             const_iterator1 (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator1.html">iterator1</a> &amp;it):
<a name="l01366"></a>01366                 container_const_reference&lt;self_type&gt; (it ()), it1_ (it.it1_) {}
<a name="l01367"></a>01367 
<a name="l01368"></a>01368             <span class="comment">// Arithmetic</span>
<a name="l01369"></a>01369             BOOST_UBLAS_INLINE
<a name="l01370"></a>01370             const_iterator1 &amp;operator ++ () {
<a name="l01371"></a>01371                 ++ it1_;
<a name="l01372"></a>01372                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01373"></a>01373             }
<a name="l01374"></a>01374             BOOST_UBLAS_INLINE
<a name="l01375"></a>01375             const_iterator1 &amp;operator -- () {
<a name="l01376"></a>01376                 -- it1_;
<a name="l01377"></a>01377                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01378"></a>01378             }
<a name="l01379"></a>01379             BOOST_UBLAS_INLINE
<a name="l01380"></a>01380             const_iterator1 &amp;operator += (difference_type n) {
<a name="l01381"></a>01381                 it1_ += n;
<a name="l01382"></a>01382                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01383"></a>01383             }
<a name="l01384"></a>01384             BOOST_UBLAS_INLINE
<a name="l01385"></a>01385             const_iterator1 &amp;operator -= (difference_type n) {
<a name="l01386"></a>01386                 it1_ -= n;
<a name="l01387"></a>01387                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01388"></a>01388             }
<a name="l01389"></a>01389             BOOST_UBLAS_INLINE
<a name="l01390"></a>01390             difference_type operator - (<span class="keyword">const</span> const_iterator1 &amp;it)<span class="keyword"> const </span>{
<a name="l01391"></a>01391                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l01392"></a>01392                 <span class="keywordflow">return</span> it1_ - it.it1_;
<a name="l01393"></a>01393             }
<a name="l01394"></a>01394 
<a name="l01395"></a>01395             <span class="comment">// Dereference</span>
<a name="l01396"></a>01396             BOOST_UBLAS_INLINE
<a name="l01397"></a>01397             const_reference operator * ()<span class="keyword"> const </span>{
<a name="l01398"></a>01398                 size_type i = index1 ();
<a name="l01399"></a>01399                 size_type j = index2 ();
<a name="l01400"></a>01400                 BOOST_UBLAS_CHECK (i &lt; (*<span class="keyword">this</span>) ().size1 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01401"></a>01401                 BOOST_UBLAS_CHECK (j &lt; (*<span class="keyword">this</span>) ().size2 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01402"></a>01402 <span class="preprocessor">#ifdef BOOST_UBLAS_OWN_BANDED</span>
<a name="l01403"></a>01403 <span class="preprocessor"></span>                size_type k = (std::max) (i, j);
<a name="l01404"></a>01404                 size_type l = (*this) ().lower () + j - i;
<a name="l01405"></a>01405                 <span class="keywordflow">if</span> (k &lt; (std::max) ((*this) ().size1 (), (*this) ().size2 ()) &amp;&amp;
<a name="l01406"></a>01406                     l &lt; (*<span class="keyword">this</span>) ().lower () + 1 + (*this) ().upper ())
<a name="l01407"></a>01407                     <span class="keywordflow">return</span> *it1_;
<a name="l01408"></a>01408 <span class="preprocessor">#else</span>
<a name="l01409"></a>01409 <span class="preprocessor"></span>                size_type k = j;
<a name="l01410"></a>01410                 size_type l = (*this) ().upper () + i - j;
<a name="l01411"></a>01411                 <span class="keywordflow">if</span> (k &lt; (*<span class="keyword">this</span>) ().size2 () &amp;&amp;
<a name="l01412"></a>01412                     l &lt; (*this) ().lower () + 1 + (*this) ().upper ())
<a name="l01413"></a>01413                     <span class="keywordflow">return</span> *it1_;
<a name="l01414"></a>01414 <span class="preprocessor">#endif</span>
<a name="l01415"></a>01415 <span class="preprocessor"></span>                <span class="keywordflow">return</span> (*<span class="keyword">this</span>) () (i, j);
<a name="l01416"></a>01416             }
<a name="l01417"></a>01417             BOOST_UBLAS_INLINE
<a name="l01418"></a>01418             const_reference operator [] (difference_type n)<span class="keyword"> const </span>{
<a name="l01419"></a>01419                 <span class="keywordflow">return</span> *(*<span class="keyword">this</span> + n);
<a name="l01420"></a>01420             }
<a name="l01421"></a>01421 
<a name="l01422"></a>01422 <span class="preprocessor">#ifndef BOOST_UBLAS_NO_NESTED_CLASS_RELATION</span>
<a name="l01423"></a>01423 <span class="preprocessor"></span>            BOOST_UBLAS_INLINE
<a name="l01424"></a>01424 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01425"></a>01425 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01426"></a>01426 <span class="preprocessor">#endif</span>
<a name="l01427"></a>01427 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator2.html">const_iterator2</a> begin ()<span class="keyword"> const </span>{
<a name="l01428"></a>01428                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find2 (1, index1 (), 0);
<a name="l01429"></a>01429             }
<a name="l01430"></a>01430             BOOST_UBLAS_INLINE
<a name="l01431"></a>01431 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01432"></a>01432 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01433"></a>01433 <span class="preprocessor">#endif</span>
<a name="l01434"></a>01434 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator2.html">const_iterator2</a> end ()<span class="keyword"> const </span>{
<a name="l01435"></a>01435                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find2 (1, index1 (), (*this) ().size2 ());
<a name="l01436"></a>01436             }
<a name="l01437"></a>01437             BOOST_UBLAS_INLINE
<a name="l01438"></a>01438 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01439"></a>01439 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01440"></a>01440 <span class="preprocessor">#endif</span>
<a name="l01441"></a>01441 <span class="preprocessor"></span>            const_reverse_iterator2 rbegin ()<span class="keyword"> const </span>{
<a name="l01442"></a>01442                 <span class="keywordflow">return</span> const_reverse_iterator2 (end ());
<a name="l01443"></a>01443             }
<a name="l01444"></a>01444             BOOST_UBLAS_INLINE
<a name="l01445"></a>01445 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01446"></a>01446 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01447"></a>01447 <span class="preprocessor">#endif</span>
<a name="l01448"></a>01448 <span class="preprocessor"></span>            const_reverse_iterator2 rend ()<span class="keyword"> const </span>{
<a name="l01449"></a>01449                 <span class="keywordflow">return</span> const_reverse_iterator2 (begin ());
<a name="l01450"></a>01450             }
<a name="l01451"></a>01451 <span class="preprocessor">#endif</span>
<a name="l01452"></a>01452 <span class="preprocessor"></span>
<a name="l01453"></a>01453             <span class="comment">// Indices</span>
<a name="l01454"></a>01454             BOOST_UBLAS_INLINE
<a name="l01455"></a>01455             size_type index1 ()<span class="keyword"> const </span>{
<a name="l01456"></a>01456                 <span class="keywordflow">return</span> it1_.index1 ();
<a name="l01457"></a>01457             }
<a name="l01458"></a>01458             BOOST_UBLAS_INLINE
<a name="l01459"></a>01459             size_type index2 ()<span class="keyword"> const </span>{
<a name="l01460"></a>01460                 <span class="keywordflow">return</span> it1_.index2 ();
<a name="l01461"></a>01461             }
<a name="l01462"></a>01462 
<a name="l01463"></a>01463             <span class="comment">// Assignment</span>
<a name="l01464"></a>01464             BOOST_UBLAS_INLINE
<a name="l01465"></a>01465             const_iterator1 &amp;operator = (<span class="keyword">const</span> const_iterator1 &amp;it) {
<a name="l01466"></a>01466                 container_const_reference&lt;self_type&gt;::assign (&amp;it ());
<a name="l01467"></a>01467                 it1_ = it.it1_;
<a name="l01468"></a>01468                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01469"></a>01469             }
<a name="l01470"></a>01470 
<a name="l01471"></a>01471             <span class="comment">// Comparison</span>
<a name="l01472"></a>01472             BOOST_UBLAS_INLINE
<a name="l01473"></a>01473             <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> const_iterator1 &amp;it)<span class="keyword"> const </span>{
<a name="l01474"></a>01474                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l01475"></a>01475                 <span class="keywordflow">return</span> it1_ == it.it1_;
<a name="l01476"></a>01476             }
<a name="l01477"></a>01477             BOOST_UBLAS_INLINE
<a name="l01478"></a>01478             <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> const_iterator1 &amp;it)<span class="keyword"> const </span>{
<a name="l01479"></a>01479                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l01480"></a>01480                 <span class="keywordflow">return</span> it1_ &lt; it.it1_;
<a name="l01481"></a>01481             }
<a name="l01482"></a>01482 
<a name="l01483"></a>01483         <span class="keyword">private</span>:
<a name="l01484"></a>01484             const_subiterator1_type it1_;
<a name="l01485"></a>01485         };
<a name="l01486"></a>01486 <span class="preprocessor">#endif</span>
<a name="l01487"></a>01487 <span class="preprocessor"></span>
<a name="l01488"></a>01488         BOOST_UBLAS_INLINE
<a name="l01489"></a>01489         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator1.html">const_iterator1</a> begin1 ()<span class="keyword"> const </span>{
<a name="l01490"></a>01490             <span class="keywordflow">return</span> find1 (0, 0, 0);
<a name="l01491"></a>01491         }
<a name="l01492"></a>01492         BOOST_UBLAS_INLINE
<a name="l01493"></a>01493         const_iterator1 end1 ()<span class="keyword"> const </span>{
<a name="l01494"></a>01494             <span class="keywordflow">return</span> find1 (0, size1 (), 0);
<a name="l01495"></a>01495         }
<a name="l01496"></a>01496 
<a name="l01497"></a>01497 <span class="preprocessor">#ifndef BOOST_UBLAS_USE_INDEXED_ITERATOR</span>
<a name="l01498"></a><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator1.html">01498</a> <span class="preprocessor"></span>        <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator1.html">iterator1</a>:
<a name="l01499"></a>01499             <span class="keyword">public</span> container_reference&lt;banded_adaptor&gt;,
<a name="l01500"></a>01500             <span class="keyword">public</span> random_access_iterator_base&lt;typename iterator_restrict_traits&lt;
<a name="l01501"></a>01501                                                    typename subiterator1_type::iterator_category, packed_random_access_iterator_tag&gt;::iterator_category,
<a name="l01502"></a>01502                                                iterator1, value_type&gt; {
<a name="l01503"></a>01503         <span class="keyword">public</span>:
<a name="l01504"></a>01504             <span class="keyword">typedef</span> <span class="keyword">typename</span> subiterator1_type::value_type value_type;
<a name="l01505"></a>01505             <span class="keyword">typedef</span> <span class="keyword">typename</span> subiterator1_type::difference_type difference_type;
<a name="l01506"></a>01506             <span class="keyword">typedef</span> <span class="keyword">typename</span> subiterator1_type::reference reference;
<a name="l01507"></a>01507             <span class="keyword">typedef</span> <span class="keyword">typename</span> subiterator1_type::pointer pointer;
<a name="l01508"></a>01508 
<a name="l01509"></a>01509             <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator2.html">iterator2</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator2.html">dual_iterator_type</a>;
<a name="l01510"></a>01510             <span class="keyword">typedef</span> reverse_iterator2 dual_reverse_iterator_type;
<a name="l01511"></a>01511 
<a name="l01512"></a>01512             <span class="comment">// Construction and destruction</span>
<a name="l01513"></a>01513             BOOST_UBLAS_INLINE
<a name="l01514"></a>01514             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator1.html">iterator1</a> ():
<a name="l01515"></a>01515                 container_reference&lt;self_type&gt; (), it1_ () {}
<a name="l01516"></a>01516             BOOST_UBLAS_INLINE
<a name="l01517"></a>01517             iterator1 (<a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a> &amp;m, <span class="keyword">const</span> subiterator1_type &amp;it1):
<a name="l01518"></a>01518                 container_reference&lt;self_type&gt; (m), it1_ (it1) {}
<a name="l01519"></a>01519 
<a name="l01520"></a>01520             <span class="comment">// Arithmetic</span>
<a name="l01521"></a>01521             BOOST_UBLAS_INLINE
<a name="l01522"></a>01522             iterator1 &amp;operator ++ () {
<a name="l01523"></a>01523                 ++ it1_;
<a name="l01524"></a>01524                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01525"></a>01525             }
<a name="l01526"></a>01526             BOOST_UBLAS_INLINE
<a name="l01527"></a>01527             iterator1 &amp;operator -- () {
<a name="l01528"></a>01528                 -- it1_;
<a name="l01529"></a>01529                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01530"></a>01530             }
<a name="l01531"></a>01531             BOOST_UBLAS_INLINE
<a name="l01532"></a>01532             iterator1 &amp;operator += (difference_type n) {
<a name="l01533"></a>01533                 it1_ += n;
<a name="l01534"></a>01534                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01535"></a>01535             }
<a name="l01536"></a>01536             BOOST_UBLAS_INLINE
<a name="l01537"></a>01537             iterator1 &amp;operator -= (difference_type n) {
<a name="l01538"></a>01538                 it1_ -= n;
<a name="l01539"></a>01539                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01540"></a>01540             }
<a name="l01541"></a>01541             BOOST_UBLAS_INLINE
<a name="l01542"></a>01542             difference_type operator - (<span class="keyword">const</span> iterator1 &amp;it)<span class="keyword"> const </span>{
<a name="l01543"></a>01543                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l01544"></a>01544                 <span class="keywordflow">return</span> it1_ - it.it1_;
<a name="l01545"></a>01545             }
<a name="l01546"></a>01546 
<a name="l01547"></a>01547             <span class="comment">// Dereference</span>
<a name="l01548"></a>01548             BOOST_UBLAS_INLINE
<a name="l01549"></a>01549             reference operator * ()<span class="keyword"> const </span>{
<a name="l01550"></a>01550                 size_type i = index1 ();
<a name="l01551"></a>01551                 size_type j = index2 ();
<a name="l01552"></a>01552                 BOOST_UBLAS_CHECK (i &lt; (*<span class="keyword">this</span>) ().size1 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01553"></a>01553                 BOOST_UBLAS_CHECK (j &lt; (*<span class="keyword">this</span>) ().size2 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01554"></a>01554 <span class="preprocessor">#ifdef BOOST_UBLAS_OWN_BANDED</span>
<a name="l01555"></a>01555 <span class="preprocessor"></span>                size_type k = (std::max) (i, j);
<a name="l01556"></a>01556                 size_type l = (*this) ().lower () + j - i;
<a name="l01557"></a>01557                 <span class="keywordflow">if</span> (k &lt; (std::max) ((*this) ().size1 (), (*this) ().size2 ()) &amp;&amp;
<a name="l01558"></a>01558                     l &lt; (*<span class="keyword">this</span>) ().lower () + 1 + (*this) ().upper ())
<a name="l01559"></a>01559                     <span class="keywordflow">return</span> *it1_;
<a name="l01560"></a>01560 <span class="preprocessor">#else</span>
<a name="l01561"></a>01561 <span class="preprocessor"></span>                size_type k = j;
<a name="l01562"></a>01562                 size_type l = (*this) ().upper () + i - j;
<a name="l01563"></a>01563                 <span class="keywordflow">if</span> (k &lt; (*<span class="keyword">this</span>) ().size2 () &amp;&amp;
<a name="l01564"></a>01564                     l &lt; (*this) ().lower () + 1 + (*this) ().upper ())
<a name="l01565"></a>01565                     <span class="keywordflow">return</span> *it1_;
<a name="l01566"></a>01566 <span class="preprocessor">#endif</span>
<a name="l01567"></a>01567 <span class="preprocessor"></span>                <span class="keywordflow">return</span> (*<span class="keyword">this</span>) () (i, j);
<a name="l01568"></a>01568             }
<a name="l01569"></a>01569             BOOST_UBLAS_INLINE
<a name="l01570"></a>01570             reference operator [] (difference_type n)<span class="keyword"> const </span>{
<a name="l01571"></a>01571                 <span class="keywordflow">return</span> *(*<span class="keyword">this</span> + n);
<a name="l01572"></a>01572             }
<a name="l01573"></a>01573 
<a name="l01574"></a>01574 <span class="preprocessor">#ifndef BOOST_UBLAS_NO_NESTED_CLASS_RELATION</span>
<a name="l01575"></a>01575 <span class="preprocessor"></span>            BOOST_UBLAS_INLINE
<a name="l01576"></a>01576 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01577"></a>01577 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01578"></a>01578 <span class="preprocessor">#endif</span>
<a name="l01579"></a>01579 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator2.html">iterator2</a> begin ()<span class="keyword"> const </span>{
<a name="l01580"></a>01580                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find2 (1, index1 (), 0);
<a name="l01581"></a>01581             }
<a name="l01582"></a>01582             BOOST_UBLAS_INLINE
<a name="l01583"></a>01583 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01584"></a>01584 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01585"></a>01585 <span class="preprocessor">#endif</span>
<a name="l01586"></a>01586 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator2.html">iterator2</a> end ()<span class="keyword"> const </span>{
<a name="l01587"></a>01587                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find2 (1, index1 (), (*this) ().size2 ());
<a name="l01588"></a>01588             }
<a name="l01589"></a>01589             BOOST_UBLAS_INLINE
<a name="l01590"></a>01590 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01591"></a>01591 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01592"></a>01592 <span class="preprocessor">#endif</span>
<a name="l01593"></a>01593 <span class="preprocessor"></span>            reverse_iterator2 rbegin ()<span class="keyword"> const </span>{
<a name="l01594"></a>01594                 <span class="keywordflow">return</span> reverse_iterator2 (end ());
<a name="l01595"></a>01595             }
<a name="l01596"></a>01596             BOOST_UBLAS_INLINE
<a name="l01597"></a>01597 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01598"></a>01598 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01599"></a>01599 <span class="preprocessor">#endif</span>
<a name="l01600"></a>01600 <span class="preprocessor"></span>            reverse_iterator2 rend ()<span class="keyword"> const </span>{
<a name="l01601"></a>01601                 <span class="keywordflow">return</span> reverse_iterator2 (begin ());
<a name="l01602"></a>01602             }
<a name="l01603"></a>01603 <span class="preprocessor">#endif</span>
<a name="l01604"></a>01604 <span class="preprocessor"></span>
<a name="l01605"></a>01605             <span class="comment">// Indices</span>
<a name="l01606"></a>01606             BOOST_UBLAS_INLINE
<a name="l01607"></a>01607             size_type index1 ()<span class="keyword"> const </span>{
<a name="l01608"></a>01608                 <span class="keywordflow">return</span> it1_.index1 ();
<a name="l01609"></a>01609             }
<a name="l01610"></a>01610             BOOST_UBLAS_INLINE
<a name="l01611"></a>01611             size_type index2 ()<span class="keyword"> const </span>{
<a name="l01612"></a>01612                 <span class="keywordflow">return</span> it1_.index2 ();
<a name="l01613"></a>01613             }
<a name="l01614"></a>01614 
<a name="l01615"></a>01615             <span class="comment">// Assignment</span>
<a name="l01616"></a>01616             BOOST_UBLAS_INLINE
<a name="l01617"></a>01617             iterator1 &amp;operator = (<span class="keyword">const</span> iterator1 &amp;it) {
<a name="l01618"></a>01618                 container_reference&lt;self_type&gt;::assign (&amp;it ());
<a name="l01619"></a>01619                 it1_ = it.it1_;
<a name="l01620"></a>01620                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01621"></a>01621             }
<a name="l01622"></a>01622 
<a name="l01623"></a>01623             <span class="comment">// Comparison</span>
<a name="l01624"></a>01624             BOOST_UBLAS_INLINE
<a name="l01625"></a>01625             <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> iterator1 &amp;it)<span class="keyword"> const </span>{
<a name="l01626"></a>01626                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l01627"></a>01627                 <span class="keywordflow">return</span> it1_ == it.it1_;
<a name="l01628"></a>01628             }
<a name="l01629"></a>01629             BOOST_UBLAS_INLINE
<a name="l01630"></a>01630             <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> iterator1 &amp;it)<span class="keyword"> const </span>{
<a name="l01631"></a>01631                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l01632"></a>01632                 <span class="keywordflow">return</span> it1_ &lt; it.it1_;
<a name="l01633"></a>01633             }
<a name="l01634"></a>01634 
<a name="l01635"></a>01635         <span class="keyword">private</span>:
<a name="l01636"></a>01636             subiterator1_type it1_;
<a name="l01637"></a>01637 
<a name="l01638"></a>01638             <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator1.html">const_iterator1</a>;
<a name="l01639"></a>01639         };
<a name="l01640"></a>01640 <span class="preprocessor">#endif</span>
<a name="l01641"></a>01641 <span class="preprocessor"></span>
<a name="l01642"></a>01642         BOOST_UBLAS_INLINE
<a name="l01643"></a>01643         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator1.html">iterator1</a> begin1 () {
<a name="l01644"></a>01644             <span class="keywordflow">return</span> find1 (0, 0, 0);
<a name="l01645"></a>01645         }
<a name="l01646"></a>01646         BOOST_UBLAS_INLINE
<a name="l01647"></a>01647         iterator1 end1 () {
<a name="l01648"></a>01648             <span class="keywordflow">return</span> find1 (0, size1 (), 0);
<a name="l01649"></a>01649         }
<a name="l01650"></a>01650 
<a name="l01651"></a>01651 <span class="preprocessor">#ifndef BOOST_UBLAS_USE_INDEXED_ITERATOR</span>
<a name="l01652"></a><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator2.html">01652</a> <span class="preprocessor"></span>        <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator2.html">const_iterator2</a>:
<a name="l01653"></a>01653             <span class="keyword">public</span> container_const_reference&lt;banded_adaptor&gt;,
<a name="l01654"></a>01654             <span class="keyword">public</span> random_access_iterator_base&lt;packed_random_access_iterator_tag,
<a name="l01655"></a>01655                                                const_iterator2, value_type&gt; {
<a name="l01656"></a>01656         <span class="keyword">public</span>:
<a name="l01657"></a>01657             <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1numeric_1_1ublas_1_1iterator__restrict__traits.html">iterator_restrict_traits</a>&lt;<span class="keyword">typename</span> const_subiterator2_type::iterator_category,
<a name="l01658"></a>01658                                                       <a class="code" href="structboost_1_1numeric_1_1ublas_1_1packed__random__access__iterator__tag.html">packed_random_access_iterator_tag</a>&gt;::iterator_category iterator_category;
<a name="l01659"></a>01659             <span class="keyword">typedef</span> <span class="keyword">typename</span> const_subiterator2_type::value_type value_type;
<a name="l01660"></a>01660             <span class="keyword">typedef</span> <span class="keyword">typename</span> const_subiterator2_type::difference_type difference_type;
<a name="l01661"></a>01661             <span class="keyword">typedef</span> <span class="keyword">typename</span> const_subiterator2_type::reference reference;
<a name="l01662"></a>01662             <span class="keyword">typedef</span> <span class="keyword">typename</span> const_subiterator2_type::pointer pointer;
<a name="l01663"></a>01663 
<a name="l01664"></a>01664             <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator1.html">const_iterator1</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator1.html">dual_iterator_type</a>;
<a name="l01665"></a>01665             <span class="keyword">typedef</span> const_reverse_iterator1 dual_reverse_iterator_type;
<a name="l01666"></a>01666 
<a name="l01667"></a>01667             <span class="comment">// Construction and destruction</span>
<a name="l01668"></a>01668             BOOST_UBLAS_INLINE
<a name="l01669"></a>01669             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator2.html">const_iterator2</a> ():
<a name="l01670"></a>01670                 container_const_reference&lt;self_type&gt; (), it2_ () {}
<a name="l01671"></a>01671             BOOST_UBLAS_INLINE
<a name="l01672"></a>01672             const_iterator2 (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a> &amp;m, <span class="keyword">const</span> const_subiterator2_type &amp;it2):
<a name="l01673"></a>01673                 container_const_reference&lt;self_type&gt; (m), it2_ (it2) {}
<a name="l01674"></a>01674             BOOST_UBLAS_INLINE
<a name="l01675"></a>01675             const_iterator2 (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator2.html">iterator2</a> &amp;it):
<a name="l01676"></a>01676                 container_const_reference&lt;self_type&gt; (it ()), it2_ (it.it2_) {}
<a name="l01677"></a>01677 
<a name="l01678"></a>01678             <span class="comment">// Arithmetic</span>
<a name="l01679"></a>01679             BOOST_UBLAS_INLINE
<a name="l01680"></a>01680             const_iterator2 &amp;operator ++ () {
<a name="l01681"></a>01681                 ++ it2_;
<a name="l01682"></a>01682                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01683"></a>01683             }
<a name="l01684"></a>01684             BOOST_UBLAS_INLINE
<a name="l01685"></a>01685             const_iterator2 &amp;operator -- () {
<a name="l01686"></a>01686                 -- it2_;
<a name="l01687"></a>01687                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01688"></a>01688             }
<a name="l01689"></a>01689             BOOST_UBLAS_INLINE
<a name="l01690"></a>01690             const_iterator2 &amp;operator += (difference_type n) {
<a name="l01691"></a>01691                 it2_ += n;
<a name="l01692"></a>01692                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01693"></a>01693             }
<a name="l01694"></a>01694             BOOST_UBLAS_INLINE
<a name="l01695"></a>01695             const_iterator2 &amp;operator -= (difference_type n) {
<a name="l01696"></a>01696                 it2_ -= n;
<a name="l01697"></a>01697                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01698"></a>01698             }
<a name="l01699"></a>01699             BOOST_UBLAS_INLINE
<a name="l01700"></a>01700             difference_type operator - (<span class="keyword">const</span> const_iterator2 &amp;it)<span class="keyword"> const </span>{
<a name="l01701"></a>01701                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l01702"></a>01702                 <span class="keywordflow">return</span> it2_ - it.it2_;
<a name="l01703"></a>01703             }
<a name="l01704"></a>01704 
<a name="l01705"></a>01705             <span class="comment">// Dereference</span>
<a name="l01706"></a>01706             BOOST_UBLAS_INLINE
<a name="l01707"></a>01707             const_reference operator * ()<span class="keyword"> const </span>{
<a name="l01708"></a>01708                 size_type i = index1 ();
<a name="l01709"></a>01709                 size_type j = index2 ();
<a name="l01710"></a>01710                 BOOST_UBLAS_CHECK (i &lt; (*<span class="keyword">this</span>) ().size1 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01711"></a>01711                 BOOST_UBLAS_CHECK (j &lt; (*<span class="keyword">this</span>) ().size2 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01712"></a>01712 <span class="preprocessor">#ifdef BOOST_UBLAS_OWN_BANDED</span>
<a name="l01713"></a>01713 <span class="preprocessor"></span>                size_type k = (std::max) (i, j);
<a name="l01714"></a>01714                 size_type l = (*this) ().lower () + j - i;
<a name="l01715"></a>01715                 <span class="keywordflow">if</span> (k &lt; (std::max) ((*this) ().size1 (), (*this) ().size2 ()) &amp;&amp;
<a name="l01716"></a>01716                     l &lt; (*<span class="keyword">this</span>) ().lower () + 1 + (*this) ().upper ())
<a name="l01717"></a>01717                     <span class="keywordflow">return</span> *it2_;
<a name="l01718"></a>01718 <span class="preprocessor">#else</span>
<a name="l01719"></a>01719 <span class="preprocessor"></span>                size_type k = j;
<a name="l01720"></a>01720                 size_type l = (*this) ().upper () + i - j;
<a name="l01721"></a>01721                 <span class="keywordflow">if</span> (k &lt; (*<span class="keyword">this</span>) ().size2 () &amp;&amp;
<a name="l01722"></a>01722                     l &lt; (*this) ().lower () + 1 + (*this) ().upper ())
<a name="l01723"></a>01723                     <span class="keywordflow">return</span> *it2_;
<a name="l01724"></a>01724 <span class="preprocessor">#endif</span>
<a name="l01725"></a>01725 <span class="preprocessor"></span>                <span class="keywordflow">return</span> (*<span class="keyword">this</span>) () (i, j);
<a name="l01726"></a>01726             }
<a name="l01727"></a>01727             BOOST_UBLAS_INLINE
<a name="l01728"></a>01728             const_reference operator [] (difference_type n)<span class="keyword"> const </span>{
<a name="l01729"></a>01729                 <span class="keywordflow">return</span> *(*<span class="keyword">this</span> + n);
<a name="l01730"></a>01730             }
<a name="l01731"></a>01731 
<a name="l01732"></a>01732 <span class="preprocessor">#ifndef BOOST_UBLAS_NO_NESTED_CLASS_RELATION</span>
<a name="l01733"></a>01733 <span class="preprocessor"></span>            BOOST_UBLAS_INLINE
<a name="l01734"></a>01734 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01735"></a>01735 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01736"></a>01736 <span class="preprocessor">#endif</span>
<a name="l01737"></a>01737 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator1.html">const_iterator1</a> begin ()<span class="keyword"> const </span>{
<a name="l01738"></a>01738                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find1 (1, 0, index2 ());
<a name="l01739"></a>01739             }
<a name="l01740"></a>01740             BOOST_UBLAS_INLINE
<a name="l01741"></a>01741 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01742"></a>01742 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01743"></a>01743 <span class="preprocessor">#endif</span>
<a name="l01744"></a>01744 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator1.html">const_iterator1</a> end ()<span class="keyword"> const </span>{
<a name="l01745"></a>01745                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find1 (1, (*<span class="keyword">this</span>) ().size1 (), index2 ());
<a name="l01746"></a>01746             }
<a name="l01747"></a>01747             BOOST_UBLAS_INLINE
<a name="l01748"></a>01748 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01749"></a>01749 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01750"></a>01750 <span class="preprocessor">#endif</span>
<a name="l01751"></a>01751 <span class="preprocessor"></span>            const_reverse_iterator1 rbegin ()<span class="keyword"> const </span>{
<a name="l01752"></a>01752                 <span class="keywordflow">return</span> const_reverse_iterator1 (end ());
<a name="l01753"></a>01753             }
<a name="l01754"></a>01754             BOOST_UBLAS_INLINE
<a name="l01755"></a>01755 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01756"></a>01756 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01757"></a>01757 <span class="preprocessor">#endif</span>
<a name="l01758"></a>01758 <span class="preprocessor"></span>            const_reverse_iterator1 rend ()<span class="keyword"> const </span>{
<a name="l01759"></a>01759                 <span class="keywordflow">return</span> const_reverse_iterator1 (begin ());
<a name="l01760"></a>01760             }
<a name="l01761"></a>01761 <span class="preprocessor">#endif</span>
<a name="l01762"></a>01762 <span class="preprocessor"></span>
<a name="l01763"></a>01763             <span class="comment">// Indices</span>
<a name="l01764"></a>01764             BOOST_UBLAS_INLINE
<a name="l01765"></a>01765             size_type index1 ()<span class="keyword"> const </span>{
<a name="l01766"></a>01766                 <span class="keywordflow">return</span> it2_.index1 ();
<a name="l01767"></a>01767             }
<a name="l01768"></a>01768             BOOST_UBLAS_INLINE
<a name="l01769"></a>01769             size_type index2 ()<span class="keyword"> const </span>{
<a name="l01770"></a>01770                 <span class="keywordflow">return</span> it2_.index2 ();
<a name="l01771"></a>01771             }
<a name="l01772"></a>01772 
<a name="l01773"></a>01773             <span class="comment">// Assignment</span>
<a name="l01774"></a>01774             BOOST_UBLAS_INLINE
<a name="l01775"></a>01775             const_iterator2 &amp;operator = (<span class="keyword">const</span> const_iterator2 &amp;it) {
<a name="l01776"></a>01776                 container_const_reference&lt;self_type&gt;::assign (&amp;it ());
<a name="l01777"></a>01777                 it2_ = it.it2_;
<a name="l01778"></a>01778                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01779"></a>01779             }
<a name="l01780"></a>01780 
<a name="l01781"></a>01781             <span class="comment">// Comparison</span>
<a name="l01782"></a>01782             BOOST_UBLAS_INLINE
<a name="l01783"></a>01783             <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> const_iterator2 &amp;it)<span class="keyword"> const </span>{
<a name="l01784"></a>01784                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l01785"></a>01785                 <span class="keywordflow">return</span> it2_ == it.it2_;
<a name="l01786"></a>01786             }
<a name="l01787"></a>01787             BOOST_UBLAS_INLINE
<a name="l01788"></a>01788             <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> const_iterator2 &amp;it)<span class="keyword"> const </span>{
<a name="l01789"></a>01789                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l01790"></a>01790                 <span class="keywordflow">return</span> it2_ &lt; it.it2_;
<a name="l01791"></a>01791             }
<a name="l01792"></a>01792 
<a name="l01793"></a>01793         <span class="keyword">private</span>:
<a name="l01794"></a>01794             const_subiterator2_type it2_;
<a name="l01795"></a>01795         };
<a name="l01796"></a>01796 <span class="preprocessor">#endif</span>
<a name="l01797"></a>01797 <span class="preprocessor"></span>
<a name="l01798"></a>01798         BOOST_UBLAS_INLINE
<a name="l01799"></a>01799         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator2.html">const_iterator2</a> begin2 ()<span class="keyword"> const </span>{
<a name="l01800"></a>01800             <span class="keywordflow">return</span> find2 (0, 0, 0);
<a name="l01801"></a>01801         }
<a name="l01802"></a>01802         BOOST_UBLAS_INLINE
<a name="l01803"></a>01803         const_iterator2 end2 ()<span class="keyword"> const </span>{
<a name="l01804"></a>01804             <span class="keywordflow">return</span> find2 (0, 0, size2 ());
<a name="l01805"></a>01805         }
<a name="l01806"></a>01806 
<a name="l01807"></a>01807 <span class="preprocessor">#ifndef BOOST_UBLAS_USE_INDEXED_ITERATOR</span>
<a name="l01808"></a><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator2.html">01808</a> <span class="preprocessor"></span>        <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator2.html">iterator2</a>:
<a name="l01809"></a>01809             <span class="keyword">public</span> container_reference&lt;banded_adaptor&gt;,
<a name="l01810"></a>01810             <span class="keyword">public</span> random_access_iterator_base&lt;typename iterator_restrict_traits&lt;
<a name="l01811"></a>01811                                                    typename subiterator2_type::iterator_category, packed_random_access_iterator_tag&gt;::iterator_category,
<a name="l01812"></a>01812                                                iterator2, value_type&gt; {
<a name="l01813"></a>01813         <span class="keyword">public</span>:
<a name="l01814"></a>01814             <span class="keyword">typedef</span> <span class="keyword">typename</span> subiterator2_type::value_type value_type;
<a name="l01815"></a>01815             <span class="keyword">typedef</span> <span class="keyword">typename</span> subiterator2_type::difference_type difference_type;
<a name="l01816"></a>01816             <span class="keyword">typedef</span> <span class="keyword">typename</span> subiterator2_type::reference reference;
<a name="l01817"></a>01817             <span class="keyword">typedef</span> <span class="keyword">typename</span> subiterator2_type::pointer pointer;
<a name="l01818"></a>01818 
<a name="l01819"></a>01819             <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator1.html">iterator1</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator1.html">dual_iterator_type</a>;
<a name="l01820"></a>01820             <span class="keyword">typedef</span> reverse_iterator1 dual_reverse_iterator_type;
<a name="l01821"></a>01821 
<a name="l01822"></a>01822             <span class="comment">// Construction and destruction</span>
<a name="l01823"></a>01823             BOOST_UBLAS_INLINE
<a name="l01824"></a>01824             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator2.html">iterator2</a> ():
<a name="l01825"></a>01825                 container_reference&lt;self_type&gt; (), it2_ () {}
<a name="l01826"></a>01826             BOOST_UBLAS_INLINE
<a name="l01827"></a>01827             iterator2 (<a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a> &amp;m, <span class="keyword">const</span> subiterator2_type &amp;it2):
<a name="l01828"></a>01828                 container_reference&lt;self_type&gt; (m), it2_ (it2) {}
<a name="l01829"></a>01829 
<a name="l01830"></a>01830             <span class="comment">// Arithmetic</span>
<a name="l01831"></a>01831             BOOST_UBLAS_INLINE
<a name="l01832"></a>01832             iterator2 &amp;operator ++ () {
<a name="l01833"></a>01833                 ++ it2_;
<a name="l01834"></a>01834                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01835"></a>01835             }
<a name="l01836"></a>01836             BOOST_UBLAS_INLINE
<a name="l01837"></a>01837             iterator2 &amp;operator -- () {
<a name="l01838"></a>01838                 -- it2_;
<a name="l01839"></a>01839                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01840"></a>01840             }
<a name="l01841"></a>01841             BOOST_UBLAS_INLINE
<a name="l01842"></a>01842             iterator2 &amp;operator += (difference_type n) {
<a name="l01843"></a>01843                 it2_ += n;
<a name="l01844"></a>01844                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01845"></a>01845             }
<a name="l01846"></a>01846             BOOST_UBLAS_INLINE
<a name="l01847"></a>01847             iterator2 &amp;operator -= (difference_type n) {
<a name="l01848"></a>01848                 it2_ -= n;
<a name="l01849"></a>01849                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01850"></a>01850             }
<a name="l01851"></a>01851             BOOST_UBLAS_INLINE
<a name="l01852"></a>01852             difference_type operator - (<span class="keyword">const</span> iterator2 &amp;it)<span class="keyword"> const </span>{
<a name="l01853"></a>01853                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l01854"></a>01854                 <span class="keywordflow">return</span> it2_ - it.it2_;
<a name="l01855"></a>01855             }
<a name="l01856"></a>01856 
<a name="l01857"></a>01857             <span class="comment">// Dereference</span>
<a name="l01858"></a>01858             BOOST_UBLAS_INLINE
<a name="l01859"></a>01859             reference operator * ()<span class="keyword"> const </span>{
<a name="l01860"></a>01860                 size_type i = index1 ();
<a name="l01861"></a>01861                 size_type j = index2 ();
<a name="l01862"></a>01862                 BOOST_UBLAS_CHECK (i &lt; (*<span class="keyword">this</span>) ().size1 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01863"></a>01863                 BOOST_UBLAS_CHECK (j &lt; (*<span class="keyword">this</span>) ().size2 (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1bad__index.html">bad_index</a> ());
<a name="l01864"></a>01864 <span class="preprocessor">#ifdef BOOST_UBLAS_OWN_BANDED</span>
<a name="l01865"></a>01865 <span class="preprocessor"></span>                size_type k = (std::max) (i, j);
<a name="l01866"></a>01866                 size_type l = (*this) ().lower () + j - i;
<a name="l01867"></a>01867                 <span class="keywordflow">if</span> (k &lt; (std::max) ((*this) ().size1 (), (*this) ().size2 ()) &amp;&amp;
<a name="l01868"></a>01868                     l &lt; (*<span class="keyword">this</span>) ().lower () + 1 + (*this) ().upper ())
<a name="l01869"></a>01869                     <span class="keywordflow">return</span> *it2_;
<a name="l01870"></a>01870 <span class="preprocessor">#else</span>
<a name="l01871"></a>01871 <span class="preprocessor"></span>                size_type k = j;
<a name="l01872"></a>01872                 size_type l = (*this) ().upper () + i - j;
<a name="l01873"></a>01873                 <span class="keywordflow">if</span> (k &lt; (*<span class="keyword">this</span>) ().size2 () &amp;&amp;
<a name="l01874"></a>01874                     l &lt; (*this) ().lower () + 1 + (*this) ().upper ())
<a name="l01875"></a>01875                     <span class="keywordflow">return</span> *it2_;
<a name="l01876"></a>01876 <span class="preprocessor">#endif</span>
<a name="l01877"></a>01877 <span class="preprocessor"></span>                <span class="keywordflow">return</span> (*<span class="keyword">this</span>) () (i, j);
<a name="l01878"></a>01878             }
<a name="l01879"></a>01879             BOOST_UBLAS_INLINE
<a name="l01880"></a>01880             reference operator [] (difference_type n)<span class="keyword"> const </span>{
<a name="l01881"></a>01881                 <span class="keywordflow">return</span> *(*<span class="keyword">this</span> + n);
<a name="l01882"></a>01882             }
<a name="l01883"></a>01883 
<a name="l01884"></a>01884 <span class="preprocessor">#ifndef BOOST_UBLAS_NO_NESTED_CLASS_RELATION</span>
<a name="l01885"></a>01885 <span class="preprocessor"></span>            BOOST_UBLAS_INLINE
<a name="l01886"></a>01886 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01887"></a>01887 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01888"></a>01888 <span class="preprocessor">#endif</span>
<a name="l01889"></a>01889 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator1.html">iterator1</a> begin ()<span class="keyword"> const </span>{
<a name="l01890"></a>01890                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find1 (1, 0, index2 ());
<a name="l01891"></a>01891             }
<a name="l01892"></a>01892             BOOST_UBLAS_INLINE
<a name="l01893"></a>01893 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01894"></a>01894 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01895"></a>01895 <span class="preprocessor">#endif</span>
<a name="l01896"></a>01896 <span class="preprocessor"></span>            <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator1.html">iterator1</a> end ()<span class="keyword"> const </span>{
<a name="l01897"></a>01897                 <span class="keywordflow">return</span> (*<span class="keyword">this</span>) ().find1 (1, (*<span class="keyword">this</span>) ().size1 (), index2 ());
<a name="l01898"></a>01898             }
<a name="l01899"></a>01899             BOOST_UBLAS_INLINE
<a name="l01900"></a>01900 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01901"></a>01901 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01902"></a>01902 <span class="preprocessor">#endif</span>
<a name="l01903"></a>01903 <span class="preprocessor"></span>            reverse_iterator1 rbegin ()<span class="keyword"> const </span>{
<a name="l01904"></a>01904                 <span class="keywordflow">return</span> reverse_iterator1 (end ());
<a name="l01905"></a>01905             }
<a name="l01906"></a>01906             BOOST_UBLAS_INLINE
<a name="l01907"></a>01907 <span class="preprocessor">#ifdef BOOST_UBLAS_MSVC_NESTED_CLASS_RELATION</span>
<a name="l01908"></a>01908 <span class="preprocessor"></span>            <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">self_type</a>::
<a name="l01909"></a>01909 <span class="preprocessor">#endif</span>
<a name="l01910"></a>01910 <span class="preprocessor"></span>            reverse_iterator1 rend ()<span class="keyword"> const </span>{
<a name="l01911"></a>01911                 <span class="keywordflow">return</span> reverse_iterator1 (begin ());
<a name="l01912"></a>01912             }
<a name="l01913"></a>01913 <span class="preprocessor">#endif</span>
<a name="l01914"></a>01914 <span class="preprocessor"></span>
<a name="l01915"></a>01915             <span class="comment">// Indices</span>
<a name="l01916"></a>01916             BOOST_UBLAS_INLINE
<a name="l01917"></a>01917             size_type index1 ()<span class="keyword"> const </span>{
<a name="l01918"></a>01918                 <span class="keywordflow">return</span> it2_.index1 ();
<a name="l01919"></a>01919             }
<a name="l01920"></a>01920             BOOST_UBLAS_INLINE
<a name="l01921"></a>01921             size_type index2 ()<span class="keyword"> const </span>{
<a name="l01922"></a>01922                 <span class="keywordflow">return</span> it2_.index2 ();
<a name="l01923"></a>01923             }
<a name="l01924"></a>01924 
<a name="l01925"></a>01925             <span class="comment">// Assignment</span>
<a name="l01926"></a>01926             BOOST_UBLAS_INLINE
<a name="l01927"></a>01927             iterator2 &amp;operator = (<span class="keyword">const</span> iterator2 &amp;it) {
<a name="l01928"></a>01928                 container_reference&lt;self_type&gt;::assign (&amp;it ());
<a name="l01929"></a>01929                 it2_ = it.it2_;
<a name="l01930"></a>01930                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01931"></a>01931             }
<a name="l01932"></a>01932 
<a name="l01933"></a>01933             <span class="comment">// Comparison</span>
<a name="l01934"></a>01934             BOOST_UBLAS_INLINE
<a name="l01935"></a>01935             <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> iterator2 &amp;it)<span class="keyword"> const </span>{
<a name="l01936"></a>01936                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l01937"></a>01937                 <span class="keywordflow">return</span> it2_ == it.it2_;
<a name="l01938"></a>01938             }
<a name="l01939"></a>01939             BOOST_UBLAS_INLINE
<a name="l01940"></a>01940             <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> iterator2 &amp;it)<span class="keyword"> const </span>{
<a name="l01941"></a>01941                 BOOST_UBLAS_CHECK (&amp;(*<span class="keyword">this</span>) () == &amp;it (), <a class="code" href="structboost_1_1numeric_1_1ublas_1_1external__logic.html">external_logic</a> ());
<a name="l01942"></a>01942                 <span class="keywordflow">return</span> it2_ &lt; it.it2_;
<a name="l01943"></a>01943             }
<a name="l01944"></a>01944 
<a name="l01945"></a>01945         <span class="keyword">private</span>:
<a name="l01946"></a>01946             subiterator2_type it2_;
<a name="l01947"></a>01947 
<a name="l01948"></a>01948             <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1const__iterator2.html">const_iterator2</a>;
<a name="l01949"></a>01949         };
<a name="l01950"></a>01950 <span class="preprocessor">#endif</span>
<a name="l01951"></a>01951 <span class="preprocessor"></span>
<a name="l01952"></a>01952         BOOST_UBLAS_INLINE
<a name="l01953"></a>01953         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor_1_1iterator2.html">iterator2</a> begin2 () {
<a name="l01954"></a>01954             <span class="keywordflow">return</span> find2 (0, 0, 0);
<a name="l01955"></a>01955         }
<a name="l01956"></a>01956         BOOST_UBLAS_INLINE
<a name="l01957"></a>01957         iterator2 end2 () {
<a name="l01958"></a>01958             <span class="keywordflow">return</span> find2 (0, 0, size2 ());
<a name="l01959"></a>01959         }
<a name="l01960"></a>01960 
<a name="l01961"></a>01961         <span class="comment">// Reverse iterators</span>
<a name="l01962"></a>01962 
<a name="l01963"></a>01963         BOOST_UBLAS_INLINE
<a name="l01964"></a>01964         const_reverse_iterator1 rbegin1 ()<span class="keyword"> const </span>{
<a name="l01965"></a>01965             <span class="keywordflow">return</span> const_reverse_iterator1 (end1 ());
<a name="l01966"></a>01966         }
<a name="l01967"></a>01967         BOOST_UBLAS_INLINE
<a name="l01968"></a>01968         const_reverse_iterator1 rend1 ()<span class="keyword"> const </span>{
<a name="l01969"></a>01969             <span class="keywordflow">return</span> const_reverse_iterator1 (begin1 ());
<a name="l01970"></a>01970         }
<a name="l01971"></a>01971 
<a name="l01972"></a>01972         BOOST_UBLAS_INLINE
<a name="l01973"></a>01973         reverse_iterator1 rbegin1 () {
<a name="l01974"></a>01974             <span class="keywordflow">return</span> reverse_iterator1 (end1 ());
<a name="l01975"></a>01975         }
<a name="l01976"></a>01976         BOOST_UBLAS_INLINE
<a name="l01977"></a>01977         reverse_iterator1 rend1 () {
<a name="l01978"></a>01978             <span class="keywordflow">return</span> reverse_iterator1 (begin1 ());
<a name="l01979"></a>01979         }
<a name="l01980"></a>01980 
<a name="l01981"></a>01981         BOOST_UBLAS_INLINE
<a name="l01982"></a>01982         const_reverse_iterator2 rbegin2 ()<span class="keyword"> const </span>{
<a name="l01983"></a>01983             <span class="keywordflow">return</span> const_reverse_iterator2 (end2 ());
<a name="l01984"></a>01984         }
<a name="l01985"></a>01985         BOOST_UBLAS_INLINE
<a name="l01986"></a>01986         const_reverse_iterator2 rend2 ()<span class="keyword"> const </span>{
<a name="l01987"></a>01987             <span class="keywordflow">return</span> const_reverse_iterator2 (begin2 ());
<a name="l01988"></a>01988         }
<a name="l01989"></a>01989 
<a name="l01990"></a>01990         BOOST_UBLAS_INLINE
<a name="l01991"></a>01991         reverse_iterator2 rbegin2 () {
<a name="l01992"></a>01992             <span class="keywordflow">return</span> reverse_iterator2 (end2 ());
<a name="l01993"></a>01993         }
<a name="l01994"></a>01994         BOOST_UBLAS_INLINE
<a name="l01995"></a>01995         reverse_iterator2 rend2 () {
<a name="l01996"></a>01996             <span class="keywordflow">return</span> reverse_iterator2 (begin2 ());
<a name="l01997"></a>01997         }
<a name="l01998"></a>01998 
<a name="l01999"></a>01999     <span class="keyword">private</span>:
<a name="l02000"></a>02000         matrix_closure_type data_;
<a name="l02001"></a>02001         size_type lower_;
<a name="l02002"></a>02002         size_type upper_;
<a name="l02003"></a>02003         <span class="keyword">typedef</span> <span class="keyword">const</span> value_type const_value_type;
<a name="l02004"></a>02004         <span class="keyword">static</span> const_value_type zero_;
<a name="l02005"></a>02005     };
<a name="l02006"></a>02006 
<a name="l02007"></a>02007     <span class="comment">// Specialization for temporary_traits</span>
<a name="l02008"></a>02008     <span class="keyword">template</span> &lt;<span class="keyword">class</span> M&gt;
<a name="l02009"></a><a class="code" href="structboost_1_1numeric_1_1ublas_1_1vector__temporary__traits_3_01banded__adaptor_3_01_m_01_4_01_4.html">02009</a>     <span class="keyword">struct </span>vector_temporary_traits&lt; banded_adaptor&lt;M&gt; &gt;
<a name="l02010"></a>02010     : vector_temporary_traits&lt; M &gt; {} ;
<a name="l02011"></a>02011     <span class="keyword">template</span> &lt;<span class="keyword">class</span> M&gt;
<a name="l02012"></a><a class="code" href="structboost_1_1numeric_1_1ublas_1_1vector__temporary__traits_3_01const_01banded__adaptor_3_01_m_01_4_01_4.html">02012</a>     <span class="keyword">struct </span>vector_temporary_traits&lt; const banded_adaptor&lt;M&gt; &gt;
<a name="l02013"></a>02013     : vector_temporary_traits&lt; M &gt; {} ;
<a name="l02014"></a>02014 
<a name="l02015"></a>02015     <span class="keyword">template</span> &lt;<span class="keyword">class</span> M&gt;
<a name="l02016"></a><a class="code" href="structboost_1_1numeric_1_1ublas_1_1matrix__temporary__traits_3_01banded__adaptor_3_01_m_01_4_01_4.html">02016</a>     <span class="keyword">struct </span>matrix_temporary_traits&lt; banded_adaptor&lt;M&gt; &gt;
<a name="l02017"></a>02017     : matrix_temporary_traits&lt; M &gt; {} ;
<a name="l02018"></a>02018     <span class="keyword">template</span> &lt;<span class="keyword">class</span> M&gt;
<a name="l02019"></a><a class="code" href="structboost_1_1numeric_1_1ublas_1_1matrix__temporary__traits_3_01const_01banded__adaptor_3_01_m_01_4_01_4.html">02019</a>     <span class="keyword">struct </span>matrix_temporary_traits&lt; const banded_adaptor&lt;M&gt; &gt;
<a name="l02020"></a>02020     : matrix_temporary_traits&lt; M &gt; {} ;
<a name="l02021"></a>02021 
<a name="l02022"></a>02022 
<a name="l02023"></a>02023     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M&gt;
<a name="l02024"></a>02024     <span class="keyword">typename</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">banded_adaptor&lt;M&gt;::const_value_type</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">banded_adaptor&lt;M&gt;::zero_</a> = value_type<span class="comment">/*zero*/</span>();
<a name="l02025"></a>02025 
<a name="l02038"></a>02038     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M&gt;
<a name="l02039"></a><a class="code" href="classboost_1_1numeric_1_1ublas_1_1diagonal__adaptor.html">02039</a>     <span class="keyword">class </span><a class="code" href="classboost_1_1numeric_1_1ublas_1_1diagonal__adaptor.html" title="A diagonal matrix adaptator: convert a any matrix into a diagonal matrix expression...">diagonal_adaptor</a>:
<a name="l02040"></a>02040         <span class="keyword">public</span> banded_adaptor&lt;M&gt; {
<a name="l02041"></a>02041     <span class="keyword">public</span>:
<a name="l02042"></a>02042         <span class="keyword">typedef</span> M matrix_type;
<a name="l02043"></a>02043         <span class="keyword">typedef</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">banded_adaptor&lt;M&gt;</a> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">adaptor_type</a>;
<a name="l02044"></a>02044 
<a name="l02045"></a>02045         <span class="comment">// Construction and destruction</span>
<a name="l02046"></a>02046         BOOST_UBLAS_INLINE
<a name="l02047"></a>02047         <a class="code" href="classboost_1_1numeric_1_1ublas_1_1diagonal__adaptor.html" title="A diagonal matrix adaptator: convert a any matrix into a diagonal matrix expression...">diagonal_adaptor</a> ():
<a name="l02048"></a>02048             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">adaptor_type</a> () {}
<a name="l02049"></a>02049         BOOST_UBLAS_INLINE
<a name="l02050"></a>02050         diagonal_adaptor (matrix_type &amp;data):
<a name="l02051"></a>02051             <a class="code" href="classboost_1_1numeric_1_1ublas_1_1banded__adaptor.html" title="A banded matrix adaptator: convert a any matrix into a banded matrix expression.">adaptor_type</a> (data) {}
<a name="l02052"></a>02052         BOOST_UBLAS_INLINE
<a name="l02053"></a>02053         ~diagonal_adaptor () {}
<a name="l02054"></a>02054 
<a name="l02055"></a>02055         <span class="comment">// Assignment</span>
<a name="l02056"></a>02056         BOOST_UBLAS_INLINE
<a name="l02057"></a>02057         diagonal_adaptor &amp;operator = (<span class="keyword">const</span> diagonal_adaptor &amp;m) {
<a name="l02058"></a>02058             adaptor_type::operator = (m);
<a name="l02059"></a>02059             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02060"></a>02060         }
<a name="l02061"></a>02061         <span class="keyword">template</span>&lt;<span class="keyword">class</span> AE&gt;
<a name="l02062"></a>02062         BOOST_UBLAS_INLINE
<a name="l02063"></a>02063         diagonal_adaptor &amp;operator = (<span class="keyword">const</span> <a class="code" href="classboost_1_1numeric_1_1ublas_1_1matrix__expression.html" title="Base class for Matrix Expression models.">matrix_expression&lt;AE&gt;</a> &amp;ae) {
<a name="l02064"></a>02064             adaptor_type::operator = (ae);
<a name="l02065"></a>02065             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02066"></a>02066         }
<a name="l02067"></a>02067     };
<a name="l02068"></a>02068 
<a name="l02069"></a>02069 }}}
<a name="l02070"></a>02070 
<a name="l02071"></a>02071 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Jul 4 20:30:49 2010 for ublas by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
