<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<link rel="stylesheet" href="../../../../boost.css" type="text/css"/>
<link rel="stylesheet" href="ublas.css" type="text/css" />
<script type="text/javascript" src="js/jquery-1.3.2.min.js" async="async" ></script>
<script type="text/javascript" src="js/jquery.toc-gw.js" async="async" ></script>
<title>Expression Concepts</title>
</head>
<body>
<h1><img src="../../../../boost.png" align="middle" />Expression Concepts</h1>
<div class="toc" id="toc"></div>
<h2><a name="scalar_expression"></a>Scalar Expression</h2>
<h4>Description</h4>
<p>A Scalar Expression is an expression convertible to a scalar
type.</p>
<h4>Refinement of</h4>
<p>Default Constructible.</p>
<h4>Associated types</h4>
<table border="1" summary="associated types">
<tbody>
<tr>
<td>Public base</td>
<td>scaler_expression&lt;S&gt;</td>
<td>S must be derived from this public base type.</td>
</tr>
<tr>
<td>Value type</td>
<td><code>value_type</code></td>
<td>The type of the scalar expression.</td>
</tr>
</tbody>
</table>
<h4>Notation</h4>
<table border="0" summary="notation">
<tbody>
<tr>
<td><code>S</code></td>
<td>A type that is a model of Scalar Expression</td>
</tr>
</tbody>
</table>
<h4>Definitions</h4>
<h4>Valid expressions</h4>
<p>In addition to the expressions defined in Default Constructible
the following expressions must be valid.</p>
<table border="1" summary="expressions">
<tbody>
<tr>
<th>Name</th>
<th>Expression</th>
<th>Type requirements</th>
<th>Return type</th>
</tr>
<tr>
<td>Evaluation</td>
<td><code>operator value_type () const</code></td>
<td>&nbsp;</td>
<td><code>value_type</code></td>
</tr>
</tbody>
</table>
<h4>Expression semantics</h4>
<p>Semantics of an expression is defined only where it differs
from, or is not defined in Default Constructible.</p>
<table border="1" summary="semantics">
<tbody>
<tr>
<th>Name</th>
<th>Expression</th>
<th>Precondition</th>
<th>Semantics</th>
<th>Postcondition</th>
</tr>
<tr>
<td>Evaluation</td>
<td><code>operator value_type () const</code></td>
<td>&nbsp;</td>
<td>&nbsp; Evaluates the scalar expression.</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<h4>Complexity guarantees</h4>
<p>The run-time complexity of the evaluation is specific for the
evaluated scalar expression.</p>
<h4>Invariants</h4>
<h4>Models</h4>
<ul>
<li><code>vector_scalar_unary</code></li>
<li><code>vector_scalar_binary</code></li>
</ul>
<h2><a name="vector_expression"></a>Vector Expression</h2>
<h4>Description</h4>
<p>A Vector Expression is an expression evaluatable to a vector.
Vector Expression provides an <a href=
"iterator_concept.htm#indexed_bidirectional_iterator">Indexed Bidirectional
Iterator</a> or an <a href=
"iterator_concept.htm#indexed_random_access_iterator">Indexed Random Access
Iterator</a> .</p>
<h4>Refinement of</h4>
<p>Default Constructible.</p>
<h4>Associated types</h4>
<table border="1" summary="associated types">
<tbody>
<tr>
<td>Public base</td>
<td>vector_expression&lt;V&gt;</td>
<td>V must be derived from this public base type.</td>
</tr>
<tr>
<td>Value type</td>
<td><code>value_type</code></td>
<td>
The element type of the vector expression.
</td>
</tr>
<tr>
<td>Reference type</td>
<td><code>reference</code></td>
<td>
The return type when accessing an element of a vector expression.
<br />
Convertable to a<code>value_type</code>.
</td>
</tr>
<tr>
<td>Const reference type</td>
<td><code>const_reference</code></td>
<td>
The return type when accessing an element of a constant vector expression.
<br />
Convertable to a<code>value_type</code>.
</td>
</tr>
<tr>
<td>Size type</td>
<td><code>size_type</code></td>
<td>
The index type of the vector expression. Am unsigned integral type used to represent size and index values.
<br />
Can represent any nonnegative value of <code>difference_type</code>.
</td>
</tr>
<tr>
<td>Distance type</td>
<td><code>difference_type</code></td>
<td>
A signed integral type used to represent the distance between two of the vector expression&#039;s iterators.
</td>
</tr>
<tr>
<td>Const iterator type</td>
<td><code>const_iterator</code></td>
<td>A type of iterator that may be used to examine a vector
expression's elements.</td>
</tr>
<tr>
<td>Iterator type</td>
<td><code>iterator</code></td>
<td>A type of iterator that may be used to modify a vector
expression's elements.</td>
</tr>
<tr>
<td>Const reverse iterator type</td>
<td><code>const_reverse_iterator</code></td>
<td>A Reverse Iterator adaptor whose base iterator type is the
vector expression's const iterator type.</td>
</tr>
<tr>
<td>Reverse iterator type</td>
<td><code>reverse_iterator</code></td>
<td>A Reverse Iterator adaptor whose base iterator type is the
vector expression's iterator type.</td>
</tr>
</tbody>
</table>
<h4>Notation</h4>
<table border="0" summary="notation">
<tbody>
<tr>
<td><code>V</code></td>
<td>A type that is a model of Vector Expression</td>
</tr>
<tr>
<td><code>v, v1, v2</code></td>
<td>Object of type <code>V</code></td>
</tr>
<tr>
<td><code>i</code></td>
<td>Object of a type convertible to <code>size_type</code></td>
</tr>
<tr>
<td><code>t</code></td>
<td>Object of a type convertible to <code>value_type</code></td>
</tr>
</tbody>
</table>
<h4>Definitions</h4>
<h4>Valid expressions</h4>
<p>In addition to the expressions defined in Default Constructible
the following expressions must be valid.</p>
<table border="1" summary="expressions">
<tbody>
<tr>
<th>Name</th>
<th>Expression</th>
<th>Type requirements</th>
<th>Return type</th>
</tr>
<tr>
<td rowspan="2">Beginning of range</td>
<td><code>v.begin ()</code></td>
<td>&nbsp;</td>
<td><code>const_iterator</code></td>
</tr>
<tr>
<td><code>v.begin ()</code></td>
<td><code>v</code> is mutable.</td>
<td><code>iterator</code></td>
</tr>
<tr>
<td rowspan="2">End of range</td>
<td><code>v.end ()</code></td>
<td>&nbsp;</td>
<td><code>const_iterator</code></td>
</tr>
<tr>
<td><code>v.end ()</code></td>
<td><code>v</code> is mutable.</td>
<td><code>iterator</code></td>
</tr>
<tr>
<td>Size</td>
<td><code>v.size ()</code></td>
<td>&nbsp;</td>
<td><code>size_type</code></td>
</tr>
<tr>
<td>Swap</td>
<td><code>v1.swap (v2)</code></td>
<td><code>v1</code> and <code>v2</code> are mutable.</td>
<td><code>void</code></td>
</tr>
<tr>
<td rowspan="2">Beginning of reverse range</td>
<td><code>v.rbegin ()</code></td>
<td>&nbsp;</td>
<td><code>const_reverse_iterator</code></td>
</tr>
<tr>
<td><code>v.rbegin ()</code></td>
<td><code>v</code> is mutable.</td>
<td><code>reverse_iterator</code></td>
</tr>
<tr>
<td rowspan="2">End of reverse range</td>
<td><code>v.rend ()</code></td>
<td>&nbsp;</td>
<td><code>const_reverse_iterator</code></td>
</tr>
<tr>
<td><code>v.rend ()</code></td>
<td><code>v</code> is mutable.</td>
<td><code>reverse_iterator</code></td>
</tr>
<tr>
<td>Element access</td>
<td><code>v (i)</code></td>
<td><code>i</code> is convertible to <code>size_type</code>.</td>
<td>Convertible to <code>value_type</code>.</td>
</tr>
<tr>
<td rowspan="2">Assignment</td>
<td><code>v2 = v1</code></td>
<td><code>v2</code> is mutable and <code>v1</code> is convertible
to <code>V</code>.</td>
<td><code>V &amp;</code></td>
</tr>
<tr>
<td><code>v2.assign (v1)</code></td>
<td><code>v2</code> is mutable and <code>v1</code> is convertible
to <code>V</code>.</td>
<td><code>V &amp;</code></td>
</tr>
<tr>
<td rowspan="5">Computed assignment</td>
<td><code>v2 += v1</code></td>
<td><code>v2</code> is mutable and <code>v1</code> is convertible
to <code>V</code>.</td>
<td><code>V &amp;</code></td>
</tr>
<tr>
<td><code>v2.plus_assign (v1)</code></td>
<td><code>v2</code> is mutable and <code>v1</code> is convertible
to <code>V</code>.</td>
<td><code>V &amp;</code></td>
</tr>
<tr>
<td><code>v2 -= v1</code></td>
<td><code>v2</code> is mutable and <code>v1</code> is convertible
to <code>V</code>.</td>
<td><code>V &amp;</code></td>
</tr>
<tr>
<td><code>v2.minus_assign (v1)</code></td>
<td><code>v2</code> is mutable and <code>v1</code> is convertible
to <code>V</code>.</td>
<td><code>V &amp;</code></td>
</tr>
<tr>
<td><code>v *= t</code></td>
<td><code>v</code> is mutable and <code>t</code> is convertible to
<code>value_type</code>.</td>
<td><code>V &amp;</code></td>
</tr>
</tbody>
</table>
<h4>Expression semantics</h4>
<p>Semantics of an expression is defined only where it differs
from, or is not defined in Default Constructible.</p>
<table border="1" summary="semantics">
<tbody>
<tr>
<th>Name</th>
<th>Expression</th>
<th>Precondition</th>
<th>Semantics</th>
<th>Postcondition</th>
</tr>
<tr>
<td>Beginning of range</td>
<td><code>v.begin ()</code></td>
<td>&nbsp;</td>
<td>Returns an iterator pointing to the first element in the vector
expression.</td>
<td><code>v.begin ()</code> is either dereferenceable or
past-the-end. It is past-the-end if and only if <code>v.size () ==
0</code>.</td>
</tr>
<tr>
<td>End of range</td>
<td><code>v.end ()</code></td>
<td>&nbsp;</td>
<td>Returns an iterator pointing one past the last element in the
vector expression.</td>
<td><code>v.end ()</code> is past-the-end.</td>
</tr>
<tr>
<td>Size</td>
<td><code>v.size ()</code></td>
<td>&nbsp;</td>
<td>Returns the size of the vector expression, that is, its number
of elements.</td>
<td><code>v.size () &gt;= 0</code></td>
</tr>
<tr>
<td>Swap</td>
<td><code>v1.swap (v2)</code></td>
<td>&nbsp;</td>
<td>Equivalent to <code>swap (v1, v2)</code>.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>Beginning of reverse range</td>
<td><code>v.rbegin ()</code></td>
<td>&nbsp;</td>
<td>Equivalent to <code>reverse_iterator (v.end ())</code>.</td>
<td><code>v.rbegin ()</code> is either dereferenceable or
past-the-end. It is past-the-end if and only if <code>v.size () ==
0</code>.</td>
</tr>
<tr>
<td>End of reverse range</td>
<td><code>v.rend ()</code></td>
<td>&nbsp;</td>
<td>Equivalent to <code>reverse_iterator (v.begin ())</code>.</td>
<td><code>v.rend ()</code> is past-the-end.</td>
</tr>
<tr>
<td>Element access</td>
<td><code>v (i)</code></td>
<td><code>0 &lt;= i &lt; v.size ()</code></td>
<td>Returns the <code>i</code>-th element of the vector
expression.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td rowspan="2">Assignment</td>
<td><code>v2 = v1</code></td>
<td><code>v1.size () == v2.size ()</code></td>
<td>Assigns every element of the evaluated vector expression
<code>v1</code> to the corresponding element of <code>v2</code>
.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>v2.assign (v1)</code></td>
<td><code>v1.size () == v2.size ()</code></td>
<td>Assigns every element of <code>v1</code> to the corresponding
element of <code>v2</code>.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td rowspan="5">Computed assignment</td>
<td><code>v2 += v1</code></td>
<td><code>v1.size () == v2.size ()</code></td>
<td>Adds every element of the evaluated vector expression
<code>v1</code> to the corresponding element of
<code>v2</code>.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>v2.plus_assign (v1)</code></td>
<td><code>v1.size () == v2.size ()</code></td>
<td>Adds every element of <code>v1</code> to the corresponding
element of <code>v2</code>.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>v2 -= v1</code></td>
<td><code>v1.size () == v2.size ()</code></td>
<td>Subtracts every element of the evaluated vector expression
<code>v1</code> from the corresponding element of <code>v2</code>
.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>v2.minus_assign (v1)</code></td>
<td><code>v1.size () == v2.size ()</code></td>
<td>Subtracts every element of <code>v1</code> from the
corresponding element of <code>v2</code>.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>v *= t</code></td>
<td>&nbsp;</td>
<td>Multiplies every element of <code>v</code> with <code>t</code>
.</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<h4>Complexity guarantees</h4>
<p>The run-time complexity of <code>begin ()</code> and <code>end
()</code> is specific for the evaluated vector expression,
typically amortized constant time.</p>
<p>The run-time complexity of <code>size ()</code> is constant
time.</p>
<p>The run-time complexity of <code>swap ()</code> is specific for
the evaluated vector expression, typically constant time.</p>
<p>The run-time complexity of <code>rbegin ()</code> and <code>rend
()</code> is specific for the evaluated vector expression,
typically amortized constant time.</p>
<p>The run-time complexity of the element access is specific for
the evaluated vector expression, typically amortized constant time
for the dense and logarithmic for the sparse case.</p>
<p>The run-time complexity of the arithmetic operations is specific
for the evaluated vector expressions, typically linear in the size
of the expressions.</p>
<h4>Invariants</h4>
<table border="1" summary="invariants">
<tbody>
<tr>
<td>Valid range</td>
<td>For any vector expression <code>v</code>, <code>[v.begin (),
v.end ())</code> is a valid range.</td>
</tr>
<tr>
<td>Completeness</td>
<td>An algorithm that iterates through the range <code>[v.begin (),
v.end ())</code> will pass through every element of <code>v</code>
.</td>
</tr>
<tr>
<td>Valid reverse range</td>
<td><code>[v.rbegin (), v.rend ())</code> is a valid range.</td>
</tr>
<tr>
<td>Equivalence of ranges</td>
<td>The distance from <code>v.begin ()</code> to <code>v.end
()</code> is the same as the distance from <code>v.rbegin ()</code>
to <code>v.rend ()</code>.</td>
</tr>
</tbody>
</table>
<h4>Models</h4>
<ul>
<li><code>vector_range;</code></li>
<li><code>vector_slice</code></li>
<li><code>matrix_row</code></li>
<li><code>matrix_column</code></li>
<li><code>matrix_vector_range</code></li>
<li><code>matrix_vector_slice</code></li>
<li><code>vector_unary</code></li>
<li><code>vector_binary</code></li>
<li><code>vector_binary_scalar1</code></li>
<li><code>vector_binary_scalar2</code></li>
<li><code>matrix_vector_unary1</code></li>
<li><code>matrix_vector_unary2</code></li>
<li><code>matrix_vector_binary1</code></li>
<li><code>matrix_vector_binary2</code></li>
</ul>

<h2><a name="matrix_expression"></a>Matrix Expression</h2>
<h4>Description</h4>
<p>A Matrix Expression is an expression evaluatable to a matrix.
Matrix Expression provides an <a href=
"iterator_concept.htm#indexed_bidirectional_cr_iterator">Indexed
Bidirectional Column/Row Iterator</a> or an <a href=
"iterator_concept.htm#indexed_random_access_cr_iterator">Indexed Random
Access Column/Row Iterator</a> .</p>
<h4>Refinement of</h4>
<p>Default Constructible.</p>

<h4>Associated types</h4>
<h5>immutable types</h5>
<table border="1" summary="associated immutable types" title="">
<tbody>
<tr>
<td>Public base</td>
<td><code>matrix_expression&lt;M&gt;</code></td>
<td>M must be derived from this public base type.</td>
</tr>
<tr>
<td>Value type</td>
<td><code>value_type</code></td>
<td>
The element type of the matrix expression.
</td>
</tr>
<tr>
<td>Const reference type</td>
<td><code>const_reference</code></td>
<td>
The return type when accessing an element of a constant matrix expression.
<br />
Convertable to a <code>value_type</code>.
</td>
</tr>
<tr>
<td>Size type</td>
<td><code>size_type</code></td>
<td>
The index type of the matrix expression. Am unsigned integral type used to represent size and index values.
<br />
Can represent any nonnegative value of <code>difference_type</code>.
</td>
</tr>
<tr>
<td>Distance type</td>
<td><code>difference_type</code></td>
<td>
A signed integral type used to represent the distance between two of the matrix expression&#039;s iterators.
</td>
</tr>
<tr>
<td rowspan="2">Const iterator types</td>
<td><code>const_iterator1</code></td>
<td>A type of column iterator that may be used to examine a matrix
expression's elements.</td>
</tr>
<tr>
<td><code>const_iterator2</code></td>
<td>A type of row iterator that may be used to examine a matrix
expression's elements.</td>
</tr>
<tr>
<td rowspan="2">Const reverse iterator types</td>
<td><code>const_reverse_iterator1</code></td>
<td>A Reverse Iterator adaptor whose base iterator type is the
matrix expression's const column iterator type.</td>
</tr>
<tr>
<td><code>const_reverse_iterator2</code></td>
<td>A Reverse Iterator adaptor whose base iterator type is the
matrix expression's const row iterator type.</td>
</tr>
</tbody>
</table>
 
<h5>mutable types</h5>
<table border="1" summary="associated mutable types">
<tbody>
<tr>
<td>Reference type</td>
<td><code>reference</code></td>
<td>
The return type when accessing an element of a matrix expression.
<br />
Convertable to a <code>value_type</code>.
</td>
</tr>
<tr>
<td rowspan="2">Iterator types</td>
<td><code>iterator1</code></td>
<td>A type of column iterator that may be used to modify a matrix
expression's elements.</td>
</tr>
<tr>
<td><code>iterator2</code></td>
<td>A type of row iterator that may be used to modify a matrix
expression's elements.</td>
</tr>
<tr>
<td rowspan="2">Reverse iterator types</td>
<td><code>reverse_iterator1</code></td>
<td>A Reverse Iterator adaptor whose base iterator type is the
matrix expression's column iterator type.</td>
</tr>
<tr>
<td><code>reverse_iterator2</code></td>
<td>A Reverse Iterator adaptor whose base iterator type is the
matrix expression's row iterator type.</td>
</tr>
</tbody>
</table>


<h4>Notation</h4>
<table border="0" summary="notation">
<tbody>
<tr>
<td><code>M</code></td>
<td>A type that is a model of Matrix Expression</td>
</tr>
<tr>
<td><code>m, m1, m2</code></td>
<td>Object of type <code>M</code></td>
</tr>
<tr>
<td><code>i, j</code></td>
<td>Objects of a type convertible to <code>size_type</code></td>
</tr>
<tr>
<td><code>t</code></td>
<td>Object of a type convertible to <code>value_type</code></td>
</tr>
</tbody>
</table>
<h4>Definitions</h4>
<h4>Valid expressions</h4>
<p>In addition to the expressions defined in Default Constructible
the following expressions must be valid.</p>

<h5>immutable expressions</h5>
<table border="1" summary="expressions">
<thead>
<tr>
<th>Name</th>
<th>Expression</th>
<th>Type requirements</th>
<th>Return type</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="2">Size</td>
<td><code>m.size1 ()</code></td>
<td>&nbsp;</td>
<td><code>size_type</code></td>
</tr>
<tr>
<td><code>m.size2 ()</code></td>
<td>&nbsp;</td>
<td><code>size_type</code></td>
</tr>
</tbody>
</table>

<h5>possibly mutable expressions</h5>
<table border="1" summary="expressions">
<tbody>
<tr>
<th>Name</th>
<th>Expression</th>
<th>Type requirements</th>
<th>Return type</th>
</tr>
<tr>
<td rowspan="4">Beginning of range</td>
<td><code>m.begin1 ()</code></td>
<td>&nbsp;</td>
<td><code>const_iterator1</code></td>
</tr>
<tr>
<td><code>m.begin2 ()</code></td>
<td>&nbsp;</td>
<td><code>const_iterator2</code></td>
</tr>
<tr>
<td><code>m.begin1 ()</code></td>
<td><code>m</code> is mutable.&nbsp;</td>
<td><code>iterator1</code></td>
</tr>
<tr>
<td><code>m.begin2 ()</code></td>
<td><code>m</code> is mutable.</td>
<td><code>iterator2</code></td>
</tr>
<tr>
<td rowspan="4">End of range</td>
<td><code>m.end1 ()</code></td>
<td>&nbsp;</td>
<td><code>const_iterator1</code></td>
</tr>
<tr>
<td><code>m.end2 ()</code></td>
<td>&nbsp;</td>
<td><code>const_iterator2</code></td>
</tr>
<tr>
<td><code>m.end1 ()</code></td>
<td><code>m</code> is mutable.&nbsp;</td>
<td><code>iterator1</code></td>
</tr>
<tr>
<td><code>m.end2 ()</code></td>
<td><code>m</code> is mutable.</td>
<td><code>iterator2</code></td>
</tr>
<tr>
<td>Swap</td>
<td><code>m1.swap (m2)</code></td>
<td><code>m1</code> and <code>m2</code> are mutable.&nbsp;</td>
<td><code>void</code></td>
</tr>
<tr>
<td rowspan="4">Beginning of reverse range</td>
<td><code>m.rbegin1 ()</code></td>
<td>&nbsp;</td>
<td><code>const_reverse_iterator1</code></td>
</tr>
<tr>
<td><code>m.rbegin2 ()</code></td>
<td>&nbsp;</td>
<td><code>const_reverse_iterator2</code></td>
</tr>
<tr>
<td><code>m.rbegin1 ()</code></td>
<td><code>m</code> is mutable.&nbsp;</td>
<td><code>reverse_iterator1</code></td>
</tr>
<tr>
<td><code>m.rbegin2 ()</code></td>
<td><code>m</code> is mutable.</td>
<td><code>reverse_iterator2</code></td>
</tr>
<tr>
<td rowspan="4">End of reverse range</td>
<td><code>m.rend1 ()</code></td>
<td>&nbsp;</td>
<td><code>const_reverse_iterator1</code></td>
</tr>
<tr>
<td><code>m.rend2 ()</code></td>
<td>&nbsp;</td>
<td><code>const_reverse_iterator2</code></td>
</tr>
<tr>
<td><code>m.rend1 ()</code></td>
<td><code>m</code> is mutable.</td>
<td><code>reverse_iterator1</code></td>
</tr>
<tr>
<td><code>m.rend2 ()</code></td>
<td><code>m</code> is mutable.</td>
<td><code>reverse_iterator2</code></td>
</tr>
<tr>
<td>Element access</td>
<td><code>m (i, j)</code></td>
<td><code>i</code> and <code>j</code> are convertible to
<code>size_type</code> .</td>
<td>Convertible to <code>value_type</code>.</td>
</tr>
<tr>
<td rowspan="2">Assignment</td>
<td><code>m2 = m1</code></td>
<td><code>m2</code> is mutable and <code>m1</code> is convertible
to <code>M</code>.</td>
<td><code>M &amp;</code></td>
</tr>
<tr>
<td><code>m2.assign (m1)</code></td>
<td><code>m2</code> is mutable and <code>m1</code> is convertible
to <code>M</code>.</td>
<td><code>M &amp;</code></td>
</tr>
<tr>
<td rowspan="5">Computed assignment</td>
<td><code>m2 += m1</code></td>
<td><code>m2</code> is mutable and <code>m1</code> is convertible
to <code>M</code>.</td>
<td><code>M &amp;</code></td>
</tr>
<tr>
<td><code>m2.plus_assign (m1)</code></td>
<td><code>m2</code> is mutable and <code>m1</code> is convertible
to <code>M</code>.</td>
<td><code>M &amp;</code></td>
</tr>
<tr>
<td><code>m2 -= m1</code></td>
<td><code>m2</code> is mutable and <code>m1</code> is convertible
to <code>M</code>.</td>
<td><code>M &amp;</code></td>
</tr>
<tr>
<td><code>m2.minus_assign (m1)</code></td>
<td><code>m2</code> is mutable and <code>m1</code> is convertible
to <code>M</code>.</td>
<td><code>M &amp;</code></td>
</tr>
<tr>
<td><code>m *= t</code></td>
<td><code>m</code> is mutable and <code>t</code> is convertible to
<code>value_type</code>.</td>
<td><code>M &amp;</code></td>
</tr>
</tbody>
</table>
<h4>Expression semantics</h4>
<p>Semantics of an expression is defined only where it differs
from, or is not defined in Default Constructible.</p>
<table border="1" summary="semantics">
<tbody>
<tr>
<th>Name</th>
<th>Expression</th>
<th>Precondition</th>
<th>Semantics</th>
<th>Postcondition</th>
</tr>
<tr>
<td rowspan="2">Beginning of range</td>
<td><code>m.begin1 ()</code></td>
<td>&nbsp;</td>
<td>Returns an iterator pointing to the first element in the first
column of a matrix expression.</td>
<td><code>m.begin1 ()</code> is either dereferenceable or
past-the-end. It is past-the-end if and only if <code>m.size1 () ==
0</code>.</td>
</tr>
<tr>
<td><code>m.begin2 ()</code></td>
<td>&nbsp;</td>
<td>Returns an iterator pointing to the first element in the first
row of a matrix expression.</td>
<td><code>m.begin2 ()</code> is either dereferenceable or
past-the-end. It is past-the-end if and only if <code>m.size2 () ==
0</code>.</td>
</tr>
<tr>
<td rowspan="2">End of range</td>
<td><code>m.end1 ()</code></td>
<td>&nbsp;</td>
<td>Returns an iterator pointing one past the last element in the
matrix expression.</td>
<td><code>m.end1 ()</code> is past-the-end.</td>
</tr>
<tr>
<td><code>m.end2 ()</code></td>
<td>&nbsp;</td>
<td>Returns an iterator pointing one past the last element in the
matrix expression.</td>
<td><code>m.end2 ()</code> is past-the-end.</td>
</tr>
<tr>
<td rowspan="2">Size</td>
<td><code>m.size1 ()</code></td>
<td>&nbsp;</td>
<td>Returns the number of rows of the matrix expression.</td>
<td><code>m.size1 () &gt;= 0</code></td>
</tr>
<tr>
<td><code>m.size2 ()</code></td>
<td>&nbsp;</td>
<td>Returns the number of columns of the matrix expression.</td>
<td><code>m.size2 () &gt;= 0</code></td>
</tr>
<tr>
<td>Swap</td>
<td><code>m1.swap (m2)</code></td>
<td>&nbsp;</td>
<td>Equivalent to <code>swap (m1, m2)</code>.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td rowspan="2">Beginning of reverse range</td>
<td><code>m.rbegin1 ()</code></td>
<td>&nbsp;</td>
<td>Equivalent to <code>reverse_iterator1 (m.end1 ())</code>.</td>
<td><code>m.rbegin1 ()</code> is either dereferenceable or
past-the-end. It is past-the-end if and only if <code>m.size1 () ==
0</code>.</td>
</tr>
<tr>
<td><code>m.rbegin2 ()</code></td>
<td>&nbsp;</td>
<td>Equivalent to <code>reverse_iterator2 (m.end2 ())</code>.</td>
<td><code>m.rbegin2 ()</code> is either dereferenceable or
past-the-end. It is past-the-end if and only if <code>m.size2 () ==
0</code>.</td>
</tr>
<tr>
<td rowspan="2">End of reverse range</td>
<td><code>m.rend1 ()</code></td>
<td>&nbsp;</td>
<td>Equivalent to <code>reverse_iterator1 (m.begin1
())</code>.</td>
<td><code>m.rend1 ()</code> is past-the-end.</td>
</tr>
<tr>
<td><code>m.rend2 ()</code></td>
<td>&nbsp;</td>
<td>Equivalent to <code>reverse_iterator2 (m.begin2
())</code>.</td>
<td><code>m.rend2 ()</code> is past-the-end.</td>
</tr>
<tr>
<td>Element access</td>
<td><code>m (i, j)</code></td>
<td><code>0 &lt;= i &lt; m.size1 ()</code> and <code>0 &lt;= j &lt;
m.size2 ()</code></td>
<td>Returns the <code>j</code>-th element of the <code>i</code>-th
row of the matrix expression.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td rowspan="2">Assignment</td>
<td><code>m2 = m1</code></td>
<td><code>m1.size1 () == m2.size1 ()</code> and <code><br />
m1.size2 () == m2.size2 ()</code></td>
<td>Assigns every element of the evaluated matrix expression
<code>m1</code> to the corresponding element of <code>m2</code>
.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>m2.assign (m1)</code></td>
<td><code>m1.size1 () == m2.size1 ()</code> and <code><br />
m1.size2 () == m2.size2 ()</code></td>
<td>Assigns every element of <code>m1</code> to the corresponding
element of <code>m2</code>.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td rowspan="5">Computed assignment</td>
<td><code>m2 += m1</code></td>
<td><code>m1.size1 () == m2.size1 ()</code> and <code><br />
m1.size2 () == m2.size2 ()</code></td>
<td>Adds every element of the evaluated matrix expression
<code>m1</code> to the corresponding element of
<code>m2</code>.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>m2.plus_assign (m1)</code></td>
<td><code>m1.size1 () == m2.size1 ()</code> and <code><br />
m1.size2 () == m2.size2 ()</code></td>
<td>Adds every element of <code>m1</code> to the corresponding
element of <code>m2</code>.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>m2 -= m1</code></td>
<td><code>m1.size1 () == m2.size1 ()</code> and <code><br />
m1.size2 () == m2.size2 ()</code></td>
<td>Subtracts every element of the evaluated matrix expression
<code>m1</code> from the corresponding element of <code>m2</code>
.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>m2.minus_assign (m1)</code></td>
<td><code>m1.size1 () == m2.size1 ()</code> and <code><br />
m1.size2 () == m2.size2 ()</code></td>
<td>Subtracts every element of <code>m1</code> from the
corresponding element of <code>m2</code>.</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>m *= t</code></td>
<td>&nbsp;</td>
<td>Multiplies every element of <code>m</code> with <code>t</code>
.</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<h4>Complexity guarantees</h4>
<p>The run-time complexity of <code>begin1 ()</code>, <code>begin2
()</code> , <code>end1 ()</code> and <code>end2 ()</code> is
specific for the evaluated matrix expression.</p>
<p>The run-time complexity of <code>size1 ()</code> and <code>size2
()</code> is constant time.</p>
<p>The run-time complexity of <code>swap ()</code> is specific for
the evaluated matrix expression, typically constant time.</p>
<p>The run-time complexity of <code>rbegin1 ()</code>,
<code>rbegin2 ()</code> , <code>rend1 ()</code> and <code>rend2
()</code> is specific for the evaluated matrix expression.</p>
<p>The run-time complexity of the element access is specific for
the evaluated matrix expression, typically amortized constant time
for the dense and logarithmic for the sparse case.</p>
<p>The run-time complexity of the arithmetic operations is specific
for the evaluated matrix expressions, typically quadratic in the
size of the proxies.</p>
<h4>Invariants</h4>
<table border="1" summary="invariants">
<tbody>
<tr>
<td>Valid range</td>
<td>For any matrix expression <code>m</code>, <code>[m.begin1 (),
m.end1 ())</code> and <code>[m.begin2 (), m.end2 ())</code> are
valid ranges.</td>
</tr>
<tr>
<td>Completeness</td>
<td>An algorithm that iterates through the range <code>[m.begin1
(), m.end1 ())</code> will pass through every row of <code>m</code>
, an algorithm that iterates through the range <code>[m.begin2 (),
m.end2 ())</code> will pass through every column of <code>m</code>
.</td>
</tr>
<tr>
<td>Valid reverse range</td>
<td><code>[m.rbegin1 (), m.rend1 ())</code> and <code>[m.rbegin2
(), m.rend2 ())</code> are valid ranges.</td>
</tr>
<tr>
<td>Equivalence of ranges</td>
<td>The distance from <code>m.begin1 ()</code> to <code>m.end1
()</code> is the same as the distance from <code>m.rbegin1
()</code> to <code>m.rend1 ()</code> and the distance from
<code>m.begin2 ()</code> to <code>m.end2 ()</code> is the same as
the distance from <code>m.rbegin2 ()</code> to <code>m.rend2
()</code>.</td>
</tr>
</tbody>
</table>
<h4>Models</h4>
<ul>
<li><code>matrix_range</code></li>
<li><code>matrix_slice;</code></li>
<li><code>triangular_adaptor</code></li>
<li><code>symmetric_adaptor</code></li>
<li><code>banded_adaptor</code></li>
<li><code>vector_matrix_binary</code></li>
<li><code>matrix_unary1</code></li>
<li><code>matrix_unary2</code></li>
<li><code>matrix_binary</code></li>
<li><code>matrix_binary_scalar1</code></li>
<li><code>matrix_binary_scalar2</code></li>
<li><code>matrix_matrix_binary</code></li>
</ul>
<hr />
<p>Copyright (&copy;) 2000-2002 Joerg Walter, Mathias Koch<br />
   Use, modification and distribution are subject to the
   Boost Software License, Version 1.0.
   (See accompanying file LICENSE_1_0.txt
   or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
      http://www.boost.org/LICENSE_1_0.txt
   </a>).
</p>
<script type="text/javascript">
(function($) {
    $('#toc').toc();
})(jQuery);
</script>
</body>
</html>
