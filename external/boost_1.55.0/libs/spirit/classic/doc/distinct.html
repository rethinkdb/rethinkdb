<html>
<head>
<!-- Generated by the Spirit (http://spirit.sf.net) QuickDoc -->
<title>Distinct Parser</title>
<link rel="stylesheet" href="theme/style.css" type="text/css">
</head>
<body>
<table width="100%" height="48" border="0" background="theme/bkd2.gif" cellspacing="2">
  <tr>
    <td width="10">
    </td>
    <td width="85%">
    <font size="6" face="Verdana, Arial, Helvetica, sans-serif"><b>Distinct Parser </b></font></td>
    <td width="112"><a href="http://spirit.sf.net"><img src="theme/spirit.gif" align="right" border="0"></a></td>
  </tr>
</table>
<br>
<table border="0">
  <tr>
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="scoped_lock.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="symbols.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</table>
<h3>Distinct Parsers</h3><p>
The distinct parsers are utility parsers which ensure that matched input is
not immediately followed by a forbidden pattern. Their typical usage is to
distinguish keywords from identifiers.</p>
<h3>distinct_parser</h3>
<p>
The basic usage of the <tt>distinct_parser</tt> is to replace the <tt>str_p</tt> parser. For
example the <tt>declaration_rule</tt> in the following example:</p>
<pre>
    <code><span class=identifier>rule</span><span class=special>&lt;</span><span class="identifier">ScannerT</span><span class=special>&gt; </span><span class=identifier>declaration_rule </span><span class=special>= </span><span class=identifier>str_p</span><span class=special>(</span><span class=string>&quot;declare&quot;</span><span class=special>) &gt;&gt; </span><span class=identifier>lexeme_d</span><span class=special>[+</span><span class=identifier>alpha_p</span><span class=special>];
</span></code></pre>
<p>
would correctly match an input &quot;declare abc&quot;, but as well an input&quot;declareabc&quot; what is usually not intended. In order to avoid this, we can
use <tt>distinct_parser</tt>:</p>
<code>
<pre>
    <span class=comment>// keyword_p may be defined in the global scope
    </span><span class=identifier>distinct_parser</span><span class=special>&lt;&gt; </span><span class=identifier>keyword_p</span><span class=special>(</span><span class=string>&quot;a-zA-Z0-9_&quot;</span><span class=special>);

    </span><span class=identifier>rule</span><span class=special>&lt;</span><span class="identifier">ScannerT</span><span class=special>&gt; </span><span class=identifier>declaration_rule </span><span class=special>= </span><span class=identifier>keyword_p</span><span class=special>(</span><span class=string>&quot;declare&quot;</span><span class=special>) &gt;&gt; </span><span class=identifier>lexeme_d</span><span class=special>[+</span><span class=identifier>alpha_p</span><span class=special>];
</span></pre>
</code>
<p>
The <tt>keyword_p</tt> works in the same way as the <tt>str_p</tt> parser but matches only
when the matched input is not immediately followed by one of the characters
from the set passed to the constructor of <tt>keyword_p</tt>. In the example the
&quot;declare&quot; can't be immediately followed by any alphabetic character, any
number or an underscore.</p>
<p>
See the full <a href="../example/fundamental/distinct/distinct_parser.cpp">example here </a>.</p>
<h3>distinct_directive</h3><p>
For more sophisticated cases, for example when keywords are stored in a
symbol table, we can use <tt>distinct_directive</tt>.</p>
<pre>
    <code><span class=identifier>distinct_directive</span><span class=special>&lt;&gt; </span><span class=identifier>keyword_d</span><span class=special>(</span><span class=string>&quot;a-zA-Z0-9_&quot;</span><span class=special>);

    </span><span class=identifier>symbol</span><span class=special>&lt;&gt; </span><span class=identifier>keywords </span><span class=special>= </span><span class=string>&quot;declare&quot;</span><span class=special>, </span><span class=string>&quot;begin&quot;</span><span class=special>, </span><span class=string>&quot;end&quot;</span><span class=special>;
    </span><span class=identifier>rule</span><span class=special>&lt;</span><span class="identifier">ScannerT</span><span class=special>&gt; </span><span class=identifier>keyword </span><span class=special>= </span><span class=identifier>keyword_d</span><span class=special>[</span><span class=identifier>keywords</span><span class=special>];
</span></code></pre>
<h3>dynamic_distinct_parser and dynamic_distinct_directive</h3><p>
In some cases a set of forbidden follow-up characters is not sufficient.
For example ASN.1 naming conventions allows identifiers to contain dashes,
but not double dashes (which marks the beginning of a comment).
Furthermore, identifiers can't end with a dash. So, a matched keyword can't
be followed by any alphanumeric character or exactly one dash, but can be
followed by two dashes.</p>
<p>
This is when <tt>dynamic_distinct_parser</tt> and the <tt>dynamic_distinct_directive </tt>come into play. The constructor of the <tt>dynamic_distinct_parser</tt> accepts a
parser which matches any input that <strong>must NOT</strong> follow the keyword.</p>
<pre>
    <code><span class=comment>// Alphanumeric characters and a dash followed by a non-dash
    // may not follow an ASN.1 identifier.
    </span><span class=identifier>dynamic_distinct_parser</span><span class=special>&lt;&gt; </span><span class=identifier>keyword_p</span><span class=special>(</span><span class=identifier>alnum_p </span><span class=special>| (</span><span class=literal>'-' </span><span class=special>&gt;&gt; ~</span><span class=identifier>ch_p</span><span class=special>(</span><span class=literal>'-'</span><span class=special>)));

    </span><span class=identifier>rule</span><span class=special>&lt;</span><span class="identifier">ScannerT</span><span class=special>&gt; </span><span class=identifier>declaration_rule </span><span class=special>= </span><span class=identifier>keyword_p</span><span class=special>(</span><span class=string>&quot;declare&quot;</span><span class=special>) &gt;&gt; </span><span class=identifier>lexeme_d</span><span class=special>[+</span><span class=identifier>alpha_p</span><span class=special>];
</span></code></pre>
<p>
Since the <tt>dynamic_distinct_parser</tt> internally uses a rule, its type is
dependent on the scanner type. So, the <tt>keyword_p</tt> shouldn't be defined
globally, but rather within the grammar.</p>
<p>
See the full <a href="../example/fundamental/distinct/distinct_parser_dynamic.cpp">example here</a>.</p>
<h3>How it works</h3><p>
When the <tt>keyword_p_1</tt> and the <tt>keyword_p_2</tt> are defined as</p>
<code><pre>
    <span class=identifier>distinct_parser</span><span class=special>&lt;&gt; </span><span class=identifier>keyword_p</span><span class=special>(</span><span class=identifier>forbidden_chars</span><span class=special>);
    </span><span class=identifier>distinct_parser_dynamic</span><span class=special>&lt;&gt; </span><span class=identifier>keyword_p</span><span class=special>(</span><span class=identifier>forbidden_tail_parser</span><span class=special>);
</span></pre></code>
<p>
the parsers</p>
<code><pre>
    <span class=identifier>keyword_p_1</span><span class=special>(</span><span class=identifier>str</span><span class=special>)
    </span><span class=identifier>keyword_p_2</span><span class=special>(</span><span class=identifier>str</span><span class=special>)
</span></pre></code>
<p>
are equivalent to the rules</p>
<code><pre>
    <span class=identifier>lexeme_d</span><span class=special>[</span><span class=identifier>chseq_p</span><span class=special>(</span><span class=identifier>str</span><span class=special>) &gt;&gt; ~</span><span class=identifier>epsilon_p</span><span class=special>(</span><span class=identifier>chset_p</span><span class=special>(</span><span class=identifier>forbidden_chars</span><span class=special>))]
    </span><span class=identifier>lexeme_d</span><span class=special>[</span><span class=identifier>chseq_p</span><span class=special>(</span><span class=identifier>str</span><span class=special>) &gt;&gt; ~</span><span class=identifier>epsilon_p</span><span class=special>(</span><span class=identifier>forbidden_tail_parser</span><span class=special>)]
</span></pre></code>
<table border="0">
  <tr>
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="scoped_lock.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="symbols.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</table>
<br>
<hr size="1">
<p class="copyright">Copyright &copy; 2003-2004


 Vaclav Vesely<br><br>
 <font size="2">Use, modification and distribution is subject to the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) </font>  </p>
</body>
</html>
