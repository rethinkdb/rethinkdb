<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Refactoring Parsers</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="theme/style.css" rel="stylesheet" type="text/css">
</head>

<body>
<table width="100%" border="0" background="theme/bkd2.gif" cellspacing="2">
  <tr> 
    <td width="10"> <font size="6" face="Verdana, Arial, Helvetica, sans-serif"><b>&nbsp;</b></font></td>
    <td width="85%"> <font size="6" face="Verdana, Arial, Helvetica, sans-serif"><b>Refactoring Parsers</b></font></td>
    <td width="112"><a href="http://spirit.sf.net"><img src="theme/spirit.gif" width="112" height="48" align="right" border="0"></a></td>
  </tr>
</table>
<br>
<table border="0">
  <tr> 
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="functor_parser.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="regular_expression_parser.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</table>
<p><a name="refactoring_parsers"></a>There are three types of Refactoring Parsers 
  implemented right now, which help to abstract common parser refactoring tasks. 
  Parser refactoring means, that a concrete parser construct is replaced (refactored) 
  by another very similar parser construct. Two of the Refactoring Parsers described 
  here (<tt>refactor_unary_parser</tt> and <tt>refactor_action_parser</tt>) are 
  introduced to allow a simple and more expressive notation while using <a href="confix.html">Confix 
  Parsers</a> and <a href="list_parsers.html">List Parsers</a>. The third Refactoring 
  Parser (<tt>attach_action_parser</tt>) is implemented to abstract some functionality 
  required for the Grouping Parser. Nevertheless 
  these Refactoring Parsers may help in solving other complex parsing tasks too.</p>
<h3>Refactoring unary parsers</h3>
<p>The <tt>refactor_unary_d</tt> parser generator, which should be used to generate 
  a unary refactoring parser, transforms a construct of the following type</p> 
<pre><code>    <span class=identifier>refactor_unary_d</span><span class=special>[*</span><span class=identifier>some_parser </span><span class=special>- </span><span class=identifier>another_parser</span><span class=special>]</span></code></pre>
<p>to </p> 
<pre><code>    <span class=special>*(</span><span class=identifier>some_parser</span> <span class=special>- </span><span class=identifier>another_parser</span><span class=special>)</span></code></pre>
<blockquote>
  <p>where <tt>refactor_unary_d</tt> is a predefined object of the parser generator 
    struct <tt>refactor_unary_gen&lt;&gt;</tt></p>
</blockquote>
<p>The <tt>refactor_unary_d</tt> parser generator generates a new parser as shown 
  above, only if the original construct is an auxilliary binary parser (here the 
  difference parser) and the left operand of this binary parser is an auxilliary 
  unary parser (here the kleene star operator). If the original parser isn't a 
  binary parser the compilation will fail. If the left operand isn't an unary 
  parser, no refactoring will take place.</p>
<h3>Refactoring action parsers</h3>
<p>The <tt>refactor_action_d</tt> parser generator, which should be used to generate 
  an action refactoring parser, transforms a construct of the following type</p>
<pre><code>    <span class=identifier>refactor_action_d</span><span class=special>[</span><span class=identifier>some_parser</span><span class=special>[</span><span class=identifier>some_actor</span><span class=special>] </span><span class=special>- </span><span class=identifier>another_parser</span><span class=special>]</span></code></pre>
<p>to </p>
<pre><code>    <span class=special>(</span><span class=identifier>some_parser </span><span class=special>- </span><span class=identifier>another_parser</span><span class=special>)[</span><span class=identifier>some_actor</span><span class=special>]</span></code></pre>
<blockquote> 
  <p>where <tt>refactor_action_d</tt> is a predefined object of the parser generator 
    struct <tt>refactor_action_gen&lt;&gt;</tt></p>
</blockquote>
<p>The <tt>refactor_action_d</tt> parser generator generates a new parser as shown 
  above, only if the original construct is an auxilliary binary parser (here the 
  difference parser) and the left operand of this binary parser is an auxilliary 
  parser generated by an attached semantic action. If the original parser isn't 
  a binary parser the compilation will fail. If the left operand isn't an action 
  parser, no refactoring will take place.</p>
<h3>Attach action refactoring</h3>
<p>The <tt>attach_action_d</tt> parser generator, which should be used to generate 
  an attach action refactoring parser, transforms a construct of the following 
  type</p>
<pre><code>    <span class=identifier>attach_action_d</span><span class=special>[</span><span class=identifier>(some_parser</span> <span class=special>&gt;&gt; </span><span class=identifier>another_parser</span>)<span class=special>[</span><span class=identifier>some_actor</span><span class=special>]</span><span class=special>]</span></code></pre>
<p>to </p>
<pre><code>    <span class=identifier>some_parser</span><span class=special>[</span><span class=identifier>some_actor</span><span class=special>]</span><span class=identifier> </span><span class=special>&gt;&gt; </span><span class=identifier>another_parser</span><span class=special>[</span><span class=identifier>some_actor</span><span class=special>]</span></code></pre>
<blockquote> 
  <p>where <tt>attach_action_d</tt> is a predefined object of the parser generator 
    struct <tt>attach_action_gen&lt;&gt;</tt></p>
</blockquote> 
  
<p>The <tt>attach_action_d</tt> parser generator generates a new parser as shown 
  above, only if the original construct is an auxilliary action parser and the 
  parser to it this action is attached is an auxilliary binary parser (here the 
  sequence parser). If the original parser isn't a action parser the compilation 
  will fail. If the parser to which the action is attached isn't an binary parser, 
  no refactoring will take place.</p>
<h3>Nested refactoring</h3>
<p>Sometimes it is required to nest different types of refactoring, i.e. to transform 
  constructs like</p>
<pre><code>    <span class=special>(*</span><span class=identifier>some_parser</span><span class=special>)[</span><span class=identifier>some_actor</span><span class=special>] </span><span class=special>- </span><span class=identifier>another_parser</span></code></pre>
<p>to </p>
<pre><code>    <span class=special>(*(</span><span class=identifier>some_parser </span><span class=special>- </span><span class=identifier>another_parser</span><span class=special>))[</span><span class=identifier>some_actor</span><span class=special>]</span></code></pre>
<p>To simplify the construction of such nested refactoring parsers the <tt>refactor_unary_gen&lt;&gt;</tt> 
  and <tt>refactor_action_gen&lt;&gt;</tt> both can take another refactoring parser 
  generator type as their respective template parameter. For instance, to construct 
  a refactoring parser generator for the mentioned nested transformation we should 
  write:</p>
<pre><span class=special>    </span><span class=keyword>typedef </span><span class=identifier>refactor_action_gen</span><span class=special>&lt;</span><span class=identifier>refactor_unary_gen</span><span class=special>&lt;&gt; </span><span class=special>&gt; </span><span class=identifier>refactor_t</span><span class=special>;
    </span><span class=keyword>const </span><span class=identifier>refactor_t </span><span class=identifier>refactor_nested_d </span><span class=special>= </span><span class=identifier>refactor_t</span><span class=special>(</span><span class=identifier>refactor_unary_d</span><span class=special>);</span></pre>
<p>Now we could use it as follows to get the required result:</p>
<pre><code><font color="#0000FF">    </font><span class=identifier>refactor_nested_d</span><span class=special>[(*</span><span class=identifier>some_parser</span><span class=special>)[</span><span class=identifier>some_actor</span><span class=special>] </span><span class=special>- </span><span class=identifier>another_parser</span><span class=special>]</span></code></pre>
<p>An empty template parameter means not to nest this particular refactoring parser. 
  The default template parameter is <tt>non_nesting_refactoring</tt>, a predefined 
  helper structure for inhibiting nesting. Sometimes it is required to nest a 
  particular refactoring parser with itself. This is achieved by providing the 
  predefined helper structure <tt>self_nested_refactoring</tt> as the template 
  parameter to the corresponding refactoring parser generator template.</p>
<p><img src="theme/lens.gif" width="15" height="16"> See <a href="../example/fundamental/refactoring.cpp">refactoring.cpp</a> for a compilable example. This is part of the Spirit distribution. </p>
<table border="0">
  <tr> 
    <td width="10"></td>
    <td width="30"><a href="../index.html"><img src="theme/u_arr.gif" border="0"></a></td>
    <td width="30"><a href="functor_parser.html"><img src="theme/l_arr.gif" border="0"></a></td>
    <td width="30"><a href="regular_expression_parser.html"><img src="theme/r_arr.gif" border="0"></a></td>
  </tr>
</table>
<br>
<hr size="1">
<p class="copyright">Copyright &copy; 2001-2003 Hartmut Kaiser<br>
  <br>
  <font size="2">Use, modification and distribution is subject to the Boost Software
    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)</font></p>
<p>&nbsp;</p>
</body>
</html>
