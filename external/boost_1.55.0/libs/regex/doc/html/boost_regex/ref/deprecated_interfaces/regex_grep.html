<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>regex_grep (Deprecated)</title>
<link rel="stylesheet" href="../../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../../../index.html" title="Boost.Regex">
<link rel="up" href="../deprecated_interfaces.html" title="Deprecated Interfaces">
<link rel="prev" href="regex_format.html" title="regex_format (Deprecated)">
<link rel="next" href="regex_split.html" title="regex_split (deprecated)">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="regex_format.html"><img src="../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../deprecated_interfaces.html"><img src="../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="regex_split.html"><img src="../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section  boost_regex_ref_deprecated_interfaces_regex_grep">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_regex.ref.deprecated_interfaces.regex_grep"></a><a class="link" href="regex_grep.html" title="regex_grep (Deprecated)">regex_grep
        (Deprecated)</a>
</h4></div></div></div>
<p>
          The algorithm <code class="computeroutput"><span class="identifier">regex_grep</span></code>
          is deprecated in favor of <a class="link" href="../regex_iterator.html" title="regex_iterator"><code class="computeroutput"><span class="identifier">regex_iterator</span></code></a> which provides
          a more convenient and standard library friendly interface.
        </p>
<p>
          The following documentation is taken unchanged from the previous boost
          release, and will not be updated in future.
        </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">regex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
          <code class="computeroutput"><span class="identifier">regex_grep</span></code> allows you to
          search through a bidirectional-iterator range and locate all the (non-overlapping)
          matches with a given regular expression. The function is declared as:
        </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">iterator</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">charT</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">traits</span><span class="special">&gt;</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">regex_grep</span><span class="special">(</span><span class="identifier">Predicate</span> <span class="identifier">foo</span><span class="special">,</span>
                        <span class="identifier">iterator</span> <span class="identifier">first</span><span class="special">,</span>
                        <span class="identifier">iterator</span> <span class="identifier">last</span><span class="special">,</span>
                        <span class="keyword">const</span> <span class="identifier">basic_regex</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">traits</span><span class="special">&gt;&amp;</span> <span class="identifier">e</span><span class="special">,</span>
                        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">match_flag_type</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">match_default</span><span class="special">)</span>
</pre>
<p>
          The library also defines the following convenience versions, which take
          either a <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">charT</span><span class="special">*</span></code>, or a <code class="computeroutput"><span class="keyword">const</span>
          <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;&gt;&amp;</span></code>
          in place of a pair of iterators.
        </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">charT</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">traits</span><span class="special">&gt;</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">regex_grep</span><span class="special">(</span><span class="identifier">Predicate</span> <span class="identifier">foo</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">charT</span><span class="special">*</span> <span class="identifier">str</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">basic_regex</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">traits</span><span class="special">&gt;&amp;</span> <span class="identifier">e</span><span class="special">,</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">match_flag_type</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">match_default</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Predicate</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">ST</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">SA</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">charT</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">traits</span><span class="special">&gt;</span>
<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">regex_grep</span><span class="special">(</span><span class="identifier">Predicate</span> <span class="identifier">foo</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">ST</span><span class="special">,</span> <span class="identifier">SA</span><span class="special">&gt;&amp;</span> <span class="identifier">s</span><span class="special">,</span>
            <span class="keyword">const</span> <span class="identifier">basic_regex</span><span class="special">&lt;</span><span class="identifier">charT</span><span class="special">,</span> <span class="identifier">traits</span><span class="special">&gt;&amp;</span> <span class="identifier">e</span><span class="special">,</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">match_flag_type</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="identifier">match_default</span><span class="special">);</span>
</pre>
<p>
          The parameters for the primary version of <code class="computeroutput"><span class="identifier">regex_grep</span></code>
          have the following meanings:
        </p>
<p>
          foo: A predicate function object or function pointer, see below for more
          information.
        </p>
<p>
          first: The start of the range to search.
        </p>
<p>
          last: The end of the range to search.
        </p>
<p>
          e: The regular expression to search for.
        </p>
<p>
          flags: The flags that determine how matching is carried out, one of the
          match_flags enumerators.
        </p>
<p>
          The algorithm finds all of the non-overlapping matches of the expression
          <span class="emphasis"><em>e</em></span>, for each match it fills a <code class="computeroutput"><span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">&gt;</span></code> structure, which contains information
          on what matched, and calls the predicate <span class="emphasis"><em>foo</em></span>, passing
          the <code class="computeroutput"><span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">&gt;</span></code>
          as a single argument. If the predicate returns <span class="emphasis"><em>true</em></span>,
          then the grep operation continues, otherwise it terminates without searching
          for further matches. The function returns the number of matches found.
        </p>
<p>
          The general form of the predicate is:
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">grep_predicate</span>
<span class="special">{</span>
   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">match_results</span><span class="special">&lt;</span><span class="identifier">iterator_type</span><span class="special">&gt;&amp;</span> <span class="identifier">m</span><span class="special">);</span>
<span class="special">};</span>
</pre>
<p>
          For example the regular expression "a*b" would find one match
          in the string "aaaaab" and two in the string "aaabb".
        </p>
<p>
          Remember this algorithm can be used for a lot more than implementing a
          version of grep, the predicate can be and do anything that you want, grep
          utilities would output the results to the screen, another program could
          index a file based on a regular expression and store a set of bookmarks
          in a list, or a text file conversion utility would output to file. The
          results of one <code class="computeroutput"><span class="identifier">regex_grep</span></code>
          can even be chained into another <code class="computeroutput"><span class="identifier">regex_grep</span></code>
          to create recursive parsers.
        </p>
<p>
          The algorithm may throw <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span></code>
          if the complexity of matching the expression against an <span class="emphasis"><em>N</em></span>
          character string begins to exceed O(N<sup>2</sup>), or if the program runs out of
          stack space while matching the expression (if Boost.Regex is configured
          in recursive mode), or if the matcher exhausts it's permitted memory allocation
          (if Boost.Regex is configured in non-recursive mode).
        </p>
<p>
          Example: convert the example from <a class="link" href="../regex_search.html" title="regex_search"><code class="computeroutput"><span class="identifier">regex_search</span></code></a> to use <code class="computeroutput"><span class="identifier">regex_grep</span></code> instead:
        </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">map</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">regex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="comment">// IndexClasses: </span>
<span class="comment">// takes the contents of a file in the form of a string </span>
<span class="comment">// and searches for all the C++ class definitions, storing </span>
<span class="comment">// their locations in a map of strings/int's </span>
<span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">map_type</span><span class="special">;</span>

<span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">re</span> <span class="special">=</span>
   <span class="comment">// possibly leading whitespace:   </span>
   <span class="string">"^[[:space:]]*"</span>
   <span class="comment">// possible template declaration:</span>
   <span class="string">"(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?"</span>
   <span class="comment">// class or struct:</span>
   <span class="string">"(class|struct)[[:space:]]*"</span>
   <span class="comment">// leading declspec macros etc:</span>
   <span class="string">"("</span>
      <span class="string">"\\&lt;\\w+\\&gt;"</span>
      <span class="string">"("</span>
         <span class="string">"[[:blank:]]*\\([^)]*\\)"</span>
      <span class="string">")?"</span>
      <span class="string">"[[:space:]]*"</span>
   <span class="string">")*"</span>
   <span class="comment">// the class name</span>
   <span class="string">"(\\&lt;\\w*\\&gt;)[[:space:]]*"</span>
   <span class="comment">// template specialisation parameters</span>
   <span class="string">"(&lt;[^;:{]+&gt;)?[[:space:]]*"</span>
   <span class="comment">// terminate in { or :</span>
   <span class="string">"(\\{|:[^;\\{()]*\\{)"</span><span class="special">;</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">regex</span> <span class="identifier">expression</span><span class="special">(</span><span class="identifier">re</span><span class="special">);</span>
<span class="keyword">class</span> <span class="identifier">IndexClassesPred</span>
<span class="special">{</span>
   <span class="identifier">map_type</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">;</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">base</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
   <span class="identifier">IndexClassesPred</span><span class="special">(</span><span class="identifier">map_type</span><span class="special">&amp;</span> <span class="identifier">a</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">b</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">m</span><span class="special">(</span><span class="identifier">a</span><span class="special">),</span> <span class="identifier">base</span><span class="special">(</span><span class="identifier">b</span><span class="special">)</span> <span class="special">{}</span>
   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span>  <span class="identifier">smatch</span><span class="special">&amp;</span> <span class="identifier">what</span><span class="special">)</span>
   <span class="special">{</span>
      <span class="comment">// what[0] contains the whole string </span>
      <span class="comment">// what[5] contains the class name. </span>
      <span class="comment">// what[6] contains the template specialisation if any. </span>
      <span class="comment">// add class name and position to map: </span>
      <span class="identifier">m</span><span class="special">[</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="identifier">what</span><span class="special">[</span><span class="number">5</span><span class="special">].</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">what</span><span class="special">[</span><span class="number">5</span><span class="special">].</span><span class="identifier">second</span><span class="special">)</span> <span class="special">+</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="identifier">what</span><span class="special">[</span><span class="number">6</span><span class="special">].</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">what</span><span class="special">[</span><span class="number">6</span><span class="special">].</span><span class="identifier">second</span><span class="special">)]</span> <span class="special">=</span>
               <span class="identifier">what</span><span class="special">[</span><span class="number">5</span><span class="special">].</span><span class="identifier">first</span> <span class="special">-</span> <span class="identifier">base</span><span class="special">;</span>
      <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
   <span class="special">}</span>
<span class="special">};</span>
<span class="keyword">void</span> <span class="identifier">IndexClasses</span><span class="special">(</span><span class="identifier">map_type</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">file</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">start</span><span class="special">,</span> <span class="identifier">end</span><span class="special">;</span>
   <span class="identifier">start</span> <span class="special">=</span> <span class="identifier">file</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
   <span class="identifier">end</span> <span class="special">=</span> <span class="identifier">file</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span>
   <span class="identifier">regex_grep</span><span class="special">(</span><span class="identifier">IndexClassesPred</span><span class="special">(</span><span class="identifier">m</span><span class="special">,</span> <span class="identifier">start</span><span class="special">),</span> <span class="identifier">start</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">expression</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          Example: Use <code class="computeroutput"><span class="identifier">regex_grep</span></code>
          to call a global callback function:
        </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">map</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">regex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="comment">// purpose: </span>
<span class="comment">// takes the contents of a file in the form of a string </span>
<span class="comment">// and searches for all the C++ class definitions, storing </span>
<span class="comment">// their locations in a map of strings/int's </span>
<span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">map_type</span><span class="special">;</span>

<span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">re</span> <span class="special">=</span>
   <span class="comment">// possibly leading whitespace:   </span>
   <span class="string">"^[[:space:]]*"</span>
   <span class="comment">// possible template declaration:</span>
   <span class="string">"(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?"</span>
   <span class="comment">// class or struct:</span>
   <span class="string">"(class|struct)[[:space:]]*"</span>
   <span class="comment">// leading declspec macros etc:</span>
   <span class="string">"("</span>
      <span class="string">"\\&lt;\\w+\\&gt;"</span>
      <span class="string">"("</span>
         <span class="string">"[[:blank:]]*\\([^)]*\\)"</span>
      <span class="string">")?"</span>
      <span class="string">"[[:space:]]*"</span>
   <span class="string">")*"</span>
   <span class="comment">// the class name</span>
   <span class="string">"(\\&lt;\\w*\\&gt;)[[:space:]]*"</span>
   <span class="comment">// template specialisation parameters</span>
   <span class="string">"(&lt;[^;:{]+&gt;)?[[:space:]]*"</span>
   <span class="comment">// terminate in { or :</span>
   <span class="string">"(\\{|:[^;\\{()]*\\{)"</span><span class="special">;</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">regex</span> <span class="identifier">expression</span><span class="special">(</span><span class="identifier">re</span><span class="special">);</span>
<span class="identifier">map_type</span> <span class="identifier">class_index</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">base</span><span class="special">;</span>

<span class="keyword">bool</span> <span class="identifier">grep_callback</span><span class="special">(</span><span class="keyword">const</span>  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">smatch</span><span class="special">&amp;</span> <span class="identifier">what</span><span class="special">)</span>
<span class="special">{</span>
   <span class="comment">// what[0] contains the whole string </span>
   <span class="comment">// what[5] contains the class name. </span>
   <span class="comment">// what[6] contains the template specialisation if any. </span>
   <span class="comment">// add class name and position to map: </span>
   <span class="identifier">class_index</span><span class="special">[</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="identifier">what</span><span class="special">[</span><span class="number">5</span><span class="special">].</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">what</span><span class="special">[</span><span class="number">5</span><span class="special">].</span><span class="identifier">second</span><span class="special">)</span> <span class="special">+</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="identifier">what</span><span class="special">[</span><span class="number">6</span><span class="special">].</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">what</span><span class="special">[</span><span class="number">6</span><span class="special">].</span><span class="identifier">second</span><span class="special">)]</span> <span class="special">=</span>
               <span class="identifier">what</span><span class="special">[</span><span class="number">5</span><span class="special">].</span><span class="identifier">first</span> <span class="special">-</span> <span class="identifier">base</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
<span class="special">}</span>
<span class="keyword">void</span> <span class="identifier">IndexClasses</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">file</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">start</span><span class="special">,</span> <span class="identifier">end</span><span class="special">;</span>
   <span class="identifier">start</span> <span class="special">=</span> <span class="identifier">file</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
   <span class="identifier">end</span> <span class="special">=</span> <span class="identifier">file</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span>
   <span class="identifier">base</span> <span class="special">=</span> <span class="identifier">start</span><span class="special">;</span>
   <span class="identifier">regex_grep</span><span class="special">(</span><span class="identifier">grep_callback</span><span class="special">,</span> <span class="identifier">start</span><span class="special">,</span> <span class="identifier">end</span><span class="special">,</span> <span class="identifier">expression</span><span class="special">,</span> <span class="identifier">match_default</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          Example: use <code class="computeroutput"><span class="identifier">regex_grep</span></code>
          to call a class member function, use the standard library adapters <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">mem_fun</span></code> and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bind1st</span></code>
          to convert the member function into a predicate:
        </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">map</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">regex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">functional</span><span class="special">&gt;</span>
<span class="comment">// purpose: </span>
<span class="comment">// takes the contents of a file in the form of a string </span>
<span class="comment">// and searches for all the C++ class definitions, storing </span>
<span class="comment">// their locations in a map of strings/int's </span>

<span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">map_type</span><span class="special">;</span>
<span class="keyword">class</span> <span class="identifier">class_index</span>
<span class="special">{</span>
   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">regex</span> <span class="identifier">expression</span><span class="special">;</span>
   <span class="identifier">map_type</span> <span class="identifier">index</span><span class="special">;</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">base</span><span class="special">;</span>
   <span class="keyword">bool</span>  <span class="identifier">grep_callback</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">smatch</span> <span class="identifier">what</span><span class="special">);</span>
<span class="keyword">public</span><span class="special">:</span>
   <span class="keyword">void</span> <span class="identifier">IndexClasses</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">file</span><span class="special">);</span>
   <span class="identifier">class_index</span><span class="special">()</span>
      <span class="special">:</span> <span class="identifier">index</span><span class="special">(),</span>
      <span class="identifier">expression</span><span class="special">(</span><span class="string">"^(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?"</span>
                  <span class="string">"(class|struct)[[:space:]]*(\\&lt;\\w+\\&gt;([[:blank:]]*\\([^)]*\\))?"</span>
                  <span class="string">"[[:space:]]*)*(\\&lt;\\w*\\&gt;)[[:space:]]*(&lt;[^;:{]+&gt;[[:space:]]*)?"</span>
                  <span class="string">"(\\{|:[^;\\{()]*\\{)"</span>
                  <span class="special">){}</span>
<span class="special">};</span>
<span class="keyword">bool</span>  <span class="identifier">class_index</span><span class="special">::</span><span class="identifier">grep_callback</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">smatch</span> <span class="identifier">what</span><span class="special">)</span>
<span class="special">{</span>
   <span class="comment">// what[0] contains the whole string </span>
   <span class="comment">// what[5] contains the class name. </span>
   <span class="comment">// what[6] contains the template specialisation if any. </span>
   <span class="comment">// add class name and position to map: </span>
   <span class="identifier">index</span><span class="special">[</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="identifier">what</span><span class="special">[</span><span class="number">5</span><span class="special">].</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">what</span><span class="special">[</span><span class="number">5</span><span class="special">].</span><span class="identifier">second</span><span class="special">)</span> <span class="special">+</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="identifier">what</span><span class="special">[</span><span class="number">6</span><span class="special">].</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">what</span><span class="special">[</span><span class="number">6</span><span class="special">].</span><span class="identifier">second</span><span class="special">)]</span> <span class="special">=</span>
               <span class="identifier">what</span><span class="special">[</span><span class="number">5</span><span class="special">].</span><span class="identifier">first</span> <span class="special">-</span> <span class="identifier">base</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">void</span> <span class="identifier">class_index</span><span class="special">::</span><span class="identifier">IndexClasses</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">file</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">start</span><span class="special">,</span> <span class="identifier">end</span><span class="special">;</span>
   <span class="identifier">start</span> <span class="special">=</span> <span class="identifier">file</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
   <span class="identifier">end</span> <span class="special">=</span> <span class="identifier">file</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span>
   <span class="identifier">base</span> <span class="special">=</span> <span class="identifier">start</span><span class="special">;</span>
   <span class="identifier">regex_grep</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">bind1st</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">mem_fun</span><span class="special">(&amp;</span><span class="identifier">class_index</span><span class="special">::</span><span class="identifier">grep_callback</span><span class="special">),</span> <span class="keyword">this</span><span class="special">),</span>
            <span class="identifier">start</span><span class="special">,</span>
            <span class="identifier">end</span><span class="special">,</span>
            <span class="identifier">expression</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          Finally, C++ Builder users can use C++ Builder's closure type as a callback
          argument:
        </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">map</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">regex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">functional</span><span class="special">&gt;</span>
<span class="comment">// purpose: </span>
<span class="comment">// takes the contents of a file in the form of a string </span>
<span class="comment">// and searches for all the C++ class definitions, storing </span>
<span class="comment">// their locations in a map of strings/int's </span>

<span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">map_type</span><span class="special">;</span>
<span class="keyword">class</span> <span class="identifier">class_index</span>
<span class="special">{</span>
   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">regex</span> <span class="identifier">expression</span><span class="special">;</span>
   <span class="identifier">map_type</span> <span class="identifier">index</span><span class="special">;</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">base</span><span class="special">;</span>
   <span class="keyword">typedef</span>  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">smatch</span> <span class="identifier">arg_type</span><span class="special">;</span>
   <span class="keyword">bool</span> <span class="identifier">grep_callback</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">arg_type</span><span class="special">&amp;</span> <span class="identifier">what</span><span class="special">);</span>
<span class="keyword">public</span><span class="special">:</span>
   <span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="special">(</span><span class="identifier">__closure</span><span class="special">*</span> <span class="identifier">grep_callback_type</span><span class="special">)(</span><span class="keyword">const</span> <span class="identifier">arg_type</span><span class="special">&amp;);</span>
   <span class="keyword">void</span> <span class="identifier">IndexClasses</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">file</span><span class="special">);</span>
   <span class="identifier">class_index</span><span class="special">()</span>
      <span class="special">:</span> <span class="identifier">index</span><span class="special">(),</span>
      <span class="identifier">expression</span><span class="special">(</span><span class="string">"^(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?"</span>
                  <span class="string">"(class|struct)[[:space:]]*(\\&lt;\\w+\\&gt;([[:blank:]]*\\([^)]*\\))?"</span>
                  <span class="string">"[[:space:]]*)*(\\&lt;\\w*\\&gt;)[[:space:]]*(&lt;[^;:{]+&gt;[[:space:]]*)?"</span>
                  <span class="string">"(\\{|:[^;\\{()]*\\{)"</span>
                  <span class="special">){}</span>
<span class="special">};</span>

<span class="keyword">bool</span> <span class="identifier">class_index</span><span class="special">::</span><span class="identifier">grep_callback</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">arg_type</span><span class="special">&amp;</span> <span class="identifier">what</span><span class="special">)</span>
<span class="special">{</span>
   <span class="comment">// what[0] contains the whole string    </span>
<span class="comment">// what[5] contains the class name.    </span>
<span class="comment">// what[6] contains the template specialisation if any.    </span>
<span class="comment">// add class name and position to map:    </span>
<span class="identifier">index</span><span class="special">[</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="identifier">what</span><span class="special">[</span><span class="number">5</span><span class="special">].</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">what</span><span class="special">[</span><span class="number">5</span><span class="special">].</span><span class="identifier">second</span><span class="special">)</span> <span class="special">+</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="identifier">what</span><span class="special">[</span><span class="number">6</span><span class="special">].</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">what</span><span class="special">[</span><span class="number">6</span><span class="special">].</span><span class="identifier">second</span><span class="special">)]</span> <span class="special">=</span>
               <span class="identifier">what</span><span class="special">[</span><span class="number">5</span><span class="special">].</span><span class="identifier">first</span> <span class="special">-</span> <span class="identifier">base</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">void</span> <span class="identifier">class_index</span><span class="special">::</span><span class="identifier">IndexClasses</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">file</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">start</span><span class="special">,</span> <span class="identifier">end</span><span class="special">;</span>
   <span class="identifier">start</span> <span class="special">=</span> <span class="identifier">file</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
   <span class="identifier">end</span> <span class="special">=</span> <span class="identifier">file</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span>
   <span class="identifier">base</span> <span class="special">=</span> <span class="identifier">start</span><span class="special">;</span>
   <span class="identifier">class_index</span><span class="special">::</span><span class="identifier">grep_callback_type</span> <span class="identifier">cl</span> <span class="special">=</span> <span class="special">&amp;(</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">grep_callback</span><span class="special">);</span>
   <span class="identifier">regex_grep</span><span class="special">(</span><span class="identifier">cl</span><span class="special">,</span>
            <span class="identifier">start</span><span class="special">,</span>
            <span class="identifier">end</span><span class="special">,</span>
            <span class="identifier">expression</span><span class="special">);</span>
<span class="special">}</span>
</pre>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 1998-2010 John Maddock<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="regex_format.html"><img src="../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../deprecated_interfaces.html"><img src="../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="regex_split.html"><img src="../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
