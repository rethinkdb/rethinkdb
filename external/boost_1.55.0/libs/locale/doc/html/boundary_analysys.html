<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Boost.Locale: Boundary analysis</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="boost-small.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Locale
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('boundary_analysys.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Boundary analysis </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_basics">Basics</a></li>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_segments">Iterating Over Segments</a><ul>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_segments_basics">Basic Iteration</a></li>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_segments_rules">Using Rules</a></li>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_segments_search">Locating Segments</a></li>
</ul>
</li>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_break">Iterating Over Boundary Points</a><ul>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_break_basics">Basic Iteration</a></li>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_break_rules">Using Rules</a></li>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_break_search">Locating Boundary Points</a></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="boundary_analysys_basics"></a>
Basics</h2>
<p>Boost.Locale provides a boundary analysis tool, allowing you to split text into characters, words, or sentences, and find appropriate places for line breaks.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This task is not a trivial task. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A Unicode code point and a character are not equivalent, for example: Hebrew word Shalom - "שָלוֹם" that consists of 4 characters and 6 code points (4 base letters and 2 diacritical marks) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Words may not be separated by space characters in some languages like in Japanese or Chinese.</dd></dl>
<p>Boost.Locale provides 2 major classes for boundary analysis:</p>
<ul>
<li><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a> - an object that holds an index of segments in the text (like words, characters, sentences). It provides an access to <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a> objects via iterators.</li>
<li><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a> - an object that holds an index of boundary points in the text. It allows to iterate over the <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary_point</a> objects.</li>
</ul>
<p>Each of the classes above use an iterator type as template parameter. Both of these classes accept in their constructor:</p>
<ul>
<li>A flag that defines boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>.</li>
<li>The pair of iterators that define the text range that should be analysed</li>
<li>A locale parameter (if not given the global one is used)</li>
</ul>
<p>For example: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>ba=boost::locale::boundary;
std::string text= ... ;
std::locale loc = ... ;
ba::segment_index&lt;std::string::const_iterator&gt; map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6" title="Analyse the text for word boundaries.">ba::word</a>,text.begin(),text.end(),loc);
</pre></div><p>Each of them provide a members <code>begin()</code>, <code>end()</code> and <code>find()</code> that allow to iterate over the selected segments or boundaries in the text or find a location of a segment or boundary for given iterator.</p>
<p>Convenience a typedefs like <a class="el" href="group__boundary.html#gad4785439a3f03ee455c93830b8f1366c">ssegment_index</a> or <a class="el" href="group__boundary.html#gabcb5bcc788909afeb8c68d857284cb59">wcboundary_point_index</a> provided as well, where "w", "u16" and "u32" prefixes define a character type <code>wchar_t</code>, <code>char16_t</code> and <code>char32_t</code> and "c" and "s" prefixes define whether <code>std::basic_string&lt;CharType&gt;::const_iterator</code> or <code>CharType const *</code> are used.</p>
<h2><a class="anchor" id="boundary_analysys_segments"></a>
Iterating Over Segments</h2>
<h2><a class="anchor" id="boundary_analysys_segments_basics"></a>
Basic Iteration</h2>
<p>The text segments analysis is done using <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a> class.</p>
<p>It provides a bidirectional iterator that returns <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a> object. The segment object represents a pair of iterators that define this segment and a rule according to which it was selected. It can be automatically converted to <code>std::basic_string</code> object.</p>
<p>To perform boundary analysis, we first create an index object and then iterate over it:</p>
<p>For example:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>boost::locale::boundary;
<a class="code" href="classboost_1_1locale_1_1generator.html" title="the major class used for locale generation">boost::locale::generator</a> gen;
std::string text=<span class="stringliteral">&quot;To be or not to be, that is the question.&quot;</span>
<span class="comment">// Create mapping of text for token iterator using global locale.</span>
<a class="code" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">ssegment_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6" title="Analyse the text for word boundaries.">word</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;en_US.UTF-8&quot;</span>)); 
<span class="comment">// Print all &quot;words&quot; -- chunks of word boundary</span>
<span class="keywordflow">for</span>(<a class="code" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">ssegment_index::iterator</a> it=map.begin(),e=map.end();it!=e;++it)
    std::cout &lt;&lt;<span class="stringliteral">&quot;\&quot;&quot;</span>&lt;&lt; * it &lt;&lt; <span class="stringliteral">&quot;\&quot;, &quot;</span>;
std::cout &lt;&lt; std::endl;
</pre></div><p>Would print:</p>
<div class="fragment"><pre class="fragment">
"To", " ", "be", " ", "or", " ", "not", " ", "to", " ", "be", ",", " ", "that", " ", "is", " ", "the", " ", "question", ".",
</pre></div><p>This sentence "生きるか死ぬか、それが問題だ。" (<a href="http://tatoeba.org/eng/sentences/show/868189">from Tatoeba database</a>) would be split into following segments in <code>ja_JP.UTF-8</code> (Japanese) locale:</p>
<div class="fragment"><pre class="fragment">
"生", "きるか", "死", "ぬか", "、", "それが", "問題", "だ", "。", 
</pre></div><p>The boundary analysis that is done by Boost.Locale is much more complicated then just splitting the text according to white space characters, even thou it is not perfect.</p>
<h2><a class="anchor" id="boundary_analysys_segments_rules"></a>
Using Rules</h2>
<p>The segments selection can be customized using <a class="el" href="group__boundary.html#gad19735180401edb15acbdbbeb21e5a73">rule()</a> and <a class="el" href="group__boundary.html#ga205fd51daa439a18527675e663a0802f">full_select()</a> member functions.</p>
<p>By default segment_index's iterator return each text segment defined by two boundary points regardless the way they were selected. Thus in the example above we could see text segments like "." or " " that were selected as words.</p>
<p>Using a <code>rule()</code> member function we can specify a binary mask of rules we want to use for selection of the boundary points using <a class="el" href="group__boundary.html#bl_boundary_word_rules">word</a>, <a class="el" href="group__boundary.html#bl_boundary_line_rules">line</a> and <a class="el" href="group__boundary.html#bl_boundary_sentence_rules">sentence</a> boundary rules.</p>
<p>For example, by calling</p>
<div class="fragment"><pre class="fragment">map.rule(<a class="code" href="group__boundary.html#ga3ab98808dbb1cc4a346dcc2554c9d8dc" title="Any word including numbers, 0 is special flag, equivalent to 15.">word_any</a>);
</pre></div><p>Before starting the iteration process, specify a selection mask that fetches: numbers, letter, Kana letters and ideographic characters ignoring all non-word related characters like white space or punctuation marks.</p>
<p>So the code:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>boost::locale::boundary;
std::string text=<span class="stringliteral">&quot;To be or not to be, that is the question.&quot;</span>
<span class="comment">// Create mapping of text for token iterator using global locale.</span>
<a class="code" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">ssegment_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6" title="Analyse the text for word boundaries.">word</a>,text.begin(),text.end()); 
<span class="comment">// Define a rule</span>
map.<a class="code" href="group__boundary.html#ga72b4ceb5bacec0eded2601c43a4d671a">rule</a>(<a class="code" href="group__boundary.html#ga3ab98808dbb1cc4a346dcc2554c9d8dc" title="Any word including numbers, 0 is special flag, equivalent to 15.">word_any</a>);
<span class="comment">// Print all &quot;words&quot; -- chunks of word boundary</span>
<span class="keywordflow">for</span>(<a class="code" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">ssegment_index::iterator</a> it=map.begin(),e=map.end();it!=e;++it)
    std::cout &lt;&lt;<span class="stringliteral">&quot;\&quot;&quot;</span>&lt;&lt; * it &lt;&lt; <span class="stringliteral">&quot;\&quot;, &quot;</span>;
std::cout &lt;&lt; std::endl;
</pre></div><p>Would print:</p>
<div class="fragment"><pre class="fragment">
"To", "be", "or", "not", "to", "be", "that", "is", "the", "question",
</pre></div><p>And the for given text="生きるか死ぬか、それが問題だ。" and rule(<a class="el" href="group__boundary.html#ga705ab96f9e62810c8ed977c90d404ef8">word_ideo</a>), the example above would print.</p>
<div class="fragment"><pre class="fragment">
"生", "死", "問題",
</pre></div><p>You can access specific rules the segments where selected it using <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html#a5b36a522d7013306617dbcccc9919343">segment::rule()</a> member function. Using a bit-mask of rules.</p>
<p>For example:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="classboost_1_1locale_1_1generator.html" title="the major class used for locale generation">boost::locale::generator</a> gen;
<span class="keyword">using namespace </span>boost::locale::boundary;
std::string text=<span class="stringliteral">&quot;生きるか死ぬか、それが問題だ。&quot;</span>;
<a class="code" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">ssegment_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6" title="Analyse the text for word boundaries.">word</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;ja_JP.UTF-8&quot;</span>)); 
<span class="keywordflow">for</span>(<a class="code" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">ssegment_index::iterator</a> it=map.begin(),e=map.end();it!=e;++it) {
    std::cout &lt;&lt; <span class="stringliteral">&quot;Segment &quot;</span> &lt;&lt; *it &lt;&lt; <span class="stringliteral">&quot; contains: &quot;</span>;
    <span class="keywordflow">if</span>(it-&gt;rule() &amp; <a class="code" href="group__boundary.html#ga90cf4f01b95658f659685377226677e7" title="Not a word, like white space or punctuation mark.">word_none</a>)
        std::cout &lt;&lt; <span class="stringliteral">&quot;white space or punctuation marks &quot;</span>;
    <span class="keywordflow">if</span>(it-&gt;rule() &amp; <a class="code" href="group__boundary.html#ga52d8c63e1f3f8c898c645352206a78ef" title="Word that contains kana characters.">word_kana</a>)
        std::cout &lt;&lt; <span class="stringliteral">&quot;kana characters &quot;</span>;
    <span class="keywordflow">if</span>(it-&gt;rule() &amp; <a class="code" href="group__boundary.html#ga705ab96f9e62810c8ed977c90d404ef8" title="Word that contains ideographic characters.">word_ideo</a>)
        std::cout &lt;&lt; <span class="stringliteral">&quot;ideographic characters&quot;</span>;
    std::cout&lt;&lt; std::endl;
}
</pre></div><p>Would print</p>
<div class="fragment"><pre class="fragment">
Segment 生 contains: ideographic characters
Segment きるか contains: kana characters 
Segment 死 contains: ideographic characters
Segment ぬか contains: kana characters 
Segment 、 contains: white space or punctuation marks 
Segment それが contains: kana characters 
Segment 問題 contains: ideographic characters
Segment だ contains: kana characters 
Segment 。 contains: white space or punctuation marks 
</pre></div><p>One important things that should be noted that each segment is defined by a pair of boundaries and the rule of its ending point defines if it is selected or not.</p>
<p>In some cases it may be not what we actually look like.</p>
<p>For example we have a text:</p>
<div class="fragment"><pre class="fragment">
Hello! How
are you?
</pre></div><p>And we want to fetch all sentences from the text.</p>
<p>The <a class="el" href="group__boundary.html#bl_boundary_sentence_rules">sentence rules</a> have two options:</p>
<ul>
<li>Split the text on the point where sentence terminator like ".!?" detected: <a class="el" href="group__boundary.html#ga3befefe67f79691c117bf5588741355b">sentence_term</a></li>
<li>Split the text on the point where sentence separator like "line feed" detected: <a class="el" href="group__boundary.html#gaf67883341dd3d8f786e7281d40790000">sentence_sep</a></li>
</ul>
<p>Naturally to ignore sentence separators we would call <a class="el" href="group__boundary.html#gad19735180401edb15acbdbbeb21e5a73">segment_index::rule(rule_type v)</a> with sentence_term parameter and then run the iterator.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="classboost_1_1locale_1_1generator.html" title="the major class used for locale generation">boost::locale::generator</a> gen;
<span class="keyword">using namespace </span>boost::locale::boundary;
std::string text=   <span class="stringliteral">&quot;Hello! How\n&quot;</span>
                    <span class="stringliteral">&quot;are you?\n&quot;</span>;
<a class="code" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">ssegment_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9" title="Analyse the text for Find sentence boundaries.">sentence</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;en_US.UTF-8&quot;</span>)); 
map.<a class="code" href="group__boundary.html#ga72b4ceb5bacec0eded2601c43a4d671a">rule</a>(<a class="code" href="group__boundary.html#ga3befefe67f79691c117bf5588741355b" title="The sentence was terminated with a sentence terminator like &quot;.&quot;, &quot;!&quot; possible followed by hard separa...">sentence_term</a>);
<span class="keywordflow">for</span>(<a class="code" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">ssegment_index::iterator</a> it=map.begin(),e=map.end();it!=e;++it) 
    std::cout &lt;&lt; <span class="stringliteral">&quot;Sentence [&quot;</span> &lt;&lt; *it &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;
</pre></div><p>However we would get the expected segments: </p>
<div class="fragment"><pre class="fragment">
Sentence [Hello! ]
Sentence [are you?
]
</pre></div><p>The reason is that "How\n" is still considered a sentence but selected by different rule.</p>
<p>This behavior can be changed by setting <a class="el" href="group__boundary.html#ga205fd51daa439a18527675e663a0802f">segment_index::full_select(bool)</a> to <code>true</code>. It would force iterator to join the current segment with all previous segments that may not fit the required rule.</p>
<p>So we add this line:</p>
<div class="fragment"><pre class="fragment">map.full_select(<span class="keyword">true</span>);
</pre></div><p>Right after "map.rule(sentence_term);" and get expected output:</p>
<div class="fragment"><pre class="fragment">
Sentence [Hello! ]
Sentence [How
are you?
]
</pre></div><h3><a class="anchor" id="boundary_analysys_segments_search"></a>
Locating Segments</h3>
<p>Sometimes it is useful to find a segment that some specific iterator is pointing on.</p>
<p>For example a user had clicked at specific point, we want to select a word on this location.</p>
<p><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a> provides <a class="el" href="group__boundary.html#ga2480236106971797460187777f2a4411">find(base_iterator p)</a> member function for this purpose.</p>
<p>This function returns the iterator to the segmet such that <em>p</em> points to.</p>
<p>For example:</p>
<div class="fragment"><pre class="fragment">text=<span class="stringliteral">&quot;to be or &quot;</span>;
<a class="code" href="group__boundary.html#gad4785439a3f03ee455c93830b8f1366c">ssegment_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6" title="Analyse the text for word boundaries.">word</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;en_US.UTF-8&quot;</span>));
ssegment_index::iterator  p = map.find(text.begin() + 4);
<span class="keywordflow">if</span>(p!=map.end())
    std::cout &lt;&lt; *p &lt;&lt; std::endl;
</pre></div><p>Would print:</p>
<div class="fragment"><pre class="fragment">
be
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>if the iterator lays inside the segment this segment returned. If the segment does not fit the selection rules, then the segment following requested position is returned.</p>
<p>For example: For <a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">word</a> boundary analysis with <a class="el" href="group__boundary.html#ga3ab98808dbb1cc4a346dcc2554c9d8dc">word_any</a> rule:</p>
<ul>
<li>"t|o be or ", would point to "to" - the iterator in the middle of segment "to".</li>
<li>"to |be or ", would point to "be" - the iterator at the beginning of the segment "be"</li>
<li>"to| be or ", would point to "be" - the iterator does is not point to segment with required rule so next valid segment is selected "be".</li>
<li>"to be or| ", would point to end as not valid segment found.</li>
</ul>
<h2><a class="anchor" id="boundary_analysys_break"></a>
Iterating Over Boundary Points</h2>
<h2><a class="anchor" id="boundary_analysys_break_basics"></a>
Basic Iteration</h2>
<p>The <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a> is similar to <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a> in its interface but as a different role. Instead of returning text chunks (<a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>s, it returns <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary_point</a> object that represents a position in text - a base iterator used that is used for iteration of the source text C++ characters. The <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary_point</a> object also provides a <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html#a757b28e11c66f9871d3f51fe93a51bdb">rule()</a> member function that defines a rule this boundary was selected according to.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The beginning and the ending of the text are considered boundary points, so even an empty text consists of at least one boundary point.</dd></dl>
<p>Lets see an example of selecting first two sentences from a text:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>boost::locale::boundary;
<a class="code" href="classboost_1_1locale_1_1generator.html" title="the major class used for locale generation">boost::locale::generator</a> gen;

<span class="comment">// our text sample</span>
std::string <span class="keyword">const</span> text=<span class="stringliteral">&quot;First sentence. Second sentence! Third one?&quot;</span>;
<span class="comment">// Create an index </span>
<a class="code" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them.">sboundary_point_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9" title="Analyse the text for Find sentence boundaries.">sentence</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;en_US.UTF-8&quot;</span>));

<span class="comment">// Count two boundary points</span>
<a class="code" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">sboundary_point_index::iterator</a> p = map.<a class="code" href="group__boundary.html#ga56f42a32f0378b6e157671f9e17bd66f">begin</a>(),e=map.end();
<span class="keywordtype">int</span> count = 0;
<span class="keywordflow">while</span>(p!=e &amp;&amp; count &lt; 2) {
    ++count;
    ++p;
}

<span class="keywordflow">if</span>(p!=e) {
    std::cout   &lt;&lt; <span class="stringliteral">&quot;First two sentences are: &quot;</span> 
                &lt;&lt; std::string(text.begin(),p-&gt;iterator()) 
                &lt;&lt; std::endl;
}
<span class="keywordflow">else</span> {
    std::cout   &lt;&lt;<span class="stringliteral">&quot;There are less then two sentences in this &quot;</span>
                &lt;&lt;<span class="stringliteral">&quot;text: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;
}
</pre></div><p>Would print:</p>
<div class="fragment"><pre class="fragment">
First two sentences are: First sentence. Second sentence!
</pre></div><h2><a class="anchor" id="boundary_analysys_break_rules"></a>
Using Rules</h2>
<p>Similarly to the <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a> the <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a> provides a <a class="el" href="group__boundary.html#ga56e63913f51109e05a24a7136472a975">rule(rule_type mask)</a> member function to filter boundary points that interest us.</p>
<p>It allows to set <a class="el" href="group__boundary.html#bl_boundary_word_rules">word</a>, <a class="el" href="group__boundary.html#bl_boundary_line_rules">line</a> and <a class="el" href="group__boundary.html#bl_boundary_sentence_rules">sentence</a> rules for filtering boundary points.</p>
<p>Lets change an example above a little:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// our text sample</span>
std::string <span class="keyword">const</span> text= <span class="stringliteral">&quot;First sentence. Second\n&quot;</span>
                        <span class="stringliteral">&quot;sentence! Third one?&quot;</span>;
</pre></div><p>If we run our program as is on the sample above we would get: </p>
<div class="fragment"><pre class="fragment">
First two sentences are: First sentence. Second
</pre></div><p>Which is not something that we really expected. As the "Second\n" is considered an independent sentence that was separated by a line separator "Line Feed".</p>
<p>However, we can set set a rule <a class="el" href="group__boundary.html#ga3befefe67f79691c117bf5588741355b">sentence_term</a> and the iterator would use only boundary points that are created by a sentence terminators like ".!?".</p>
<p>So by adding: </p>
<div class="fragment"><pre class="fragment">map.rule(<a class="code" href="group__boundary.html#ga3befefe67f79691c117bf5588741355b" title="The sentence was terminated with a sentence terminator like &quot;.&quot;, &quot;!&quot; possible followed by hard separa...">sentence_term</a>);
</pre></div><p>Right after the generation of the index we would get the desired output:</p>
<div class="fragment"><pre class="fragment">
First two sentences are: First sentence. Second
sentence! 
</pre></div><p>You can also use <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html#a757b28e11c66f9871d3f51fe93a51bdb">boundary_point::rule()</a> member function to learn about the reason this boundary point was created by comparing it with an appropriate mask.</p>
<p>For example:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>boost::locale::boundary;
<a class="code" href="classboost_1_1locale_1_1generator.html" title="the major class used for locale generation">boost::locale::generator</a> gen;
<span class="comment">// our text sample</span>
std::string <span class="keyword">const</span> text= <span class="stringliteral">&quot;First sentence. Second\n&quot;</span>
                        <span class="stringliteral">&quot;sentence! Third one?&quot;</span>;
<a class="code" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them.">sboundary_point_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9" title="Analyse the text for Find sentence boundaries.">sentence</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;en_US.UTF-8&quot;</span>));

<span class="keywordflow">for</span>(<a class="code" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">sboundary_point_index::iterator</a> p = map.begin(),e=map.end();p!=e;++p) {
    <span class="keywordflow">if</span>(p-&gt;rule() &amp; <a class="code" href="group__boundary.html#ga3befefe67f79691c117bf5588741355b" title="The sentence was terminated with a sentence terminator like &quot;.&quot;, &quot;!&quot; possible followed by hard separa...">sentence_term</a>)
        std::cout &lt;&lt; <span class="stringliteral">&quot;There is a sentence terminator: &quot;</span>;
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(p-&gt;rule() &amp; <a class="code" href="group__boundary.html#gaf67883341dd3d8f786e7281d40790000" title="The sentence does not contain terminator like &quot;.&quot;, &quot;!&quot; but ended with hard separator like CR...">sentence_sep</a>)
        std::cout &lt;&lt; <span class="stringliteral">&quot;There is a sentence separator: &quot;</span>;
    <span class="keywordflow">if</span>(p-&gt;rule()!=0) <span class="comment">// print if some rule exists</span>
        std::cout   &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; std::string(text.begin(),p-&gt;iterator()) 
                    &lt;&lt; <span class="stringliteral">&quot;|&quot;</span> &lt;&lt; std::string(p-&gt;iterator(),text.end()) 
                    &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;
}
</pre></div><p>Would give the following output: </p>
<div class="fragment"><pre class="fragment">
There is a sentence terminator: [First sentence. |Second
sentence! Third one?]
There is a sentence separator: [First sentence. Second
|sentence! Third one?]
There is a sentence terminator: [First sentence. Second
sentence! |Third one?]
There is a sentence terminator: [First sentence. Second
sentence! Third one?|]
</pre></div><h3><a class="anchor" id="boundary_analysys_break_search"></a>
Locating Boundary Points</h3>
<p>Sometimes it is useful to find a specific boundary point according to given iterator.</p>
<p><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a> provides a <a class="el" href="group__boundary.html#ga0bb71a287afca990e85b17246568492d">iterator find(base_iterator p)</a> member function.</p>
<p>It would return an iterator to a boundary point on <em>p's</em> location or at the location following it if <em>p</em> does not point to appropriate position.</p>
<p>For example, for word boundary analysis:</p>
<ul>
<li>If a base iterator points to "to |be", then the returned boundary point would be "to |be" (same position)</li>
<li>If a base iterator points to "t|o be", then the returned boundary point would be "to| be" (next valid position)</li>
</ul>
<p>For example if we want to select 6 words around specific boundary point we can use following code:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>boost::locale::boundary;
<a class="code" href="classboost_1_1locale_1_1generator.html" title="the major class used for locale generation">boost::locale::generator</a> gen;
<span class="comment">// our text sample</span>
std::string <span class="keyword">const</span> text= <span class="stringliteral">&quot;To be or not to be, that is the question.&quot;</span>;

<span class="comment">// Create a mapping</span>
<a class="code" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them.">sboundary_point_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6" title="Analyse the text for word boundaries.">word</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;en_US.UTF-8&quot;</span>));
<span class="comment">// Ignore wite space</span>
map.<a class="code" href="group__boundary.html#ga1d214029f1a780b7bf6e3f23a3004c03">rule</a>(<a class="code" href="group__boundary.html#ga3ab98808dbb1cc4a346dcc2554c9d8dc" title="Any word including numbers, 0 is special flag, equivalent to 15.">word_any</a>);

<span class="comment">// define our arbitraty point</span>
std::string::const_iterator pos = text.begin() + 12; <span class="comment">// &quot;no|t&quot;;</span>

<span class="comment">// Get the search range</span>
<a class="code" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">sboundary_point_index::iterator</a> 
    begin =map.begin(),
    end = map.end(),
    it = map.find(pos); <span class="comment">// find a boundary</span>

<span class="comment">// go 3 words backward</span>
<span class="keywordflow">for</span>(<span class="keywordtype">int</span> count = 0;count &lt;3 &amp;&amp; it!=begin; count ++) 
    --it;

<span class="comment">// Save the start</span>
std::string::const_iterator start = *it;

<span class="comment">// go 6 words forward</span>
<span class="keywordflow">for</span>(<span class="keywordtype">int</span> count = 0;count &lt; 6 &amp;&amp; it!=end; count ++)
    ++it;

<span class="comment">// make sure we at valid position</span>
<span class="keywordflow">if</span>(it==end)
    --it;

<span class="comment">// print the text</span>
std::cout &lt;&lt; std::string(start,it-&gt;iterator()) &lt;&lt; std::endl;
</pre></div><p>That would print:</p>
<div class="fragment"><pre class="fragment">
 be or not to be, that
</pre></div> </div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">Boost.Locale</a>      </li>
      <li class="navelem"><a class="el" href="using_boost_locale.html">Using Boost.Locale</a>      </li>

    <li class="footer">
&copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License</a>, Version 1.0.
    </li>
   </ul>
 </div>


</body>
</html>
