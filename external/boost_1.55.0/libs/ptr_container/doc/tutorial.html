<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" />
<title>Boost Pointer Container Library</title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2007-11-25 10:38:02 -0800 (Sun, 25 Nov 2007) $
:Revision: $Revision: 41370 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* "! important" is used here to override other ``margin-top`` and
   ``margin-bottom`` styles that are later in the stylesheet or 
   more specific.  See http://www.w3.org/TR/CSS1#the-cascade */
.first {
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

img.borderless {
  border: 0 }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid thin gray }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid thin black }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="boost-pointer-container-library">
<h1 class="title"><img alt="Boost" src="boost.png" /> Pointer Container Library</h1>
<h2 class="subtitle" id="tutorial">Tutorial</h2>
<p>The tutorial shows you the most simple usage of the
library. It is assumed that the reader is familiar
with the use of standard containers. Although
the tutorial is devided into sections, it is recommended
that you read it all from top to bottom.</p>
<ul class="simple">
<li><a class="reference" href="#basic-usage">Basic usage</a></li>
<li><a class="reference" href="#indirected-interface">Indirected interface</a></li>
<li><a class="reference" href="#sequence-containers">Sequence containers</a></li>
<li><a class="reference" href="#associative-containers">Associative containers</a></li>
<li><a class="reference" href="#null-values">Null values</a></li>
<li><a class="reference" href="#cloneability">Cloneability</a></li>
<li><a class="reference" href="#new-functions">New functions</a></li>
<li><a class="reference" href="#std-auto-ptr-u-overloads">std::auto_ptr&lt;U&gt; overloads</a></li>
<li><a class="reference" href="#algorithms">Algorithms</a></li>
</ul>
<div class="section">
<h1><a id="basic-usage" name="basic-usage">Basic usage</a></h1>
<p>The most important aspect of a pointer container is that it manages
memory for you. This means that you in most cases do not need to worry
about deleting memory.</p>
<p>Let us assume that we have an OO-hierarchy of animals</p>
<pre class="literal-block">
class animal : <a class="reference" href="http://www.boost.org/libs/utility/utility.htm#Class_noncopyable">boost::noncopyable</a>
{
public:
    virtual      ~animal()   {}
    virtual void eat()       = 0;
    virtual int  age() const = 0;
    // ...
};

class mammal : public animal
{
    // ...
};

class bird : public animal
{
    // ...
};
</pre>
<p>Then the managing of the animals is straight-forward. Imagine a 
Zoo:</p>
<pre class="literal-block">
class zoo
{
    boost::ptr_vector&lt;animal&gt; the_animals;
public:

    void add_animal( animal* a )
    {
        the_animals.push_back( a );
    }
};
</pre>
<p>Notice how we just pass the class name to the container; there
is no <tt class="docutils literal"><span class="pre">*</span></tt> to indicate it is a pointer.
With this declaration we can now say:</p>
<pre class="literal-block">
zoo the_zoo;
the_zoo.add_animal( new mammal(&quot;joe&quot;) );
the_zoo.add_animal( new bird(&quot;dodo&quot;) );
</pre>
<p>Thus we heap-allocate all elements of the container
and never rely on copy-semantics.</p>
</div>
<div class="section">
<h1><a id="indirected-interface" name="indirected-interface">Indirected interface</a></h1>
<p>A particular feature of the pointer containers is that
the query interface is indirected. For example,</p>
<pre class="literal-block">
boost::ptr_vector&lt;animal&gt; vec;
vec.push_back( new animal ); // you add it as pointer ...
vec[0].eat();                // but get a reference back
</pre>
<p>This indirection also happens to iterators, so</p>
<pre class="literal-block">
typedef std::vector&lt;animal*&gt; std_vec;
std_vec vec;
...
std_vec::iterator i = vec.begin();
(*i)-&gt;eat(); // '*' needed
</pre>
<p>now becomes</p>
<pre class="literal-block">
typedef boost::ptr_vector&lt;animal&gt;  ptr_vec;
ptr_vec vec;
ptr_vec::iterator i = vec.begin();
i-&gt;eat(); // no indirection needed
</pre>
</div>
<div class="section">
<h1><a id="sequence-containers" name="sequence-containers">Sequence containers</a></h1>
<p>The sequence containers are used when you do not need to
keep an ordering on your elements. You can basically
expect all operations of the normal standard containers
to be available. So, for example, with a  <tt class="docutils literal"><span class="pre">ptr_deque</span></tt>
and <tt class="docutils literal"><span class="pre">ptr_list</span></tt> object you can say:</p>
<pre class="literal-block">
boost::ptr_deque&lt;animal&gt; deq;
deq.push_front( new animal );    
deq.pop_front();
</pre>
<p>because <tt class="docutils literal"><span class="pre">std::deque</span></tt> and <tt class="docutils literal"><span class="pre">std::list</span></tt> have <tt class="docutils literal"><span class="pre">push_front()</span></tt>
and <tt class="docutils literal"><span class="pre">pop_front()</span></tt> members.</p>
<p>If the standard sequence supports
random access, so does the pointer container; for example:</p>
<pre class="literal-block">
for( boost::ptr_deque&lt;animal&gt;::size_type i = 0u;
     i != deq.size(); ++i )
     deq[i].eat();
</pre>
<p>The <tt class="docutils literal"><span class="pre">ptr_vector</span></tt> also allows you to specify the size of
the buffer to allocate; for example</p>
<pre class="literal-block">
boost::ptr_vector&lt;animal&gt; animals( 10u );
</pre>
<p>will reserve room for 10 animals.</p>
</div>
<div class="section">
<h1><a id="associative-containers" name="associative-containers">Associative containers</a></h1>
<p>To keep an ordering on our animals, we could use a <tt class="docutils literal"><span class="pre">ptr_set</span></tt>:</p>
<pre class="literal-block">
boost::ptr_set&lt;animal&gt; set;
set.insert( new monkey(&quot;bobo&quot;) );
set.insert( new whale(&quot;anna&quot;) );
...
</pre>
<p>This requires that <tt class="docutils literal"><span class="pre">operator&lt;()</span></tt> is defined for animals. One
way to do this could be</p>
<pre class="literal-block">
inline bool operator&lt;( const animal&amp; l, const animal&amp; r )
{
    return l.name() &lt; r.name();
}
</pre>
<p>if we wanted to keep the animals sorted by name.</p>
<p>Maybe you want to keep all the animals in zoo ordered wrt.
their name, but it so happens that many animals have the
same name. We can then use a <tt class="docutils literal"><span class="pre">ptr_multimap</span></tt>:</p>
<pre class="literal-block">
typedef boost::ptr_multimap&lt;std::string,animal&gt; zoo_type;
zoo_type zoo;
std::string bobo = &quot;bobo&quot;,
            anna = &quot;anna&quot;;
zoo.insert( bobo, new monkey(bobo) );
zoo.insert( bobo, new elephant(bobo) );
zoo.insert( anna, new whale(anna) );
zoo.insert( anna, new emu(anna) );
</pre>
<p>Note that must create the key as an lvalue 
(due to exception-safety issues); the following would not 
have compiled</p>
<pre class="literal-block">
zoo.insert( &quot;bobo&quot;, // this is bad, but you get compile error
            new monkey(&quot;bobo&quot;) );
</pre>
<p>If a multimap is not needed, we can use <tt class="docutils literal"><span class="pre">operator[]()</span></tt>
to avoid the clumsiness:</p>
<pre class="literal-block">
boost::ptr_map&lt;std::string,animal&gt; animals;
animals[&quot;bobo&quot;].set_name(&quot;bobo&quot;);
</pre>
<p>This requires a default constructor for animals and
a function to do the initialization, in this case <tt class="docutils literal"><span class="pre">set_name()</span></tt>.</p>
<p>A better alternative is to use <a class="reference" href="../../assign/index.html">Boost.Assign</a>
to help you out. In particular, consider</p>
<ul class="simple">
<li><a class="reference" href="../../assign/doc/index.html#ptr_push_back">ptr_push_back(), ptr_push_front(), ptr_insert() and ptr_map_insert()</a></li>
<li><a class="reference" href="../../assign/doc/index.html#ptr_list_of">ptr_list_of()</a></li>
</ul>
<p>For example, the above insertion may now be written</p>
<pre class="literal-block">
boost::ptr_multimap&lt;std::string,animal&gt; animals;

using namespace boost::assign;
ptr_map_insert&lt;monkey&gt;( animals )( &quot;bobo&quot;, &quot;bobo&quot; );
ptr_map_insert&lt;elephant&gt;( animals )( &quot;bobo&quot;, &quot;bobo&quot; );
ptr_map_insert&lt;whale&gt;( animals )( &quot;anna&quot;, &quot;anna&quot; );
ptr_map_insert&lt;emu&gt;( animals )( &quot;anna&quot;, &quot;anna&quot; );
</pre>
</div>
<div class="section">
<h1><a id="null-values" name="null-values">Null values</a></h1>
<p>By default, if you try to insert null into a container, an exception
is thrown. If you want to allow nulls, then you must
say so explicitly when declaring the container variable</p>
<pre class="literal-block">
boost::ptr_vector&lt; boost::nullable&lt;animal&gt; &gt; animals_type;
animals_type animals;
...
animals.insert( animals.end(), new dodo(&quot;fido&quot;) );
animals.insert( animals.begin(), 0 ) // ok
</pre>
<p>Once you have inserted a null into the container, you must
always check if the value is null before accessing the object</p>
<pre class="literal-block">
for( animals_type::iterator i = animals.begin();
     i != animals.end(); ++i )
{
    if( !boost::is_null(i) ) // always check for validity
        i-&gt;eat();
}
</pre>
<p>If the container support random access, you may also check this as</p>
<pre class="literal-block">
for( animals_type::size_type i = 0u; 
     i != animals.size(); ++i )
{
    if( !animals.is_null(i) )
         animals[i].eat();
}
</pre>
<p>Note that it is meaningless to insert
null into <tt class="docutils literal"><span class="pre">ptr_set</span></tt> and <tt class="docutils literal"><span class="pre">ptr_multiset</span></tt>.</p>
</div>
<div class="section">
<h1><a id="cloneability" name="cloneability">Cloneability</a></h1>
<p>In OO programming it is typical to prohibit copying of objects; the 
objects may sometimes be allowed to be Cloneable; for example,:</p>
<pre class="literal-block">
animal* animal::clone() const
{
    return do_clone(); // implemented by private virtual function
}
</pre>
<p>If the OO hierarchy thus allows cloning, we need to tell the 
pointer containers how cloning is to be done. This is simply
done by defining a free-standing function, <tt class="docutils literal"><span class="pre">new_clone()</span></tt>, 
in the same namespace as
the object hierarchy:</p>
<pre class="literal-block">
inline animal* new_clone( const animal&amp; a )
{
    return a.clone();
}
</pre>
<p>That is all, now a lot of functions in a pointer container
can exploit the cloneability of the animal objects. For example</p>
<pre class="literal-block">
typedef boost::ptr_list&lt;animal&gt; zoo_type;
zoo_type zoo, another_zoo;
...
another_zoo.assign( zoo.begin(), zoo.end() );
</pre>
<p>will fill another zoo with clones of the first zoo. Similarly,
<tt class="docutils literal"><span class="pre">insert()</span></tt> can now insert clones into your pointer container</p>
<pre class="literal-block">
another_zoo.insert( another_zoo.begin(), zoo.begin(), zoo.end() );
</pre>
<p>The whole container can now also be cloned</p>
<pre class="literal-block">
zoo_type yet_another_zoo = zoo.clone();
</pre>
<p>Copying or assigning the container has the same effect as cloning (though it is slightly cheaper):</p>
<pre class="literal-block">
zoo_type yet_another_zoo = zoo;
</pre>
<p>Copying also support derived-to-base class conversions:</p>
<pre class="literal-block">
boost::ptr_vector&lt;monkey&gt; monkeys = boost::assign::ptr_list_of&lt;monkey&gt;( &quot;bobo&quot; )( &quot;bebe&quot;)( &quot;uhuh&quot; );
boost::ptr_vector&lt;animal&gt; animals = monkeys;
</pre>
<p>This also works for maps:</p>
<pre class="literal-block">
boost::ptr_map&lt;std::string,monkey&gt; monkeys = ...;
boost::ptr_map&lt;std::string,animal&gt; animals = monkeys;
</pre>
</div>
<div class="section">
<h1><a id="new-functions" name="new-functions">New functions</a></h1>
<p>Given that we know we are working with pointers, a few new functions
make sense. For example, say you want to remove an
animal from the zoo</p>
<pre class="literal-block">
zoo_type::auto_type the_animal = zoo.release( zoo.begin() );
the_animal-&gt;eat();
animal* the_animal_ptr = the_animal.release(); // now this is not deleted
zoo.release(2); // for random access containers
</pre>
<p>You can think of <tt class="docutils literal"><span class="pre">auto_type</span></tt> as a non-copyable form of 
<tt class="docutils literal"><span class="pre">std::auto_ptr</span></tt>. Notice that when you release an object, the
pointer is removed from the container and the containers size
shrinks. For containers that store nulls, we can exploit that
<tt class="docutils literal"><span class="pre">auto_type</span></tt> is convertible to <tt class="docutils literal"><span class="pre">bool</span></tt>:</p>
<pre class="literal-block">
if( ptr_vector&lt; nullable&lt;T&gt; &gt;::auto_type r = vec.pop_back() )
{
  ...
}  
</pre>
<p>You can also release the entire container if you
want to return it from a function</p>
<pre class="literal-block">
std::auto_ptr&lt; boost::ptr_deque&lt;animal&gt; &gt; get_zoo()
{
    boost::ptr_deque&lt;animal&gt;  result;
    ...
    return result.release(); // give up ownership
}
...
boost::ptr_deque&lt;animal&gt; animals = get_zoo();    
</pre>
<p>Let us assume we want to move an animal object from
one zoo to another. In other words, we want to move the 
animal and the responsibility of it to another zoo</p>
<pre class="literal-block">
another_zoo.transfer( another_zoo.end(), // insert before end 
                      zoo.begin(),       // insert this animal ...
                      zoo );             // from this container
</pre>
<p>This kind of &quot;move-semantics&quot; is different from
normal value-based containers. You can think of <tt class="docutils literal"><span class="pre">transfer()</span></tt>
as the same as <tt class="docutils literal"><span class="pre">splice()</span></tt> on <tt class="docutils literal"><span class="pre">std::list</span></tt>.</p>
<p>If you want to replace an element, you can easily do so</p>
<pre class="literal-block">
zoo_type::auto_type old_animal = zoo.replace( zoo.begin(), new monkey(&quot;bibi&quot;) ); 
zoo.replace( 2, old_animal.release() ); // for random access containers
</pre>
<p>A map is slightly different to iterate over than standard maps.
Now we say</p>
<pre class="literal-block">
typedef boost::ptr_map&lt;std::string, boost::nullable&lt;animal&gt; &gt; animal_map;
animal_map map;
...
for( animal_map::const_iterator i = map.begin(), e = map.end(); i != e; ++i )
{
    std::cout &lt;&lt; &quot;\n key: &quot; &lt;&lt; i-&gt;first;
    std::cout &lt;&lt; &quot;\n age: &quot;;
    
    if( boost::is_null(i) )
        std::cout &lt;&lt; &quot;unknown&quot;;
    else
        std::cout &lt;&lt; i-&gt;second-&gt;age(); 
 }
</pre>
<p>Except for the check for null, this looks like it would with a normal map. But if <tt class="docutils literal"><span class="pre">age()</span></tt> had 
not been a <tt class="docutils literal"><span class="pre">const</span></tt> member function,
it would not have compiled.</p>
<p>Maps can also be indexed with bounds-checking</p>
<pre class="literal-block">
try
{
    animal&amp; bobo = map.at(&quot;bobo&quot;);
}
catch( boost::bad_ptr_container_operation&amp; e )
{
    // &quot;bobo&quot; not found
}        
</pre>
</div>
<div class="section">
<h1><a id="std-auto-ptr-u-overloads" name="std-auto-ptr-u-overloads"><tt class="docutils literal"><span class="pre">std::auto_ptr&lt;U&gt;</span></tt> overloads</a></h1>
<p>Every time there is a function that takes a <tt class="docutils literal"><span class="pre">T*</span></tt> parameter, there is
also a function taking an <tt class="docutils literal"><span class="pre">std::auto_ptr&lt;U&gt;</span></tt> parameter. This is of course done
to make the library intregrate seamlessly with <tt class="docutils literal"><span class="pre">std::auto_ptr</span></tt>. For example</p>
<pre class="literal-block">
std::ptr_vector&lt;Base&gt; vec;
vec.push_back( new Base );
</pre>
<p>is complemented by</p>
<pre class="literal-block">
std::auto_ptr&lt;Derived&gt; p( new Derived );
vec.push_back( p );   
</pre>
<p>Notice that the template argument for <tt class="docutils literal"><span class="pre">std::auto_ptr</span></tt> does not need to
follow the template argument for <tt class="docutils literal"><span class="pre">ptr_vector</span></tt> as long as <tt class="docutils literal"><span class="pre">Derived*</span></tt>
can be implicitly converted to <tt class="docutils literal"><span class="pre">Base*</span></tt>.</p>
</div>
<div class="section">
<h1><a id="algorithms" name="algorithms">Algorithms</a></h1>
<p>Unfortunately it is not possible to use pointer containers with
mutating algorithms from the standard library. However,
the most useful ones
are instead provided as member functions:</p>
<pre class="literal-block">
boost::ptr_vector&lt;animal&gt; zoo;
...
zoo.sort();                               // assume 'bool operator&lt;( const animal&amp;, const animal&amp; )'
zoo.sort( std::less&lt;animal&gt;() );          // the same, notice no '*' is present
zoo.sort( zoo.begin(), zoo.begin() + 5 ); // sort selected range
</pre>
<p>Notice that predicates are automatically wrapped in an <a class="reference" href="indirect_fun.html">indirect_fun</a> object.</p>
<p>You can remove equal and adjacent elements using <tt class="docutils literal"><span class="pre">unique()</span></tt>:</p>
<pre class="literal-block">
zoo.unique();                             // assume 'bool operator==( const animal&amp;, const animal&amp; )'
zoo.unique( zoo.begin(), zoo.begin() + 5, my_comparison_predicate() ); 
</pre>
<p>If you just want to remove certain elements, use <tt class="docutils literal"><span class="pre">erase_if</span></tt>:</p>
<pre class="literal-block">
zoo.erase_if( my_predicate() );
</pre>
<p>Finally you may want to merge two sorted containers:</p>
<pre class="literal-block">
boost::ptr_vector&lt;animal&gt; another_zoo = ...;
another_zoo.sort();                      // sorted wrt. to same order as 'zoo'
zoo.merge( another_zoo );
BOOST_ASSERT( another_zoo.empty() );    
</pre>
<p>That is all; now you have learned all the basics!</p>
<hr><p><strong>See also</strong></p>
<ul class="simple">
<li><a class="reference" href="guidelines.html">Usage guidelines</a></li>
<li><a class="reference" href="../../conversion/cast.htm#Polymorphic_castl">Cast utilities</a></li>
</ul>
<p><strong>Navigate</strong></p>
<ul class="simple">
<li><a class="reference" href="ptr_container.html">home</a></li>
<li><a class="reference" href="examples.html">examples</a></li>
</ul>
<hr><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Copyright:</th><td class="field-body">Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see <a class="reference" href="http://www.boost.org/LICENSE_1_0.txt">LICENSE_1_0.txt</a>).</td>
</tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
