<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" />
<title>Boost Pointer Container Library</title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2007-11-25 10:38:02 -0800 (Sun, 25 Nov 2007) $
:Revision: $Revision: 41370 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* "! important" is used here to override other ``margin-top`` and
   ``margin-bottom`` styles that are later in the stylesheet or 
   more specific.  See http://www.w3.org/TR/CSS1#the-cascade */
.first {
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

img.borderless {
  border: 0 }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid thin gray }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid thin black }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="boost-pointer-container-library">
<h1 class="title"><img alt="Boost" src="boost.png" /> Pointer Container Library</h1>
<h2 class="subtitle" id="faq">FAQ</h2>
<div class="contents local topic">
<ul class="simple">
<li><a class="reference" href="#calling-assign-is-very-costly-and-i-do-not-really-need-to-store-cloned-objects-i-merely-need-to-overwrite-the-existing-ones-what-do-i-do" id="id5" name="id5">Calling <tt class="docutils literal"><span class="pre">assign()</span></tt> is very costly and I do not really need to store cloned objects; I merely need to overwrite the existing ones; what do I do?</a></li>
<li><a class="reference" href="#which-mutating-algorithms-are-safe-to-use-with-pointers" id="id6" name="id6">Which mutating algorithms are safe to use with pointers?</a></li>
<li><a class="reference" href="#why-does-ptr-map-t-insert-replace-take-two-arguments-the-key-and-the-pointer-instead-of-one-std-pair-and-why-is-the-key-passed-by-non-const-reference" id="id7" name="id7">Why does <tt class="docutils literal"><span class="pre">ptr_map&lt;T&gt;::insert()/replace()</span></tt> take two arguments (the key and the pointer) instead of one <tt class="docutils literal"><span class="pre">std::pair</span></tt>? And why is the key passed by non-const reference?</a></li>
<li><a class="reference" href="#when-instantiating-a-pointer-container-with-a-type-t-is-t-then-allowed-to-be-incomplete-at-that-point" id="id8" name="id8">When instantiating a pointer container with a type <tt class="docutils literal"><span class="pre">T</span></tt>, is <tt class="docutils literal"><span class="pre">T</span></tt> then allowed to be incomplete at that point?</a></li>
<li><a class="reference" href="#why-do-iterator-range-inserts-give-the-strong-exception-safety-guarantee" id="id9" name="id9">Why do iterator-range inserts give the strong exception-safety guarantee?</a></li>
<li><a class="reference" href="#what-is-the-polymorphic-class-problem" id="id10" name="id10">What is the polymorphic class problem?</a></li>
<li><a class="reference" href="#are-the-pointer-containers-faster-and-do-they-have-a-better-memory-footprint-than-a-container-of-smart-pointers" id="id11" name="id11">Are the pointer containers faster and do they have a better memory  footprint than a container of smart pointers?</a></li>
<li><a class="reference" href="#when-the-stored-pointers-cannot-be-0-how-do-i-allow-this-empty-behavior-anyway" id="id12" name="id12">When the stored pointers cannot be <tt class="docutils literal"><span class="pre">0</span></tt>, how do I allow this &quot;empty&quot; behavior anyway?</a></li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id5" id="calling-assign-is-very-costly-and-i-do-not-really-need-to-store-cloned-objects-i-merely-need-to-overwrite-the-existing-ones-what-do-i-do" name="calling-assign-is-very-costly-and-i-do-not-really-need-to-store-cloned-objects-i-merely-need-to-overwrite-the-existing-ones-what-do-i-do">Calling <tt class="docutils literal docutils literal"><span class="pre">assign()</span></tt> is very costly and I do not really need to store cloned objects; I merely need to overwrite the existing ones; what do I do?</a></h1>
<p>Call <tt class="docutils literal"><span class="pre">std::copy(</span> <span class="pre">first,</span> <span class="pre">last,</span> <span class="pre">c.begin()</span> <span class="pre">);</span></tt>.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id6" id="which-mutating-algorithms-are-safe-to-use-with-pointers" name="which-mutating-algorithms-are-safe-to-use-with-pointers">Which mutating algorithms are safe to use with pointers?</a></h1>
<p>Any mutating algorithm that moves elements around by swapping them.  An 
important example is <tt class="docutils literal"><span class="pre">std::sort()</span></tt>; examples of unsafe algorithms are 
<tt class="docutils literal"><span class="pre">std::unique()</span></tt> and <tt class="docutils literal"><span class="pre">std::remove()</span></tt>.</p>
<!-- That is why these algorithms are 
provided as member functions.   -->
</div>
<div class="section">
<h1><a class="toc-backref" href="#id7" id="why-does-ptr-map-t-insert-replace-take-two-arguments-the-key-and-the-pointer-instead-of-one-std-pair-and-why-is-the-key-passed-by-non-const-reference" name="why-does-ptr-map-t-insert-replace-take-two-arguments-the-key-and-the-pointer-instead-of-one-std-pair-and-why-is-the-key-passed-by-non-const-reference">Why does <tt class="docutils literal docutils literal"><span class="pre">ptr_map&lt;T&gt;::insert()/replace()</span></tt> take two arguments (the key and the pointer) instead of one <tt class="docutils literal docutils literal"><span class="pre">std::pair</span></tt>? And why is the key passed by non-const reference?</a></h1>
<p>This is the only way the function can be implemented in an exception-safe 
manner; since the copy-constructor of the key might throw, and since 
function arguments are not guaranteed to be evaluated from left to right, 
we need to ensure that evaluating the first argument does not throw.  
Passing the key as a reference achieves just that.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id8" id="when-instantiating-a-pointer-container-with-a-type-t-is-t-then-allowed-to-be-incomplete-at-that-point" name="when-instantiating-a-pointer-container-with-a-type-t-is-t-then-allowed-to-be-incomplete-at-that-point">When instantiating a pointer container with a type <tt class="docutils literal docutils literal"><span class="pre">T</span></tt>, is <tt class="docutils literal docutils literal"><span class="pre">T</span></tt> then allowed to be incomplete at that point?</a></h1>
<p>No. This is a distinct property of <tt class="docutils literal"><span class="pre">shared_ptr</span></tt> which implies some overhead.</p>
<p>However, one can leave <tt class="docutils literal"><span class="pre">T</span></tt> incomplete in the header file:</p>
<pre class="literal-block">
// foo.hpp
class Foo { ... };
new_clone( const Foo&amp; ) { ... }
delete_clone( const Foo* )     { ... }

// x.hpp
class Foo; // Foo is incomplete here
class X { ptr_deque&lt;Foo&gt; container; ... }

// x.cpp
#include &lt;x.hpp&gt;
#include &lt;foo.hpp&gt; // now Foo is not incomplete anymore
...
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id9" id="why-do-iterator-range-inserts-give-the-strong-exception-safety-guarantee" name="why-do-iterator-range-inserts-give-the-strong-exception-safety-guarantee">Why do iterator-range inserts give the strong exception-safety guarantee?</a></h1>
<p>Is this not very inefficient?  It is because it is actually affordable to 
do so; the overhead is one heap-allocation which is relatively small 
compared to cloning N objects.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id10" id="what-is-the-polymorphic-class-problem" name="what-is-the-polymorphic-class-problem">What is the <span class="target" id="polymorphic-class-problem">polymorphic class problem</span>?</a></h1>
<p>The problem refers to the relatively troublesome way C++ supports Object 
Oriented programming in connection with containers of pointers to 
polymorphic objects.  In a language without garbage collection, you end up 
using either a container of smart pointers or a container that takes 
ownership of the pointers.  The hard part is to find a safe, fast and 
elegant solution.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id11" id="are-the-pointer-containers-faster-and-do-they-have-a-better-memory-footprint-than-a-container-of-smart-pointers" name="are-the-pointer-containers-faster-and-do-they-have-a-better-memory-footprint-than-a-container-of-smart-pointers">Are the pointer containers faster and do they have a better memory  footprint than a container of smart pointers?</a></h1>
<p>The short answer is yes: they are faster and they do use less memory; in 
fact, they are the only way to obtain the zero-overhead hallmark of C++.  
Smart pointers usually have one word or more of memory overhead per 
pointer because a reference count must be maintained.  And since the 
reference count must be maintained, there is also a runtime-overhead.  If 
your objects are big, then the memory overhead is often negligible, but if 
you have many small objects, it is not.  Further reading can be found in 
these references: <a class="reference" href="ptr_container.html#references">[11]</a> and <a class="reference" href="ptr_container.html#references">[12]</a>.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id12" id="when-the-stored-pointers-cannot-be-0-how-do-i-allow-this-empty-behavior-anyway" name="when-the-stored-pointers-cannot-be-0-how-do-i-allow-this-empty-behavior-anyway">When the stored pointers cannot be <tt class="docutils literal docutils literal"><span class="pre">0</span></tt>, how do I allow this &quot;empty&quot; behavior anyway?</a></h1>
<p>Storing a null-pointer among a list of pointers does not fit well into the Object Oriented paradigm. 
The most elegant design is to use the Null-Object Pattern where one basically makes a concrete
class with dummy implementations of the virtual functions. See <a class="reference" href="ptr_container.html#references">[13]</a> for details.</p>
<hr><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Copyright:</th><td class="field-body">Thorsten Ottosen 2004-2006. Use, modification and distribution is subject to the Boost Software License, Version 1.0 (see <a class="reference" href="http://www.boost.org/LICENSE_1_0.txt">LICENSE_1_0.txt</a>).</td>
</tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
