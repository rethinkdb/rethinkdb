<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;11.&nbsp; Functional programming</title><link rel="stylesheet" href="boostbook.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="index.html" title="Meta State Machine (MSM)"><link rel="up" href="pt02.html" title="Part&nbsp;II.&nbsp;Reference"><link rel="prev" href="ch10.html" title="Chapter&nbsp;10.&nbsp;eUML operators and basic helpers"><link rel="next" href="re01.html" title="Common headers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;11.&nbsp;
                Functional programming </th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch10.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;II.&nbsp;Reference</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="re01.html">Next</a></td></tr></table><hr></div><div class="chapter" title="Chapter&nbsp;11.&nbsp; Functional programming"><div class="titlepage"><div><div><h2 class="title"><a name="d0e4014"></a>Chapter&nbsp;11.&nbsp;
                <span class="command"><strong><a name="eUML-STL-all"></a></strong></span>Functional programming </h2></div></div></div><p>To use these functions, you need to include: </p><p><code class="code">#include &lt;msm/front/euml/stl.hpp&gt;</code></p><p>or the specified header in the following tables.</p><p>The following tables list the supported STL algorithms: </p><p>
                <span class="command"><strong><a name="eUML-STL-querying"></a></strong></span>
                </p><div class="table"><a name="d0e4032"></a><p class="title"><b>Table&nbsp;11.1.&nbsp;STL algorithms</b></p><div class="table-contents"><table summary="STL algorithms" border="1"><colgroup><col><col></colgroup><thead><tr><th>STL algorithms in querying.hpp</th><th>Functor</th></tr></thead><tbody><tr><td>find_(first, last, value)</td><td>Find_</td></tr><tr><td>find_if_(first, last, value)</td><td>FindIf_</td></tr><tr><td>lower_bound_(first, last, value [,op&#7491;])</td><td>LowerBound_</td></tr><tr><td>upper_bound_(first, last, value [,op&#7491;])</td><td>UpperBound_</td></tr><tr><td>equal_range_(first, last, value [,op&#7491;])</td><td>EqualRange_</td></tr><tr><td>binary_search_(first, last, value [,op&#7491;])</td><td>BinarySearch_</td></tr><tr><td>min_element_(first, last[,op&#7491;])</td><td>MinElement_</td></tr><tr><td>max_element_(first, last[,op&#7491;])</td><td>MaxElement_</td></tr><tr><td>adjacent_find_(first, last[,op&#7491;])</td><td>AdjacentFind_</td></tr><tr><td>find_end_( first1, last1, first2, last2 [,op &#7491;])</td><td>FindEnd_</td></tr><tr><td>find_first_of_( first1, last1, first2, last2 [,op &#7491;])</td><td>FindFirstOf_</td></tr><tr><td>equal_( first1, last1, first2 [,op &#7491;])</td><td>Equal_</td></tr><tr><td>search_( first1, last1, first2, last2 [,op &#7491;])</td><td>Search_</td></tr><tr><td>includes_( first1, last1, first2, last2 [,op &#7491;])</td><td>Includes_</td></tr><tr><td>lexicographical_compare_ ( first1, last1, first2, last2 [,op
                                    &#7491;]) </td><td>LexicographicalCompare_</td></tr><tr><td>count_(first, last, value [,size])</td><td>Count_</td></tr><tr><td>count_if_(first, last, op &#7491; [,size])</td><td>CountIf_</td></tr><tr><td>distance_(first, last)</td><td>Distance_</td></tr><tr><td>mismatch _( first1, last1, first2 [,op &#7491;])</td><td>Mismatch_</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p>
                <span class="command"><strong><a name="eUML-STL-iteration"></a></strong></span>
                </p><div class="table"><a name="d0e4145"></a><p class="title"><b>Table&nbsp;11.2.&nbsp;STL algorithms</b></p><div class="table-contents"><table summary="STL algorithms" border="1"><colgroup><col><col></colgroup><thead><tr><th>STL algorithms in iteration.hpp</th><th>Functor</th></tr></thead><tbody><tr><td>for_each_(first,last, unary op&#7491;)</td><td>ForEach_</td></tr><tr><td>accumulate_first, last, init [,op&#7491;])</td><td>Accumulate_</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p>
                <span class="command"><strong><a name="eUML-STL-transformation"></a></strong></span>
                </p><div class="table"><a name="d0e4173"></a><p class="title"><b>Table&nbsp;11.3.&nbsp;STL algorithms</b></p><div class="table-contents"><table summary="STL algorithms" border="1"><colgroup><col><col></colgroup><thead><tr><th>STL algorithms in transformation.hpp</th><th>Functor</th></tr></thead><tbody><tr><td>copy_(first, last, result)</td><td>Copy_</td></tr><tr><td>copy_backward_(first, last, result)</td><td>CopyBackward_</td></tr><tr><td>reverse_(first, last)</td><td>Reverse_</td></tr><tr><td>reverse_copy_(first, last , result)</td><td>ReverseCopy_</td></tr><tr><td>remove_(first, last, value)</td><td>Remove_</td></tr><tr><td>remove_if_(first, last , op&#7491;)</td><td>RemoveIf_</td></tr><tr><td>remove_copy_(first, last , output, value)</td><td>RemoveCopy_</td></tr><tr><td>remove_copy_if_(first, last, output, op&#7491;)</td><td>RemoveCopyIf_</td></tr><tr><td>fill_(first, last, value)</td><td>Fill_</td></tr><tr><td>fill_n_(first, size, value)&#7495;</td><td>FillN_</td></tr><tr><td>generate_(first, last, generator&#7491;)</td><td>Generate_</td></tr><tr><td>generate_(first, size, generator&#7491;)&#7495;</td><td>GenerateN_</td></tr><tr><td>unique_(first, last [,op&#7491;])</td><td>Unique_</td></tr><tr><td>unique_copy_(first, last, output [,op&#7491;])</td><td>UniqueCopy_</td></tr><tr><td>random_shuffle_(first, last [,op&#7491;])</td><td>RandomShuffle_</td></tr><tr><td>rotate_copy_(first, middle, last, output)</td><td>RotateCopy_</td></tr><tr><td>partition_ (first, last [,op&#7491;])</td><td>Partition_</td></tr><tr><td>stable_partition_ (first, last [,op&#7491;])</td><td>StablePartition_</td></tr><tr><td>stable_sort_(first, last [,op&#7491;])</td><td>StableSort_</td></tr><tr><td>sort_(first, last [,op&#7491;])</td><td>Sort_</td></tr><tr><td>partial_sort_(first, middle, last [,op&#7491;])</td><td>PartialSort_</td></tr><tr><td>partial_sort_copy_ (first, last, res_first, res_last [,op&#7491;]) </td><td>PartialSortCopy_</td></tr><tr><td>nth_element_(first, nth, last [,op&#7491;])</td><td>NthElement_</td></tr><tr><td>merge_( first1, last1, first2, last2, output [,op &#7491;])</td><td>Merge_</td></tr><tr><td>inplace_merge_(first, middle, last [,op&#7491;])</td><td>InplaceMerge_</td></tr><tr><td>set_union_(first1, last1, first2, last2, output [,op
                                    &#7491;])</td><td>SetUnion_</td></tr><tr><td>push_heap_(first, last [,op &#7491;])</td><td>PushHeap_</td></tr><tr><td>pop_heap_(first, last [,op &#7491;])</td><td>PopHeap_</td></tr><tr><td>make_heap_(first, last [,op &#7491;])</td><td>MakeHeap_</td></tr><tr><td>sort_heap_(first, last [,op &#7491;])</td><td>SortHeap_</td></tr><tr><td>next_permutation_(first, last [,op &#7491;])</td><td>NextPermutation_</td></tr><tr><td>prev_permutation_(first, last [,op &#7491;])</td><td>PrevPermutation_</td></tr><tr><td>inner_product_(first1, last1, first2, init [,op1&#7491;] [,op2&#7491;]) </td><td>InnerProduct_</td></tr><tr><td>partial_sum_(first, last, output [,op&#7491;])</td><td>PartialSum_</td></tr><tr><td>adjacent_difference_(first, last, output [,op&#7491;])</td><td>AdjacentDifference_</td></tr><tr><td>replace_(first, last, old_value, new_value)</td><td>Replace_</td></tr><tr><td>replace_if_(first, last, op&#7491;, new_value)</td><td>ReplaceIf_</td></tr><tr><td>replace_copy_(first, last, result, old_value,
                                    new_value)</td><td>ReplaceCopy_</td></tr><tr><td>replace_copy_if_(first, last, result, op&#7491;, new_value)</td><td>ReplaceCopyIf_</td></tr><tr><td>rotate_(first, middle, last)&#7495;</td><td>Rotate_</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p>
                <span class="command"><strong><a name="eUML-STL-container"></a></strong></span>
                </p><div class="table"><a name="d0e4391"></a><p class="title"><b>Table&nbsp;11.4.&nbsp;STL container methods</b></p><div class="table-contents"><table summary="STL container methods" border="1"><colgroup><col><col></colgroup><thead><tr><th>STL container methods(common) in container.hpp</th><th>Functor</th></tr></thead><tbody><tr><td>container::reference front_(container)</td><td>Front_</td></tr><tr><td>container::reference back_(container)</td><td>Back_</td></tr><tr><td>container::iterator begin_(container)</td><td>Begin_</td></tr><tr><td>container::iterator end_(container)</td><td>End_</td></tr><tr><td>container::reverse_iterator rbegin_(container)</td><td>RBegin_</td></tr><tr><td>container::reverse_iterator rend_(container)</td><td>REnd_</td></tr><tr><td>void push_back_(container, value)</td><td>Push_Back_</td></tr><tr><td>void pop_back_(container, value)</td><td>Pop_Back_</td></tr><tr><td>void push_front_(container, value)</td><td>Push_Front_</td></tr><tr><td>void pop_front_(container, value)</td><td>Pop_Front_</td></tr><tr><td>void clear_(container)</td><td>Clear_</td></tr><tr><td>size_type capacity_(container)</td><td>Capacity_</td></tr><tr><td>size_type size_(container)</td><td>Size_</td></tr><tr><td>size_type max_size_(container)</td><td>Max_Size_</td></tr><tr><td>void reserve_(container, value)</td><td>Reserve _</td></tr><tr><td>void resize_(container, value)</td><td>Resize _</td></tr><tr><td>iterator insert_(container, pos, value)</td><td>Insert_</td></tr><tr><td>void insert_( container , pos, first, last)</td><td>Insert_</td></tr><tr><td>void insert_( container , pos, number, value)</td><td>Insert_</td></tr><tr><td>void swap_( container , other_container)</td><td>Swap_</td></tr><tr><td>void erase_( container , pos)</td><td>Erase_</td></tr><tr><td>void erase_( container , first, last) </td><td>Erase_</td></tr><tr><td>bool empty_( container)</td><td>Empty_</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p>
                </p><div class="table"><a name="d0e4522"></a><p class="title"><b>Table&nbsp;11.5.&nbsp;STL list methods</b></p><div class="table-contents"><table summary="STL list methods" border="1"><colgroup><col><col></colgroup><thead><tr><th>std::list methods in container.hpp</th><th>Functor</th></tr></thead><tbody><tr><td>void list_remove_(container, value)</td><td>ListRemove_</td></tr><tr><td>void list_remove_if_(container, op&#7491;)</td><td>ListRemove_If_</td></tr><tr><td>void list_merge_(container, other_list)</td><td>ListMerge_</td></tr><tr><td>void list_merge_(container, other_list, op&#7491;)</td><td>ListMerge_</td></tr><tr><td>void splice_(container, iterator, other_list)</td><td>Splice_</td></tr><tr><td>void splice_(container, iterator, other_list,
                                    iterator)</td><td>Splice_</td></tr><tr><td>void splice_(container, iterator, other_list, first,
                                    last)</td><td>Splice_</td></tr><tr><td>void list_reverse_(container)</td><td>ListReverse_</td></tr><tr><td>void list_unique_(container)</td><td>ListUnique_</td></tr><tr><td>void list_unique_(container, op&#7491;)</td><td>ListUnique_</td></tr><tr><td>void list_sort_(container)</td><td>ListSort_</td></tr><tr><td>void list_sort_(container, op&#7491;)</td><td>ListSort_</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p>
                </p><div class="table"><a name="d0e4598"></a><p class="title"><b>Table&nbsp;11.6.&nbsp;STL associative container methods </b></p><div class="table-contents"><table summary="STL associative container methods " border="1"><colgroup><col><col></colgroup><thead><tr><th>Associative container methods in container.hpp</th><th>Functor</th></tr></thead><tbody><tr><td>iterator insert_(container, pos, value)</td><td>Insert_</td></tr><tr><td>void insert_( container , first, last)</td><td>Insert_</td></tr><tr><td>pair&lt;iterator, bool&gt; insert_( container , value)</td><td>Insert_</td></tr><tr><td>void associative_erase_( container , pos)</td><td>Associative_Erase_</td></tr><tr><td>void associative_erase_( container , first, last)</td><td>Associative_Erase_</td></tr><tr><td>size_type associative_erase_( container , key)</td><td>Associative_Erase_</td></tr><tr><td>iterator associative_find_( container , key)</td><td>Associative_Find_</td></tr><tr><td>size_type associative_count_( container , key)</td><td>AssociativeCount_</td></tr><tr><td>iterator associative_lower_bound_( container , key)</td><td>Associative_Lower_Bound_</td></tr><tr><td>iterator associative_upper_bound_( container , key)</td><td>Associative_Upper_Bound_</td></tr><tr><td>pair&lt;iterator, iterator&gt; associative_equal_range_(
                                    container , key)</td><td>Associative_Equal_Range_</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p>
                </p><div class="table"><a name="d0e4669"></a><p class="title"><b>Table&nbsp;11.7.&nbsp;STL pair</b></p><div class="table-contents"><table summary="STL pair" border="1"><colgroup><col><col></colgroup><thead><tr><th>std::pair in container.hpp</th><th>Functor</th></tr></thead><tbody><tr><td>first_type first_(pair&lt;T1, T2&gt;)</td><td>First_</td></tr><tr><td>second_type second_(pair&lt;T1, T2&gt;)</td><td>Second_</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p>
                </p><div class="table"><a name="d0e4695"></a><p class="title"><b>Table&nbsp;11.8.&nbsp;STL string</b></p><div class="table-contents"><table summary="STL string" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>STL string method</th><th>std::string method in container.hpp</th><th>Functor</th></tr></thead><tbody><tr><td>substr (size_type pos, size_type size)</td><td>string substr_(container, pos, length)</td><td>Substr_</td></tr><tr><td>int compare(string)</td><td>int string_compare_(container, another_string)</td><td>StringCompare_</td></tr><tr><td>int compare(char*)</td><td>int string_compare_(container, another_string)</td><td>StringCompare_</td></tr><tr><td>int compare(size_type pos, size_type size, string)</td><td>int string_compare_(container, pos, size,
                                    another_string)</td><td>StringCompare_</td></tr><tr><td>int compare (size_type pos, size_type size, string, size_type
                                    length)</td><td>int string_compare_(container, pos, size, another_string,
                                    length)</td><td>StringCompare_</td></tr><tr><td>string&amp; append(const string&amp;)</td><td>string&amp; append_(container, another_string)</td><td>Append_</td></tr><tr><td>string&amp; append (charT*)</td><td>string&amp; append_(container, another_string)</td><td>Append_</td></tr><tr><td>string&amp; append (string , size_type pos, size_type
                                    size)</td><td>string&amp; append_(container, other_string, pos,
                                    size)</td><td>Append_</td></tr><tr><td>string&amp; append (charT*, size_type size)</td><td>string&amp; append_(container, another_string,
                                    length)</td><td>Append_</td></tr><tr><td>string&amp; append (size_type size, charT)</td><td>string&amp; append_(container, size, char)</td><td>Append_</td></tr><tr><td>string&amp; append (iterator begin, iterator end)</td><td>string&amp; append_(container, begin, end)</td><td>Append_</td></tr><tr><td>string&amp; insert (size_type pos, charT*)</td><td>string&amp; string_insert_(container, pos,
                                    other_string)</td><td>StringInsert_</td></tr><tr><td>string&amp; insert(size_type pos, charT*,size_type n)</td><td>string&amp; string_insert_(container, pos, other_string,
                                    n)</td><td>StringInsert_</td></tr><tr><td>string&amp; insert(size_type pos,size_type n, charT
                                    c)</td><td>string&amp; string_insert_(container, pos, n, c)</td><td>StringInsert_</td></tr><tr><td>string&amp; insert (size_type pos, const string&amp;)</td><td>string&amp; string_insert_(container, pos,
                                    other_string)</td><td>StringInsert_</td></tr><tr><td>string&amp; insert (size_type pos, const string&amp;,
                                    size_type pos1, size_type n)</td><td>string&amp; string_insert_(container, pos, other_string,
                                    pos1, n)</td><td>StringInsert_</td></tr><tr><td>string&amp; erase(size_type pos=0, size_type n=npos)</td><td>string&amp; string_erase_(container, pos, n)</td><td>StringErase_</td></tr><tr><td>string&amp; assign(const string&amp;)</td><td>string&amp; string_assign_(container, another_string)</td><td>StringAssign_</td></tr><tr><td>string&amp; assign(const charT*)</td><td>string&amp; string_assign_(container, another_string)</td><td>StringAssign_</td></tr><tr><td>string&amp; assign(const string&amp;, size_type pos,
                                    size_type n)</td><td>string&amp; string_assign_(container, another_string, pos,
                                    n)</td><td>StringAssign_</td></tr><tr><td>string&amp; assign(const charT*, size_type n)</td><td>string&amp; string_assign_(container, another_string,
                                    n)</td><td>StringAssign_</td></tr><tr><td>string&amp; assign(size_type n, charT c)</td><td>string&amp; string_assign_(container, n, c)</td><td>StringAssign_</td></tr><tr><td>string&amp; assign(iterator first, iterator last)</td><td>string&amp; string_assign_(container, first, last)</td><td>StringAssign_</td></tr><tr><td>string&amp; replace(size_type pos, size_type n, const
                                    string&amp;)</td><td>string&amp; string_replace_(container, pos, n,
                                    another_string)</td><td>StringReplace_</td></tr><tr><td>string&amp; replace(size_type pos, size_type n, const charT*,
                                    size_type n1)</td><td>string&amp; string_replace_(container, pos, n,
                                    another_string, n1)</td><td>StringReplace_</td></tr><tr><td>string&amp; replace(size_type pos, size_type n, const
                                    charT*)</td><td>string&amp; string_replace_(container, pos, n,
                                    another_string)</td><td>StringReplace_</td></tr><tr><td>string&amp; replace(size_type pos, size_type n, size_type n1,
                                    charT c)</td><td>string&amp; string_replace_(container, pos, n, n1, c)</td><td>StringReplace_</td></tr><tr><td>string&amp; replace(iterator first, iterator last, const
                                    string&amp;)</td><td>string&amp; string_replace_(container, first, last,
                                    another_string)</td><td>StringReplace_</td></tr><tr><td>string&amp; replace(iterator first, iterator last, const
                                    charT*, size_type n)</td><td>string&amp; string_replace_(container, first, last,
                                    another_string, n)</td><td>StringReplace_</td></tr><tr><td>string&amp; replace(iterator first, iterator last, const
                                    charT*)</td><td>string&amp; string_replace_(container, first, last,
                                    another_string)</td><td>StringReplace_</td></tr><tr><td>string&amp; replace(iterator first, iterator last, size_type
                                    n, charT c)</td><td>string&amp; string_replace_(container, first, last, n,
                                    c)</td><td>StringReplace_</td></tr><tr><td>string&amp; replace(iterator first, iterator last, iterator
                                    f, iterator l)</td><td>string&amp; string_replace_(container, first, last, f,
                                    l)</td><td>StringReplace_</td></tr><tr><td>const charT* c_str()</td><td>const charT* c_str_(container)</td><td>CStr_</td></tr><tr><td>const charT* data()</td><td>const charT* string_data_(container)</td><td>StringData_</td></tr><tr><td>size_type copy(charT* buf, size_type n, size_type pos =
                                    0)</td><td>size_type string_copy_(container, buf, n, pos); size_type
                                    string_copy_(container, buf, n) </td><td>StringCopy_</td></tr><tr><td>size_type find(charT* s, size_type pos, size_type n)</td><td>size_type string_find_(container, s, pos, n)</td><td>StringFind_</td></tr><tr><td>size_type find(charT* s, size_type pos=0)</td><td>size_type string_find_(container, s, pos); size_type
                                    string_find_(container, s) </td><td>StringFind_</td></tr><tr><td>size_type find(const string&amp; s, size_type pos=0)</td><td>size_type string_find_(container, s, pos) size_type
                                    string_find_(container, s) </td><td>StringFind_</td></tr><tr><td>size_type find(charT c, size_type pos=0)</td><td>size_type string_find_(container, c, pos) size_type
                                    string_find_(container, c) </td><td>StringFind_</td></tr><tr><td>size_type rfind(charT* s, size_type pos, size_type n)</td><td>size_type string_rfind_(container, s, pos, n)</td><td>StringRFind_</td></tr><tr><td>size_type rfind(charT* s, size_type pos=npos)</td><td>size_type string_rfind_(container, s, pos); size_type
                                    string_rfind_(container, s) </td><td>StringRFind_</td></tr><tr><td>size_type rfind(const string&amp; s, size_type
                                    pos=npos)</td><td>size_type string_rfind_(container, s, pos); size_type
                                    string_rfind_(container, s) </td><td>StringRFind_</td></tr><tr><td>size_type rfind(charT c, size_type pos=npos)</td><td>size_type string_rfind_(container, c, pos) size_type
                                    string_rfind_(container, c) </td><td>StringRFind_</td></tr><tr><td>size_type find_first_of(charT* s, size_type pos, size_type
                                    n)</td><td>size_type find_first_of_(container, s, pos, n)</td><td>StringFindFirstOf_</td></tr><tr><td>size_type find_first_of (charT* s, size_type pos=0)</td><td>size_type find_first_of_(container, s, pos); size_type
                                    find_first_of_(container, s) </td><td>StringFindFirstOf_</td></tr><tr><td>size_type find_first_of (const string&amp; s, size_type
                                    pos=0)</td><td>size_type find_first_of_(container, s, pos); size_type
                                    find_first_of_(container, s) </td><td>StringFindFirstOf_</td></tr><tr><td>size_type find_first_of (charT c, size_type pos=0)</td><td>size_type find_first_of_(container, c, pos) size_type
                                    find_first_of_(container, c) </td><td>StringFindFirstOf_</td></tr><tr><td>size_type find_first_not_of(charT* s, size_type pos,
                                    size_type n)</td><td>size_type find_first_not_of_(container, s, pos, n)</td><td>StringFindFirstNotOf_</td></tr><tr><td>size_type find_first_not_of (charT* s, size_type
                                    pos=0)</td><td>size_type find_first_not_of_(container, s, pos); size_type
                                    find_first_not_of_(container, s) </td><td>StringFindFirstNotOf_</td></tr><tr><td>size_type find_first_not_of (const string&amp; s, size_type
                                    pos=0)</td><td>size_type find_first_not_of_(container, s, pos); size_type
                                    find_first_not_of_(container, s) </td><td>StringFindFirstNotOf_</td></tr><tr><td>size_type find_first_not_of (charT c, size_type
                                    pos=0)</td><td>size_type find_first_not_of_(container, c, pos); size_type
                                    find_first_not_of_(container, c) </td><td>StringFindFirstNotOf_</td></tr><tr><td>size_type find_last_of(charT* s, size_type pos, size_type
                                    n)</td><td>size_type find_last_of_(container, s, pos, n)</td><td>StringFindLastOf_</td></tr><tr><td>size_type find_last_of (charT* s, size_type pos=npos)</td><td>size_type find_last_of_(container, s, pos); size_type
                                    find_last_of_(container, s) </td><td>StringFindLastOf_</td></tr><tr><td>size_type find_last_of (const string&amp; s, size_type
                                    pos=npos)</td><td>size_type find_last_of_(container, s, pos); size_type
                                    find_last_of_(container, s) </td><td>StringFindLastOf_</td></tr><tr><td>size_type find_last_of (charT c, size_type pos=npos)</td><td>size_type find_last_of_(container, c, pos); size_type
                                    find_last_of_(container, c) </td><td>StringFindLastOf_</td></tr><tr><td>size_type find_last_not_of(charT* s, size_type pos, size_type
                                    n)</td><td>size_type find_last_not_of_(container, s, pos, n)</td><td>StringFindLastNotOf_</td></tr><tr><td>size_type find_last_not_of (charT* s, size_type
                                    pos=npos)</td><td>size_type find_last_not_of_(container, s, pos); size_type
                                    find_last_of_(container, s) </td><td>StringFindLastNotOf_</td></tr><tr><td>size_type find_last_not_of (const string&amp; s, size_type
                                    pos=npos)</td><td>size_type find_last_not_of_(container, s, pos); size_type
                                    find_last_not_of_(container, s) </td><td>StringFindLastNotOf_</td></tr><tr><td>size_type find_last_not_of (charT c, size_type
                                    pos=npos)</td><td>size_type find_last_not_of_(container, c, pos); size_type
                                    find_last_not_of_(container, c) </td><td>StringFindLastNotOf_</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p><span class="underline">Notes</span>: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>&#7491;: algorithms requiring a predicate need to make them eUML compatible
                            by wrapping them inside a Predicate_ functor. For example,
                            std::less&lt;int&gt; =&gt; Predicate_&lt;std::less&lt;int&gt; &gt;()</p></li><li class="listitem"><p>&#7495;: If using the SGI STL implementation, these functors use the SGI
                            return value</p></li></ul></div><p>
            </p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch10.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="pt02.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="re01.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;10.&nbsp;eUML operators and basic helpers&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Common headers</td></tr></table></div></body></html>