[/ 
  (C) Copyright Edward Diener 2011,2012
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:tti_detail Macro Metafunctions]

The TTI library uses macros to create metafunctions, in the current scope, 
for introspecting an inner element by name. Each macro for a particular type of inner 
element has two forms, the simple one where the first macro parameter designating the 
'name' of the inner element is used to create the name of the metafunction, and the 
complex one where the first macro parameter, called 'trait', designates 
the name of the metafunction and the second macro parameter designates the 'name' to be 
introspected. Other than that difference, the two forms of the macro create metafunctions
which have the exact same functionality.

To use these metafunctions you can include the main general header file 'boost/tti/tti.hpp',
unless otherwise noted. Alternatively you can include a specific header file as 
given in the table below.

A table of these macros is given, based on the inner element whose 
existence the metaprogrammer is introspecting. More detailed explanations  
and examples for each of the macro metafunctions will follow this 
section in the documentation. The actual syntax for each macro metafunction
can be found in the reference section, and examples of usage for all the 
macro metafunctions can be found in the 
[link sectti_usingMM "Using the Macro Metafunctions"] section.

In the Template column only the name generated by the simple form 
of the template is given since the name generated by the complex form is always 'trait'
where 'trait' is the first parameter to the corresponding complex form macro. 

All of the introspecting metafunctions in the table below return a boolean constant 
called 'value', which specifies whether or not the inner element exists. All of the 
metafunctions also have a nested type called 'type', which for each one is the type 
of the boolean constant value. This is always boost::mpl::bool_.

[table:tbmacros TTI Macro Metafunctions
  [
    [Inner Element]
    [Macro]
    [Template]
    [Specific Header File]
  ]
  [
    [Type]
    [
    [macroref BOOST_TTI_HAS_TYPE](name)
    ]
    [
    `has_type_'name'`
    
    class TTI_T = enclosing type
    ]
    [[headerref boost/tti/has_type.hpp `has_type.hpp`]]
  ]
  [
    [Type with lambda expression]
    [
    [macroref BOOST_TTI_HAS_TYPE](name)
    ]
    [
    `has_type_'name'`
    
    class TTI_T = enclosing type
    
    class TTI_U = lambda expression invoked with the inner type and returning a boolean constant
    ]
    [[headerref boost/tti/has_type.hpp `has_type.hpp`]]
  ]
  [
    [Class Template ( using variadic macros )]
    [
    [macroref BOOST_TTI_HAS_TEMPLATE](name)
    ]
    [
    `has_template_'name'`
    
    class TTI_T = enclosing type
    
    All of the template parameters must be template type parameters ( 'class' or 'typename' parameters )
    ]
    [[headerref boost/tti/has_template.hpp `has_template.hpp`]]
  ]
  [
    [Class Template ( not using variadic macros )]
    [
    [macroref BOOST_TTI_HAS_TEMPLATE](name,BOOST_PP_NIL)
    ]
    [
    `has_template_'name'`
    
    class TTI_T = enclosing type
    
    All of the template parameters must be template type parameters ( 'class' or 'typename' parameters )
    ]
    [[headerref boost/tti/has_template.hpp `has_template.hpp`]]
  ]
  [
    [Class Template with params ( using variadic macros )]
    [
    [macroref BOOST_TTI_HAS_TEMPLATE](name,...[footnote The template parameters as variadic data.])
    ]
    [
    `has_template_'name'`
    
    class TTI_T = enclosing type
    ]
    [[headerref boost/tti/has_template.hpp `has_template.hpp`]]
  ]
  [
    [Class Template with params]
    [
    [macroref BOOST_TTI_HAS_TEMPLATE](name,ppArray[footnote The template parameters as the tuple part of the PP array.])
    ]
    [
    `has_template_'name'`
    
    class TTI_T = enclosing type
    ]
    [[headerref boost/tti/has_template.hpp `has_template.hpp`]]
  ]
  [
    [Member data]
    [
    [macroref BOOST_TTI_HAS_MEMBER_DATA](name)
    ]
    [
    `has_member_data_'name'`
    
    class TTI_T = enclosing type 
                      OR 
                  pointer to member data ( 'MemberData_Type Enclosing_Type::*' )
    
    class TTI_R = (optional) data type
                  If the first parameter is the pointer to member data this must not be specified.
    ]
    [[headerref boost/tti/has_member_data.hpp `has_member_data.hpp`]]
  ]
  [
    [Member function]
    [
    [macroref BOOST_TTI_HAS_MEMBER_FUNCTION](name)
    ]
    [
    `has_member_function_'name'`
    
    class TTI_T   = enclosing type 
                        OR 
                    pointer to member function 
                    ( 'Return_Type Enclosing_Type::* ( Zero or more comma-separated parameter types )' )
    
    class TTI_R   = (optional) return type if the first parameter is the enclosing type.
                    If the first parameter is the pointer to member function this must not be specified.
    
    class TTI_FS  = (optional) function parameter types as a Boost MPL forward sequence.
                    If the first parameter is the pointer to member function this must not be specified.
                    If there are no function parameters this does not have to be specified.
                    Defaults to boost::mpl::vector<>.
    
    class TTI_TAG = (optional) Boost `function_types` tag type.
                    If the first parameter is the pointer to member function this must not be specified.
                    Defaults to `boost::function_types::null_tag`.
    ]
    [[headerref boost/tti/has_member_function.hpp `has_member_function.hpp`]]
  ]
  [
    [Static member data]
    [
    [macroref BOOST_TTI_HAS_STATIC_MEMBER_DATA](name)
    ]
    [
    `has_static_member_data_'name'`
    
    class TTI_T = enclosing type
    
    class TTI_Type = data type
    ]
    [[headerref boost/tti/has_static_member_data.hpp `has_static_member_data.hpp`]]
  ]
  [
    [Static member function]
    [
    [macroref BOOST_TTI_HAS_STATIC_MEMBER_FUNCTION](name)
    ]
    [
    `has_static_member_function_'name'`
    
    class TTI_T   = enclosing type
    
    class TTI_R   = return type 
                        OR 
                    function type ( 'Return_Type (Zero or more comma-separated parameter types)' )
    
    class TTI_FS  = (optional) function parameter types as a Boost MPL forward sequence.
                    If the second parameter is the function type this must not be specified.
                    If there are no function parameters, this does not have to be specified.
                    Defaults to boost::mpl::vector<>.
    
    class TTI_TAG = (optional) Boost `function_types` tag type.
                    If the second parameter is the function type this must not be specified.
                    Defaults to `boost::function_types::null_tag`.
    ]
    [[headerref boost/tti/has_static_member_function.hpp `has_static_member_function.hpp`]]
  ]
  [
    [Data, either member data or static member data]
    [
    [macroref BOOST_TTI_HAS_DATA](name)
    ]
    [
    `has_data_'name'`
    
    class TTI_T = enclosing type
    
    class TTI_Type = data type
    ]
    [[headerref boost/tti/has_data.hpp `has_data.hpp`]]
  ]
  [
    [Function, either member function or static member function]
    [
    [macroref BOOST_TTI_HAS_FUNCTION](name)
    ]
    [
    `has_function_'name'`
    
    class TTI_T   = enclosing type
    
    class TTI_R   = return type 
    
    class TTI_FS  = (optional) function parameter types as a Boost MPL forward sequence.
                    If there are no function parameters, this does not have to be specified.
                    Defaults to boost::mpl::vector<>.
    
    class TTI_TAG = (optional) Boost `function_types` tag type.
                    Defaults to `boost::function_types::null_tag`.
    ]
    [[headerref boost/tti/has_function.hpp `has_function.hpp`]]
  ]
]

[endsect]
