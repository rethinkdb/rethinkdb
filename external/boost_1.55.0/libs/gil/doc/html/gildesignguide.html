<!-- Copyright 2008 Lubomir Bourdev and Hailin Jin

     Distributed under the Boost Software License, Version 1.0.
     (See accompanying file LICENSE_1_0.txt or copy at
     http://www.boost.org/LICENSE_1_0.txt)
  -->

<!--
    Copyright 2005-2007 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
    <TITLE>Generic Image Library: Generic Image Library Design Guide</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
</head>
<body>
<table border="0" cellspacing="0" cellpadding="0" style='width: 100%; margin: 0; padding: 0'><tr>
<td width="100%" valign="top" style='padding-left: 10px; padding-right: 10px; padding-bottom: 10px'>
<div class="qindex"><a class="qindex" href="index.html">Modules</a> 
                  | <a class="qindex" href="classes.html">Alphabetical List</a> 
                  | <a class="qindex" href="annotated.html">Class List</a> 
                  | <a class="qindex" href="dirs.html">Directories</a> 
                  | <a class="qindex" href="files.html">File List</a> 
                  | <a class="qindex" href="../index.html">GIL Home Page</a> 
</div>
<!-- End Header -->
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1><a class="anchor" name="GILDesignGuide">Generic Image Library Design Guide </a></h1><dl class="author" compact><dt><b>Author:</b></dt><dd>Lubomir Bourdev (<a href="mailto:lbourdev@adobe.com">lbourdev@adobe.com</a>) and Hailin Jin (<a href="mailto:hljin@adobe.com">hljin@adobe.com</a>) <br>
 Adobe Systems Incorporated </dd></dl>
<dl class="version" compact><dt><b>Version:</b></dt><dd>2.1 </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>September 15, 2007</dd></dl>
<p>
This document describes the design of the Generic Image Library, a C++ image-processing library that abstracts image representation from algorithms on images. It covers more than you need to know for a causal use of GIL. You can find a quick, jump-start GIL tutorial on the main GIL page at <a href="http://stlab.adobe.com/gil">http://stlab.adobe.com/gil</a><p>
<ul>
<li><a class="el" href="gildesignguide.html#OverviewSectionDG">1. Overview</a></li><li><a class="el" href="gildesignguide.html#ConceptsSectionDG">2. About Concepts</a></li><li><a class="el" href="gildesignguide.html#PointSectionDG">3. Point</a></li><li><a class="el" href="gildesignguide.html#ChannelSectionDG">4. Channel</a></li><li><a class="el" href="gildesignguide.html#ColorSpaceSectionDG">5. Color Space and Layout</a></li><li><a class="el" href="gildesignguide.html#ColorBaseSectionDG">6. Color Base</a></li><li><a class="el" href="gildesignguide.html#PixelSectionDG">7. Pixel</a></li><li><a class="el" href="gildesignguide.html#PixelIteratorSectionDG">8. Pixel Iterator</a><ul>
<li><a class="el" href="gildesignguide.html#FundamentalIteratorDG">Fundamental Iterator</a></li><li><a class="el" href="gildesignguide.html#IteratorAdaptorDG">Iterator Adaptor</a></li><li><a class="el" href="gildesignguide.html#PixelDereferenceAdaptorAG">Pixel Dereference Adaptor</a></li><li><a class="el" href="gildesignguide.html#StepIteratorDG">Step Iterator</a></li><li><a class="el" href="gildesignguide.html#LocatorDG">Pixel Locator</a></li><li><a class="el" href="gildesignguide.html#IteratorFrom2DDG">Iterator over 2D image</a></li></ul>
</li><li><a class="el" href="gildesignguide.html#ImageViewSectionDG">9. Image View</a><ul>
<li><a class="el" href="gildesignguide.html#ImageViewFrowRawDG">Creating Views from Raw Pixels</a></li><li><a class="el" href="gildesignguide.html#ImageViewFrowImageViewDG">Creating Image Views from Other Image Views</a></li></ul>
</li><li><a class="el" href="gildesignguide.html#ImageSectionDG">10. Image</a></li><li><a class="el" href="gildesignguide.html#VariantSecDG">11. Run-time specified images and image views</a></li><li><a class="el" href="gildesignguide.html#MetafunctionsDG">12. Useful Metafunctions and Typedefs</a></li><li><a class="el" href="gildesignguide.html#IO_DG">13. I/O Extension</a></li><li><a class="el" href="gildesignguide.html#SampleImgCodeDG">14. Sample Code</a><ul>
<li><a class="el" href="gildesignguide.html#PixelLevelExampleDG">Pixel-level Sample Code</a></li><li><a class="el" href="gildesignguide.html#SafeAreaExampleDG">Creating a Copy of an Image with a Safe Buffer</a></li><li><a class="el" href="gildesignguide.html#HistogramExampleDG">Histogram</a></li><li><a class="el" href="gildesignguide.html#ImageViewsExampleDG">Using Image Views</a></li></ul>
</li><li><a class="el" href="gildesignguide.html#ExtendingGIL_DG">15. Extending the Generic Image Library</a><ul>
<li><a class="el" href="gildesignguide.html#NewColorSpacesDG">Defining New Color Spaces</a></li><li><a class="el" href="gildesignguide.html#NewColorConversionDG">Overloading Color Conversion</a></li><li><a class="el" href="gildesignguide.html#NewChannelsDG">Defining New Channel Types</a></li><li><a class="el" href="gildesignguide.html#NewImagesDG">Defining New Image Views</a></li></ul>
</li><li><a class="el" href="gildesignguide.html#TechnicalitiesDG">16. Technicalities</a></li><li><a class="el" href="gildesignguide.html#ConclusionDG">17. Conclusion</a></li></ul>
<p>
<br>
 <hr>
 <h2><a class="anchor" name="OverviewSectionDG">
1. Overview</a></h2>
Images are essential in any image processing, vision and video project, and yet the variability in image representations makes it difficult to write imaging algorithms that are both generic and efficient. In this section we will describe some of the challenges that we would like to address.<p>
In the following discussion an <em>image</em> is a 2D array of pixels. A <em>pixel</em> is a set of color channels that represents the color at a given point in an image. Each <em>channel</em> represents the value of a color component. There are two common memory structures for an image. <em>Interleaved</em> images are represented by grouping the pixels together in memory and interleaving all channels together, whereas <em>planar</em> images keep the channels in separate color planes. Here is a 4x3 RGB image in which the second pixel of the first row is marked in red, in interleaved form:<p>
<div align="center">
<img src="interleaved.jpg" alt="interleaved.jpg">
</div>
 and in planar form:<p>
<div align="center">
<img src="planar.jpg" alt="planar.jpg">
</div>
<p>
Note also that rows may optionally be aligned resulting in a potential padding at the end of rows. <p>
The Generic Image Library (GIL) provides models for images that vary in:<ul>
<li>Structure (planar vs. interleaved)</li><li>Color space and presence of alpha (RGB, RGBA, CMYK, etc.)</li><li>Channel depth (8-bit, 16-bit, etc.)</li><li>Order of channels (RGB vs. BGR, etc.)</li><li>Row alignment policy (no alignment, word-alignment, etc.)</li></ul>
<p>
It also supports user-defined models of images, and images whose parameters are specified at run-time. GIL abstracts image representation from algorithms applied on images and allows us to write the algorithm once and have it work on any of the above image variations while generating code that is comparable in speed to that of hand-writing the algorithm for a specific image type.<p>
This document follows bottom-up design. Each section defines concepts that build on top of concepts defined in previous sections. It is recommended to read the sections in order.<p>
<hr>
 <h2><a class="anchor" name="ConceptsSectionDG">
2. About Concepts</a></h2>
All constructs in GIL are models of GIL concepts. A <em>concept</em> is a set of requirements that a type (or a set of related types) must fulfill to be used correctly in generic algorithms. The requirements include syntactic and algorithming guarantees. For example, GIL's class <code>pixel</code> is a model of GIL's <code>PixelConcept</code>. The user may substitute the pixel class with one of their own, and, as long as it satisfies the requirements of <code>PixelConcept</code>, all other GIL classes and algorithms can be used with it. See more about concepts here: <a href="http://www.generic-programming.org/languages/conceptcpp/">http://www.generic-programming.org/languages/conceptcpp/</a><p>
In this document we will use a syntax for defining concepts that is described in a proposal for a Concepts extension to C++0x specified here: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2081.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2081.pdf</a><p>
Here are some common concepts that will be used in GIL. Most of them are defined here: <a href="http://www.generic-programming.org/languages/conceptcpp/concept_web.php">http://www.generic-programming.org/languages/conceptcpp/concept_web.php</a><p>
<div class="fragment"><pre class="fragment"><span class="keyword">auto</span> concept DefaultConstructible&lt;typename T&gt; {
    T::T();    
};

<span class="keyword">auto</span> concept CopyConstructible&lt;typename T&gt; {
    T::T(T);
    T::~T();
};

<span class="keyword">auto</span> concept Assignable&lt;typename T, typename U = T&gt; {
    <span class="keyword">typename</span> result_type;
    result_type operator=(T&amp;, U);    
};

<span class="keyword">auto</span> concept EqualityComparable&lt;typename T, typename U = T&gt; {
    <span class="keywordtype">bool</span> operator==(T x, T y);    
    <span class="keywordtype">bool</span> operator!=(T x, T y) { <span class="keywordflow">return</span> !(x==y); }
};

concept SameType&lt;typename T, typename U&gt; { <span class="comment">/* unspecified */</span> };
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; concept_map SameType&lt;T, T&gt; { <span class="comment">/* unspecified */</span> };

<span class="keyword">auto</span> concept Swappable&lt;typename T&gt; {
    <span class="keywordtype">void</span> swap(T&amp; t, T&amp; u);
};
</pre></div><p>
Here are some additional basic concepts that GIL needs:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">auto</span> concept Regular&lt;typename T&gt; : DefaultConstructible&lt;T&gt;, CopyConstructible&lt;T&gt;, EqualityComparable&lt;T&gt;, Assignable&lt;T&gt;, Swappable&lt;T&gt; {};

<span class="keyword">auto</span> concept Metafunction&lt;typename T&gt; {
    <span class="keyword">typename</span> type;
};
</pre></div><h2><a class="anchor" name="PointSectionDG">
3. Point</a></h2>
A point defines the location of a pixel inside an image. It can also be used to describe the dimensions of an image. In most general terms, points are N-dimensional and model the following concept:<p>
<div class="fragment"><pre class="fragment">concept PointNDConcept&lt;typename T&gt; : Regular&lt;T&gt; {    
    <span class="comment">// the type of a coordinate along each axis</span>
    <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> K&gt; <span class="keyword">struct </span>axis; where Metafunction&lt;axis&gt;;
            
    <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_dimensions;
    
    <span class="comment">// accessor/modifier of the value of each axis.</span>
    <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> K&gt; <span class="keyword">const</span> <span class="keyword">typename</span> axis&lt;K&gt;::type&amp; T::axis_value() <span class="keyword">const</span>;
    <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> K&gt;       <span class="keyword">typename</span> axis&lt;K&gt;::type&amp; T::axis_value();
};
</pre></div><p>
GIL uses a two-dimensional point, which is a refinement of <code>PointNDConcept</code> in which both dimensions are of the same type:<p>
<div class="fragment"><pre class="fragment">concept Point2DConcept&lt;typename T&gt; : PointNDConcept&lt;T&gt; {    
    where num_dimensions == 2;
    where SameType&lt;axis&lt;0&gt;::type, axis&lt;1&gt;::type&gt;;

    <span class="keyword">typename</span> value_type = axis&lt;0&gt;::type;

    <span class="keyword">const</span> value_type&amp; operator[](<span class="keyword">const</span> T&amp;, <span class="keywordtype">size_t</span> i);
          value_type&amp; operator[](      T&amp;, <span class="keywordtype">size_t</span> i);

    value_type x,y;
};
</pre></div><p>
<b>Related Concepts:</b><p>
<ul>
<li>PointNDConcept&lt;T&gt;</li><li>Point2DConcept&lt;T&gt;</li></ul>
<p>
<b>Models:</b><p>
GIL provides a model of <code>Point2DConcept</code>, <code>point2&lt;T&gt;</code> where <code>T</code> is the coordinate type.<p>
<hr>
 <h2><a class="anchor" name="ChannelSectionDG">
4. Channel</a></h2>
A channel indicates the intensity of a color component (for example, the red channel in an RGB pixel). Typical channel operations are getting, comparing and setting the channel values. Channels have associated minimum and maximum value. GIL channels model the following concept:<p>
<div class="fragment"><pre class="fragment">concept ChannelConcept&lt;typename T&gt; : EqualityComparable&lt;T&gt; {
    <span class="keyword">typename</span> value_type      = T;        <span class="comment">// use channel_traits&lt;T&gt;::value_type to access it</span>
       where ChannelValueConcept&lt;value_type&gt;;
    <span class="keyword">typename</span> reference       = T&amp;;       <span class="comment">// use channel_traits&lt;T&gt;::reference to access it</span>
    <span class="keyword">typename</span> pointer         = T*;       <span class="comment">// use channel_traits&lt;T&gt;::pointer to access it</span>
    <span class="keyword">typename</span> const_reference = <span class="keyword">const</span> T&amp;; <span class="comment">// use channel_traits&lt;T&gt;::const_reference to access it</span>
    <span class="keyword">typename</span> const_pointer   = <span class="keyword">const</span> T*; <span class="comment">// use channel_traits&lt;T&gt;::const_pointer to access it</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_mutable;        <span class="comment">// use channel_traits&lt;T&gt;::is_mutable to access it</span>

    <span class="keyword">static</span> T min_value();                <span class="comment">// use channel_traits&lt;T&gt;::min_value to access it</span>
    <span class="keyword">static</span> T max_value();                <span class="comment">// use channel_traits&lt;T&gt;::min_value to access it</span>
};

concept MutableChannelConcept&lt;ChannelConcept T&gt; : Swappable&lt;T&gt;, Assignable&lt;T&gt; {};

concept ChannelValueConcept&lt;ChannelConcept T&gt; : Regular&lt;T&gt; {}; 
</pre></div><p>
GIL allows built-in integral and floating point types to be channels. Therefore the associated types and range information are defined in <code>channel_traits</code> with the following default implementation:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">struct </span>channel_traits {
    <span class="keyword">typedef</span> T         value_type;
    <span class="keyword">typedef</span> T&amp;        reference;
    <span class="keyword">typedef</span> T*        pointer;
    <span class="keyword">typedef</span> T&amp; <span class="keyword">const</span>  const_reference;
    <span class="keyword">typedef</span> T* <span class="keyword">const</span>  const_pointer;
    
    <span class="keyword">static</span> value_type min_value() { <span class="keywordflow">return</span> std::numeric_limits&lt;T&gt;::min(); }
    <span class="keyword">static</span> value_type max_value() { <span class="keywordflow">return</span> std::numeric_limits&lt;T&gt;::max(); }
};
</pre></div><p>
Two channel types are <em>compatible</em> if they have the same value type:<p>
<div class="fragment"><pre class="fragment">concept ChannelsCompatibleConcept&lt;ChannelConcept T1, ChannelConcept T2&gt; {
    where SameType&lt;T1::value_type, T2::value_type&gt;;
};
</pre></div><p>
A channel may be <em>convertible</em> to another channel:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;ChannelConcept Src, ChannelValueConcept Dst&gt;
concept ChannelConvertibleConcept {
    Dst <a class="code" href="g_i_l_0099.html#gf04e6ac30a35a1f68a8bb84730e34786" title="Converting from one channel type to another.">channel_convert</a>(Src);
};
</pre></div><p>
Note that <code>ChannelConcept</code> and <code>MutableChannelConcept</code> do not require a default constructor. Channels that also support default construction (and thus are regular types) model <code>ChannelValueConcept</code>. To understand the motivation for this distinction, consider a 16-bit RGB pixel in a "565" bit pattern. Its channels correspond to bit ranges. To support such channels, we need to create a custom proxy class corresponding to a reference to a subbyte channel. Such a proxy reference class models only <code>ChannelConcept</code>, because, similar to native C++ references, it may not have a default constructor.<p>
Note also that algorithms may impose additional requirements on channels, such as support for arithmentic operations.<p>
<b>Related Concepts:</b><p>
<ul>
<li>ChannelConcept&lt;T&gt;</li><li>ChannelValueConcept&lt;T&gt;</li><li>MutableChannelConcept&lt;T&gt;</li><li>ChannelsCompatibleConcept&lt;T1,T2&gt;</li><li>ChannelConvertibleConcept&lt;SrcChannel,DstChannel&gt;</li></ul>
<p>
<b>Models:</b><p>
All built-in integral and floating point types are valid channels. GIL provides standard typedefs for some integral channels:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> boost::uint8_t  bits8;
<span class="keyword">typedef</span> boost::uint16_t bits16;
<span class="keyword">typedef</span> boost::uint32_t bits32;
<span class="keyword">typedef</span> boost::int8_t   bits8s;
<span class="keyword">typedef</span> boost::int16_t  bits16s;
<span class="keyword">typedef</span> boost::int32_t  bits32s;
</pre></div><p>
The minimum and maximum values of a channel modeled by a built-in type correspond to the minimum and maximum physical range of the built-in type, as specified by its <code>std::numeric_limits</code>. Sometimes the physical range is not appropriate. GIL provides <code>scoped_channel_value</code>, a model for a channel adapter that allows for specifying a custom range. We use it to define a [0..1] floating point channel type as follows:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>float_zero { <span class="keyword">static</span> <span class="keywordtype">float</span> apply() { <span class="keywordflow">return</span> 0.0f; } };
<span class="keyword">struct </span>float_one  { <span class="keyword">static</span> <span class="keywordtype">float</span> apply() { <span class="keywordflow">return</span> 1.0f; } };
<span class="keyword">typedef</span> scoped_channel_value&lt;float,float_zero,float_one&gt; bits32f;
</pre></div><p>
GIL also provides models for channels corresponding to ranges of bits:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Value of a channel defined over NumBits bits. Models ChannelValueConcept</span>
<span class="keyword">template</span> &lt;<span class="keywordtype">int</span> NumBits&gt; <span class="keyword">class </span>packed_channel_value;

<span class="comment">// Reference to a channel defined over NumBits bits. Models ChannelConcept</span>
<span class="keyword">template</span> &lt;<span class="keywordtype">int</span> FirstBit, 
          <span class="keywordtype">int</span> NumBits,       <span class="comment">// Defines the sequence of bits in the data value that contain the channel </span>
          <span class="keywordtype">bool</span> Mutable&gt;      <span class="comment">// true if the reference is mutable </span>
<span class="keyword">class </span>packed_channel_reference;

<span class="comment">// Reference to a channel defined over NumBits bits. Its FirstBit is a run-time parameter. Models ChannelConcept</span>
<span class="keyword">template</span> &lt;<span class="keywordtype">int</span> NumBits,       <span class="comment">// Defines the sequence of bits in the data value that contain the channel </span>
          <span class="keywordtype">bool</span> Mutable&gt;      <span class="comment">// true if the reference is mutable </span>
<span class="keyword">class </span>packed_dynamic_channel_reference;
</pre></div><p>
Note that there are two models of a reference proxy which differ based on whether the offset of the channel range is specified as a template or a run-time parameter. The first model is faster and more compact while the second model is more flexible. For example, the second model allows us to construct an iterator over bitrange channels.<p>
<b>Algorithms:</b><p>
Here is how to construct the three channels of a 16-bit "565" pixel and set them to their maximum value:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> packed_channel_reference&lt;0,5,true&gt; channel16_0_5_reference_t;
<span class="keyword">typedef</span> packed_channel_reference&lt;5,6,true&gt; channel16_5_6_reference_t;
<span class="keyword">typedef</span> packed_channel_reference&lt;11,5,true&gt; channel16_11_5_reference_t;

boost::uint16_t data=0;
channel16_0_5_reference_t   channel1(&amp;data);
channel16_5_6_reference_t   channel2(&amp;data);
channel16_11_5_reference_t  channel3(&amp;data);

channel1=channel_traits&lt;channel16_0_5_reference_t&gt;::max_value();
channel2=channel_traits&lt;channel16_5_6_reference_t&gt;::max_value();
channel3=channel_traits&lt;channel16_11_5_reference_t&gt;::max_value();
assert(data==65535);
</pre></div><p>
Assignment, equality comparison and copy construction are defined only between compatible channels:<p>
<div class="fragment"><pre class="fragment">packed_channel_value&lt;5&gt; channel_6bit = channel1;
channel_6bit = channel3;

<span class="comment">//channel_6bit = channel2; // compile error: Assignment between incompatible channels.</span>
</pre></div><p>
All channel models provided by GIL are pairwise convertible:<p>
<div class="fragment"><pre class="fragment">channel1 = channel_traits&lt;channel16_0_5_reference_t&gt;::max_value();
assert(channel1 == 31);

bits16 chan16 = channel_convert&lt;bits16&gt;(channel1);
assert(chan16 == 65535);
</pre></div><p>
Channel conversion is a lossy operation. GIL's channel conversion is a linear transformation between the ranges of the source and destination channel. It maps precisely the minimum to the minimum and the maximum to the maximum. (For example, to convert from uint8_t to uint16_t GIL does not do a bit shift because it will not properly match the maximum values. Instead GIL multiplies the source by 257).<p>
All channel models that GIL provides are convertible from/to an integral or floating point type. Thus they support arithmetic operations. Here are the channel-level algorithms that GIL provides:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Converts a source channel value into a destrination channel. Linearly maps the value of the source</span>
<span class="comment">// into the range of the destination</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> DstChannel, <span class="keyword">typename</span> SrcChannel&gt;
<span class="keyword">typename</span> channel_traits&lt;DstChannel&gt;::value_type <a class="code" href="g_i_l_0099.html#gf04e6ac30a35a1f68a8bb84730e34786" title="Converting from one channel type to another.">channel_convert</a>(SrcChannel src);

<span class="comment">// returns max_value - x + min_value</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Channel&gt;
<span class="keyword">typename</span> channel_traits&lt;Channel&gt;::value_type <a class="code" href="g_i_l_0101.html#ge2e0267865f89610ef26148874a04bb5" title="Default implementation. Provide overloads for performance.">channel_invert</a>(Channel x);

<span class="comment">// returns a * b / max_value</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Channel&gt;
<span class="keyword">typename</span> channel_traits&lt;Channel&gt;::value_type <a class="code" href="g_i_l_0103.html#gf73b2a47a7877767534df0eee46dda17" title="A function multiplying two channels. result = a * b / max_value.">channel_multiply</a>(Channel a, Channel b);
</pre></div><p>
<hr>
 <h2><a class="anchor" name="ColorSpaceSectionDG">
5. Color Space and Layout</a></h2>
A color space captures the set and interpretation of channels comprising a pixel. It is an MPL random access sequence containing the types of all elements in the color space. Two color spaces are considered <em>compatible</em> if they are equal (i.e. have the same set of colors in the same order).<p>
<b>Related Concepts:</b><p>
<ul>
<li>ColorSpaceConcept&lt;ColorSpace&gt;</li><li>ColorSpacesCompatibleConcept&lt;ColorSpace1,ColorSpace2&gt;</li><li>ChannelMappingConcept&lt;Mapping&gt;</li></ul>
<p>
<b>Models:</b><p>
GIL currently provides the following color spaces: <code>gray_t</code>, <code>rgb_t</code>, <code>rgba_t</code>, and <code>cmyk_t</code>. It also provides unnamed N-channel color spaces of two to five channels, <code>devicen_t&lt;2&gt;</code>, <code>devicen_t&lt;3&gt;</code>, <code>devicen_t&lt;4&gt;</code>, <code>devicen_t&lt;5&gt;</code>. Besides the standard layouts, it provides <code>bgr_layout_t</code>, <code>bgra_layout_t</code>, <code>abgr_layout_t</code> and <code>argb_layout_t</code>.<p>
As an example, here is how GIL defines the RGBA color space:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>red_t{};
<span class="keyword">struct </span>green_t{};
<span class="keyword">struct </span>blue_t{};
<span class="keyword">struct </span>alpha_t{};
<span class="keyword">typedef</span> mpl::vector4&lt;red_t,green_t,blue_t,alpha_t&gt; rgba_t;
</pre></div><p>
The ordering of the channels in the color space definition specifies their semantic order. For example, <code>red_t</code> is the first semantic channel of <code>rgba_t</code>. While there is a unique semantic ordering of the channels in a color space, channels may vary in their physical ordering in memory. The mapping of channels is specified by <code>ChannelMappingConcept</code>, which is an MPL random access sequence of integral types. A color space and its associated mapping are often used together. Thus they are grouped in GIL's layout:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorSpace, 
          <span class="keyword">typename</span> ChannelMapping = mpl::range_c&lt;int,0,mpl::size&lt;ColorSpace&gt;::value&gt; &gt;
<span class="keyword">struct </span>layout {
    <span class="keyword">typedef</span> ColorSpace      color_space_t;
    <span class="keyword">typedef</span> ChannelMapping  channel_mapping_t;
};
</pre></div><p>
Here is how to create layouts for the RGBA color space:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> layout&lt;rgba_t&gt; rgba_layout_t; <span class="comment">// default ordering is 0,1,2,3...</span>
<span class="keyword">typedef</span> layout&lt;rgba_t, mpl::vector4_c&lt;int,2,1,0,3&gt; &gt; bgra_layout_t;
<span class="keyword">typedef</span> layout&lt;rgba_t, mpl::vector4_c&lt;int,1,2,3,0&gt; &gt; argb_layout_t;
<span class="keyword">typedef</span> layout&lt;rgba_t, mpl::vector4_c&lt;int,3,2,1,0&gt; &gt; abgr_layout_t;
</pre></div><p>
<hr>
 <h2><a class="anchor" name="ColorBaseSectionDG">
6. Color Base</a></h2>
A color base is a container of color elements. The most common use of color base is in the implementation of a pixel, in which case the color elements are channel values. The color base concept, however, can be used in other scenarios. For example, a planar pixel has channels that are not contiguous in memory. Its reference is a proxy class that uses a color base whose elements are channel references. Its iterator uses a color base whose elements are channel iterators.<p>
Color base models must satisfy the following concepts:<p>
<div class="fragment"><pre class="fragment">concept ColorBaseConcept&lt;typename T&gt; : CopyConstructible&lt;T&gt;, EqualityComparable&lt;T&gt; {
    <span class="comment">// a GIL layout (the color space and element permutation)</span>
    <span class="keyword">typename</span> layout_t;
        
    <span class="comment">// The type of K-th element</span>
    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_element_type;
        where Metafunction&lt;kth_element_type&gt;;
    
    <span class="comment">// The result of at_c</span>
    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_element_const_reference_type;
        where Metafunction&lt;kth_element_const_reference_type&gt;;        
    
    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; kth_element_const_reference_type&lt;T,K&gt;::type at_c(T);
    
    <span class="keyword">template</span> &lt;ColorBaseConcept T2&gt; where { ColorBasesCompatibleConcept&lt;T,T2&gt; } 
        T::T(T2);
    <span class="keyword">template</span> &lt;ColorBaseConcept T2&gt; where { ColorBasesCompatibleConcept&lt;T,T2&gt; } 
        <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T2&amp;);
    <span class="keyword">template</span> &lt;ColorBaseConcept T2&gt; where { ColorBasesCompatibleConcept&lt;T,T2&gt; } 
        <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T2&amp;);

};

concept MutableColorBaseConcept&lt;ColorBaseConcept T&gt; : Assignable&lt;T&gt;, Swappable&lt;T&gt; {
    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_element_reference_type;
        where Metafunction&lt;kth_element_reference_type&gt;;

    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; kth_element_reference_type&lt;T,K&gt;::type at_c(T);
    
    <span class="keyword">template</span> &lt;ColorBaseConcept T2&gt; where { ColorBasesCompatibleConcept&lt;T,T2&gt; } 
        T&amp; operator=(T&amp;, <span class="keyword">const</span> T2&amp;);
};

concept ColorBaseValueConcept&lt;typename T&gt; : MutableColorBaseConcept&lt;T&gt;, Regular&lt;T&gt; {
};

concept HomogeneousColorBaseConcept&lt;ColorBaseConcept CB&gt; {
    <span class="comment">// For all K in [0 ... size&lt;C1&gt;::value-1):</span>
    <span class="comment">//     where SameType&lt;kth_element_type&lt;K&gt;::type, kth_element_type&lt;K+1&gt;::type&gt;;    </span>
    kth_element_const_reference_type&lt;0&gt;::type dynamic_at_c(<span class="keyword">const</span> CB&amp;, std::size_t n) <span class="keyword">const</span>;
};

concept MutableHomogeneousColorBaseConcept&lt;MutableColorBaseConcept CB&gt; : HomogeneousColorBaseConcept&lt;CB&gt; {
    kth_element_reference_type&lt;0&gt;::type dynamic_at_c(<span class="keyword">const</span> CB&amp;, std::size_t n);
};

concept HomogeneousColorBaseValueConcept&lt;typename T&gt; : MutableHomogeneousColorBaseConcept&lt;T&gt;, Regular&lt;T&gt; {
};

concept ColorBasesCompatibleConcept&lt;ColorBaseConcept C1, ColorBaseConcept C2&gt; {
    where SameType&lt;C1::layout_t::color_space_t, C2::layout_t::color_space_t&gt;;
    <span class="comment">// also, for all K in [0 ... size&lt;C1&gt;::value):</span>
    <span class="comment">//     where Convertible&lt;kth_semantic_element_type&lt;C1,K&gt;::type, kth_semantic_element_type&lt;C2,K&gt;::type&gt;;</span>
    <span class="comment">//     where Convertible&lt;kth_semantic_element_type&lt;C2,K&gt;::type, kth_semantic_element_type&lt;C1,K&gt;::type&gt;;</span>
};
</pre></div><p>
A color base must have an associated layout (which consists of a color space, as well as an ordering of the channels). There are two ways to index the elements of a color base: A physical index corresponds to the way they are ordered in memory, and a semantic index corresponds to the way the elements are ordered in their color space. For example, in the RGB color space the elements are ordered as {red_t, green_t, blue_t}. For a color base with a BGR layout, the first element in physical ordering is the blue element, whereas the first semantic element is the red one. Models of <code>ColorBaseConcept</code> are required to provide the <code>at_c&lt;K&gt;(ColorBase)</code> function, which allows for accessing the elements based on their physical order. GIL provides a <code>semantic_at_c&lt;K&gt;(ColorBase)</code> function (described later) which can operate on any model of ColorBaseConcept and returns the corresponding semantic element.<p>
Two color bases are <em>compatible</em> if they have the same color space and their elements (paired semantically) are convertible to each other.<p>
<b>Models:</b><p>
GIL provides a model for a homogeneous color base (a color base whose elements all have the same type).<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>detail {
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> Layout, <span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>homogeneous_color_base;
}
</pre></div><p>
It is used in the implementation of GIL's pixel, planar pixel reference and planar pixel iterator. Another model of <code>ColorBaseConcept</code> is <code>packed_pixel</code> - it is a pixel whose channels are bit ranges. See the <a class="el" href="gildesignguide.html#PixelSectionDG">7. Pixel</a> section for more.<p>
<b>Algorithms:</b><p>
GIL provides the following functions and metafunctions operating on color bases:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Metafunction returning an mpl::int_ equal to the number of elements in the color base</span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase&gt; <span class="keyword">struct </span>size;

<span class="comment">// Returns the type of the return value of semantic_at_c&lt;K&gt;(color_base)</span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase, <span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_semantic_element_reference_type;
<span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase, <span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>kth_semantic_element_const_reference_type;

<span class="comment">// Returns a reference to the element with K-th semantic index.</span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase, <span class="keywordtype">int</span> K&gt; 
<span class="keyword">typename</span> kth_semantic_element_reference_type&lt;ColorBase,K&gt;::type       <a class="code" href="g_i_l_0114.html#g2cdd9bfd1b27576659b8c79a3a0233de" title="A mutable accessor to the K-th semantic element of a color base.">semantic_at_c</a>(ColorBase&amp; p) 
<span class="keyword">template</span> &lt;<span class="keyword">class</span> ColorBase, <span class="keywordtype">int</span> K&gt; 
<span class="keyword">typename</span> kth_semantic_element_const_reference_type&lt;ColorBase,K&gt;::type <a class="code" href="g_i_l_0114.html#g2cdd9bfd1b27576659b8c79a3a0233de" title="A mutable accessor to the K-th semantic element of a color base.">semantic_at_c</a>(<span class="keyword">const</span> ColorBase&amp; p) 

<span class="comment">// Returns the type of the return value of get_color&lt;Color&gt;(color_base)</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Color, <span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>color_reference_t;
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Color, <span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>color_const_reference_t;

<span class="comment">// Returns a reference to the element corresponding to the given color</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keyword">typename</span> Color&gt; 
<span class="keyword">typename</span> color_reference_t&lt;Color,ColorBase&gt;::type <a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(ColorBase&amp; cb, Color=Color());
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keyword">typename</span> Color&gt; 
<span class="keyword">typename</span> color_const_reference_t&lt;Color,ColorBase&gt;::type <a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(<span class="keyword">const</span> ColorBase&amp; cb, Color=Color());

<span class="comment">// Returns the element type of the color base. Defined for homogeneous color bases only</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>element_type;
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>element_reference_type;
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase&gt; <span class="keyword">struct </span>element_const_reference_type;
</pre></div><p>
GIL also provides the following algorithms which operate on color bases. Note that they all pair the elements semantically:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Equivalents to std::equal, std::copy, std::fill, std::generate</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2&gt;   <span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> CB1&amp; p1, <span class="keyword">const</span> CB2&amp; p2);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Src,<span class="keyword">typename</span> Dst&gt;   <span class="keywordtype">void</span> static_copy(<span class="keyword">const</span> Src&amp; src, Dst&amp; dst);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB, <span class="keyword">typename</span> Op&gt;    <span class="keywordtype">void</span> static_generate(CB&amp; dst,Op op);

<span class="comment">// Equivalents to std::transform</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB ,             <span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(      CB&amp;,Dst&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB ,             <span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(<span class="keyword">const</span> CB&amp;,Dst&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(      CB1&amp;,      CB2&amp;,Dst&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(<span class="keyword">const</span> CB1&amp;,      CB2&amp;,Dst&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(      CB1&amp;,<span class="keyword">const</span> CB2&amp;,Dst&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; Op static_transform(<span class="keyword">const</span> CB1&amp;,<span class="keyword">const</span> CB2&amp;,Dst&amp;,Op); 

<span class="comment">// Equivalents to std::for_each</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,                          <span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,                          <span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,             <span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,      CB2&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,             <span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,<span class="keyword">const</span> CB2&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,             <span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,      CB2&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,             <span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,<span class="keyword">const</span> CB2&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,      CB2&amp;,      CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,      CB2&amp;,<span class="keyword">const</span> CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,<span class="keyword">const</span> CB2&amp;,      CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(      CB1&amp;,<span class="keyword">const</span> CB2&amp;,<span class="keyword">const</span> CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,      CB2&amp;,      CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,      CB2&amp;,<span class="keyword">const</span> CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,<span class="keyword">const</span> CB2&amp;,      CB3&amp;,Op); 
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CB1,<span class="keyword">typename</span> CB2,<span class="keyword">typename</span> CB3,<span class="keyword">typename</span> Op&gt; Op static_for_each(<span class="keyword">const</span> CB1&amp;,<span class="keyword">const</span> CB2&amp;,<span class="keyword">const</span> CB3&amp;,Op); 

<span class="comment">// The following algorithms are only defined for homogeneous color bases:</span>
<span class="comment">// Equivalent to std::fill</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB, <span class="keyword">typename</span> Element&gt; <span class="keywordtype">void</span> static_fill(HCB&amp; p, <span class="keyword">const</span> Element&amp; v);

<span class="comment">// Equivalents to std::min_element and std::max_element</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB&gt; <span class="keyword">typename</span> element_const_reference_type&lt;HCB&gt;::type static_min(<span class="keyword">const</span> HCB&amp;);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB&gt; <span class="keyword">typename</span> element_reference_type&lt;HCB&gt;::type       static_min(      HCB&amp;);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB&gt; <span class="keyword">typename</span> element_const_reference_type&lt;HCB&gt;::type static_max(<span class="keyword">const</span> HCB&amp;);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> HCB&gt; <span class="keyword">typename</span> element_reference_type&lt;HCB&gt;::type       static_max(      HCB&amp;);
</pre></div><p>
These algorithms are designed after the corresponding STL algorithms, except that instead of ranges they take color bases and operate on their elements. In addition, they are implemented with a compile-time recursion (thus the prefix "static_"). Finally, they pair the elements semantically instead of based on their physical order in memory. For example, here is the implementation of <code>static_equal:</code> <p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>detail {
<span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span>element_recursion {
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;
    <span class="keyword">static</span> <span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> P1&amp; p1, <span class="keyword">const</span> P2&amp; p2) { 
        <span class="keywordflow">return</span> element_recursion&lt;K-1&gt;::static_equal(p1,p2) &amp;&amp;
               <a class="code" href="g_i_l_0114.html#g2cdd9bfd1b27576659b8c79a3a0233de" title="A mutable accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;K-1&gt;(p1)==semantic_at_c&lt;N-1&gt;(p2); 
    }
};
<span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>element_recursion&lt;0&gt; {
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;
    <span class="keyword">static</span> <span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> P1&amp;, <span class="keyword">const</span> P2&amp;) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
};
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;
<span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> P1&amp; p1, <span class="keyword">const</span> P2&amp; p2) {
    gil_function_requires&lt;ColorSpacesCompatibleConcept&lt;P1::layout_t::color_space_t,P2::layout_t::color_space_t&gt; &gt;(); 
    <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_equal(p1,p2); 
}    
</pre></div><p>
This algorithm is used when invoking <code>operator==</code> on two pixels, for example. By using semantic accessors we are properly comparing an RGB pixel to a BGR pixel. Notice also that all of the above algorithms taking more than one color base require that they all have the same color space.<p>
<hr>
 <h2><a class="anchor" name="PixelSectionDG">
7. Pixel</a></h2>
A pixel is a set of channels defining the color at a given point in an image. Conceptually, a pixel is little more than a color base whose elements model <code>ChannelConcept</code>. All properties of pixels inherit from color bases: pixels may be <em>homogeneous</em> if all of their channels have the same type; otherwise they are called <em>heterogeneous</em>. The channels of a pixel may be addressed using semantic or physical indexing, or by color; all color-base algorithms work on pixels as well. Two pixels are <em>compatible</em> if their color spaces are the same and their channels, paired semantically, are compatible. Note that constness, memory organization and reference/value are ignored. For example, an 8-bit RGB planar reference is compatible to a constant 8-bit BGR interleaved pixel value. Most pairwise pixel operations (copy construction, assignment, equality, etc.) are only defined for compatible pixels.<p>
Pixels (as well as other GIL constructs built on pixels, such as iterators, locators, views and images) must provide metafunctions to access their color space, channel mapping, number of channels, and (for homogeneous pixels) the channel type:<p>
<div class="fragment"><pre class="fragment">concept PixelBasedConcept&lt;typename T&gt; {
    <span class="keyword">typename</span> color_space_type&lt;T&gt;;     
        where Metafunction&lt;color_space_type&lt;T&gt; &gt;;
        where ColorSpaceConcept&lt;color_space_type&lt;T&gt;::type&gt;;
    <span class="keyword">typename</span> channel_mapping_type&lt;T&gt;; 
        where Metafunction&lt;channel_mapping_type&lt;T&gt; &gt;;  
        where ChannelMappingConcept&lt;channel_mapping_type&lt;T&gt;::type&gt;;
    <span class="keyword">typename</span> is_planar&lt;T&gt;;
        where Metafunction&lt;is_planar&lt;T&gt; &gt;;
        where SameType&lt;is_planar&lt;T&gt;::type, <span class="keywordtype">bool</span>&gt;;
};

concept HomogeneousPixelBasedConcept&lt;PixelBasedConcept T&gt; {
    <span class="keyword">typename</span> channel_type&lt;T&gt;;         
        where Metafunction&lt;channel_type&lt;T&gt; &gt;;
        where ChannelConcept&lt;channel_type&lt;T&gt;::type&gt;;
};
</pre></div><p>
Pixels model the following concepts:<p>
<div class="fragment"><pre class="fragment">concept PixelConcept&lt;typename P&gt; : ColorBaseConcept&lt;P&gt;, PixelBasedConcept&lt;P&gt; {    
    where is_pixel&lt;P&gt;::type::value==<span class="keyword">true</span>;
    <span class="comment">// where for each K [0..size&lt;P&gt;::value-1]:</span>
    <span class="comment">//      ChannelConcept&lt;kth_element_type&lt;K&gt; &gt;;</span>
        
    <span class="keyword">typename</span> value_type;       where PixelValueConcept&lt;value_type&gt;;
    <span class="keyword">typename</span> reference;        where PixelConcept&lt;reference&gt;;
    <span class="keyword">typename</span> const_reference;  where PixelConcept&lt;const_reference&gt;;
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> P::is_mutable;

    <span class="keyword">template</span> &lt;PixelConcept P2&gt; where { PixelConcept&lt;P,P2&gt; } 
        P::P(P2);
    <span class="keyword">template</span> &lt;PixelConcept P2&gt; where { PixelConcept&lt;P,P2&gt; } 
        <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> P&amp;, <span class="keyword">const</span> P2&amp;);
    <span class="keyword">template</span> &lt;PixelConcept P2&gt; where { PixelConcept&lt;P,P2&gt; } 
        <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> P&amp;, <span class="keyword">const</span> P2&amp;);
}; 

concept MutablePixelConcept&lt;typename P&gt; : PixelConcept&lt;P&gt;, MutableColorBaseConcept&lt;P&gt; {
    where is_mutable==<span class="keyword">true</span>;
};

concept HomogeneousPixelConcept&lt;PixelConcept P&gt; : HomogeneousColorBaseConcept&lt;P&gt;, HomogeneousPixelBasedConcept&lt;P&gt; { 
    P::template element_const_reference_type&lt;P&gt;::type operator[](P p, std::size_t i)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> dynamic_at_c(P,i); }
};

concept MutableHomogeneousPixelConcept&lt;MutablePixelConcept P&gt; : MutableHomogeneousColorBaseConcept&lt;P&gt; { 
    P::template element_reference_type&lt;P&gt;::type operator[](P p, std::size_t i) { <span class="keywordflow">return</span> dynamic_at_c(p,i); }
};

concept PixelValueConcept&lt;typename P&gt; : PixelConcept&lt;P&gt;, Regular&lt;P&gt; {
    where SameType&lt;value_type,P&gt;;
};    

concept PixelsCompatibleConcept&lt;PixelConcept P1, PixelConcept P2&gt; : ColorBasesCompatibleConcept&lt;P1,P2&gt; {
    <span class="comment">// where for each K [0..size&lt;P1&gt;::value):</span>
    <span class="comment">//    ChannelsCompatibleConcept&lt;kth_semantic_element_type&lt;P1,K&gt;::type, kth_semantic_element_type&lt;P2,K&gt;::type&gt;;</span>
};
</pre></div><p>
A pixel is <em>convertible</em> to a second pixel if it is possible to approximate its color in the form of the second pixel. Conversion is an explicit, non-symmetric and often lossy operation (due to both channel and color space approximation). Convertability requires modeling the following concept:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;PixelConcept SrcPixel, MutablePixelConcept DstPixel&gt;
concept PixelConvertibleConcept {
    <span class="keywordtype">void</span> <a class="code" href="g_i_l_0178.html#gaa258d34eafbf9d9e34a2a2ad6131af2" title="helper function for converting one pixel to another using GIL default color-converters...">color_convert</a>(<span class="keyword">const</span> SrcPixel&amp;, DstPixel&amp;);
};
</pre></div><p>
The distinction between <code>PixelConcept</code> and <code>PixelValueConcept</code> is analogous to that for channels and color bases - pixel reference proxies model both, but only pixel values model the latter.<p>
<b>Related Concepts:</b><p>
<ul>
<li>PixelBasedConcept&lt;P&gt;</li><li>PixelConcept&lt;Pixel&gt;</li><li>MutablePixelConcept&lt;Pixel&gt;</li><li>PixelValueConcept&lt;Pixel&gt;</li><li>HomogeneousPixelConcept&lt;Pixel&gt;</li><li>MutableHomogeneousPixelConcept&lt;Pixel&gt;</li><li>HomogeneousPixelValueConcept&lt;Pixel&gt;</li><li>PixelsCompatibleConcept&lt;Pixel1,Pixel2&gt;</li><li>PixelConvertibleConcept&lt;SrcPixel,DstPixel&gt;</li></ul>
<p>
<b>Models:</b><p>
The most commonly used pixel is a homogeneous pixel whose values are together in memory. For this purpose GIL provides the struct <code>pixel</code>, templated over the channel value and layout:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// models HomogeneousPixelValueConcept</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout&gt; <span class="keyword">struct </span>pixel;

<span class="comment">// Those typedefs are already provided by GIL</span>
<span class="keyword">typedef</span> pixel&lt;bits8, rgb_layout_t&gt; rgb8_pixel_t;
<span class="keyword">typedef</span> pixel&lt;bits8, bgr_layout_t&gt; bgr8_pixel_t;

bgr8_pixel_t bgr8(255,0,0);     <span class="comment">// pixels can be initialized with the channels directly</span>
rgb8_pixel_t rgb8(bgr8);        <span class="comment">// compatible pixels can also be copy-constructed</span>

rgb8 = bgr8;            <span class="comment">// assignment and equality is defined between compatible pixels</span>
assert(rgb8 == bgr8);   <span class="comment">// assignment and equality operate on the semantic channels</span>

<span class="comment">// The first physical channels of the two pixels are different</span>
assert(at_c&lt;0&gt;(rgb8) != at_c&lt;0&gt;(bgr8));
assert(dynamic_at_c(bgr8,0) != dynamic_at_c(rgb8,0));
assert(rgb8[0] != bgr8[0]); <span class="comment">// same as above (but operator[] is defined for pixels only)</span>
</pre></div><p>
Planar pixels have their channels distributed in memory. While they share the same value type (<code>pixel</code>) with interleaved pixels, their reference type is a proxy class containing references to each of the channels. This is implemented with the struct <code>planar_pixel_reference:</code> <p>
<div class="fragment"><pre class="fragment"><span class="comment">// models HomogeneousPixel</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelReference, <span class="keyword">typename</span> ColorSpace&gt; <span class="keyword">struct </span>planar_pixel_reference;

<span class="comment">// Define the type of a mutable and read-only reference. (These typedefs are already provided by GIL)</span>
<span class="keyword">typedef</span> planar_pixel_reference&lt;      bits8&amp;,rgb_t&gt; rgb8_planar_ref_t;
<span class="keyword">typedef</span> planar_pixel_reference&lt;const bits8&amp;,rgb_t&gt; rgb8c_planar_ref_t;
</pre></div><p>
Note that, unlike the <code>pixel</code> struct, planar pixel references are templated over the color space, not over the pixel layout. They always use a cannonical channel ordering. Ordering of their elements is unnecessary because their elements are references to the channels.<p>
Sometimes the channels of a pixel may not be byte-aligned. For example an RGB pixel in '5-5-6' format is a 16-bit pixel whose red, green and blue channels occupy bits [0..4],[5..9] and [10..15] respectively. GIL provides a model for such packed pixel formats:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// define an rgb565 pixel</span>
<span class="keyword">typedef</span> packed_pixel_type&lt;uint16_t, mpl::vector3_c&lt;unsigned,5,6,5&gt;, rgb_layout_t&gt;::type rgb565_pixel_t;

function_requires&lt;PixelValueConcept&lt;rgb565_pixel_t&gt; &gt;();
BOOST_STATIC_ASSERT((<span class="keyword">sizeof</span>(rgb565_pixel_t)==2));

<span class="comment">// define a bgr556 pixel</span>
<span class="keyword">typedef</span> packed_pixel_type&lt;uint16_t, mpl::vector3_c&lt;unsigned,5,6,5&gt;, bgr_layout_t&gt;::type bgr556_pixel_t;

function_requires&lt;PixelValueConcept&lt;bgr556_pixel_t&gt; &gt;();

<span class="comment">// rgb565 is compatible with bgr556.</span>
function_requires&lt;PixelsCompatibleConcept&lt;rgb565_pixel_t,bgr556_pixel_t&gt; &gt;();
</pre></div><p>
In some cases, the pixel itself may not be byte aligned. For example, consider an RGB pixel in '2-3-2' format. Its size is 7 bits. GIL refers to such pixels, pixel iterators and images as "bit-aligned". Bit-aligned pixels (and images) are more complex than packed ones. Since packed pixels are byte-aligned, we can use a C++ reference as the reference type to a packed pixel, and a C pointer as an x_iterator over a row of packed pixels. For bit-aligned constructs we need a special reference proxy class (bit_aligned_pixel_reference) and iterator class (bit_aligned_pixel_iterator). The value type of bit-aligned pixels is a packed_pixel. Here is how to use bit_aligned pixels and pixel iterators:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Mutable reference to a BGR232 pixel</span>
<span class="keyword">typedef</span> <span class="keyword">const</span> bit_aligned_pixel_reference&lt;unsigned char, mpl::vector3_c&lt;unsigned,2,3,2&gt;, bgr_layout_t, <span class="keyword">true</span>&gt;  bgr232_ref_t;

<span class="comment">// A mutable iterator over BGR232 pixels</span>
<span class="keyword">typedef</span> bit_aligned_pixel_iterator&lt;bgr232_ref_t&gt; bgr232_ptr_t;

<span class="comment">// BGR232 pixel value. It is a packed_pixel of size 1 byte. (The last bit is unused)</span>
<span class="keyword">typedef</span> std::iterator_traits&lt;bgr232_ptr_t&gt;::value_type bgr232_pixel_t; 
BOOST_STATIC_ASSERT((<span class="keyword">sizeof</span>(bgr232_pixel_t)==1));

bgr232_pixel_t red(0,0,3); <span class="comment">// = 0RRGGGBB, = 01100000 = 0x60</span>

<span class="comment">// a buffer of 7 bytes fits exactly 8 BGR232 pixels.</span>
<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pix_buffer[7];    
<a class="code" href="g_i_l_0214.html#g718772a47188f4e2ecfce2f28fa3dc4f" title="std::fill(I,I,V) with I being a iterator_from_2d">std::fill</a>(pix_buffer,pix_buffer+7,0);

<span class="comment">// Fill the 8 pixels with red</span>
bgr232_ptr_t pix_it(&amp;pix_buffer[0],0);  <span class="comment">// start at bit 0 of the first pixel</span>
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;8; ++i) {
    *pix_it++ = red;
}
<span class="comment">// Result: 0x60 0x30 0x11 0x0C 0x06 0x83 0xC1</span>
</pre></div><p>
<b>Algorithms:</b><p>
Since pixels model <code>ColorBaseConcept</code> and <code>PixelBasedConcept</code> all algorithms and metafunctions of color bases can work with them as well:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// This is how to access the first semantic channel (red)</span>
assert(semantic_at_c&lt;0&gt;(rgb8) == semantic_at_c&lt;0&gt;(bgr8));

<span class="comment">// This is how to access the red channel by name</span>
assert(get_color&lt;red_t&gt;(rgb8) == get_color&lt;red_t&gt;(bgr8));

<span class="comment">// This is another way of doing it (some compilers don't like the first one)</span>
assert(<a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(rgb8,red_t()) == <a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(bgr8,red_t()));

<span class="comment">// This is how to use the PixelBasedConcept metafunctions</span>
BOOST_MPL_ASSERT(num_channels&lt;rgb8_pixel_t&gt;::value == 3);
BOOST_MPL_ASSERT((is_same&lt;channel_type&lt;rgb8_pixel_t&gt;::type, bits8&gt;));
BOOST_MPL_ASSERT((is_same&lt;color_space_type&lt;bgr8_pixel_t&gt;::type, rgb_t&gt; ));
BOOST_MPL_ASSERT((is_same&lt;channel_mapping_type&lt;bgr8_pixel_t&gt;::type, mpl::vector3_c&lt;int,2,1,0&gt; &gt; ));

<span class="comment">// Pixels contain just the three channels and nothing extra</span>
BOOST_MPL_ASSERT(<span class="keyword">sizeof</span>(rgb8_pixel_t)==3);

rgb8_planar_ref_t ref(bgr8);    <span class="comment">// copy construction is allowed from a compatible mutable pixel type</span>

get_color&lt;red_t&gt;(ref) = 10;     <span class="comment">// assignment is ok because the reference is mutable</span>
assert(get_color&lt;red_t&gt;(bgr8)==10);  <span class="comment">// references modify the value they are bound to</span>

<span class="comment">// Create a zero packed pixel and a full regular unpacked pixel.</span>
rgb565_pixel_t r565;
rgb8_pixel_t rgb_full(255,255,255);

<span class="comment">// Convert all channels of the unpacked pixel to the packed one &amp; assert the packed one is full</span>
<a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(r565,red_t())   = channel_convert&lt;rgb565_channel0_t&gt;(<a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(rgb_full,red_t()));
<a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(r565,green_t()) = channel_convert&lt;rgb565_channel1_t&gt;(<a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(rgb_full,green_t()));
<a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(r565,blue_t())  = channel_convert&lt;rgb565_channel2_t&gt;(<a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(rgb_full,blue_t()));
assert(r565 == rgb565_pixel_t((uint16_t)65535));    
</pre></div><p>
GIL also provides the <code>color_convert</code> algorithm to convert between pixels of different color spaces and channel types:<p>
<div class="fragment"><pre class="fragment">rgb8_pixel_t red_in_rgb8(255,0,0);
cmyk16_pixel_t red_in_cmyk16;
<a class="code" href="g_i_l_0178.html#gaa258d34eafbf9d9e34a2a2ad6131af2" title="helper function for converting one pixel to another using GIL default color-converters...">color_convert</a>(red_in_rgb8,red_in_cmyk16);
</pre></div><p>
<hr>
 <h2><a class="anchor" name="PixelIteratorSectionDG">
8. Pixel Iterator</a></h2>
<h2><a class="anchor" name="FundamentalIteratorDG">
Fundamental Iterator</a></h2>
Pixel iterators are random traversal iterators whose <code>value_type</code> models <code>PixelValueConcept</code>. Pixel iterators provide metafunctions to determine whether they are mutable (i.e. whether they allow for modifying the pixel they refer to), to get the immutable (read-only) type of the iterator, and to determine whether they are plain iterators or adaptors over another pixel iterator:<p>
<div class="fragment"><pre class="fragment">concept PixelIteratorConcept&lt;RandomAccessTraversalIteratorConcept Iterator&gt; : PixelBasedConcept&lt;Iterator&gt; {
    where PixelValueConcept&lt;value_type&gt;;
    <span class="keyword">typename</span> const_iterator_type&lt;It&gt;::type;         
        where PixelIteratorConcept&lt;const_iterator_type&lt;It&gt;::type&gt;;
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span>  iterator_is_mutable&lt;It&gt;::type::value;          
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span>  is_iterator_adaptor&lt;It&gt;::type::value;   <span class="comment">// is it an iterator adaptor</span>
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;
concept MutablePixelIteratorConcept : PixelIteratorConcept&lt;Iterator&gt;, MutableRandomAccessIteratorConcept&lt;Iterator&gt; {};
</pre></div><p>
<b>Related Concepts:</b><p>
<ul>
<li>PixelIteratorConcept&lt;Iterator&gt;</li><li>MutablePixelIteratorConcept&lt;Iterator&gt;</li></ul>
<p>
<b>Models:</b><p>
A built-in pointer to pixel, <code>pixel&lt;ChannelValue,Layout&gt;*</code>, is GIL's model for pixel iterator over interleaved homogeneous pixels. Similarly, <code>packed_pixel&lt;PixelData,ChannelRefVec,Layout&gt;*</code> is GIL's model for an iterator over interleaved packed pixels.<p>
For planar homogeneous pixels, GIL provides the class <code>planar_pixel_iterator</code>, templated over a channel iterator and color space. Here is how the standard mutable and read-only planar RGB iterators over unsigned char are defined:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelPtr, <span class="keyword">typename</span> ColorSpace&gt; <span class="keyword">struct </span>planar_pixel_iterator;

<span class="comment">// GIL provided typedefs</span>
<span class="keyword">typedef</span> planar_pixel_iterator&lt;const bits8*, rgb_t&gt; rgb8c_planar_ptr_t;
<span class="keyword">typedef</span> planar_pixel_iterator&lt;      bits8*, rgb_t&gt; rgb8_planar_ptr_t;
</pre></div><p>
<code>planar_pixel_iterator</code> also models <code>HomogeneousColorBaseConcept</code> (it subclasses from <code>homogeneous_color_base</code>) and, as a result, all color base algorithms apply to it. The element type of its color base is a channel iterator. For example, GIL implements <code>operator++</code> of planar iterators approximately like this:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">struct </span>inc : <span class="keyword">public</span> std::unary_function&lt;T,T&gt; {
    T operator()(T x)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ++x; }
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelPtr, <span class="keyword">typename</span> ColorSpace&gt;
planar_pixel_iterator&lt;ChannelPtr,ColorSpace&gt;&amp; 
planar_pixel_iterator&lt;ChannelPtr,ColorSpace&gt;::operator++() {
    static_transform(*<span class="keyword">this</span>,*<span class="keyword">this</span>,inc&lt;ChannelPtr&gt;());
    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div><p>
Since <code>static_transform</code> uses compile-time recursion, incrementing an instance of <code>rgb8_planar_ptr_t</code> amounts to three pointer increments. GIL also uses the class bit_aligned_pixel_iterator as a model for a pixel iterator over bit-aligned pixels. Internally it keeps track of the current byte and the bit offset.<h2><a class="anchor" name="IteratorAdaptorDG">
Iterator Adaptor</a></h2>
Iterator adaptor is an iterator that wraps around another iterator. Its <code>is_iterator_adaptor</code> metafunction must evaluate to true, and it needs to provide a member method to return the base iterator, a metafunction to get its type, and a metafunction to rebind to another base iterator:<p>
<div class="fragment"><pre class="fragment">concept IteratorAdaptorConcept&lt;RandomAccessTraversalIteratorConcept Iterator&gt; {
    where SameType&lt;is_iterator_adaptor&lt;Iterator&gt;::type, mpl::true_&gt;;

    <span class="keyword">typename</span> iterator_adaptor_get_base&lt;Iterator&gt;;
        where Metafunction&lt;iterator_adaptor_get_base&lt;Iterator&gt; &gt;;
        where boost_concepts::ForwardTraversalConcept&lt;iterator_adaptor_get_base&lt;Iterator&gt;::type&gt;;
    
    <span class="keyword">typename</span> another_iterator; 
    <span class="keyword">typename</span> iterator_adaptor_rebind&lt;Iterator,another_iterator&gt;::type;
        where boost_concepts::ForwardTraversalConcept&lt;another_iterator&gt;;
        where IteratorAdaptorConcept&lt;iterator_adaptor_rebind&lt;Iterator,another_iterator&gt;::type&gt;;

    <span class="keyword">const</span> iterator_adaptor_get_base&lt;Iterator&gt;::type&amp; Iterator::base() <span class="keyword">const</span>;
};

<span class="keyword">template</span> &lt;boost_concepts::Mutable_ForwardIteratorConcept Iterator&gt;
concept MutableIteratorAdaptorConcept : IteratorAdaptorConcept&lt;Iterator&gt; {};
</pre></div><p>
<b>Related Concepts:</b><p>
<ul>
<li>IteratorAdaptorConcept&lt;Iterator&gt;</li><li>MutableIteratorAdaptorConcept&lt;Iterator&gt;</li></ul>
<p>
<b>Models:</b><p>
GIL provides several models of IteratorAdaptorConcept:<ul>
<li><code>memory_based_step_iterator&lt;Iterator&gt;</code>: An iterator adaptor that changes the fundamental step of the base iterator (see <a class="el" href="gildesignguide.html#StepIteratorDG">Step Iterator</a>)</li><li><code>dereference_iterator_adaptor&lt;Iterator</code>,Fn&gt;: An iterator that applies a unary function <code>Fn</code> upon dereferencing. It is used, for example, for on-the-fly color conversion. It can be used to construct a shallow image "view" that pretends to have a different color space or channel depth. See <a class="el" href="gildesignguide.html#ImageViewFrowImageViewDG">Creating Image Views from Other Image Views</a> for more. The unary function <code>Fn</code> must model <code>PixelDereferenceAdaptorConcept</code> (see below).</li></ul>
<h2><a class="anchor" name="PixelDereferenceAdaptorAG">
Pixel Dereference Adaptor</a></h2>
Pixel dereference adaptor is a unary function that can be applied upon dereferencing a pixel iterator. Its argument type could be anything (usually a <code>PixelConcept</code>) and the result type must be convertible to <code>PixelConcept</code> <p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;boost::UnaryFunctionConcept D&gt;
concept PixelDereferenceAdaptorConcept : DefaultConstructibleConcept&lt;D&gt;, CopyConstructibleConcept&lt;D&gt;, AssignableConcept&lt;D&gt;  {
    <span class="keyword">typename</span> const_t;         where PixelDereferenceAdaptorConcept&lt;const_t&gt;;
    <span class="keyword">typename</span> value_type;      where PixelValueConcept&lt;value_type&gt;;
    <span class="keyword">typename</span> reference;       where PixelConcept&lt;remove_reference&lt;reference&gt;::type&gt;;  <span class="comment">// may be mutable</span>
    <span class="keyword">typename</span> const_reference;   <span class="comment">// must not be mutable</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> D::is_mutable;

    where Convertible&lt;value_type, result_type&gt;;
};
</pre></div><p>
<b>Models:</b><p>
GIL provides several models of <code>PixelDereferenceAdaptorConcept</code> <ul>
<li><code>color_convert_deref_fn:</code> a function object that performs color conversion</li><li><code>detail::nth_channel_deref_fn:</code> a function object that returns a grayscale pixel corresponding to the n-th channel of a given pixel</li><li><code>deref_compose:</code> a function object that composes two models of <code>PixelDereferenceAdaptorConcept</code>. Similar to <code>std::unary_compose</code>, except it needs to pull the additional typedefs required by <code>PixelDereferenceAdaptorConcept</code> </li></ul>
<p>
GIL uses pixel dereference adaptors to implement image views that perform color conversion upon dereferencing, or that return the N-th channel of the underlying pixel. They can be used to model virtual image views that perform an arbitrary function upon dereferencing, for example a view of the Mandelbrot set. <code>dereference_iterator_adaptor&lt;Iterator,Fn&gt;</code> is an iterator wrapper over a pixel iterator <code>Iterator</code> that invokes the given dereference iterator adaptor <code>Fn</code> upon dereferencing.<h2><a class="anchor" name="StepIteratorDG">
Step Iterator</a></h2>
Sometimes we want to traverse pixels with a unit step other than the one provided by the fundamental pixel iterators. Examples where this would be useful:<ul>
<li>a single-channel view of the red channel of an RGB interleaved image</li><li>left-to-right flipped image (step = -fundamental_step)</li><li>subsampled view, taking every N-th pixel (step = N*fundamental_step)</li><li>traversal in vertical direction (step = number of bytes per row)</li><li>any combination of the above (steps are multiplied)</li></ul>
<p>
Step iterators are forward traversal iterators that allow changing the step between adjacent values:<p>
<div class="fragment"><pre class="fragment">concept StepIteratorConcept&lt;boost_concepts::ForwardTraversalConcept Iterator&gt; {
    <span class="keyword">template</span> &lt;Integral D&gt; <span class="keywordtype">void</span> Iterator::set_step(D step);
};

concept MutableStepIteratorConcept&lt;boost_concepts::Mutable_ForwardIteratorConcept Iterator&gt; : StepIteratorConcept&lt;Iterator&gt; {};
</pre></div><p>
GIL currently provides a step iterator whose <code>value_type</code> models <code>PixelValueConcept</code>. In addition, the step is specified in memory units (which are bytes or bits). This is necessary, for example, when implementing an iterator navigating along a column of pixels - the size of a row of pixels may sometimes not be divisible by the size of a pixel; for example rows may be word-aligned.<p>
To advance in bytes/bits, the base iterator must model MemoryBasedIteratorConcept. A memory-based iterator has an inherent memory unit, which is either a bit or a byte. It must supply functions returning the number of bits per memory unit (1 or 8), the current step in memory units, the memory-unit distance between two iterators, and a reference a given distance in memunits away. It must also supply a function that advances an iterator a given distance in memory units. <code>memunit_advanced</code> and <code>memunit_advanced_ref</code> have a default implementation but some iterators may supply a more efficient version:<p>
<div class="fragment"><pre class="fragment">concept MemoryBasedIteratorConcept&lt;boost_concepts::RandomAccessTraversalConcept Iterator&gt; {
    <span class="keyword">typename</span> byte_to_memunit&lt;Iterator&gt;; where metafunction&lt;byte_to_memunit&lt;Iterator&gt; &gt;;
    std::ptrdiff_t      memunit_step(<span class="keyword">const</span> Iterator&amp;);
    std::ptrdiff_t      memunit_distance(<span class="keyword">const</span> Iterator&amp; , <span class="keyword">const</span> Iterator&amp;);
    <span class="keywordtype">void</span>                memunit_advance(Iterator&amp;, std::ptrdiff_t diff);
    Iterator            memunit_advanced(<span class="keyword">const</span> Iterator&amp; p, std::ptrdiff_t diff) { Iterator tmp; memunit_advance(tmp,diff); <span class="keywordflow">return</span> tmp; }
    Iterator::reference memunit_advanced_ref(<span class="keyword">const</span> Iterator&amp; p, std::ptrdiff_t diff) { <span class="keywordflow">return</span> *memunit_advanced(p,diff); }
};
</pre></div><p>
It is useful to be able to construct a step iterator over another iterator. More generally, given a type, we want to be able to construct an equivalent type that allows for dynamically specified horizontal step:<p>
<div class="fragment"><pre class="fragment">concept HasDynamicXStepTypeConcept&lt;typename T&gt; {
    <span class="keyword">typename</span> dynamic_x_step_type&lt;T&gt;;
        where Metafunction&lt;dynamic_x_step_type&lt;T&gt; &gt;;
};
</pre></div><p>
All models of pixel iterators, locators and image views that GIL provides support <code>HasDynamicXStepTypeConcept</code>.<p>
<b>Related Concepts:</b><p>
<ul>
<li>StepIteratorConcept&lt;Iterator&gt;</li><li>MutableStepIteratorConcept&lt;Iterator&gt;</li><li>MemoryBasedIteratorConcept&lt;Iterator&gt;</li><li>HasDynamicXStepTypeConcept&lt;T&gt;</li></ul>
<p>
<b>Models:</b><p>
All standard memory-based iterators GIL currently provides model <code>MemoryBasedIteratorConcept</code>. GIL provides the class <code>memory_based_step_iterator</code> which models <code>PixelIteratorConcept</code>, <code>StepIteratorConcept</code>, and <code>MemoryBasedIteratorConcept</code>. It takes the base iterator as a template parameter (which must model <code>PixelIteratorConcept</code> and <code>MemoryBasedIteratorConcept</code>) and allows changing the step dynamically. GIL's implementation contains the base iterator and a <code>ptrdiff_t</code> denoting the number of memory units (bytes or bits) to skip for a unit step. It may also be used with a negative number. GIL provides a function to create a step iterator from a base iterator and a step:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt;  <span class="comment">// Models MemoryBasedIteratorConcept, HasDynamicXStepTypeConcept</span>
<span class="keyword">typename</span> dynamic_x_step_type&lt;I&gt;::type make_step_iterator(<span class="keyword">const</span> I&amp; it, std::ptrdiff_t step);
</pre></div><p>
GIL also provides a model of an iterator over a virtual array of pixels, <code>position_iterator</code>. It is a step iterator that keeps track of the pixel position and invokes a function object to get the value of the pixel upon dereferencing. It models <code>PixelIteratorConcept</code> and <code>StepIteratorConcept</code> but not <code>MemoryBasedIteratorConcept</code>.<h2><a class="anchor" name="LocatorDG">
Pixel Locator</a></h2>
A Locator allows for navigation in two or more dimensions. Locators are N-dimensional iterators in spirit, but we use a different name because they don't satisfy all the requirements of iterators. For example, they don't supply increment and decrement operators because it is unclear which dimension the operators should advance along. N-dimensional locators model the following concept:<p>
<div class="fragment"><pre class="fragment">concept RandomAccessNDLocatorConcept&lt;Regular Loc&gt; {    
    <span class="keyword">typename</span> value_type;        <span class="comment">// value over which the locator navigates</span>
    <span class="keyword">typename</span> reference;         <span class="comment">// result of dereferencing</span>
    <span class="keyword">typename</span> difference_type; where PointNDConcept&lt;difference_type&gt;; <span class="comment">// return value of operator-.</span>
    <span class="keyword">typename</span> const_t;           <span class="comment">// same as Loc, but operating over immutable values</span>
    <span class="keyword">typename</span> cached_location_t; <span class="comment">// type to store relative location (for efficient repeated access)</span>
    <span class="keyword">typename</span> point_t  = difference_type;
    
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_dimensions; <span class="comment">// dimensionality of the locator</span>
    where num_dimensions = point_t::num_dimensions;
    
    <span class="comment">// The difference_type and iterator type along each dimension. The iterators may only differ in </span>
    <span class="comment">// difference_type. Their value_type must be the same as Loc::value_type</span>
    <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> D&gt; <span class="keyword">struct </span>axis {
        <span class="keyword">typename</span> coord_t = point_t::axis&lt;D&gt;::coord_t;
        <span class="keyword">typename</span> iterator; where RandomAccessTraversalConcept&lt;iterator&gt;; <span class="comment">// iterator along D-th axis.</span>
        where iterator::value_type == value_type;
    };

    <span class="comment">// Defines the type of a locator similar to this type, except it invokes Deref upon dereferencing</span>
    <span class="keyword">template</span> &lt;PixelDereferenceAdaptorConcept Deref&gt; <span class="keyword">struct </span>add_deref {
        <span class="keyword">typename</span> type;        where RandomAccessNDLocatorConcept&lt;type&gt;;
        <span class="keyword">static</span> type make(<span class="keyword">const</span> Loc&amp; loc, <span class="keyword">const</span> Deref&amp; deref);
    };
    
    Loc&amp; operator+=(Loc&amp;, <span class="keyword">const</span> difference_type&amp;);
    Loc&amp; operator-=(Loc&amp;, <span class="keyword">const</span> difference_type&amp;);
    Loc operator+(<span class="keyword">const</span> Loc&amp;, <span class="keyword">const</span> difference_type&amp;);
    Loc operator-(<span class="keyword">const</span> Loc&amp;, <span class="keyword">const</span> difference_type&amp;);
    
    reference operator*(<span class="keyword">const</span> Loc&amp;);
    reference operator[](<span class="keyword">const</span> Loc&amp;, <span class="keyword">const</span> difference_type&amp;);
 
    <span class="comment">// Storing relative location for faster repeated access and accessing it   </span>
    cached_location_t Loc::cache_location(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;
    reference operator[](<span class="keyword">const</span> Loc&amp;,<span class="keyword">const</span> cached_location_t&amp;);
    
    <span class="comment">// Accessing iterators along a given dimension at the current location or at a given offset</span>
    <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> D&gt; axis&lt;D&gt;::iterator&amp;       Loc::axis_iterator();
    <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> D&gt; axis&lt;D&gt;::iterator <span class="keyword">const</span>&amp; Loc::axis_iterator() <span class="keyword">const</span>;
    <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> D&gt; axis&lt;D&gt;::iterator        Loc::axis_iterator(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Loc&gt;
concept MutableRandomAccessNDLocatorConcept : RandomAccessNDLocatorConcept&lt;Loc&gt; {    
    where Mutable&lt;reference&gt;;
};
</pre></div><p>
Two-dimensional locators have additional requirements:<p>
<div class="fragment"><pre class="fragment">concept RandomAccess2DLocatorConcept&lt;RandomAccessNDLocatorConcept Loc&gt; {
    where num_dimensions==2;
    where Point2DConcept&lt;point_t&gt;;
    
    <span class="keyword">typename</span> x_iterator = axis&lt;0&gt;::iterator;
    <span class="keyword">typename</span> y_iterator = axis&lt;1&gt;::iterator;
    <span class="keyword">typename</span> x_coord_t  = axis&lt;0&gt;::coord_t;
    <span class="keyword">typename</span> y_coord_t  = axis&lt;1&gt;::coord_t;
    
    <span class="comment">// Only available to locators that have dynamic step in Y</span>
    <span class="comment">//Loc::Loc(const Loc&amp; loc, y_coord_t);</span>

    <span class="comment">// Only available to locators that have dynamic step in X and Y</span>
    <span class="comment">//Loc::Loc(const Loc&amp; loc, x_coord_t, y_coord_t, bool transposed=false);</span>

    x_iterator&amp;       Loc::x();
    x_iterator <span class="keyword">const</span>&amp; Loc::x() <span class="keyword">const</span>;    
    y_iterator&amp;       Loc::y();
    y_iterator <span class="keyword">const</span>&amp; Loc::y() <span class="keyword">const</span>;    
    
    x_iterator Loc::x_at(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;
    y_iterator Loc::y_at(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;
    Loc Loc::xy_at(<span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>;
    
    <span class="comment">// x/y versions of all methods that can take difference type</span>
    x_iterator        Loc::x_at(x_coord_t, y_coord_t) <span class="keyword">const</span>;
    y_iterator        Loc::y_at(x_coord_t, y_coord_t) <span class="keyword">const</span>;
    Loc               Loc::xy_at(x_coord_t, y_coord_t) <span class="keyword">const</span>;
    reference         operator()(<span class="keyword">const</span> Loc&amp;, x_coord_t, y_coord_t);
    cached_location_t Loc::cache_location(x_coord_t, y_coord_t) <span class="keyword">const</span>;

    <span class="keywordtype">bool</span>      Loc::is_1d_traversable(x_coord_t width) <span class="keyword">const</span>;
    y_coord_t Loc::y_distance_to(<span class="keyword">const</span> Loc&amp; loc2, x_coord_t x_diff) <span class="keyword">const</span>;
};

concept MutableRandomAccess2DLocatorConcept&lt;RandomAccess2DLocatorConcept Loc&gt; : MutableRandomAccessNDLocatorConcept&lt;Loc&gt; {};
</pre></div><p>
2D locators can have a dynamic step not just horizontally, but also vertically. This gives rise to the Y equivalent of <code>HasDynamicXStepTypeConcept:</code> <p>
<div class="fragment"><pre class="fragment">concept HasDynamicYStepTypeConcept&lt;typename T&gt; {
    <span class="keyword">typename</span> dynamic_y_step_type&lt;T&gt;;
        where Metafunction&lt;dynamic_y_step_type&lt;T&gt; &gt;;
};
</pre></div><p>
All locators and image views that GIL provides model <code>HasDynamicYStepTypeConcept</code>.<p>
Sometimes it is necessary to swap the meaning of X and Y for a given locator or image view type (for example, GIL provides a function to transpose an image view). Such locators and views must be transposable:<p>
<div class="fragment"><pre class="fragment">concept HasTransposedTypeConcept&lt;typename T&gt; {
    <span class="keyword">typename</span> transposed_type&lt;T&gt;;
        where Metafunction&lt;transposed_type&lt;T&gt; &gt;;
};
</pre></div><p>
All GIL provided locators and views model <code>HasTransposedTypeConcept</code>.<p>
The locators GIL uses operate over models of <code>PixelConcept</code> and their x and y dimension types are the same. They model the following concept:<p>
<div class="fragment"><pre class="fragment">concept PixelLocatorConcept&lt;RandomAccess2DLocatorConcept Loc&gt; {
    where PixelValueConcept&lt;value_type&gt;;
    where PixelIteratorConcept&lt;x_iterator&gt;;
    where PixelIteratorConcept&lt;y_iterator&gt;;
    where x_coord_t == y_coord_t;

    <span class="keyword">typename</span> coord_t = x_coord_t;
};

concept MutablePixelLocatorConcept&lt;PixelLocatorConcept Loc&gt; : MutableRandomAccess2DLocatorConcept&lt;Loc&gt; {};
</pre></div><p>
<b>Related Concepts:</b><p>
<ul>
<li>HasDynamicYStepTypeConcept&lt;T&gt;</li><li>HasTransposedTypeConcept&lt;T&gt;</li><li>RandomAccessNDLocatorConcept&lt;Locator&gt;</li><li>MutableRandomAccessNDLocatorConcept&lt;Locator&gt;</li><li>RandomAccess2DLocatorConcept&lt;Locator&gt;</li><li>MutableRandomAccess2DLocatorConcept&lt;Locator&gt;</li><li>PixelLocatorConcept&lt;Locator&gt;</li><li>MutablePixelLocatorConcept&lt;Locator&gt;</li></ul>
<p>
<b>Models:</b><p>
GIL provides two models of <code>PixelLocatorConcept</code> - a memory-based locator, <code>memory_based_2d_locator</code> and a virtual locator <code>virtual_2d_locator</code>.<p>
<code>memory_based_2d_locator</code> is a locator over planar or interleaved images that have their pixels in memory. It takes a model of <code>StepIteratorConcept</code> over pixels as a template parameter. (When instantiated with a model of <code>MutableStepIteratorConcept</code>, it models <code>MutablePixelLocatorConcept</code>).<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> StepIterator&gt;  <span class="comment">// Models StepIteratorConcept, MemoryBasedIteratorConcept</span>
<span class="keyword">class </span>memory_based_2d_locator;
</pre></div><p>
The step of <code>StepIterator</code> must be the number of memory units (bytes or bits) per row (thus it must be memunit advanceable). The class <code>memory_based_2d_locator</code> is a wrapper around <code>StepIterator</code> and uses it to navigate vertically, while its base iterator is used to navigate horizontally.<p>
Combining fundamental and step iterators allows us to create locators that describe complex pixel memory organizations. First, we have a choice of iterator to use for horizontal direction, i.e. for iterating over the pixels on the same row. Using the fundamental and step iterators gives us four choices:<ul>
<li><code>pixel&lt;T,C&gt;*</code> (for interleaved images)</li><li><code>planar_pixel_iterator&lt;T*,C&gt;</code> (for planar images)</li><li><code>memory_based_step_iterator&lt;pixel&lt;T,C&gt;*&gt;</code> (for interleaved images with non-standard step)</li><li><code> memory_based_step_iterator&lt;planar_pixel_iterator&lt;T*,C&gt; &gt; </code> (for planar images with non-standard step)</li></ul>
<p>
Of course, one could provide their own custom x-iterator. One such example described later is an iterator adaptor that performs color conversion when dereferenced.<p>
Given a horizontal iterator <code>XIterator</code>, we could choose the <em>y-iterator</em>, the iterator that moves along a column, as <code>memory_based_step_iterator&lt;XIterator&gt;</code> with a step equal to the number of memory units (bytes or bits) per row. Again, one is free to provide their own y-iterator.<p>
Then we can instantiate <code>memory_based_2d_locator&lt;memory_based_step_iterator&lt;XIterator&gt;</code> &gt; to obtain a 2D pixel locator, as the diagram indicates: <div align="center">
<img src="step_iterator.gif" alt="step_iterator.gif">
</div>
<p>
<code>virtual_2d_locator</code> is a locator that is instantiated with a function object invoked upon dereferencing a pixel. It returns the value of a pixel given its X,Y coordiantes. Virtual locators can be used to implement virtual image views that can model any user-defined function. See the GIL tutorial for an example of using virtual locators to create a view of the Mandelbrot set.<p>
Both the virtual and the memory-based locators subclass from <code>pixel_2d_locator_base</code>, a base class that provides most of the interface required by <code>PixelLocatorConcept</code>. Users may find this base class useful if they need to provide other models of <code>PixelLocatorConcept</code>.<p>
Here is some sample code using locators:<p>
<div class="fragment"><pre class="fragment">loc=img.xy_at(10,10);            <span class="comment">// start at pixel (x=10,y=10)</span>
above=loc.cache_location(0,-1);  <span class="comment">// remember relative locations of neighbors above and below</span>
below=loc.cache_location(0, 1);
++loc.x();                       <span class="comment">// move to (11,10)</span>
loc.y()+=15;                     <span class="comment">// move to (11,25)</span>
loc-=point2&lt;std::ptrdiff_t&gt;(1,1);<span class="comment">// move to (10,24)</span>
*loc=(loc(0,-1)+loc(0,1))/2;     <span class="comment">// set pixel (10,24) to the average of (10,23) and (10,25) (grayscale pixels only)</span>
*loc=(loc[above]+loc[below])/2;  <span class="comment">// the same, but faster using cached relative neighbor locations</span>
</pre></div><p>
The standard GIL locators are fast and lightweight objects. For example, the locator for a simple interleaved image consists of one raw pointer to the pixel location plus one integer for the row size in bytes, for a total of 8 bytes. <code> ++loc.x() </code> amounts to incrementing a raw pointer (or N pointers for planar images). Computing 2D offsets is slower as it requires multiplication and addition. Filters, for example, need to access the same neighbors for every pixel in the image, in which case the relative positions can be cached into a raw byte difference using <code>cache_location</code>. In the above example <code> loc[above]</code> for simple interleaved images amounts to a raw array index operator.<h2><a class="anchor" name="IteratorFrom2DDG">
Iterator over 2D image</a></h2>
Sometimes we want to perform the same, location-independent operation over all pixels of an image. In such a case it is useful to represent the pixels as a one-dimensional array. GIL's <code>iterator_from_2d</code> is a random access traversal iterator that visits all pixels in an image in the natural memory-friendly order left-to-right inside top-to-bottom. It takes a locator, the width of the image and the current X position. This is sufficient information for it to determine when to do a "carriage return". Synopsis:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Locator&gt;  <span class="comment">// Models PixelLocatorConcept</span>
<span class="keyword">class </span>iterator_from_2d {
<span class="keyword">public</span>:
    iterator_from_2d(<span class="keyword">const</span> Locator&amp; loc, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> width);
    
    iterator_from_2d&amp; operator++(); <span class="comment">// if (++_x&lt;_width) ++_p.x(); else _p+=point_t(-_width,1);</span>

    ...
private:
    <span class="keywordtype">int</span> _x, _width;
    Locator _p;
};
</pre></div><p>
Iterating through the pixels in an image using <code>iterator_from_2d</code> is slower than going through all rows and using the x-iterator at each row. This is because two comparisons are done per iteration step - one for the end condition of the loop using the iterators, and one inside <code>iterator_from_2d::operator++</code> to determine whether we are at the end of a row. For fast operations, such as pixel copy, this second check adds about 15% performance delay (measured for interleaved images on Intel platform). GIL overrides some STL algorithms, such as <code>std::copy</code> and <code>std::fill</code>, when invoked with <code>iterator_from_2d-s</code>, to go through each row using their base x-iterators, and, if the image has no padding (i.e. <code>iterator_from_2d::is_1d_traversable()</code> returns true) to simply iterate using the x-iterators directly.<p>
<hr>
 <h2><a class="anchor" name="ImageViewSectionDG">
9. Image View</a></h2>
An image view is a generalization of STL's range concept to multiple dimensions. Similar to ranges (and iterators), image views are shallow, don't own the underlying data and don't propagate their constness over the data. For example, a constant image view cannot be resized, but may allow modifying the pixels. For pixel-immutable operations, use constant-value image view (also called non-mutable image view). Most general N-dimensional views satisfy the following concept:<p>
<div class="fragment"><pre class="fragment">concept RandomAccessNDImageViewConcept&lt;Regular View&gt; {
    <span class="keyword">typename</span> value_type;      <span class="comment">// for pixel-based views, the pixel type</span>
    <span class="keyword">typename</span> reference;       <span class="comment">// result of dereferencing</span>
    <span class="keyword">typename</span> difference_type; <span class="comment">// result of operator-(iterator,iterator) (1-dimensional!)</span>
    <span class="keyword">typename</span> const_t;  where RandomAccessNDImageViewConcept&lt;View&gt;; <span class="comment">// same as View, but over immutable values</span>
    <span class="keyword">typename</span> point_t;  where PointNDConcept&lt;point_t&gt;; <span class="comment">// N-dimensional point</span>
    <span class="keyword">typename</span> locator;  where RandomAccessNDLocatorConcept&lt;locator&gt;; <span class="comment">// N-dimensional locator.</span>
    <span class="keyword">typename</span> iterator; where RandomAccessTraversalConcept&lt;iterator&gt;; <span class="comment">// 1-dimensional iterator over all values</span>
    <span class="keyword">typename</span> reverse_iterator; where RandomAccessTraversalConcept&lt;reverse_iterator&gt;; 
    <span class="keyword">typename</span> size_type;       <span class="comment">// the return value of size()</span>

    <span class="comment">// Equivalent to RandomAccessNDLocatorConcept::axis</span>
    <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> D&gt; <span class="keyword">struct </span>axis {
        <span class="keyword">typename</span> coord_t = point_t::axis&lt;D&gt;::coord_t;
        <span class="keyword">typename</span> iterator; where RandomAccessTraversalConcept&lt;iterator&gt;;   <span class="comment">// iterator along D-th axis.</span>
        where SameType&lt;coord_t, iterator::difference_type&gt;;
        where SameType&lt;iterator::value_type,value_type&gt;;
    };

    <span class="comment">// Defines the type of a view similar to this type, except it invokes Deref upon dereferencing</span>
    <span class="keyword">template</span> &lt;PixelDereferenceAdaptorConcept Deref&gt; <span class="keyword">struct </span>add_deref {
        <span class="keyword">typename</span> type;        where RandomAccessNDImageViewConcept&lt;type&gt;;
        <span class="keyword">static</span> type make(<span class="keyword">const</span> View&amp; v, <span class="keyword">const</span> Deref&amp; deref);
    };

    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_dimensions = point_t::num_dimensions;
    
    <span class="comment">// Create from a locator at the top-left corner and dimensions</span>
    View::View(<span class="keyword">const</span> locator&amp;, <span class="keyword">const</span> point_type&amp;);
    
    size_type        View::size()       <span class="keyword">const</span>; <span class="comment">// total number of elements</span>
    reference        operator[](View, <span class="keyword">const</span> difference_type&amp;) <span class="keyword">const</span>; <span class="comment">// 1-dimensional reference</span>
    iterator         View::begin()      <span class="keyword">const</span>;
    iterator         View::end()        <span class="keyword">const</span>;
    reverse_iterator View::rbegin()     <span class="keyword">const</span>;
    reverse_iterator View::rend()       <span class="keyword">const</span>;
    iterator         View::at(<span class="keyword">const</span> point_t&amp;);
    point_t          View::dimensions() <span class="keyword">const</span>; <span class="comment">// number of elements along each dimension</span>
    <span class="keywordtype">bool</span>             View::is_1d_traversable() <span class="keyword">const</span>;   <span class="comment">// Does an iterator over the first dimension visit each value?</span>

    <span class="comment">// iterator along a given dimension starting at a given point</span>
    <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> D&gt; View::axis&lt;D&gt;::iterator View::axis_iterator(<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;

    reference operator()(View,<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;
};

concept MutableRandomAccessNDImageViewConcept&lt;RandomAccessNDImageViewConcept View&gt; {
    where Mutable&lt;reference&gt;;
};
</pre></div><p>
Two-dimensional image views have the following extra requirements:<p>
<div class="fragment"><pre class="fragment">concept RandomAccess2DImageViewConcept&lt;RandomAccessNDImageViewConcept View&gt; {
    where num_dimensions==2;

    <span class="keyword">typename</span> x_iterator = axis&lt;0&gt;::iterator;
    <span class="keyword">typename</span> y_iterator = axis&lt;1&gt;::iterator;
    <span class="keyword">typename</span> x_coord_t  = axis&lt;0&gt;::coord_t;
    <span class="keyword">typename</span> y_coord_t  = axis&lt;1&gt;::coord_t;
    <span class="keyword">typename</span> xy_locator = locator;
    
    x_coord_t View::width()  <span class="keyword">const</span>;
    y_coord_t View::height() <span class="keyword">const</span>;
    
    <span class="comment">// X-navigation</span>
    x_iterator View::x_at(<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;
    x_iterator View::row_begin(y_coord_t) <span class="keyword">const</span>;
    x_iterator View::row_end  (y_coord_t) <span class="keyword">const</span>;

    <span class="comment">// Y-navigation</span>
    y_iterator View::y_at(<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;
    y_iterator View::col_begin(x_coord_t) <span class="keyword">const</span>;
    y_iterator View::col_end  (x_coord_t) <span class="keyword">const</span>;
       
    <span class="comment">// navigating in 2D</span>
    xy_locator View::xy_at(<span class="keyword">const</span> point_t&amp;) <span class="keyword">const</span>;

    <span class="comment">// (x,y) versions of all methods taking point_t    </span>
    View::View(x_coord_t,y_coord_t,<span class="keyword">const</span> locator&amp;);
    iterator View::at(x_coord_t,y_coord_t) <span class="keyword">const</span>;
    reference operator()(View,x_coord_t,y_coord_t) <span class="keyword">const</span>;
    xy_locator View::xy_at(x_coord_t,y_coord_t) <span class="keyword">const</span>;
    x_iterator View::x_at(x_coord_t,y_coord_t) <span class="keyword">const</span>;
    y_iterator View::y_at(x_coord_t,y_coord_t) <span class="keyword">const</span>;
};

concept MutableRandomAccess2DImageViewConcept&lt;RandomAccess2DImageViewConcept View&gt;
  : MutableRandomAccessNDImageViewConcept&lt;View&gt; {};
</pre></div><p>
Image views that GIL typically uses operate on value types that model <code>PixelValueConcept</code> and have some additional requirements:<p>
<div class="fragment"><pre class="fragment">concept ImageViewConcept&lt;RandomAccess2DImageViewConcept View&gt; {
    where PixelValueConcept&lt;value_type&gt;;
    where PixelIteratorConcept&lt;x_iterator&gt;;        
    where PixelIteratorConcept&lt;y_iterator&gt;;
    where x_coord_t == y_coord_t;
    
    <span class="keyword">typename</span> coord_t = x_coord_t;

    std::size_t View::num_channels() <span class="keyword">const</span>;
};


concept MutableImageViewConcept&lt;ImageViewConcept View&gt; : MutableRandomAccess2DImageViewConcept&lt;View&gt; {};
</pre></div><p>
Two image views are compatible if they have compatible pixels and the same number of dimensions: <div class="fragment"><pre class="fragment">concept ViewsCompatibleConcept&lt;ImageViewConcept V1, ImageViewConcept V2&gt; {
    where PixelsCompatibleConcept&lt;V1::value_type, V2::value_type&gt;;
    where V1::num_dimensions == V2::num_dimensions;
};
</pre></div><p>
Compatible views must also have the same dimensions (i.e. the same width and height). Many algorithms taking multiple views require that they be pairwise compatible.<p>
<b>Related Concepts:</b><p>
<ul>
<li>RandomAccessNDImageViewConcept&lt;View&gt;</li><li>MutableRandomAccessNDImageViewConcept&lt;View&gt;</li><li>RandomAccess2DImageViewConcept&lt;View&gt;</li><li>MutableRandomAccess2DImageViewConcept&lt;View&gt;</li><li>ImageViewConcept&lt;View&gt;</li><li>MutableImageViewConcept&lt;View&gt;</li><li>ViewsCompatibleConcept&lt;View1,View2&gt;</li></ul>
<p>
<b>Models:</b><p>
GIL provides a model for <code>ImageViewConcept</code> called <code>image_view</code>. It is templated over a model of <code>PixelLocatorConcept</code>. (If instantiated with a model of <code>MutablePixelLocatorConcept</code>, it models <code>MutableImageViewConcept</code>). Synopsis:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Locator&gt;  <span class="comment">// Models PixelLocatorConcept (could be MutablePixelLocatorConcept)</span>
<span class="keyword">class </span>image_view {
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> Locator xy_locator;
    <span class="keyword">typedef</span> iterator_from_2d&lt;Locator&gt; iterator;
    ...
private:
    xy_locator _pixels;     <span class="comment">// 2D pixel locator at the top left corner of the image view range</span>
    point_t    _dimensions; <span class="comment">// width and height</span>
};
</pre></div><p>
Image views are lightweight objects. A regular interleaved view is typically 16 bytes long - two integers for the width and height (inside dimensions) one for the number of bytes between adjacent rows (inside the locator) and one pointer to the beginning of the pixel block.<p>
<b>Algorithms:</b><h3><a class="anchor" name="ImageViewFrowRawDG">
Creating Views from Raw Pixels</a></h3>
Standard image views can be constructed from raw data of any supported color space, bit depth, channel ordering or planar vs. interleaved structure. Interleaved views are constructed using <code>interleaved_view</code>, supplying the image dimensions, number of bytes per row, and a pointer to the first pixel:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt; <span class="comment">// Models pixel iterator (like rgb8_ptr_t or rgb8c_ptr_t)</span>
image_view&lt;...&gt; <a class="code" href="g_i_l_0140.html#g258d615c33c66b17c85b018297164df1" title="Constructing image views from raw interleaved pixel data.">interleaved_view</a>(ptrdiff_t width, ptrdiff_t height, Iterator pixels, ptrdiff_t rowsize)
</pre></div><p>
Planar views are defined for every color space and take each plane separately. Here is the RGB one:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IC&gt;  <span class="comment">// Models channel iterator (like bits8* or const bits8*)</span>
image_view&lt;...&gt; <a class="code" href="g_i_l_0140.html#g294f43780e7b88f43b91fdd6346cb51b" title="from raw RGB planar data">planar_rgb_view</a>(ptrdiff_t width, ptrdiff_t height,
                                 IC r, IC g, IC b, ptrdiff_t rowsize);
</pre></div><p>
Note that the supplied pixel/channel iterators could be constant (read-only), in which case the returned view is a constant-value (immutable) view.<h3><a class="anchor" name="ImageViewFrowImageViewDG">
Creating Image Views from Other Image Views</a></h3>
It is possible to construct one image view from another by changing some policy of how image data is interpreted. The result could be a view whose type is derived from the type of the source. GIL uses the following metafunctions to get the derived types:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Some result view types</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; 
<span class="keyword">struct </span>dynamic_xy_step_type : <span class="keyword">public</span> dynamic_y_step_type&lt;typename dynamic_x_step_type&lt;View&gt;::type&gt; {};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; 
<span class="keyword">struct </span>dynamic_xy_step_transposed_type : <span class="keyword">public</span> dynamic_xy_step_type&lt;typename transposed_type&lt;View&gt;::type&gt; {};

<span class="comment">// color and bit depth converted view to match pixel type P</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="comment">// Models ImageViewConcept</span>
          <span class="keyword">typename</span> DstP,    <span class="comment">// Models PixelConcept</span>
          <span class="keyword">typename</span> ColorConverter=gil::default_color_converter&gt;    
<span class="keyword">struct </span>color_converted_view_type {
    <span class="keyword">typedef</span> ... type;     <span class="comment">// image view adaptor with value type DstP, over SrcView</span>
};

<span class="comment">// single-channel view of the N-th channel of a given view</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView&gt;
<span class="keyword">struct </span>nth_channel_view_type {
    <span class="keyword">typedef</span> ... type;
};
</pre></div><p>
GIL Provides the following view transformations:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// flipped upside-down, left-to-right, transposed view</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_y_step_type&lt;View&gt;::type             flipped_up_down_view(<span class="keyword">const</span> View&amp; src);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_x_step_type&lt;View&gt;::type             flipped_left_right_view(<span class="keyword">const</span> View&amp; src);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_transposed_type&lt;View&gt;::type transposed_view(<span class="keyword">const</span> View&amp; src);

<span class="comment">// rotations</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_type&lt;View&gt;::type            rotated180_view(<span class="keyword">const</span> View&amp; src);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_transposed_type&lt;View&gt;::type rotated90cw_view(<span class="keyword">const</span> View&amp; src);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_transposed_type&lt;View&gt;::type rotated90ccw_view(<span class="keyword">const</span> View&amp; src);

<span class="comment">// view of an axis-aligned rectangular area within an image</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; View                                                 subimage_view(<span class="keyword">const</span> View&amp; src, 
             <span class="keyword">const</span> View::point_t&amp; top_left, <span class="keyword">const</span> View::point_t&amp; dimensions);

<span class="comment">// subsampled view (skipping pixels in X and Y)</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">typename</span> dynamic_xy_step_type&lt;View&gt;::type            subsampled_view(<span class="keyword">const</span> View&amp; src, 
             <span class="keyword">const</span> View::point_t&amp; step);

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, <span class="keyword">typename</span> P&gt; 
color_converted_view_type&lt;View,P&gt;::type                                       <a class="code" href="g_i_l_0161.html#gb5114cdb6c2a34f6706952f80baf2dfa" title="view of a different color space with a user defined color-converter">color_converted_view</a>(<span class="keyword">const</span> View&amp; src);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, <span class="keyword">typename</span> P, <span class="keyword">typename</span> CCV&gt; <span class="comment">// with a custom color converter</span>
color_converted_view_type&lt;View,P,CCV&gt;::type                                   <a class="code" href="g_i_l_0161.html#gb5114cdb6c2a34f6706952f80baf2dfa" title="view of a different color space with a user defined color-converter">color_converted_view</a>(<span class="keyword">const</span> View&amp; src);

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; 
nth_channel_view_type&lt;View&gt;::view_t                                           nth_channel_view(<span class="keyword">const</span> View&amp; <a class="code" href="g_i_l_0135.html#gad0335b7d343667d626556681486f198" title="Returns the non-constant-pixel view of an image.">view</a>, <span class="keywordtype">int</span> n);
</pre></div><p>
The implementations of most of these view factory methods are straightforward. Here is, for example, how the flip views are implemented. The flip upside-down view creates a view whose first pixel is the bottom left pixel of the original view and whose y-step is the negated step of the source.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt;
<span class="keyword">typename</span> dynamic_y_step_type&lt;View&gt;::type flipped_up_down_view(<span class="keyword">const</span> View&amp; src) { 
    gil_function_requires&lt;ImageViewConcept&lt;View&gt; &gt;();
    <span class="keyword">typedef</span> <span class="keyword">typename</span> dynamic_y_step_type&lt;View&gt;::type RView;
    <span class="keywordflow">return</span> RView(src.dimensions(),<span class="keyword">typename</span> RView::xy_locator(src.xy_at(0,src.height()-1),-1));
}
</pre></div><p>
The call to <code>gil_function_requires</code> ensures (at compile time) that the template parameter is a valid model of <code>ImageViewConcept</code>. Using it generates easier to track compile errors, creates no extra code and has no run-time performance impact. We are using the <code>boost::concept_check</code> library, but wrapping it in <code>gil_function_requires</code>, which performs the check if the <code>BOOST_GIL_USE_CONCEPT_CHECK</code> is set. It is unset by default, because there is a significant increase in compile time when using concept checks. We will skip <code>gil_function_requires</code> in the code examples in this guide for the sake of succinctness.<p>
Image views can be freely composed (see section <a class="el" href="gildesignguide.html#MetafunctionsDG">12. Useful Metafunctions and Typedefs</a> for the typedefs <code>rgb16_image_t</code> and <code>gray16_step_view_t</code>):<p>
<div class="fragment"><pre class="fragment">rgb16_image_t img(100,100);    <span class="comment">// an RGB interleaved image</span>

<span class="comment">// grayscale view over the green (index 1) channel of img</span>
gray16_step_view_t green=nth_channel_view(<a class="code" href="g_i_l_0135.html#gad0335b7d343667d626556681486f198" title="Returns the non-constant-pixel view of an image.">view</a>(img),1);

<span class="comment">// 50x50 view of the green channel of img, upside down and taking every other pixel in X and in Y</span>
gray16_step_view_t ud_fud=flipped_up_down_view(subsampled_view(green,2,2));
</pre></div><p>
As previously stated, image views are fast, constant-time, shallow views over the pixel data. The above code does not copy any pixels; it operates on the pixel data allocated when <code>img</code> was created.<h3><a class="anchor" name="ImageViewAlgorithmsDG">
STL-Style Algorithms on Image Views</a></h3>
Image views provide 1D iteration of their pixels via begin() and end() methods, which makes it possible to use STL algorithms with them. However, using nested loops over X and Y is in many cases more efficient. The algorithms in this section resemble STL algorithms, but they abstract away the nested loops and take views (as opposed to ranges) as input.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Equivalents of std::copy and std::uninitialized_copy</span>
<span class="comment">// where ImageViewConcept&lt;V1&gt;, MutableImageViewConcept&lt;V2&gt;, ViewsCompatibleConcept&lt;V1,V2&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2&gt;
<span class="keywordtype">void</span> <a class="code" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415" title="std::copy for image views">copy_pixels</a>(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2&gt;
<span class="keywordtype">void</span> <a class="code" href="g_i_l_0155.html#ge33d703beb3b085809b3b3ca64cc8906" title="std::uninitialized_copy for image views. Does not support planar heterogeneous views...">uninitialized_copy_pixels</a>(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst);

<span class="comment">// Equivalents of std::fill and std::uninitialized_fill</span>
<span class="comment">// where MutableImageViewConcept&lt;V&gt;, PixelConcept&lt;Value&gt;, PixelsCompatibleConcept&lt;Value,V::value_type&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> Value&gt;
<span class="keywordtype">void</span> <a class="code" href="g_i_l_0149.html#g3b28c66102763fd1d42f69e4eefa631f" title="std::fill for image views">fill_pixels</a>(<span class="keyword">const</span> V&amp; dst, <span class="keyword">const</span> Value&amp; val);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> Value&gt;
<span class="keywordtype">void</span> <a class="code" href="g_i_l_0156.html#g4f5edbc3fe6b776c6aa1939902333cf3" title="std::uninitialized_fill for image views. Does not support planar heterogeneous views...">uninitialized_fill_pixels</a>(<span class="keyword">const</span> V&amp; dst, <span class="keyword">const</span> Value&amp; val);

<span class="comment">// Equivalent of std::for_each</span>
<span class="comment">// where ImageViewConcept&lt;V&gt;, boost::UnaryFunctionConcept&lt;F&gt;</span>
<span class="comment">// where PixelsCompatibleConcept&lt;V::reference, F::argument_type&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> F&gt;
F for_each_pixel(<span class="keyword">const</span> V&amp; <a class="code" href="g_i_l_0135.html#gad0335b7d343667d626556681486f198" title="Returns the non-constant-pixel view of an image.">view</a>, F fun);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> F&gt;
F for_each_pixel_position(<span class="keyword">const</span> V&amp; <a class="code" href="g_i_l_0135.html#gad0335b7d343667d626556681486f198" title="Returns the non-constant-pixel view of an image.">view</a>, F fun);

<span class="comment">// Equivalent of std::generate</span>
<span class="comment">// where MutableImageViewConcept&lt;V&gt;, boost::UnaryFunctionConcept&lt;F&gt;</span>
<span class="comment">// where PixelsCompatibleConcept&lt;V::reference, F::argument_type&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> F&gt;
<span class="keywordtype">void</span> <a class="code" href="g_i_l_0152.html#gdce3525a9aa4794ba807cfb8c0100d2f" title="std::generate for image views">generate_pixels</a>(<span class="keyword">const</span> V&amp; dst, F fun);

<span class="comment">// Equivalent of std::transform with one source</span>
<span class="comment">// where ImageViewConcept&lt;V1&gt;, MutableImageViewConcept&lt;V2&gt;</span>
<span class="comment">// where boost::UnaryFunctionConcept&lt;F&gt;</span>
<span class="comment">// where PixelsCompatibleConcept&lt;V1::const_reference, F::argument_type&gt;</span>
<span class="comment">// where PixelsCompatibleConcept&lt;F::result_type, V2::reference&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> F&gt;
F <a class="code" href="g_i_l_0154.html#g27eed3931b4835e3757642ed41db0984" title="std::transform for image views">transform_pixels</a>(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst, F fun);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> F&gt;
F <a class="code" href="g_i_l_0153.html#gc74f3114086b954dfd1735a918f68389" title="Like transform_pixels but passes to the function object pixel locators instead of...">transform_pixel_positions</a>(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst, F fun);

<span class="comment">// Equivalent of std::transform with two sources</span>
<span class="comment">// where ImageViewConcept&lt;V1&gt;, ImageViewConcept&lt;V2&gt;, MutableImageViewConcept&lt;V3&gt;</span>
<span class="comment">// where boost::BinaryFunctionConcept&lt;F&gt;</span>
<span class="comment">// where PixelsCompatibleConcept&lt;V1::const_reference, F::first_argument_type&gt;</span>
<span class="comment">// where PixelsCompatibleConcept&lt;V2::const_reference, F::second_argument_type&gt;</span>
<span class="comment">// where PixelsCompatibleConcept&lt;F::result_type, V3::reference&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> V3, <span class="keyword">typename</span> F&gt;
F <a class="code" href="g_i_l_0154.html#g27eed3931b4835e3757642ed41db0984" title="std::transform for image views">transform_pixels</a>(<span class="keyword">const</span> V1&amp; src1, <span class="keyword">const</span> V2&amp; src2, <span class="keyword">const</span> V3&amp; dst, F fun);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> V3, <span class="keyword">typename</span> F&gt;
F <a class="code" href="g_i_l_0153.html#gc74f3114086b954dfd1735a918f68389" title="Like transform_pixels but passes to the function object pixel locators instead of...">transform_pixel_positions</a>(<span class="keyword">const</span> V1&amp; src1, <span class="keyword">const</span> V2&amp; src2, <span class="keyword">const</span> V3&amp; dst, F fun);

<span class="comment">// Copies a view into another, color converting the pixels if needed, with the default or user-defined color converter</span>
<span class="comment">// where ImageViewConcept&lt;V1&gt;, MutableImageViewConcept&lt;V2&gt;</span>
<span class="comment">// V1::value_type must be convertible to V2::value_type.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2&gt;
<span class="keywordtype">void</span> copy_and_convert_pixels(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2, <span class="keyword">typename</span> ColorConverter&gt;
<span class="keywordtype">void</span> copy_and_convert_pixels(<span class="keyword">const</span> V1&amp; src, <span class="keyword">const</span> V2&amp; dst, ColorConverter ccv);

<span class="comment">// Equivalent of std::equal</span>
<span class="comment">// where ImageViewConcept&lt;V1&gt;, ImageViewConcept&lt;V2&gt;, ViewsCompatibleConcept&lt;V1,V2&gt;</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V1, <span class="keyword">typename</span> V2&gt;
<span class="keywordtype">bool</span> <a class="code" href="g_i_l_0148.html#g86a5d26dbacd64b2bc4f53b4b2971a73" title="std::equal for image views">equal_pixels</a>(<span class="keyword">const</span> V1&amp; view1, <span class="keyword">const</span> V2&amp; view2);
</pre></div><p>
Algorithms that take multiple views require that they have the same dimensions. <code>for_each_pixel_position</code> and <code>transform_pixel_positions</code> pass pixel locators, as opposed to pixel references, to their function objects. This allows for writing algorithms that use pixel neighbors, as the tutorial demonstrates.<p>
Most of these algorithms check whether the image views are 1D-traversable. A 1D-traversable image view has no gaps at the end of the rows. In other words, if an x_iterator of that view is advanced past the last pixel in a row it will move to the first pixel of the next row. When image views are 1D-traversable, the algorithms use a single loop and run more efficiently. If one or more of the input views are not 1D-traversable, the algorithms fall-back to an X-loop nested inside a Y-loop.<p>
The algorithms typically delegate the work to their corresponding STL algorithms. For example, <code>copy_pixels</code> calls <code>std::copy</code> either for each row, or, when the images are 1D-traversable, once for all pixels.<p>
In addition, overloads are sometimes provided for the STL algorithms. For example, <code>std::copy</code> for planar iterators is overloaded to perform <code>std::copy</code> for each of the planes. <code>std::copy</code> over bitwise-copiable pixels results in <code>std::copy</code> over unsigned char, which STL typically implements via <code>memmove</code>.<p>
As a result <code>copy_pixels</code> may result in a single call to <code>memmove</code> for interleaved 1D-traversable views, or one per each plane of planar 1D-traversable views, or one per each row of interleaved non-1D-traversable images, etc.<p>
GIL also provides some beta-versions of image processing algorithms, such as resampling and convolution in a numerics extension available on <a href="http://stlab.adobe.com/gil/download.html.">http://stlab.adobe.com/gil/download.html.</a> This code is in early stage of development and is not optimized for speed<p>
<hr>
 <h2><a class="anchor" name="ImageSectionDG">
10. Image</a></h2>
An image is a container that owns the pixels of a given image view. It allocates them in its constructor and deletes them in the destructor. It has a deep assignment operator and copy constructor. Images are used rarely, just when data ownership is important. Most STL algorithms operate on ranges, not containers. Similarly most GIL algorithms operate on image views (which images provide).<p>
In the most general form images are N-dimensional and satisfy the following concept:<p>
<div class="fragment"><pre class="fragment">concept RandomAccessNDImageConcept&lt;typename Img&gt; : Regular&lt;Img&gt; {
    <span class="keyword">typename</span> view_t; where MutableRandomAccessNDImageViewConcept&lt;view_t&gt;;
    <span class="keyword">typename</span> const_view_t = view_t::const_t;
    <span class="keyword">typename</span> point_t      = view_t::point_t;
    <span class="keyword">typename</span> value_type   = view_t::value_type;
    <span class="keyword">typename</span> allocator_type;

    Img::Img(point_t dims, std::size_t alignment=0);
    Img::Img(point_t dims, value_type fill_value, std::size_t alignment);
    
    <span class="keywordtype">void</span> Img::recreate(point_t new_dims, std::size_t alignment=0);
    <span class="keywordtype">void</span> Img::recreate(point_t new_dims, value_type fill_value, std::size_t alignment);

    <span class="keyword">const</span> point_t&amp;        Img::dimensions() <span class="keyword">const</span>;
    <span class="keyword">const</span> const_view_t&amp;   <a class="code" href="g_i_l_0135.html#ged731349e60a30a3a241fd1809729996" title="Returns the constant-pixel view of an image.">const_view</a>(<span class="keyword">const</span> Img&amp;);
    <span class="keyword">const</span> view_t&amp;         <a class="code" href="g_i_l_0135.html#gad0335b7d343667d626556681486f198" title="Returns the non-constant-pixel view of an image.">view</a>(Img&amp;);
};
</pre></div><p>
Two-dimensional images have additional requirements:<p>
<div class="fragment"><pre class="fragment">concept RandomAccess2DImageConcept&lt;RandomAccessNDImageConcept Img&gt; {
    <span class="keyword">typename</span> x_coord_t = const_view_t::x_coord_t;
    <span class="keyword">typename</span> y_coord_t = const_view_t::y_coord_t;
    
    Img::Img(x_coord_t width, y_coord_t height, std::size_t alignment=0);
    Img::Img(x_coord_t width, y_coord_t height, value_type fill_value, std::size_t alignment);

    x_coord_t Img::width() <span class="keyword">const</span>;
    y_coord_t Img::height() <span class="keyword">const</span>;
    
    <span class="keywordtype">void</span> Img::recreate(x_coord_t width, y_coord_t height, std::size_t alignment=1);
    <span class="keywordtype">void</span> Img::recreate(x_coord_t width, y_coord_t height, value_type fill_value, std::size_t alignment);
};
</pre></div><p>
GIL's images have views that model <code>ImageViewConcept</code> and operate on pixels.<p>
<div class="fragment"><pre class="fragment">concept ImageConcept&lt;RandomAccess2DImageConcept Img&gt; {
    where MutableImageViewConcept&lt;view_t&gt;;
    <span class="keyword">typename</span> coord_t  = view_t::coord_t;
};
</pre></div><p>
Images, unlike locators and image views, don't have 'mutable' set of concepts because immutable images are not very useful.<p>
<b>Related Concepts:</b><p>
<ul>
<li>RandomAccessNDImageConcept&lt;Image&gt;</li><li>RandomAccess2DImageConcept&lt;Image&gt;</li><li>ImageConcept&lt;Image&gt;</li></ul>
<p>
<b>Models:</b><p>
GIL provides a class, <code>image</code>, which is templated over the value type (the pixel) and models <code>ImageConcept</code>.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pixel, \\ Models PixelValueConcept
          <span class="keywordtype">bool</span> IsPlanar,  \\ planar or interleaved image
          <span class="keyword">typename</span> A=std::allocator&lt;unsigned char&gt; &gt;    
<span class="keyword">class </span>image;
</pre></div><p>
The image constructor takes an alignment parameter which allows for constructing images that are word-aligned or 8-byte aligned. The alignment is specified in bytes. The default value for alignment is 0, which means there is no padding at the end of rows. Many operations are faster using such 1D-traversable images, because <code>image_view::x_iterator</code> can be used to traverse the pixels, instead of the more complicated <code>image_view::iterator</code>. Note that when alignment is 0, packed images are aligned to the bit - i.e. there are no padding bits at the end of rows of packed images. <hr>
 <h2><a class="anchor" name="VariantSecDG">
11. Run-time specified images and image views</a></h2>
The color space, channel depth, channel ordering, and interleaved/planar structure of an image are defined by the type of its template argument, which makes them compile-time bound. Often some of these parameters are available only at run time. Consider, for example, writing a module that opens the image at a given file path, rotates it and saves it back in its original color space and channel depth. How can we possibly write this using our generic image? What type is the image loading code supposed to return?<p>
GIL's dynamic_image extension allows for images, image views or any GIL constructs to have their parameters defined at run time. Here is an example: <div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="g_i_l_0083.html" title="Includes all of the GIL dynamic image extension files, for convenience.">boost/gil/extension/dynamic_image/dynamic_image_all.hpp</a>&gt;</span>
<span class="keyword">using namespace </span>boost;

<span class="preprocessor">#define ASSERT_SAME(A,B) BOOST_STATIC_ASSERT((is_same&lt; A,B &gt;::value))</span>
<span class="preprocessor"></span>
<span class="comment">// Define the set of allowed images</span>
<span class="keyword">typedef</span> mpl::vector&lt;rgb8_image_t, cmyk16_planar_image_t&gt; my_images_t;

<span class="comment">// Create any_image class (or any_image_view) class</span>
<span class="keyword">typedef</span> any_image&lt;my_images_t&gt; my_any_image_t;

<span class="comment">// Associated view types are available (equivalent to the ones in image_t)</span>
<span class="keyword">typedef</span> any_image_view&lt;mpl::vector2&lt;rgb8_view_t,  cmyk16_planar_view_t &gt; &gt; AV;
ASSERT_SAME(my_any_image_t::view_t, AV);

<span class="keyword">typedef</span> any_image_view&lt;mpl::vector2&lt;rgb8c_view_t, cmyk16c_planar_view_t&gt; &gt; CAV;
ASSERT_SAME(my_any_image_t::const_view_t, CAV);
ASSERT_SAME(my_any_image_t::const_view_t, my_any_image_t::view_t::const_t);

<span class="keyword">typedef</span> any_image_view&lt;mpl::vector2&lt;rgb8_step_view_t, cmyk16_planar_step_view_t&gt; &gt; SAV;
ASSERT_SAME(<span class="keyword">typename</span> dynamic_x_step_type&lt;my_any_image_t::view_t&gt;::type, SAV);

<span class="comment">// Assign it a concrete image at run time:</span>
my_any_image_t myImg = my_any_image_t(rgb8_image_t(100,100));

<span class="comment">// Change it to another at run time. The previous image gets destroyed</span>
myImg = cmyk16_planar_image_t(200,100);

<span class="comment">// Assigning to an image not in the allowed set throws an exception</span>
myImg = gray8_image_t();        <span class="comment">// will throw std::bad_cast</span>
</pre></div><p>
<code>any_image</code> and <code>any_image_view</code> subclass from GIL's <code>variant</code> class, which breaks down the instantiated type into a non-templated underlying base type and a unique instantiation type identifier. The underlying base instance is represented as a block of bytes. The block is large enough to hold the largest of the specified types.<p>
GIL's variant is similar to <code>boost::variant</code> in spirit (hence we borrow the name from there) but it differs in several ways from the current <a class="el" href="namespaceboost.html">boost</a> implementation. Perhaps the biggest difference is that GIL's variant always takes a single argument, which is a model of MPL Random Access Sequence enumerating the allowed types. Having a single interface allows GIL's variant to be used easier in generic code. Synopsis:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Types&gt;    <span class="comment">// models MPL Random Access Container</span>
<span class="keyword">class </span>variant {
    ...           _bits;
    std::size_t   _index;
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> Types types_t;

    variant();
    variant(<span class="keyword">const</span> variant&amp; v);
    <span class="keyword">virtual</span> ~variant();
    
    variant&amp; operator=(<span class="keyword">const</span> variant&amp; v);
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TS&gt; <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> variant&lt;TS&gt;&amp; x, <span class="keyword">const</span> variant&lt;TS&gt;&amp; y);
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TS&gt; <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> variant&lt;TS&gt;&amp; x, <span class="keyword">const</span> variant&lt;TS&gt;&amp; y);

    <span class="comment">// Construct/assign to type T. Throws std::bad_cast if T is not in Types</span>
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> variant(<span class="keyword">const</span> T&amp; obj);
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; variant&amp; operator=(<span class="keyword">const</span> T&amp; obj);

    <span class="comment">// Construct/assign by swapping T with its current instance. Only possible if they are swappable</span>
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> variant(T&amp; obj, <span class="keywordtype">bool</span> do_swap);
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> move_in(T&amp; obj);

    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">static</span> <span class="keywordtype">bool</span> has_type();

    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; _dynamic_cast() <span class="keyword">const</span>;
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;       T&amp; _dynamic_cast();
    
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">bool</span> current_type_is() <span class="keyword">const</span>;
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> UOP, <span class="keyword">typename</span> Types&gt; 
   UOP::result_type <a class="code" href="group___variant.html#g3c8fd0f3dc2495060bf062428dccc505" title="Invokes a generic mutable operation (represented as a unary function object) on a...">apply_operation</a>(variant&lt;Types&gt;&amp; v, UOP op);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> UOP, <span class="keyword">typename</span> Types&gt; 
   UOP::result_type <a class="code" href="group___variant.html#g3c8fd0f3dc2495060bf062428dccc505" title="Invokes a generic mutable operation (represented as a unary function object) on a...">apply_operation</a>(<span class="keyword">const</span> variant&lt;Types&gt;&amp; v, UOP op);

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BOP, <span class="keyword">typename</span> Types1, <span class="keyword">typename</span> Types2&gt; 
   BOP::result_type <a class="code" href="group___variant.html#g3c8fd0f3dc2495060bf062428dccc505" title="Invokes a generic mutable operation (represented as a unary function object) on a...">apply_operation</a>(      variant&lt;Types1&gt;&amp; v1,       variant&lt;Types2&gt;&amp; v2, UOP op);

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BOP, <span class="keyword">typename</span> Types1, <span class="keyword">typename</span> Types2&gt; 
   BOP::result_type <a class="code" href="group___variant.html#g3c8fd0f3dc2495060bf062428dccc505" title="Invokes a generic mutable operation (represented as a unary function object) on a...">apply_operation</a>(<span class="keyword">const</span> variant&lt;Types1&gt;&amp; v1,       variant&lt;Types2&gt;&amp; v2, UOP op);

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BOP, <span class="keyword">typename</span> Types1, <span class="keyword">typename</span> Types2&gt; 
   BOP::result_type <a class="code" href="group___variant.html#g3c8fd0f3dc2495060bf062428dccc505" title="Invokes a generic mutable operation (represented as a unary function object) on a...">apply_operation</a>(<span class="keyword">const</span> variant&lt;Types1&gt;&amp; v1, <span class="keyword">const</span> variant&lt;Types2&gt;&amp; v2, UOP op);
</pre></div><p>
GIL's <code>any_image_view</code> and <code>any_image</code> are subclasses of <code>variant:</code> <p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ImageViewTypes&gt;
<span class="keyword">class </span>any_image_view : <span class="keyword">public</span> variant&lt;ImageViewTypes&gt; {
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> ... const_t; <span class="comment">// immutable equivalent of this</span>
    <span class="keyword">typedef</span> std::ptrdiff_t x_coord_t;
    <span class="keyword">typedef</span> std::ptrdiff_t y_coord_t;
    <span class="keyword">typedef</span> point2&lt;std::ptrdiff_t&gt; point_t;

    any_image_view();
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> any_image_view(<span class="keyword">const</span> T&amp; obj);
    any_image_view(<span class="keyword">const</span> any_image_view&amp; v);

    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; any_image_view&amp; operator=(<span class="keyword">const</span> T&amp; obj);
    any_image_view&amp;                       operator=(<span class="keyword">const</span> any_image_view&amp; v);

    <span class="comment">// parameters of the currently instantiated view</span>
    std::size_t num_channels()  <span class="keyword">const</span>;
    point_t     dimensions()    <span class="keyword">const</span>;
    x_coord_t   width()         <span class="keyword">const</span>;
    y_coord_t   height()        <span class="keyword">const</span>;
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ImageTypes&gt;
<span class="keyword">class </span>any_image : <span class="keyword">public</span> variant&lt;ImageTypes&gt; {
    <span class="keyword">typedef</span> variant&lt;ImageTypes&gt; parent_t;
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> ... const_view_t;
    <span class="keyword">typedef</span> ... view_t;
    <span class="keyword">typedef</span> std::ptrdiff_t x_coord_t;
    <span class="keyword">typedef</span> std::ptrdiff_t y_coord_t;
    <span class="keyword">typedef</span> point2&lt;std::ptrdiff_t&gt; point_t;

    any_image();
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> any_image(<span class="keyword">const</span> T&amp; obj);
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">explicit</span> any_image(T&amp; obj, <span class="keywordtype">bool</span> do_swap);
    any_image(<span class="keyword">const</span> any_image&amp; v);

    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; any_image&amp; operator=(<span class="keyword">const</span> T&amp; obj);
    any_image&amp;                       operator=(<span class="keyword">const</span> any_image&amp; v);

    <span class="keywordtype">void</span> recreate(<span class="keyword">const</span> point_t&amp; dims, <span class="keywordtype">unsigned</span> alignment=1);
    <span class="keywordtype">void</span> recreate(x_coord_t width, y_coord_t height, <span class="keywordtype">unsigned</span> alignment=1);

    std::size_t num_channels()  <span class="keyword">const</span>;
    point_t     dimensions()    <span class="keyword">const</span>;
    x_coord_t   width()         <span class="keyword">const</span>;
    y_coord_t   height()        <span class="keyword">const</span>;
};
</pre></div><p>
Operations are invoked on variants via <code>apply_operation</code> passing a function object to perform the operation. The code for every allowed type in the variant is instantiated and the appropriate instantiation is selected via a switch statement. Since image view algorithms typically have time complexity at least linear on the number of pixels, the single switch statement of image view variant adds practically no measurable performance overhead compared to templated image views.<p>
Variants behave like the underlying type. Their copy constructor will invoke the copy constructor of the underlying instance. Equality operator will check if the two instances are of the same type and then invoke their operator==, etc. The default constructor of a variant will default-construct the first type. That means that <code>any_image_view</code> has shallow default-constructor, copy-constructor, assigment and equaty comparison, whereas <code>any_image</code> has deep ones.<p>
It is important to note that even though <code>any_image_view</code> and <code>any_image</code> resemble the static <code>image_view</code> and <code>image</code>, they do not model the full requirements of <code>ImageViewConcept</code> and <code>ImageConcept</code>. In particular they don't provide access to the pixels. There is no "any_pixel" or "any_pixel_iterator" in GIL. Such constructs could be provided via the <code>variant</code> mechanism, but doing so would result in inefficient algorithms, since the type resolution would have to be performed per pixel. Image-level algorithms should be implemented via <code>apply_operation</code>. That said, many common operations are shared between the static and dynamic types. In addition, all of the image view transformations and many STL-like image view algorithms have overloads operating on <code>any_image_view</code>, as illustrated with <code>copy_pixels:</code> <p>
<div class="fragment"><pre class="fragment">rgb8_view_t v1(...);  <span class="comment">// concrete image view</span>
bgr8_view_t v2(...);  <span class="comment">// concrete image view compatible with v1 and of the same size</span>
any_image_view&lt;Types&gt;  av(...);  <span class="comment">// run-time specified image view</span>

<span class="comment">// Copies the pixels from v1 into v2. </span>
<span class="comment">// If the pixels are incompatible triggers compile error </span>
<a class="code" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415" title="std::copy for image views">copy_pixels</a>(v1,v2);

<span class="comment">// The source or destination (or both) may be run-time instantiated.</span>
<span class="comment">// If they happen to be incompatible, throws std::bad_cast</span>
<a class="code" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415" title="std::copy for image views">copy_pixels</a>(v1, av);
<a class="code" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415" title="std::copy for image views">copy_pixels</a>(av, v2);
<a class="code" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415" title="std::copy for image views">copy_pixels</a>(av, av);
</pre></div><p>
By having algorithm overloads supporting dynamic constructs, we create a base upon which it is possible to write algorithms that can work with either compile-time or runtime images or views. The following code, for example, uses the GIL I/O extension to turn an image on disk upside down:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;boost\gil\extension\io\jpeg_dynamic_io.hpp&gt;</span>

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Image&gt;    <span class="comment">// Could be rgb8_image_t or any_image&lt;...&gt;</span>
<span class="keywordtype">void</span> save_180rot(<span class="keyword">const</span> std::string&amp; file_name) {
    Image img;
    <a class="code" href="g_i_l_0169.html#ga8d0be11619e190cef13ab79d7169398" title="reads a JPEG image into a run-time instantiated image Opens the given JPEG file name...">jpeg_read_image</a>(file_name, img);
    <a class="code" href="g_i_l_0169.html#g3a185bccf9e6716693003db876b25dde" title="Saves the currently instantiated view to a jpeg file specified by the given jpeg...">jpeg_write_view</a>(file_name, rotated180_view(<a class="code" href="g_i_l_0135.html#gad0335b7d343667d626556681486f198" title="Returns the non-constant-pixel view of an image.">view</a>(img)));
}
</pre></div><p>
It can be instantiated with either a compile-time or a runtime image because all functions it uses have overloads taking runtime constructs. For example, here is how <code>rotated180_view</code> is implemented:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// implementation using templated view</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; 
<span class="keyword">typename</span> dynamic_xy_step_type&lt;View&gt;::type rotated180_view(<span class="keyword">const</span> View&amp; src) { ... }

<span class="keyword">namespace </span>detail {
    <span class="comment">// the function, wrapped inside a function object</span>
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result&gt; <span class="keyword">struct </span>rotated180_view_fn {
        <span class="keyword">typedef</span> Result result_type;
        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; result_type operator()(<span class="keyword">const</span> View&amp; src)<span class="keyword"> const </span>{ 
            <span class="keywordflow">return</span> result_type(rotated180_view(src)); 
        }
    };
}

<span class="comment">// overloading of the function using variant. Takes and returns run-time bound view.</span>
<span class="comment">// The returned view has a dynamic step</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ViewTypes&gt; <span class="keyword">inline</span> <span class="comment">// Models MPL Random Access Container of models of ImageViewConcept</span>
<span class="keyword">typename</span> dynamic_xy_step_type&lt;any_image_view&lt;ViewTypes&gt; &gt;::type rotated180_view(<span class="keyword">const</span> any_image_view&lt;ViewTypes&gt;&amp; src) { 
    <span class="keywordflow">return</span> <a class="code" href="group___variant.html#g3c8fd0f3dc2495060bf062428dccc505" title="Invokes a generic mutable operation (represented as a unary function object) on a...">apply_operation</a>(src,detail::rotated180_view_fn&lt;<span class="keyword">typename</span> dynamic_xy_step_type&lt;any_image_view&lt;ViewTypes&gt; &gt;::type&gt;()); 
}
</pre></div><p>
Variants should be used with caution (especially algorithms that take more than one variant) because they instantiate the algorithm for every possible model that the variant can take. This can take a toll on compile time and executable size. Despite these limitations, <code>variant</code> is a powerful technique that allows us to combine the speed of compile-time resolution with the flexibility of run-time resolution. It allows us to treat images of different parameters uniformly as a collection and store them in the same container.<p>
<hr>
 <h2><a class="anchor" name="MetafunctionsDG">
12. Useful Metafunctions and Typedefs</a></h2>
Flexibility comes at a price. GIL types can be very long and hard to read. To address this problem, GIL provides typedefs to refer to any standard image, pixel iterator, pixel locator, pixel reference or pixel value. They follow this pattern: <p>
<em>ColorSpace</em> + <em>BitDepth</em> + ["s|f"] + ["c"] + ["_planar"] + ["_step"] + <em>ClassType</em> + "_t" <p>
Where <em>ColorSpace</em> also indicates the ordering of components. Examples are <code>rgb</code>, <code>bgr</code>, <code>cmyk</code>, <code>rgba</code>. <em>BitDepth</em> can be, for example, <code>8</code>,<code>16</code>,<code>32</code>. By default the bits are unsigned integral type. Append <code>s</code> to the bit depth to indicate signed integral, or <code>f</code> to indicate floating point. <code>c</code> indicates object whose associated pixel reference is immutable. <code>_planar</code> indicates planar organization (as opposed to interleaved). <code>_step</code> indicates the type has a dynamic step and <em>ClassType</em> is <code>_image</code> (image, using a standard allocator), <code>_view</code> (image view), <code>_loc</code> (pixel locator), <code>_ptr</code> (pixel iterator), <code>_ref</code> (pixel reference), <code>_pixel</code> (pixel value). Here are examples:<p>
<div class="fragment"><pre class="fragment">bgr8_image_t               i;     <span class="comment">// 8-bit unsigned (unsigned char) interleaved BGR image</span>
cmyk16_pixel_t;            x;     <span class="comment">// 16-bit unsigned (unsigned short) CMYK pixel value;</span>
cmyk16sc_planar_ref_t      p(x);  <span class="comment">// const reference to a 16-bit signed integral (signed short) planar CMYK pixel x.</span>
rgb32f_planar_step_ptr_t   ii;    <span class="comment">// step iterator to a floating point 32-bit (float) planar RGB pixel.</span>
</pre></div><p>
GIL provides the metafunctions that return the types of standard homogeneous memory-based GIL constructs given a channel type, a layout, and whether the construct is planar, has a step along the X direction, and is mutable:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false,                     <span class="keywordtype">bool</span> IsMutable=true&gt;
<span class="keyword">struct </span>pixel_reference_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Channel, <span class="keyword">typename</span> Layout&gt; 
<span class="keyword">struct </span>pixel_value_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsStep=false,  <span class="keywordtype">bool</span> IsMutable=true&gt;
<span class="keyword">struct </span>iterator_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsXStep=false, <span class="keywordtype">bool</span> IsMutable=true&gt;
<span class="keyword">struct </span>locator_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsXStep=false, <span class="keywordtype">bool</span> IsMutable=true&gt;
<span class="keyword">struct </span>view_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keyword">typename</span> Alloc=std::allocator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; &gt;
<span class="keyword">struct </span>image_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keyword">typename</span> ChannelBitSizeVector, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; &gt;
<span class="keyword">struct </span>packed_image_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChannelBitSizeVector, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; &gt;
<span class="keyword">struct </span>bit_aligned_image_type { <span class="keyword">typedef</span> ... type; };
</pre></div><p>
There are also helper metafunctions to construct packed and bit-aligned images with up to five channels:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>packed_image1_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>packed_image2_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>packed_image3_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <span class="keywordtype">unsigned</span> Size4, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>packed_image4_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BitField, <span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <span class="keywordtype">unsigned</span> Size4, <span class="keywordtype">unsigned</span> Size5, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>packed_image5_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>bit_aligned_image1_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2,
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>bit_aligned_image2_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>bit_aligned_image3_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <span class="keywordtype">unsigned</span> Size4, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>bit_aligned_image4_type { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> Size1, <span class="keywordtype">unsigned</span> Size2, <span class="keywordtype">unsigned</span> Size3, <span class="keywordtype">unsigned</span> Size4, <span class="keywordtype">unsigned</span> Size5, 
          <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> Alloc=std::allocator&lt;unsigned char&gt; &gt;
<span class="keyword">struct </span>bit_aligned_image5_type { <span class="keyword">typedef</span> ... type; };
</pre></div><p>
Here <code>ChannelValue</code> models <code>ChannelValueConcept</code>. We don't need <code>IsYStep</code> because GIL's memory-based locator and view already allow the vertical step to be specified dynamically. Iterators and views can be constructed from a pixel type:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pixel, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsStep=false, <span class="keywordtype">bool</span> IsMutable=true&gt; 
<span class="keyword">struct </span>iterator_type_from_pixel { <span class="keyword">typedef</span> ... type; };

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pixel, <span class="keywordtype">bool</span> IsPlanar=false, <span class="keywordtype">bool</span> IsStepX=false, <span class="keywordtype">bool</span> IsMutable=true&gt; 
<span class="keyword">struct </span>view_type_from_pixel { <span class="keyword">typedef</span> ... type; };
</pre></div><p>
Using a heterogeneous pixel type will result in heterogeneous iterators and views. Types can also be constructed from horizontal iterator:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> XIterator&gt; 
<span class="keyword">struct </span>type_from_x_iterator {
    <span class="keyword">typedef</span> ... step_iterator_t;
    <span class="keyword">typedef</span> ... xy_locator_t;
    <span class="keyword">typedef</span> ... view_t;
};
</pre></div><p>
There are metafunctions to construct the type of a construct from an existing type by changing one or more of its properties:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PixelReference, 
          <span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> IsPlanar, <span class="keyword">typename</span> IsMutable&gt;
<span class="keyword">struct </span>derived_pixel_reference_type {
    <span class="keyword">typedef</span> ... type;  <span class="comment">// Models PixelConcept</span>
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, 
          <span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> IsPlanar, <span class="keyword">typename</span> IsStep, <span class="keyword">typename</span> IsMutable&gt;
<span class="keyword">struct </span>derived_iterator_type {
    <span class="keyword">typedef</span> ... type;  <span class="comment">// Models PixelIteratorConcept</span>
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, 
          <span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> IsPlanar, <span class="keyword">typename</span> IsXStep, <span class="keyword">typename</span> IsMutable&gt;
<span class="keyword">struct </span>derived_view_type {
    <span class="keyword">typedef</span> ... type;  <span class="comment">// Models ImageViewConcept</span>
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Image, 
          <span class="keyword">typename</span> ChannelValue, <span class="keyword">typename</span> Layout, <span class="keyword">typename</span> IsPlanar&gt;
<span class="keyword">struct </span>derived_image_type {
    <span class="keyword">typedef</span> ... type;  <span class="comment">// Models ImageConcept</span>
};
</pre></div><p>
You can replace one or more of its properties and use <code>boost::use_default</code> for the rest. In this case <code>IsPlanar</code>, <code>IsStep</code> and <code>IsMutable</code> are MPL boolean constants. For example, here is how to create the type of a view just like <code>View</code>, but being grayscale and planar:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">typename</span> derived_view_type&lt;View, boost::use_default, gray_t, mpl::true_&gt;::type VT;
</pre></div><p>
You can get pixel-related types of any pixel-based GIL constructs (pixels, iterators, locators and views) using the following metafunctions provided by PixelBasedConcept, HomogeneousPixelBasedConcept and metafunctions built on top of them:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>color_space_type { <span class="keyword">typedef</span> ... type; };
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>channel_mapping_type { <span class="keyword">typedef</span> ... type; };
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>is_planar { <span class="keyword">typedef</span> ... type; };

<span class="comment">// Defined by homogeneous constructs</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>channel_type { <span class="keyword">typedef</span> ... type; };
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>num_channels { <span class="keyword">typedef</span> ... type; };
</pre></div><p>
These are metafunctions, some of which return integral types which can be evaluated like this:<p>
<div class="fragment"><pre class="fragment">BOOST_STATIC_ASSERT(is_planar&lt;rgb8_planar_view_t&gt;::value == <span class="keyword">true</span>);
</pre></div><p>
GIL also supports type analysis metafunctions of the form: [pixel_reference/iterator/locator/view/image] + <code>"_is_"</code> + [basic/mutable/step]. For example:<p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (view_is_mutable&lt;View&gt;::value) {
   ...
}
</pre></div><p>
A <em>basic</em> GIL construct is a memory-based construct that uses the built-in GIL classes and does not have any function object to invoke upon dereferencing. For example, a simple planar or interleaved, step or non-step RGB image view is basic, but a color converted view or a virtual view is not.<p>
<hr>
 <h2><a class="anchor" name="IO_DG">
13. I/O Extension</a></h2>
GIL's I/O extension provides low level image i/o utilities. It supports loading and saving several image formats, each of which requires linking against the corresponding library:<p>
<ul>
<li><b>JPEG</b>: To use JPEG files, include the file <code><a class="el" href="jpeg__io_8hpp.html" title="Support for reading and writing JPEG files Requires libjpeg.">gil/extension/io/jpeg_io.hpp</a></code>. If you are using run-time images, you need to include <code><a class="el" href="g_i_l_0232.html" title="Support for reading and writing JPEG files Requires libjpeg.">gil/extension/io/jpeg_dynamic_io.hpp</a></code> instead. You need to compile and link against libjpeg.lib (available at <a href="http://www.ijg.org">http://www.ijg.org</a>). You need to have <code>jpeglib.h</code> in your include path.</li></ul>
<p>
<ul>
<li><b>TIFF</b>: To use TIFF files, include the file <code><a class="el" href="tiff__io_8hpp.html" title="Support for reading and writing TIFF files Requires libtiff!">gil/extension/io/tiff_io.hpp</a></code>. If you are using run-time images, you need to include <code><a class="el" href="g_i_l_0639.html" title="Support for reading and writing TIFF files Requires libtiff!">gil/extension/io/tiff_dynamic_io.hpp</a></code> instead. You need to compile and link against libtiff.lib (available at <a href="http://www.libtiff.org">http://www.libtiff.org</a>). You need to have <code>tiffio.h</code> in your include path.</li></ul>
<p>
<ul>
<li><b>PNG</b>: To use PNG files, include the file <code><a class="el" href="png__io_8hpp.html" title="Support for reading and writing PNG files Requires libpng and zlib!">gil/extension/io/png_io.hpp</a></code>. If you are using run-time images, you need to include <code><a class="el" href="g_i_l_0251.html" title="Support for reading and writing PNG files Requires libpng and zlib!">gil/extension/io/png_dynamic_io.hpp</a></code> instead. You need to compile and link against libpng.lib (available at <a href="http://wwwlibpng.org">http://wwwlibpng.org</a>). You need to have <code>png.h</code> in your include path.</li></ul>
<p>
You don't need to install all these libraries; just the ones you will use. Here are the I/O APIs for JPEG files (replace <code>"jpeg"</code> with <code>"tiff"</code> or <code>"png"</code> for the APIs of the other libraries):<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Returns the width and height of the JPEG file at the specified location.</span>
<span class="comment">// Throws std::ios_base::failure if the location does not correspond to a valid JPEG file</span>
point2&lt;std::ptrdiff_t&gt; <a class="code" href="g_i_l_0169.html#g10d06211a2d4ba61145b50cf04f3ad85" title="Returns the width and height of the JPEG file at the specified location. Throws std::ios_base::failu...">jpeg_read_dimensions</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*);

<span class="comment">// Allocates a new image whose dimensions are determined by the given jpeg image file, and loads the pixels into it.</span>
<span class="comment">// Triggers a compile assert if the image color space or channel depth are not supported by the JPEG library or by the I/O extension.</span>
<span class="comment">// Throws std::ios_base::failure if the file is not a valid JPEG file, or if its color space or channel depth are not </span>
<span class="comment">// compatible with the ones specified by Image</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Img&gt; <span class="keywordtype">void</span> <a class="code" href="g_i_l_0169.html#ga8d0be11619e190cef13ab79d7169398" title="reads a JPEG image into a run-time instantiated image Opens the given JPEG file name...">jpeg_read_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, Img&amp;);

<span class="comment">// Allocates a new image whose dimensions are determined by the given jpeg image file, and loads the pixels into it,</span>
<span class="comment">// color-converting and channel-converting if necessary.</span>
<span class="comment">// Triggers a compile assert if the image color space or channel depth are not supported by the JPEG library or by the I/O extension.</span>
<span class="comment">// Throws std::ios_base::failure if the file is not a valid JPEG file or if it fails to read it.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Img&gt;               <span class="keywordtype">void</span> <a class="code" href="g_i_l_0169.html#gbe915826a254db40e74e783255b502e4" title="Allocates a new image whose dimensions are determined by the given jpeg image file...">jpeg_read_and_convert_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, Img&amp;);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Img, <span class="keyword">typename</span> CCV&gt; <span class="keywordtype">void</span> <a class="code" href="g_i_l_0169.html#gbe915826a254db40e74e783255b502e4" title="Allocates a new image whose dimensions are determined by the given jpeg image file...">jpeg_read_and_convert_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, Img&amp;, CCV color_converter);

<span class="comment">// Loads the image specified by the given jpeg image file name into the given view.</span>
<span class="comment">// Triggers a compile assert if the view color space and channel depth are not supported by the JPEG library or by the I/O extension.</span>
<span class="comment">// Throws std::ios_base::failure if the file is not a valid JPEG file, or if its color space or channel depth are not </span>
<span class="comment">// compatible with the ones specified by View, or if its dimensions don't match the ones of the view.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keywordtype">void</span> <a class="code" href="g_i_l_0169.html#g4e8ae7c617147cf99f7a2aa37e44f28c" title="Loads the image specified by the given jpeg image file name into the given view....">jpeg_read_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> View&amp;);

<span class="comment">// Loads the image specified by the given jpeg image file name into the given view and color-converts (and channel-converts) it if necessary.</span>
<span class="comment">// Triggers a compile assert if the view color space and channel depth are not supported by the JPEG library or by the I/O extension.</span>
<span class="comment">// Throws std::ios_base::failure if the file is not a valid JPEG file, or if its dimensions don't match the ones of the view.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt;               <span class="keywordtype">void</span> <a class="code" href="g_i_l_0169.html#ged18c0f8084bedab8804d2cd1b0b284d" title="Loads and color-converts the image specified by the given jpeg image file name into...">jpeg_read_and_convert_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> View&amp;);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, <span class="keyword">typename</span> CCV&gt; <span class="keywordtype">void</span> <a class="code" href="g_i_l_0169.html#ged18c0f8084bedab8804d2cd1b0b284d" title="Loads and color-converts the image specified by the given jpeg image file name into...">jpeg_read_and_convert_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> View&amp;, CCV color_converter);

<span class="comment">// Saves the view to a jpeg file specified by the given jpeg image file name.</span>
<span class="comment">// Triggers a compile assert if the view color space and channel depth are not supported by the JPEG library or by the I/O extension.</span>
<span class="comment">// Throws std::ios_base::failure if it fails to create the file.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keywordtype">void</span> <a class="code" href="g_i_l_0169.html#g3a185bccf9e6716693003db876b25dde" title="Saves the currently instantiated view to a jpeg file specified by the given jpeg...">jpeg_write_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> View&amp;);

<span class="comment">// Determines whether the given view type is supported for reading</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">struct </span>jpeg_read_support {
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = ...;
};

<span class="comment">// Determines whether the given view type is supported for writing</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> View&gt; <span class="keyword">struct </span>jpeg_write_support {
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = ...;
};
</pre></div><p>
If you use the dynamic image extension, make sure to include <code>"jpeg_dynamic_io.hpp"</code> instead of <code>"jpeg_io.hpp"</code>. In addition to the above methods, you have the following overloads dealing with dynamic images:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Opens the given JPEG file name, selects the first type in Images whose color space and channel are compatible to those of the image file</span>
<span class="comment">// and creates a new image of that type with the dimensions specified by the image file.</span>
<span class="comment">// Throws std::ios_base::failure if none of the types in Images are compatible with the type on disk.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Images&gt; <span class="keywordtype">void</span> <a class="code" href="g_i_l_0169.html#ga8d0be11619e190cef13ab79d7169398" title="reads a JPEG image into a run-time instantiated image Opens the given JPEG file name...">jpeg_read_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, any_image&lt;Images&gt;&amp;);

<span class="comment">// Saves the currently instantiated view to a jpeg file specified by the given jpeg image file name.</span>
<span class="comment">// Throws std::ios_base::failure if the currently instantiated view type is not supported for writing by the I/O extension </span>
<span class="comment">// or if it fails to create the file.</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Views&gt;  <span class="keywordtype">void</span> <a class="code" href="g_i_l_0169.html#g3a185bccf9e6716693003db876b25dde" title="Saves the currently instantiated view to a jpeg file specified by the given jpeg...">jpeg_write_view</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, any_image_view&lt;Views&gt;&amp;);
</pre></div><p>
All of the above methods have overloads taking <code>std::string</code> instead of <code>const char*</code><p>
<hr>
 <h2><a class="anchor" name="SampleImgCodeDG">
14. Sample Code</a></h2>
<h3><a class="anchor" name="PixelLevelExampleDG">
Pixel-level Sample Code</a></h3>
Here are some operations you can do with pixel values, pointers and references:<p>
<div class="fragment"><pre class="fragment">rgb8_pixel_t p1(255,0,0);     <span class="comment">// make a red RGB pixel</span>
bgr8_pixel_t p2 = p1;         <span class="comment">// RGB and BGR are compatible and the channels will be properly mapped. </span>
assert(p1==p2);               <span class="comment">// p2 will also be red.</span>
assert(p2[0]!=p1[0]);         <span class="comment">// operator[] gives physical channel order (as laid down in memory)</span>
assert(semantic_at_c&lt;0&gt;(p1)==semantic_at_c&lt;0&gt;(p2)); <span class="comment">// this is how to compare the two red channels</span>
<a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(p1,green_t()) = <a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(p2,blue_t());  <span class="comment">// channels can also be accessed by name</span>

<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* r;
<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* g;
<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* b;
rgb8c_planar_ptr_t ptr(r,g,b); <span class="comment">// constructing const planar pointer from const pointers to each plane</span>

rgb8c_planar_ref_t ref=*ptr;   <span class="comment">// just like built-in reference, dereferencing a planar pointer returns a planar reference</span>

p2=ref; p2=p1; p2=ptr[7]; p2=rgb8_pixel_t(1,2,3);    <span class="comment">// planar/interleaved references and values to RGB/BGR can be freely mixed</span>

<span class="comment">//rgb8_planar_ref_t ref2;      // compile error: References have no default constructors</span>
<span class="comment">//ref2=*ptr;                   // compile error: Cannot construct non-const reference by dereferencing const pointer</span>
<span class="comment">//ptr[3]=p1;                   // compile error: Cannot set the fourth pixel through a const pointer</span>
<span class="comment">//p1 = pixel&lt;float, rgb_layout_t&gt;();// compile error: Incompatible channel depth</span>
<span class="comment">//p1 = pixel&lt;bits8, rgb_layout_t&gt;();// compile error: Incompatible color space (even though it has the same number of channels)</span>
<span class="comment">//p1 = pixel&lt;bits8,rgba_layout_t&gt;();// compile error: Incompatible color space (even though it contains red, green and blue channels)</span>
</pre></div><p>
Here is how to use pixels in generic code:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GrayPixel, <span class="keyword">typename</span> RGBPixel&gt;
<span class="keywordtype">void</span> gray_to_rgb(<span class="keyword">const</span> GrayPixel&amp; src, RGBPixel&amp; dst) {
    gil_function_requires&lt;PixelConcept&lt;GrayPixel&gt; &gt;();    
    gil_function_requires&lt;MutableHomogeneousPixelConcept&lt;RGBPixel&gt; &gt;();

    <span class="keyword">typedef</span> <span class="keyword">typename</span> color_space_type&lt;GrayPixel&gt;::type gray_cs_t;
    BOOST_STATIC_ASSERT((boost::is_same&lt;gray_cs_t,gray_t&gt;::value));

    <span class="keyword">typedef</span> <span class="keyword">typename</span> color_space_type&lt;RGBPixel&gt;::type  rgb_cs_t;
    BOOST_STATIC_ASSERT((boost::is_same&lt;rgb_cs_t,rgb_t&gt;::value));

    <span class="keyword">typedef</span> <span class="keyword">typename</span> channel_type&lt;GrayPixel&gt;::type gray_channel_t;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> channel_type&lt;RGBPixel&gt;::type  rgb_channel_t;

    gray_channel_t gray = <a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(src,gray_color_t());
    static_fill(dst, channel_convert&lt;rgb_channel_t&gt;(gray));
}

<span class="comment">// example use patterns:</span>

<span class="comment">// converting gray l-value to RGB and storing at (5,5) in a 16-bit BGR interleaved image:</span>
bgr16_view_t b16(...);
gray_to_rgb(gray8_pixel_t(33), b16(5,5));

<span class="comment">// storing the first pixel of an 8-bit grayscale image as the 5-th pixel of 32-bit planar RGB image:</span>
rgb32f_planar_view_t rpv32;
gray8_view_t gv8(...);
gray_to_rgb(*gv8.begin(), rpv32[5]);
</pre></div><p>
As the example shows, both the source and the destination can be references or values, planar or interleaved, as long as they model <code>PixelConcept</code> and <code>MutablePixelConcept</code> respectively.<h3><a class="anchor" name="SafeAreaExampleDG">
Creating a Copy of an Image with a Safe Buffer</a></h3>
Suppose we want to convolve an image with multiple kernels, the largest of which is 2K+1 x 2K+1 pixels. It may be worth creating a margin of K pixels around the image borders. Here is how to do it:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView,   <span class="comment">// Models ImageViewConcept (the source view)</span>
          <span class="keyword">typename</span> DstImage&gt;  <span class="comment">// Models ImageConcept     (the returned image)</span>
<span class="keywordtype">void</span> create_with_margin(<span class="keyword">const</span> SrcView&amp; src, <span class="keywordtype">int</span> k, DstImage&amp; result) {
    gil_function_requires&lt;ImageViewConcept&lt;SrcView&gt; &gt;();
    gil_function_requires&lt;ImageConcept&lt;DstImage&gt; &gt;();
    gil_function_requires&lt;ViewsCompatibleConcept&lt;SrcView, typename DstImage::view_t&gt; &gt;();
    
    result=DstImage(src.width()+2*k, src.height()+2*k);
    <span class="keyword">typename</span> DstImage::view_t centerImg=subimage_view(<a class="code" href="g_i_l_0135.html#gad0335b7d343667d626556681486f198" title="Returns the non-constant-pixel view of an image.">view</a>(result), k,k,src.width(),src.height());
    <a class="code" href="g_i_l_0214.html#gc2faa90ab27d7fb0253d19839c75d341" title="Copy when both src and dst are interleaved and of the same type can be just memmove...">std::copy</a>(src.begin(), src.end(), centerImg.begin());
}
</pre></div><p>
We allocated a larger image, then we used <code>subimage_view</code> to create a shallow image of its center area of top left corner at (k,k) and of identical size as <code>src</code>, and finally we copied <code>src</code> into that center image. If the margin needs initialization, we could have done it with <code>fill_pixels</code>. Here is how to simplify this code using the <code>copy_pixels</code> algorithm:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstImage&gt;
<span class="keywordtype">void</span> create_with_margin(<span class="keyword">const</span> SrcView&amp; src, <span class="keywordtype">int</span> k, DstImage&amp; result) {
    result.recreate(src.width()+2*k, src.height()+2*k);
    <a class="code" href="g_i_l_0145.html#g16f18749152217a2b84733c330a2b415" title="std::copy for image views">copy_pixels</a>(src, subimage_view(<a class="code" href="g_i_l_0135.html#gad0335b7d343667d626556681486f198" title="Returns the non-constant-pixel view of an image.">view</a>(result), k,k,src.width(),src.height()));
}
</pre></div><p>
(Note also that <code>image::recreate</code> is more efficient than <code>operator=</code>, as the latter will do an unnecessary copy construction). Not only does the above example work for planar and interleaved images of any color space and pixel depth; it is also optimized. GIL overrides <code>std::copy</code> - when called on two identical interleaved images with no padding at the end of rows, it simply does a <code>memmove</code>. For planar images it does <code>memmove</code> for each channel. If one of the images has padding, (as in our case) it will try to do <code>memmove</code> for each row. When an image has no padding, it will use its lightweight horizontal iterator (as opposed to the more complex 1D image iterator that has to check for the end of rows). It choses the fastest method, taking into account both static and run-time parameters.<h3><a class="anchor" name="HistogramExampleDG">
Histogram</a></h3>
The histogram can be computed by counting the number of pixel values that fall in each bin. The following method takes a grayscale (one-dimensional) image view, since only grayscale pixels are convertible to integers: <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GrayView, <span class="keyword">typename</span> R&gt;
<span class="keywordtype">void</span> grayimage_histogram(<span class="keyword">const</span> GrayView&amp; img, R&amp; hist) {
    <span class="keywordflow">for</span> (<span class="keyword">typename</span> GrayView::iterator it=img.begin(); it!=img.end(); ++it)
        ++hist[*it];
}
</pre></div><p>
Using <code>boost::lambda</code> and GIL's <code>for_each_pixel</code> algorithm, we can write this more compactly:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GrayView, <span class="keyword">typename</span> R&gt;
<span class="keywordtype">void</span> grayimage_histogram(<span class="keyword">const</span> GrayView&amp; v, R&amp; hist) {
    for_each_pixel(v, ++var(hist)[_1]);
}
</pre></div><p>
Where <code>for_each_pixel</code> invokes <code>std::for_each</code> and <code>var</code> and <code>_1</code> are <code>boost::lambda</code> constructs. To compute the luminosity histogram, we call the above method using the grayscale view of an image:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> View, <span class="keyword">typename</span> R&gt;
<span class="keywordtype">void</span> luminosity_histogram(<span class="keyword">const</span> View&amp; v, R&amp; hist) {
    grayimage_histogram(color_converted_view&lt;gray8_pixel_t&gt;(v),hist);
}
</pre></div><p>
This is how to invoke it:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hist[256];
<a class="code" href="g_i_l_0214.html#g718772a47188f4e2ecfce2f28fa3dc4f" title="std::fill(I,I,V) with I being a iterator_from_2d">std::fill</a>(hist,hist+256,0);
luminosity_histogram(my_view,hist);
</pre></div><p>
If we want to view the histogram of the second channel of the image in the top left 100x100 area, we call:<p>
<div class="fragment"><pre class="fragment">grayimage_histogram(nth_channel_view(subimage_view(img,0,0,100,100),1),hist);
</pre></div><p>
No pixels are copied and no extra memory is allocated - the code operates directly on the source pixels, which could be in any supported color space and channel depth. They could be either planar or interleaved.<h3><a class="anchor" name="ImageViewsExampleDG">
Using Image Views</a></h3>
The following code illustrates the power of using image views:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="g_i_l_0169.html#ga8d0be11619e190cef13ab79d7169398" title="reads a JPEG image into a run-time instantiated image Opens the given JPEG file name...">jpeg_read_image</a>(<span class="stringliteral">"monkey.jpg"</span>, img);
step1=<a class="code" href="g_i_l_0135.html#gad0335b7d343667d626556681486f198" title="Returns the non-constant-pixel view of an image.">view</a>(img);
step2=subimage_view(step1, 200,300, 150,150);
step3=color_converted_view&lt;rgb8_view_t,gray8_pixel_t&gt;(step2);
step4=rotated180_view(step3);
step5=subsampled_view(step4, 2,1);
<a class="code" href="g_i_l_0169.html#g3a185bccf9e6716693003db876b25dde" title="Saves the currently instantiated view to a jpeg file specified by the given jpeg...">jpeg_write_view</a>(<span class="stringliteral">"monkey_transform.jpg"</span>, step5);
</pre></div><p>
The intermediate images are shown here: <div align="center">
<img src="monkey_steps.jpg" alt="monkey_steps.jpg">
</div>
<p>
Notice that no pixels are ever copied. All the work is done inside <code>jpeg_write_view</code>. If we call our <code>luminosity_histogram</code> with <code>step5</code> it will do the right thing.<p>
<hr>
 <h2><a class="anchor" name="ExtendingGIL_DG">
15. Extending the Generic Image Library</a></h2>
You can define your own pixel iterators, locators, image views, images, channel types, color spaces and algorithms. You can make virtual images that live on the disk, inside a jpeg file, somewhere on the internet, or even fully-synthetic images such as the Mandelbrot set. As long as they properly model the corresponding concepts, they will work with any existing GIL code. Most such extensions require no changes to the library and can thus be supplied in another module.<h3><a class="anchor" name="NewColorSpacesDG">
Defining New Color Spaces</a></h3>
Each color space is in a separate file. To add a new color space, just copy one of the existing ones (like <a class="el" href="rgb_8hpp.html" title="Support for RGB color space and variants.">rgb.hpp</a>) and change it accordingly. If you want color conversion support, you will have to provide methods to convert between it and the existing color spaces (see color_convert.h). For convenience you may want to provide useful typedefs for pixels, pointers, references and images with the new color space (see typedefs.h).<h3><a class="anchor" name="NewChannelsDG">
Defining New Channel Types</a></h3>
Most of the time you don't need to do anything special to use a new channel type. You can just use it:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> pixel&lt;double,rgb_layout_t&gt;   rgb64_pixel_t;    <span class="comment">// 64 bit RGB pixel </span>
<span class="keyword">typedef</span> rgb64_pixel*                 rgb64_pixel_ptr_t;<span class="comment">// pointer to 64-bit interleaved data</span>
<span class="keyword">typedef</span> image_type&lt;double,rgb_layout_t&gt;::type rgb64_image_t;    <span class="comment">// 64-bit interleaved image</span>
</pre></div><p>
If you want to use your own channel class, you will need to provide a specialization of <code>channel_traits</code> for it (see <a class="el" href="channel_8hpp.html" title="Channel utilities.">channel.hpp</a>). If you want to do conversion between your and existing channel types, you will need to provide an overload of <code>channel_convert</code>.<h3><a class="anchor" name="NewColorConversionDG">
Overloading Color Conversion</a></h3>
Suppose you want to provide your own color conversion. For example, you may want to implement higher quality color conversion using color profiles. Typically you may want to redefine color conversion only in some instances and default to GIL's color conversion in all other cases. Here is, for example, how to overload color conversion so that color conversion to gray inverts the result but everything else remains the same:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// make the default use GIL's default</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcColorSpace, <span class="keyword">typename</span> DstColorSpace&gt;
<span class="keyword">struct </span>my_color_converter_impl
  : <span class="keyword">public</span> default_color_converter_impl&lt;SrcColorSpace,DstColorSpace&gt; {};

<span class="comment">// provide specializations only for cases you care about</span>
<span class="comment">// (in this case, if the destination is grayscale, invert it)</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcColorSpace&gt;
<span class="keyword">struct </span>my_color_converter_impl&lt;SrcColorSpace,gray_t&gt; {
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcP, <span class="keyword">typename</span> DstP&gt;  <span class="comment">// Model PixelConcept</span>
    <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> SrcP&amp; src, DstP&amp; dst)<span class="keyword"> const </span>{
        default_color_converter_impl&lt;SrcColorSpace,gray_t&gt;()(src,dst);
        <a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(dst,gray_color_t())=<a class="code" href="g_i_l_0101.html#ge2e0267865f89610ef26148874a04bb5" title="Default implementation. Provide overloads for performance.">channel_invert</a>(<a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6" title="Mutable accessor to the element associated with a given color name.">get_color</a>(dst,gray_color_t()));
    }
};

<span class="comment">// create a color converter object that dispatches to your own implementation</span>
<span class="keyword">struct </span>my_color_converter {
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcP, <span class="keyword">typename</span> DstP&gt;  <span class="comment">// Model PixelConcept</span>
    <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> SrcP&amp; src,DstP&amp; dst)<span class="keyword"> const </span>{ 
        <span class="keyword">typedef</span> <span class="keyword">typename</span> color_space_type&lt;SrcP&gt;::type SrcColorSpace;
        <span class="keyword">typedef</span> <span class="keyword">typename</span> color_space_type&lt;DstP&gt;::type DstColorSpace;
        my_color_converter_impl&lt;SrcColorSpace,DstColorSpace&gt;()(src,dst);
    }
};
</pre></div><p>
GIL's color conversion functions take the color converter as an optional parameter. You can pass your own color converter:<p>
<div class="fragment"><pre class="fragment">color_converted_view&lt;gray8_pixel_t&gt;(img_view,my_color_converter());
</pre></div><h3><a class="anchor" name="NewImagesDG">
Defining New Image Views</a></h3>
You can provide your own pixel iterators, locators and views, overriding either the mechanism for getting from one pixel to the next or doing an arbitrary pixel transformation on dereference. For example, let's look at the implementation of <code>color_converted_view</code> (an image factory method that, given any image view, returns a new, otherwise identical view, except that color conversion is performed on pixel access). First we need to define a model of <code>PixelDereferenceAdaptorConcept</code>; a function object that will be called when we dereference a pixel iterator. It will call <code>color_convert</code> to convert to the destination pixel type:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcConstRefP,  <span class="comment">// const reference to the source pixel</span>
          <span class="keyword">typename</span> DstP&gt;          <span class="comment">// Destination pixel value (models PixelValueConcept)</span>
<span class="keyword">class </span>color_convert_deref_fn {
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> color_convert_deref_fn const_t;
    <span class="keyword">typedef</span> DstP                value_type;
    <span class="keyword">typedef</span> value_type          reference;      <span class="comment">// read-only dereferencing</span>
    <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp;   const_reference;
    <span class="keyword">typedef</span> SrcConstRefP        argument_type;
    <span class="keyword">typedef</span> reference           result_type;
    BOOST_STATIC_CONSTANT(<span class="keywordtype">bool</span>, is_mutable=<span class="keyword">false</span>);

    result_type operator()(argument_type srcP)<span class="keyword"> const </span>{
        result_type dstP;
        <a class="code" href="g_i_l_0178.html#gaa258d34eafbf9d9e34a2a2ad6131af2" title="helper function for converting one pixel to another using GIL default color-converters...">color_convert</a>(srcP,dstP);
        <span class="keywordflow">return</span> dstP;
    }
};
</pre></div><p>
We then use the <code>add_deref</code> member struct of image views to construct the type of a view that invokes a given function object (<code>deref_t</code>) upon dereferencing. In our case, it performs color conversion:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SrcView, <span class="keyword">typename</span> DstP&gt;
<span class="keyword">struct </span>color_converted_view_type {
<span class="keyword">private</span>:
    <span class="keyword">typedef</span> <span class="keyword">typename</span> SrcView::const_t::reference src_pix_ref;  <span class="comment">// const reference to pixel in SrcView</span>
    <span class="keyword">typedef</span> color_convert_deref_fn&lt;src_pix_ref, DstP&gt; deref_t; <span class="comment">// the dereference adaptor that performs color conversion</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> SrcView::template add_deref&lt;deref_t&gt; add_ref_t;
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> <span class="keyword">typename</span> add_ref_t::type type; <span class="comment">// the color converted view type</span>
    <span class="keyword">static</span> type make(<span class="keyword">const</span> SrcView&amp; sv) { <span class="keywordflow">return</span> add_ref_t::make(sv, deref_t()); }
};
</pre></div><p>
Finally our <code>color_converted_view</code> code simply creates color-converted view from the source view:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DstP, <span class="keyword">typename</span> View&gt; <span class="keyword">inline</span>
<span class="keyword">typename</span> color_converted_view_type&lt;View,DstP&gt;::type color_convert_view(<span class="keyword">const</span> View&amp; src) {
    <span class="keywordflow">return</span> color_converted_view_type&lt;View,DstP&gt;::make(src);
}
</pre></div><p>
(The actual color convert view transformation is slightly more complicated, as it takes an optional color conversion object, which allows users to specify their own color conversion methods). See the GIL tutorial for an example of creating a virtual image view that defines the Mandelbrot set.<p>
<hr>
 <h2><a class="anchor" name="TechnicalitiesDG">
16. Technicalities</a></h2>
<h3><a class="anchor" name="CreatingReferenceProxyDG">
Creating a reference proxy</a></h3>
Sometimes it is necessary to create a proxy class that represents a reference to a given object. Examples of these are GIL's reference to a planar pixel (<code>planar_pixel_reference</code>) and GIL's subbyte channel references. Writing a reference proxy class can be tricky. One problem is that the proxy reference is constructed as a temporary object and returned by value upon dereferencing the iterator:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>rgb_planar_pixel_iterator {
   <span class="keyword">typedef</span> my_reference_proxy&lt;T&gt; reference;
   reference operator*()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> reference(red,green,blue); }
};
</pre></div><p>
The problem arises when an iterator is dereferenced directly into a function that takes a mutable pixel:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pixel&gt;    <span class="comment">// Models MutablePixelConcept</span>
<span class="keywordtype">void</span> invert_pixel(Pixel&amp; p);

rgb_planar_pixel_iterator myIt;
invert_pixel(*myIt);        <span class="comment">// compile error!</span>
</pre></div><p>
C++ does not allow for matching a temporary object against a non-constant reference. The solution is to:<ul>
<li>Use const qualifier on all members of the reference proxy object:</li></ul>
<p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">struct </span>my_reference_proxy {
    <span class="keyword">const</span> my_reference_proxy&amp; operator=(<span class="keyword">const</span> my_reference_proxy&amp; p) <span class="keyword">const</span>;
    <span class="keyword">const</span> my_reference_proxy* operator-&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span>; }
    ...
};
</pre></div><p>
<ul>
<li>Use different classes to denote mutable and constant reference (maybe based on the constness of the template parameter)</li></ul>
<p>
<ul>
<li>Define the reference type of your iterator with const qualifier:</li></ul>
<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>iterator_traits&lt;rgb_planar_pixel_iterator&gt; {
   <span class="keyword">typedef</span> <span class="keyword">const</span> my_reference_proxy&lt;T&gt; reference;
};
</pre></div><p>
A second important issue is providing an overload for <code>swap</code> for your reference class. The default <code>std::swap</code> will not work correctly. You must use a real value type as the temporary. A further complication is that in some implementations of the STL the <code>swap</code> function is incorreclty called qualified, as <code>std::swap</code>. The only way for these STL algorithms to use your overload is if you define it in the <code>std</code> namespace: <div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>std {
   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
   <span class="keywordtype">void</span> swap(my_reference_proxy&lt;T&gt;&amp; x, my_reference_proxy&lt;T&gt;&amp; y) {
      my_value&lt;T&gt; tmp=x;
      x=y;
      y=tmp;
   }
}
</pre></div><p>
Lastly, remember that constructors and copy-constructors of proxy references are always shallow and assignment operators are deep.<p>
We are grateful to Dave Abrahams, Sean Parent and Alex Stepanov for suggesting the above solution.<p>
<hr>
 <h2><a class="anchor" name="ConclusionDG">
17. Conclusion</a></h2>
The Generic Image Library is designed with the following five goals in mind:<p>
<ul>
<li><b> Generality.</b> Abstracts image representations from algorithms on images. It allows for writing code once and have it work for any image type. </li>
<li><b> Performance.</b> Speed has been instrumental to the design of the library. The generic algorithms provided in the library are in many cases comparable in speed to hand-coding the algorithm for a specific image type. </li>
<li><b> Flexibility.</b> Compile-type parameter resolution results in faster code, but severely limits code flexibility. The library allows for any image parameter to be specified at run time, at a minor performance cost. </li>
<li><b> Extensibility.</b> Virtually every construct in GIL can be extended - new channel types, color spaces, layouts, iterators, locators, image views and images can be provided by modeling the corresponding GIL concepts. </li>
<li><b> Compatibility.</b> The library is designed as an STL complement. Generic STL algorithms can be used for pixel manipulation, and they are specifically targeted for optimization. The library works with existing raw pixel data from another image library.</li>
</ul>
<div id="footerrow"></div><div id="footer" title="footer: links to copyright and other legal information"></div><p>
<div id="footer" title="footer: links to copyright and other legal information"><a href="licenses.html" class="el">Copyright &copy; 2005 Adobe Systems Incorporated</a><ul id="list1">
<li id="terms">
<a href="http://www.adobe.com/misc/copyright.html" title="Terms of Use">Terms of Use</a></li>
<li>
<a href="http://www.adobe.com/misc/privacy.html" title="Privacy Policy">Privacy Policy</a></li>
<li>
<a href="http://access.adobe.com">Accessibility</a></li>
<li>
<a href="http://www.adobe.com/aboutadobe/antipiracy/main.html" title="Avoid software piracy">Avoid software piracy</a></li>
<li id="tms">
<a href="http://www.adobe.com/misc/agreement.html" title="Permissions and trademarks">Permissions and trademarks</a></li>
<li>
<a href="http://www.adobe.com/products/eulas/main.html" title="Product License Agreements">Product License Agreements</a></li>
</ul>
</div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat May 2 13:50:16 2009 for Generic Image Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
