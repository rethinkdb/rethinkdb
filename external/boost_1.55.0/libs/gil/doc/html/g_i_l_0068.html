<!-- Copyright 2008 Lubomir Bourdev and Hailin Jin

     Distributed under the Boost Software License, Version 1.0.
     (See accompanying file LICENSE_1_0.txt or copy at
     http://www.boost.org/LICENSE_1_0.txt)
  -->

<!--
    Copyright 2005-2007 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
    <TITLE>Generic Image Library: color_base_algorithm.hpp Source File</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
</head>
<body>
<table border="0" cellspacing="0" cellpadding="0" style='width: 100%; margin: 0; padding: 0'><tr>
<td width="100%" valign="top" style='padding-left: 10px; padding-right: 10px; padding-bottom: 10px'>
<div class="qindex"><a class="qindex" href="index.html">Modules</a> 
                  | <a class="qindex" href="classes.html">Alphabetical List</a> 
                  | <a class="qindex" href="annotated.html">Class List</a> 
                  | <a class="qindex" href="dirs.html">Directories</a> 
                  | <a class="qindex" href="files.html">File List</a> 
                  | <a class="qindex" href="../index.html">GIL Home Page</a> 
</div>
<!-- End Header -->
<!-- Generated by Doxygen 1.5.6 -->
  <div class="navpath"><a class="el" href="g_i_l_0076.html">boost</a>&nbsp;&raquo&nbsp;<a class="el" href="g_i_l_0079.html">gil</a>
  </div>
<div class="contents">
<h1>color_base_algorithm.hpp</h1><a href="g_i_l_0069.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">    Copyright 2005-2007 Adobe Systems Incorporated</span>
<a name="l00003"></a>00003 <span class="comment">   </span>
<a name="l00004"></a>00004 <span class="comment">    Use, modification and distribution are subject to the Boost Software License,</span>
<a name="l00005"></a>00005 <span class="comment">    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<a name="l00006"></a>00006 <span class="comment">    http://www.boost.org/LICENSE_1_0.txt).</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">    See http://opensource.adobe.com/gil for most recent version including documentation.</span>
<a name="l00009"></a>00009 <span class="comment">*/</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="comment">/*************************************************************************************************/</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="preprocessor">#ifndef GIL_COLOR_BASE_ALGORITHM_HPP</span>
<a name="l00014"></a>00014 <span class="preprocessor"></span><span class="preprocessor">#define GIL_COLOR_BASE_ALGORITHM_HPP</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;boost/type_traits.hpp&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;boost/utility/enable_if.hpp&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;boost/mpl/contains.hpp&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;boost/mpl/at.hpp&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include "<a class="code" href="g_i_l_0094.html" title="GIL configuration file.">gil_config.hpp</a>"</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include "<a class="code" href="g_i_l_0092.html" title="Concept check classes for GIL concepts.">gil_concept.hpp</a>"</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include "<a class="code" href="utilities_8hpp.html" title="Various utilities not specific to the image library. Some are non-standard STL extensions...">utilities.hpp</a>"</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="keyword">namespace </span>boost { <span class="keyword">namespace </span>gil {
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 
<a name="l00042"></a>00042 
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase&gt;
<a name="l00058"></a><a class="code" href="g_i_l_0621.html">00058</a> <span class="keyword">struct </span><a class="code" href="g_i_l_0621.html" title="Returns an MPL integral type specifying the number of elements in a color base.">size</a> : <span class="keyword">public</span> mpl::<a class="code" href="g_i_l_0621.html" title="Returns an MPL integral type specifying the number of elements in a color base.">size</a>&lt;typename ColorBase::layout_t::color_space_t&gt; {};
<a name="l00059"></a>00059 
<a name="l00065"></a>00065 
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 
<a name="l00094"></a><a class="code" href="g_i_l_0565.html">00094</a> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span><a class="code" href="g_i_l_0565.html" title="Specifies the type of the K-th semantic element of a color base.">kth_semantic_element_type</a> {
<a name="l00095"></a>00095     BOOST_STATIC_CONSTANT(<span class="keywordtype">int</span>, semantic_index = (mpl::at_c&lt;typename ColorBase::layout_t::channel_mapping_t,K&gt;::type::value));
<a name="l00096"></a>00096     <span class="keyword">typedef</span> <span class="keyword">typename</span> kth_element_type&lt;ColorBase, semantic_index&gt;::type type;
<a name="l00097"></a>00097 };
<a name="l00098"></a>00098 
<a name="l00101"></a><a class="code" href="g_i_l_0563.html">00101</a> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span><a class="code" href="g_i_l_0563.html" title="Specifies the return type of the mutable semantic_at_c&amp;lt;K&amp;gt;(color_base);.">kth_semantic_element_reference_type</a> {
<a name="l00102"></a>00102     BOOST_STATIC_CONSTANT(<span class="keywordtype">int</span>, semantic_index = (mpl::at_c&lt;typename ColorBase::layout_t::channel_mapping_t,K&gt;::type::value));
<a name="l00103"></a>00103     <span class="keyword">typedef</span> <span class="keyword">typename</span> kth_element_reference_type&lt;ColorBase,semantic_index&gt;::type type;
<a name="l00104"></a>00104     <span class="keyword">static</span> type       <span class="keyword">get</span>(ColorBase&amp; cb) { <span class="keywordflow">return</span> at_c&lt;semantic_index&gt;(cb); }
<a name="l00105"></a>00105 };
<a name="l00106"></a>00106 
<a name="l00109"></a><a class="code" href="g_i_l_0561.html">00109</a> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keywordtype">int</span> K&gt; <span class="keyword">struct </span><a class="code" href="g_i_l_0561.html" title="Specifies the return type of the constant semantic_at_c&amp;lt;K&amp;gt;(color_base);.">kth_semantic_element_const_reference_type</a> {
<a name="l00110"></a>00110     BOOST_STATIC_CONSTANT(<span class="keywordtype">int</span>, semantic_index = (mpl::at_c&lt;typename ColorBase::layout_t::channel_mapping_t,K&gt;::type::value));
<a name="l00111"></a>00111     <span class="keyword">typedef</span> <span class="keyword">typename</span> kth_element_const_reference_type&lt;ColorBase,semantic_index&gt;::type type;
<a name="l00112"></a>00112     <span class="keyword">static</span> type       <span class="keyword">get</span>(<span class="keyword">const</span> ColorBase&amp; cb) { <span class="keywordflow">return</span> at_c&lt;semantic_index&gt;(cb); }
<a name="l00113"></a>00113 };
<a name="l00114"></a>00114 
<a name="l00117"></a>00117 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K, <span class="keyword">typename</span> ColorBase&gt; <span class="keyword">inline</span>
<a name="l00118"></a>00118 <span class="keyword">typename</span> disable_if&lt;is_const&lt;ColorBase&gt;,<span class="keyword">typename</span> <a class="code" href="g_i_l_0563.html" title="Specifies the return type of the mutable semantic_at_c&amp;lt;K&amp;gt;(color_base);.">kth_semantic_element_reference_type&lt;ColorBase,K&gt;::type</a>&gt;::type
<a name="l00119"></a><a class="code" href="g_i_l_0114.html#g2cdd9bfd1b27576659b8c79a3a0233de">00119</a> <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>(ColorBase&amp; p) { 
<a name="l00120"></a>00120     <span class="keywordflow">return</span> <a class="code" href="g_i_l_0563.html" title="Specifies the return type of the mutable semantic_at_c&amp;lt;K&amp;gt;(color_base);.">kth_semantic_element_reference_type&lt;ColorBase,K&gt;::get</a>(p); 
<a name="l00121"></a>00121 }
<a name="l00122"></a>00122 
<a name="l00125"></a>00125 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> K, <span class="keyword">typename</span> ColorBase&gt; <span class="keyword">inline</span>
<a name="l00126"></a>00126 <span class="keyword">typename</span> kth_semantic_element_const_reference_type&lt;ColorBase,K&gt;::type
<a name="l00127"></a><a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11">00127</a> <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>(<span class="keyword">const</span> ColorBase&amp; p) { 
<a name="l00128"></a>00128     <span class="keywordflow">return</span> <a class="code" href="g_i_l_0561.html" title="Specifies the return type of the constant semantic_at_c&amp;lt;K&amp;gt;(color_base);.">kth_semantic_element_const_reference_type&lt;ColorBase,K&gt;::get</a>(p); 
<a name="l00129"></a>00129 }
<a name="l00130"></a>00130 
<a name="l00136"></a>00136 
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keyword">typename</span> Color&gt;
<a name="l00159"></a><a class="code" href="g_i_l_0447.html">00159</a> <span class="keyword">struct </span><a class="code" href="g_i_l_0447.html" title="A predicate metafunction determining whether a given color base contains a given...">contains_color</a> : <span class="keyword">public</span> mpl::contains&lt;typename ColorBase::layout_t::color_space_t,Color&gt; {};
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keyword">typename</span> Color&gt;
<a name="l00162"></a>00162 <span class="keyword">struct </span>color_index_type : <span class="keyword">public</span> detail::type_to_index&lt;typename ColorBase::layout_t::color_space_t,Color&gt; {};
<a name="l00163"></a>00163 
<a name="l00166"></a>00166 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keyword">typename</span> Color&gt;
<a name="l00167"></a><a class="code" href="g_i_l_0444.html">00167</a> <span class="keyword">struct </span><a class="code" href="g_i_l_0444.html" title="Specifies the type of the element associated with a given color tag.">color_element_type</a> : <span class="keyword">public</span> <a class="code" href="g_i_l_0565.html" title="Specifies the type of the K-th semantic element of a color base.">kth_semantic_element_type</a>&lt;ColorBase,color_index_type&lt;ColorBase,Color&gt;::value&gt; {};
<a name="l00168"></a>00168 
<a name="l00171"></a>00171 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keyword">typename</span> Color&gt;
<a name="l00172"></a><a class="code" href="g_i_l_0442.html">00172</a> <span class="keyword">struct </span><a class="code" href="g_i_l_0442.html" title="Specifies the return type of the mutable element accessor by color name, get_color(color_base...">color_element_reference_type</a> : <span class="keyword">public</span> <a class="code" href="g_i_l_0563.html" title="Specifies the return type of the mutable semantic_at_c&amp;lt;K&amp;gt;(color_base);.">kth_semantic_element_reference_type</a>&lt;ColorBase,color_index_type&lt;ColorBase,Color&gt;::value&gt; {};
<a name="l00173"></a>00173 
<a name="l00176"></a>00176 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keyword">typename</span> Color&gt;
<a name="l00177"></a><a class="code" href="g_i_l_0440.html">00177</a> <span class="keyword">struct </span><a class="code" href="g_i_l_0440.html" title="Specifies the return type of the constant element accessor by color name, get_color(color_base...">color_element_const_reference_type</a> : <span class="keyword">public</span> <a class="code" href="g_i_l_0561.html" title="Specifies the return type of the constant semantic_at_c&amp;lt;K&amp;gt;(color_base);.">kth_semantic_element_const_reference_type</a>&lt;ColorBase,color_index_type&lt;ColorBase,Color&gt;::value&gt; {};
<a name="l00178"></a>00178 
<a name="l00181"></a>00181 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keyword">typename</span> Color&gt; 
<a name="l00182"></a><a class="code" href="g_i_l_0106.html#gab1205781ba628ca806c47a51f40f5f6">00182</a> <span class="keyword">typename</span> <a class="code" href="g_i_l_0442.html" title="Specifies the return type of the mutable element accessor by color name, get_color(color_base...">color_element_reference_type&lt;ColorBase,Color&gt;::type</a> <a class="code" href="g_i_l_0106.html#g4b9fe0ec8239047ac50842800de872b9" title="Constant accessor to the element associated with a given color name.">get_color</a>(ColorBase&amp; cb, Color=Color()) {
<a name="l00183"></a>00183     <span class="keywordflow">return</span> <a class="code" href="g_i_l_0442.html" title="Specifies the return type of the mutable element accessor by color name, get_color(color_base...">color_element_reference_type&lt;ColorBase,Color&gt;::get</a>(cb);
<a name="l00184"></a>00184 }
<a name="l00185"></a>00185 
<a name="l00188"></a>00188 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase, <span class="keyword">typename</span> Color&gt; 
<a name="l00189"></a><a class="code" href="g_i_l_0106.html#g4b9fe0ec8239047ac50842800de872b9">00189</a> <span class="keyword">typename</span> <a class="code" href="g_i_l_0440.html" title="Specifies the return type of the constant element accessor by color name, get_color(color_base...">color_element_const_reference_type&lt;ColorBase,Color&gt;::type</a> <a class="code" href="g_i_l_0106.html#g4b9fe0ec8239047ac50842800de872b9" title="Constant accessor to the element associated with a given color name.">get_color</a>(<span class="keyword">const</span> ColorBase&amp; cb, Color=Color()) {
<a name="l00190"></a>00190     <span class="keywordflow">return</span> <a class="code" href="g_i_l_0440.html" title="Specifies the return type of the constant element accessor by color name, get_color(color_base...">color_element_const_reference_type&lt;ColorBase,Color&gt;::get</a>(cb);
<a name="l00191"></a>00191 }
<a name="l00192"></a>00192 
<a name="l00198"></a>00198 
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase&gt;
<a name="l00213"></a><a class="code" href="g_i_l_0535.html">00213</a> <span class="keyword">struct </span><a class="code" href="g_i_l_0535.html" title="Specifies the element type of a homogeneous color base.">element_type</a> : <span class="keyword">public</span> kth_element_type&lt;ColorBase, 0&gt; {};
<a name="l00214"></a>00214 
<a name="l00217"></a>00217 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase&gt;
<a name="l00218"></a><a class="code" href="g_i_l_0534.html">00218</a> <span class="keyword">struct </span><a class="code" href="g_i_l_0534.html" title="Specifies the return type of the mutable element accessor at_c of a homogeneous color...">element_reference_type</a> : <span class="keyword">public</span> kth_element_reference_type&lt;ColorBase, 0&gt; {};
<a name="l00219"></a>00219 
<a name="l00222"></a>00222 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ColorBase&gt;
<a name="l00223"></a><a class="code" href="g_i_l_0533.html">00223</a> <span class="keyword">struct </span><a class="code" href="g_i_l_0533.html" title="Specifies the return type of the constant element accessor at_c of a homogeneous...">element_const_reference_type</a> : <span class="keyword">public</span> kth_element_const_reference_type&lt;ColorBase, 0&gt; {};
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="keyword">namespace </span>detail {
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="comment">// compile-time recursion for per-element operations on color bases</span>
<a name="l00229"></a>00229 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N&gt;
<a name="l00230"></a>00230 <span class="keyword">struct </span>element_recursion {
<a name="l00231"></a>00231     <span class="comment">//static_equal</span>
<a name="l00232"></a>00232     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;
<a name="l00233"></a>00233     <span class="keyword">static</span> <span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> P1&amp; p1, <span class="keyword">const</span> P2&amp; p2) { 
<a name="l00234"></a>00234         <span class="keywordflow">return</span> element_recursion&lt;N-1&gt;::static_equal(p1,p2) &amp;&amp;
<a name="l00235"></a>00235                <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(p1)==semantic_at_c&lt;N-1&gt;(p2); 
<a name="l00236"></a>00236     }
<a name="l00237"></a>00237     <span class="comment">//static_copy</span>
<a name="l00238"></a>00238     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;
<a name="l00239"></a>00239     <span class="keyword">static</span> <span class="keywordtype">void</span> static_copy(<span class="keyword">const</span> P1&amp; p1, P2&amp; p2) {
<a name="l00240"></a>00240         element_recursion&lt;N-1&gt;::static_copy(p1,p2);
<a name="l00241"></a>00241         <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(p2)=semantic_at_c&lt;N-1&gt;(p1);
<a name="l00242"></a>00242     }
<a name="l00243"></a>00243     <span class="comment">//static_fill</span>
<a name="l00244"></a>00244     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P,<span class="keyword">typename</span> T2&gt;
<a name="l00245"></a>00245     <span class="keyword">static</span> <span class="keywordtype">void</span> static_fill(P&amp; p, T2 v) {
<a name="l00246"></a>00246         element_recursion&lt;N-1&gt;::static_fill(p,v);
<a name="l00247"></a>00247         <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(p)=v;
<a name="l00248"></a>00248     }
<a name="l00249"></a>00249     <span class="comment">//static_generate</span>
<a name="l00250"></a>00250     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; 
<a name="l00251"></a>00251     <span class="keyword">static</span> <span class="keywordtype">void</span> static_generate(Dst&amp; dst, Op op) {
<a name="l00252"></a>00252         element_recursion&lt;N-1&gt;::static_generate(dst,op);
<a name="l00253"></a>00253         <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(dst)=op();
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255     <span class="comment">//static_for_each with one source</span>
<a name="l00256"></a>00256     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> Op&gt; 
<a name="l00257"></a>00257     <span class="keyword">static</span> Op static_for_each(P1&amp; p1, Op op) {
<a name="l00258"></a>00258         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,op));
<a name="l00259"></a>00259         op2(semantic_at_c&lt;N-1&gt;(p1));
<a name="l00260"></a>00260         <span class="keywordflow">return</span> op2;
<a name="l00261"></a>00261     }
<a name="l00262"></a>00262     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> Op&gt; 
<a name="l00263"></a>00263     <span class="keyword">static</span> Op static_for_each(<span class="keyword">const</span> P1&amp; p1, Op op) {
<a name="l00264"></a>00264         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,op));
<a name="l00265"></a>00265         op2(semantic_at_c&lt;N-1&gt;(p1));
<a name="l00266"></a>00266         <span class="keywordflow">return</span> op2;
<a name="l00267"></a>00267     }
<a name="l00268"></a>00268     <span class="comment">//static_for_each with two sources</span>
<a name="l00269"></a>00269     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Op&gt; 
<a name="l00270"></a>00270     <span class="keyword">static</span> Op static_for_each(P1&amp; p1, P2&amp; p2, Op op) {
<a name="l00271"></a>00271         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,p2,op));
<a name="l00272"></a>00272         op2(semantic_at_c&lt;N-1&gt;(p1), semantic_at_c&lt;N-1&gt;(p2));
<a name="l00273"></a>00273         <span class="keywordflow">return</span> op2;
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Op&gt; 
<a name="l00276"></a>00276     <span class="keyword">static</span> Op static_for_each(P1&amp; p1, <span class="keyword">const</span> P2&amp; p2, Op op) {
<a name="l00277"></a>00277         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,p2,op));
<a name="l00278"></a>00278         op2(semantic_at_c&lt;N-1&gt;(p1), semantic_at_c&lt;N-1&gt;(p2));
<a name="l00279"></a>00279         <span class="keywordflow">return</span> op2;
<a name="l00280"></a>00280     }
<a name="l00281"></a>00281     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Op&gt; 
<a name="l00282"></a>00282     <span class="keyword">static</span> Op static_for_each(<span class="keyword">const</span> P1&amp; p1, P2&amp; p2, Op op) {
<a name="l00283"></a>00283         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,p2,op));
<a name="l00284"></a>00284         op2(semantic_at_c&lt;N-1&gt;(p1), semantic_at_c&lt;N-1&gt;(p2));
<a name="l00285"></a>00285         <span class="keywordflow">return</span> op2;
<a name="l00286"></a>00286     }
<a name="l00287"></a>00287     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Op&gt; 
<a name="l00288"></a>00288     <span class="keyword">static</span> Op static_for_each(<span class="keyword">const</span> P1&amp; p1, <span class="keyword">const</span> P2&amp; p2, Op op) {
<a name="l00289"></a>00289         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,p2,op));
<a name="l00290"></a>00290         op2(semantic_at_c&lt;N-1&gt;(p1), semantic_at_c&lt;N-1&gt;(p2));
<a name="l00291"></a>00291         <span class="keywordflow">return</span> op2;
<a name="l00292"></a>00292     }
<a name="l00293"></a>00293     <span class="comment">//static_for_each with three sources</span>
<a name="l00294"></a>00294     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00295"></a>00295     <span class="keyword">static</span> Op static_for_each(P1&amp; p1, P2&amp; p2, P3&amp; p3, Op op) {
<a name="l00296"></a>00296         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,p2,p3,op));
<a name="l00297"></a>00297         op2(semantic_at_c&lt;N-1&gt;(p1), semantic_at_c&lt;N-1&gt;(p2), semantic_at_c&lt;N-1&gt;(p3));
<a name="l00298"></a>00298         <span class="keywordflow">return</span> op2;
<a name="l00299"></a>00299     }
<a name="l00300"></a>00300     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00301"></a>00301     <span class="keyword">static</span> Op static_for_each(P1&amp; p1, P2&amp; p2, <span class="keyword">const</span> P3&amp; p3, Op op) {
<a name="l00302"></a>00302         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,p2,p3,op));
<a name="l00303"></a>00303         op2(semantic_at_c&lt;N-1&gt;(p1), semantic_at_c&lt;N-1&gt;(p2), semantic_at_c&lt;N-1&gt;(p3));
<a name="l00304"></a>00304         <span class="keywordflow">return</span> op2;
<a name="l00305"></a>00305     }
<a name="l00306"></a>00306     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00307"></a>00307     <span class="keyword">static</span> Op static_for_each(P1&amp; p1, <span class="keyword">const</span> P2&amp; p2, P3&amp; p3, Op op) {
<a name="l00308"></a>00308         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,p2,p3,op));
<a name="l00309"></a>00309         op2(semantic_at_c&lt;N-1&gt;(p1), semantic_at_c&lt;N-1&gt;(p2), semantic_at_c&lt;N-1&gt;(p3));
<a name="l00310"></a>00310         <span class="keywordflow">return</span> op2;
<a name="l00311"></a>00311     }
<a name="l00312"></a>00312     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00313"></a>00313     <span class="keyword">static</span> Op static_for_each(P1&amp; p1, <span class="keyword">const</span> P2&amp; p2, <span class="keyword">const</span> P3&amp; p3, Op op) {
<a name="l00314"></a>00314         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,p2,p3,op));
<a name="l00315"></a>00315         op2(semantic_at_c&lt;N-1&gt;(p1), semantic_at_c&lt;N-1&gt;(p2), semantic_at_c&lt;N-1&gt;(p3));
<a name="l00316"></a>00316         <span class="keywordflow">return</span> op2;
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00319"></a>00319     <span class="keyword">static</span> Op static_for_each(<span class="keyword">const</span> P1&amp; p1, P2&amp; p2, P3&amp; p3, Op op) {
<a name="l00320"></a>00320         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,p2,p3,op));
<a name="l00321"></a>00321         op2(semantic_at_c&lt;N-1&gt;(p1), semantic_at_c&lt;N-1&gt;(p2), semantic_at_c&lt;N-1&gt;(p3));
<a name="l00322"></a>00322         <span class="keywordflow">return</span> op2;
<a name="l00323"></a>00323     }
<a name="l00324"></a>00324     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00325"></a>00325     <span class="keyword">static</span> Op static_for_each(<span class="keyword">const</span> P1&amp; p1, P2&amp; p2, <span class="keyword">const</span> P3&amp; p3, Op op) {
<a name="l00326"></a>00326         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,p2,p3,op));
<a name="l00327"></a>00327         op2(semantic_at_c&lt;N-1&gt;(p1), semantic_at_c&lt;N-1&gt;(p2), semantic_at_c&lt;N-1&gt;(p3));
<a name="l00328"></a>00328         <span class="keywordflow">return</span> op2;
<a name="l00329"></a>00329     }
<a name="l00330"></a>00330     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00331"></a>00331     <span class="keyword">static</span> Op static_for_each(<span class="keyword">const</span> P1&amp; p1, <span class="keyword">const</span> P2&amp; p2, P3&amp; p3, Op op) {
<a name="l00332"></a>00332         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,p2,p3,op));
<a name="l00333"></a>00333         op2(semantic_at_c&lt;N-1&gt;(p1), semantic_at_c&lt;N-1&gt;(p2), semantic_at_c&lt;N-1&gt;(p3));
<a name="l00334"></a>00334         <span class="keywordflow">return</span> op2;
<a name="l00335"></a>00335     }
<a name="l00336"></a>00336     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00337"></a>00337     <span class="keyword">static</span> Op static_for_each(<span class="keyword">const</span> P1&amp; p1, <span class="keyword">const</span> P2&amp; p2, <span class="keyword">const</span> P3&amp; p3, Op op) {
<a name="l00338"></a>00338         Op op2(element_recursion&lt;N-1&gt;::static_for_each(p1,p2,p3,op));
<a name="l00339"></a>00339         op2(semantic_at_c&lt;N-1&gt;(p1), semantic_at_c&lt;N-1&gt;(p2), semantic_at_c&lt;N-1&gt;(p3));
<a name="l00340"></a>00340         <span class="keywordflow">return</span> op2;
<a name="l00341"></a>00341     }
<a name="l00342"></a>00342     <span class="comment">//static_transform with one source</span>
<a name="l00343"></a>00343     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; 
<a name="l00344"></a>00344     <span class="keyword">static</span> Op static_transform(P1&amp; src, Dst&amp; dst, Op op) {
<a name="l00345"></a>00345         Op op2(element_recursion&lt;N-1&gt;::static_transform(src,dst,op));
<a name="l00346"></a>00346         <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(dst)=op2(semantic_at_c&lt;N-1&gt;(src));
<a name="l00347"></a>00347         <span class="keywordflow">return</span> op2;
<a name="l00348"></a>00348     }
<a name="l00349"></a>00349     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt; 
<a name="l00350"></a>00350     <span class="keyword">static</span> Op static_transform(<span class="keyword">const</span> P1&amp; src, Dst&amp; dst, Op op) {
<a name="l00351"></a>00351         Op op2(element_recursion&lt;N-1&gt;::static_transform(src,dst,op));
<a name="l00352"></a>00352         <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(dst)=op2(semantic_at_c&lt;N-1&gt;(src));
<a name="l00353"></a>00353         <span class="keywordflow">return</span> op2;
<a name="l00354"></a>00354     }
<a name="l00355"></a>00355     <span class="comment">//static_transform with two sources</span>
<a name="l00356"></a>00356     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt;
<a name="l00357"></a>00357     <span class="keyword">static</span> Op static_transform(P1&amp; src1, P2&amp; src2, Dst&amp; dst, Op op) {
<a name="l00358"></a>00358         Op op2(element_recursion&lt;N-1&gt;::static_transform(src1,src2,dst,op));
<a name="l00359"></a>00359         <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(dst)=op2(semantic_at_c&lt;N-1&gt;(src1), <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(src2));
<a name="l00360"></a>00360         <span class="keywordflow">return</span> op2;
<a name="l00361"></a>00361     }
<a name="l00362"></a>00362     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt;
<a name="l00363"></a>00363     <span class="keyword">static</span> Op static_transform(P1&amp; src1, <span class="keyword">const</span> P2&amp; src2, Dst&amp; dst, Op op) {
<a name="l00364"></a>00364         Op op2(element_recursion&lt;N-1&gt;::static_transform(src1,src2,dst,op));
<a name="l00365"></a>00365         <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(dst)=op2(semantic_at_c&lt;N-1&gt;(src1), <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(src2));
<a name="l00366"></a>00366         <span class="keywordflow">return</span> op2;
<a name="l00367"></a>00367     }
<a name="l00368"></a>00368     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt;
<a name="l00369"></a>00369     <span class="keyword">static</span> Op static_transform(<span class="keyword">const</span> P1&amp; src1, P2&amp; src2, Dst&amp; dst, Op op) {
<a name="l00370"></a>00370         Op op2(element_recursion&lt;N-1&gt;::static_transform(src1,src2,dst,op));
<a name="l00371"></a>00371         <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(dst)=op2(semantic_at_c&lt;N-1&gt;(src1), <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(src2));
<a name="l00372"></a>00372         <span class="keywordflow">return</span> op2;
<a name="l00373"></a>00373     }
<a name="l00374"></a>00374     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt;
<a name="l00375"></a>00375     <span class="keyword">static</span> Op static_transform(<span class="keyword">const</span> P1&amp; src1, <span class="keyword">const</span> P2&amp; src2, Dst&amp; dst, Op op) {
<a name="l00376"></a>00376         Op op2(element_recursion&lt;N-1&gt;::static_transform(src1,src2,dst,op));
<a name="l00377"></a>00377         <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(dst)=op2(semantic_at_c&lt;N-1&gt;(src1), <a class="code" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11" title="A constant accessor to the K-th semantic element of a color base.">semantic_at_c</a>&lt;N-1&gt;(src2));
<a name="l00378"></a>00378         <span class="keywordflow">return</span> op2;
<a name="l00379"></a>00379     }
<a name="l00380"></a>00380 };
<a name="l00381"></a>00381 
<a name="l00382"></a>00382 <span class="comment">// Termination condition of the compile-time recursion for element operations on a color base</span>
<a name="l00383"></a>00383 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>element_recursion&lt;0&gt; {
<a name="l00384"></a>00384     <span class="comment">//static_equal</span>
<a name="l00385"></a>00385     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;
<a name="l00386"></a>00386     <span class="keyword">static</span> <span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> P1&amp;, <span class="keyword">const</span> P2&amp;) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00387"></a>00387     <span class="comment">//static_copy</span>
<a name="l00388"></a>00388     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;
<a name="l00389"></a>00389     <span class="keyword">static</span> <span class="keywordtype">void</span> static_copy(<span class="keyword">const</span> P1&amp;, <span class="keyword">const</span> P2&amp;) {}
<a name="l00390"></a>00390     <span class="comment">//static_fill</span>
<a name="l00391"></a>00391     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P, <span class="keyword">typename</span> T2&gt;
<a name="l00392"></a>00392     <span class="keyword">static</span> <span class="keywordtype">void</span> static_fill(<span class="keyword">const</span> P&amp;, T2) {}
<a name="l00393"></a>00393     <span class="comment">//static_generate</span>
<a name="l00394"></a>00394     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt;
<a name="l00395"></a>00395     <span class="keyword">static</span> <span class="keywordtype">void</span> static_generate(<span class="keyword">const</span> Dst&amp;,Op){}
<a name="l00396"></a>00396     <span class="comment">//static_for_each with one source</span>
<a name="l00397"></a>00397     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> Op&gt;
<a name="l00398"></a>00398     <span class="keyword">static</span> Op static_for_each(<span class="keyword">const</span> P1&amp;,Op op){<span class="keywordflow">return</span> op;}
<a name="l00399"></a>00399     <span class="comment">//static_for_each with two sources</span>
<a name="l00400"></a>00400     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Op&gt;
<a name="l00401"></a>00401     <span class="keyword">static</span> Op static_for_each(<span class="keyword">const</span> P1&amp;,<span class="keyword">const</span> P2&amp;,Op op){<span class="keywordflow">return</span> op;}
<a name="l00402"></a>00402     <span class="comment">//static_for_each with three sources</span>
<a name="l00403"></a>00403     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00404"></a>00404     <span class="keyword">static</span> Op static_for_each(<span class="keyword">const</span> P1&amp;,<span class="keyword">const</span> P2&amp;,<span class="keyword">const</span> P3&amp;,Op op){<span class="keywordflow">return</span> op;}
<a name="l00405"></a>00405     <span class="comment">//static_transform with one source</span>
<a name="l00406"></a>00406     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt;
<a name="l00407"></a>00407     <span class="keyword">static</span> Op static_transform(<span class="keyword">const</span> P1&amp;,<span class="keyword">const</span> Dst&amp;,Op op){<span class="keywordflow">return</span> op;}
<a name="l00408"></a>00408     <span class="comment">//static_transform with two sources</span>
<a name="l00409"></a>00409     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt;
<a name="l00410"></a>00410     <span class="keyword">static</span> Op static_transform(<span class="keyword">const</span> P1&amp;,<span class="keyword">const</span> P2&amp;,<span class="keyword">const</span> Dst&amp;,Op op){<span class="keywordflow">return</span> op;}
<a name="l00411"></a>00411 };
<a name="l00412"></a>00412 
<a name="l00413"></a>00413 <span class="comment">// std::min and std::max don't have the mutable overloads...</span>
<a name="l00414"></a>00414 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Q&gt; <span class="keyword">inline</span> <span class="keyword">const</span> Q&amp; mutable_min(<span class="keyword">const</span> Q&amp; x, <span class="keyword">const</span> Q&amp; y) { <span class="keywordflow">return</span> x&lt;y ? x : y; }
<a name="l00415"></a>00415 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Q&gt; <span class="keyword">inline</span>       Q&amp; mutable_min(      Q&amp; x,       Q&amp; y) { <span class="keywordflow">return</span> x&lt;y ? x : y; }
<a name="l00416"></a>00416 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Q&gt; <span class="keyword">inline</span> <span class="keyword">const</span> Q&amp; mutable_max(<span class="keyword">const</span> Q&amp; x, <span class="keyword">const</span> Q&amp; y) { <span class="keywordflow">return</span> x&lt;y ? y : x; }
<a name="l00417"></a>00417 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Q&gt; <span class="keyword">inline</span>       Q&amp; mutable_max(      Q&amp; x,       Q&amp; y) { <span class="keywordflow">return</span> x&lt;y ? y : x; }
<a name="l00418"></a>00418 
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 <span class="comment">// compile-time recursion for min/max element</span>
<a name="l00421"></a>00421 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N&gt;
<a name="l00422"></a>00422 <span class="keyword">struct </span>min_max_recur {
<a name="l00423"></a>00423     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt; <span class="keyword">static</span> <span class="keyword">typename</span> element_const_reference_type&lt;P&gt;::type max_(<span class="keyword">const</span> P&amp; p) {
<a name="l00424"></a>00424         <span class="keywordflow">return</span> mutable_max(min_max_recur&lt;N-1&gt;::max_(p),semantic_at_c&lt;N-1&gt;(p));
<a name="l00425"></a>00425     }    
<a name="l00426"></a>00426     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt; <span class="keyword">static</span> <span class="keyword">typename</span> element_reference_type&lt;P&gt;::type       max_(      P&amp; p) {
<a name="l00427"></a>00427         <span class="keywordflow">return</span> mutable_max(min_max_recur&lt;N-1&gt;::max_(p),semantic_at_c&lt;N-1&gt;(p));
<a name="l00428"></a>00428     }    
<a name="l00429"></a>00429     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt; <span class="keyword">static</span> <span class="keyword">typename</span> element_const_reference_type&lt;P&gt;::type min_(<span class="keyword">const</span> P&amp; p) {
<a name="l00430"></a>00430         <span class="keywordflow">return</span> mutable_min(min_max_recur&lt;N-1&gt;::min_(p),semantic_at_c&lt;N-1&gt;(p));
<a name="l00431"></a>00431     }    
<a name="l00432"></a>00432     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt; <span class="keyword">static</span> <span class="keyword">typename</span> element_reference_type&lt;P&gt;::type       min_(      P&amp; p) {
<a name="l00433"></a>00433         <span class="keywordflow">return</span> mutable_min(min_max_recur&lt;N-1&gt;::min_(p),semantic_at_c&lt;N-1&gt;(p));
<a name="l00434"></a>00434     }    
<a name="l00435"></a>00435 };
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="comment">// termination condition of the compile-time recursion for min/max element</span>
<a name="l00438"></a>00438 <span class="keyword">template</span> &lt;&gt;
<a name="l00439"></a>00439 <span class="keyword">struct </span>min_max_recur&lt;1&gt; {
<a name="l00440"></a>00440     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt; <span class="keyword">static</span> <span class="keyword">typename</span> element_const_reference_type&lt;P&gt;::type max_(<span class="keyword">const</span> P&amp; p) { <span class="keywordflow">return</span> semantic_at_c&lt;0&gt;(p); }
<a name="l00441"></a>00441     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt; <span class="keyword">static</span> <span class="keyword">typename</span> element_reference_type&lt;P&gt;::type       max_(      P&amp; p) { <span class="keywordflow">return</span> semantic_at_c&lt;0&gt;(p); }
<a name="l00442"></a>00442     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt; <span class="keyword">static</span> <span class="keyword">typename</span> element_const_reference_type&lt;P&gt;::type min_(<span class="keyword">const</span> P&amp; p) { <span class="keywordflow">return</span> semantic_at_c&lt;0&gt;(p); }
<a name="l00443"></a>00443     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt; <span class="keyword">static</span> <span class="keyword">typename</span> element_reference_type&lt;P&gt;::type       min_(      P&amp; p) { <span class="keywordflow">return</span> semantic_at_c&lt;0&gt;(p); }
<a name="l00444"></a>00444 };
<a name="l00445"></a>00445 }  <span class="comment">// namespace detail</span>
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 
<a name="l00463"></a>00463 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;
<a name="l00464"></a>00464 GIL_FORCEINLINE
<a name="l00465"></a>00465 <span class="keyword">typename</span> element_const_reference_type&lt;P&gt;::type static_max(<span class="keyword">const</span> P&amp; p) { <span class="keywordflow">return</span> detail::min_max_recur&lt;size&lt;P&gt;::value&gt;::max_(p); }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;
<a name="l00468"></a>00468 GIL_FORCEINLINE
<a name="l00469"></a>00469 <span class="keyword">typename</span> element_reference_type&lt;P&gt;::type       static_max(      P&amp; p) { <span class="keywordflow">return</span> detail::min_max_recur&lt;size&lt;P&gt;::value&gt;::max_(p); }
<a name="l00470"></a>00470 
<a name="l00471"></a>00471 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;
<a name="l00472"></a>00472 GIL_FORCEINLINE
<a name="l00473"></a>00473 <span class="keyword">typename</span> element_const_reference_type&lt;P&gt;::type static_min(<span class="keyword">const</span> P&amp; p) { <span class="keywordflow">return</span> detail::min_max_recur&lt;size&lt;P&gt;::value&gt;::min_(p); }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P&gt;
<a name="l00476"></a>00476 GIL_FORCEINLINE
<a name="l00477"></a>00477 <span class="keyword">typename</span> element_reference_type&lt;P&gt;::type       static_min(      P&amp; p) { <span class="keywordflow">return</span> detail::min_max_recur&lt;size&lt;P&gt;::value&gt;::min_(p); }
<a name="l00479"></a>00479 
<a name="l00497"></a>00497 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2&gt;
<a name="l00498"></a>00498 GIL_FORCEINLINE
<a name="l00499"></a>00499 <span class="keywordtype">bool</span> static_equal(<span class="keyword">const</span> P1&amp; p1, <span class="keyword">const</span> P2&amp; p2) { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_equal(p1,p2); }
<a name="l00500"></a>00500 
<a name="l00502"></a>00502 
<a name="l00520"></a>00520 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Src,<span class="keyword">typename</span> Dst&gt;
<a name="l00521"></a>00521 GIL_FORCEINLINE
<a name="l00522"></a>00522 <span class="keywordtype">void</span> static_copy(<span class="keyword">const</span> Src&amp; src, Dst&amp; dst) {  detail::element_recursion&lt;size&lt;Dst&gt;::value&gt;::static_copy(src,dst); }
<a name="l00523"></a>00523 
<a name="l00525"></a>00525 
<a name="l00539"></a>00539 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P,<span class="keyword">typename</span> V&gt;
<a name="l00540"></a>00540 GIL_FORCEINLINE
<a name="l00541"></a>00541 <span class="keywordtype">void</span> static_fill(P&amp; p, <span class="keyword">const</span> V&amp; v) {  detail::element_recursion&lt;size&lt;P&gt;::value&gt;::static_fill(p,v); }
<a name="l00543"></a>00543 
<a name="l00565"></a>00565 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> Op&gt;
<a name="l00566"></a>00566 GIL_FORCEINLINE
<a name="l00567"></a>00567 <span class="keywordtype">void</span> static_generate(P1&amp; dst,Op op)                      { detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_generate(dst,op); }
<a name="l00569"></a>00569 
<a name="l00598"></a>00598 <span class="comment">//static_transform with one source</span>
<a name="l00599"></a>00599 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Src,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt;
<a name="l00600"></a>00600 GIL_FORCEINLINE
<a name="l00601"></a>00601 Op static_transform(Src&amp; src,Dst&amp; dst,Op op)              { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;Dst&gt;::value&gt;::static_transform(src,dst,op); }
<a name="l00602"></a>00602 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Src,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt;
<a name="l00603"></a>00603 GIL_FORCEINLINE
<a name="l00604"></a>00604 Op static_transform(<span class="keyword">const</span> Src&amp; src,Dst&amp; dst,Op op)              { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;Dst&gt;::value&gt;::static_transform(src,dst,op); }
<a name="l00605"></a>00605 <span class="comment">//static_transform with two sources</span>
<a name="l00606"></a>00606 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt;
<a name="l00607"></a>00607 GIL_FORCEINLINE
<a name="l00608"></a>00608 Op static_transform(P2&amp; p2,P3&amp; p3,Dst&amp; dst,Op op) { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;Dst&gt;::value&gt;::static_transform(p2,p3,dst,op); }
<a name="l00609"></a>00609 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt;
<a name="l00610"></a>00610 GIL_FORCEINLINE
<a name="l00611"></a>00611 Op static_transform(P2&amp; p2,<span class="keyword">const</span> P3&amp; p3,Dst&amp; dst,Op op) { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;Dst&gt;::value&gt;::static_transform(p2,p3,dst,op); }
<a name="l00612"></a>00612 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt;
<a name="l00613"></a>00613 GIL_FORCEINLINE
<a name="l00614"></a>00614 Op static_transform(<span class="keyword">const</span> P2&amp; p2,P3&amp; p3,Dst&amp; dst,Op op) { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;Dst&gt;::value&gt;::static_transform(p2,p3,dst,op); }
<a name="l00615"></a>00615 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Dst,<span class="keyword">typename</span> Op&gt;
<a name="l00616"></a>00616 GIL_FORCEINLINE
<a name="l00617"></a>00617 Op static_transform(<span class="keyword">const</span> P2&amp; p2,<span class="keyword">const</span> P3&amp; p3,Dst&amp; dst,Op op) { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;Dst&gt;::value&gt;::static_transform(p2,p3,dst,op); }
<a name="l00619"></a>00619 
<a name="l00647"></a>00647 <span class="comment">//static_for_each with one source</span>
<a name="l00648"></a>00648 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> Op&gt;
<a name="l00649"></a>00649 GIL_FORCEINLINE
<a name="l00650"></a>00650 Op static_for_each(      P1&amp; p1, Op op)                          { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,op); }
<a name="l00651"></a>00651 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> Op&gt;
<a name="l00652"></a>00652 GIL_FORCEINLINE
<a name="l00653"></a>00653 Op static_for_each(<span class="keyword">const</span> P1&amp; p1, Op op)                          { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,op); }
<a name="l00654"></a>00654 <span class="comment">//static_for_each with two sources</span>
<a name="l00655"></a>00655 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Op&gt;
<a name="l00656"></a>00656 GIL_FORCEINLINE
<a name="l00657"></a>00657 Op static_for_each(P1&amp; p1,      P2&amp; p2, Op op)             { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,p2,op); }
<a name="l00658"></a>00658 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Op&gt;
<a name="l00659"></a>00659 GIL_FORCEINLINE
<a name="l00660"></a>00660 Op static_for_each(P1&amp; p1,<span class="keyword">const</span> P2&amp; p2, Op op)             { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,p2,op); }
<a name="l00661"></a>00661 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Op&gt;
<a name="l00662"></a>00662 GIL_FORCEINLINE
<a name="l00663"></a>00663 Op static_for_each(<span class="keyword">const</span> P1&amp; p1,      P2&amp; p2, Op op)             { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,p2,op); }
<a name="l00664"></a>00664 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> Op&gt;
<a name="l00665"></a>00665 GIL_FORCEINLINE
<a name="l00666"></a>00666 Op static_for_each(<span class="keyword">const</span> P1&amp; p1,<span class="keyword">const</span> P2&amp; p2, Op op)             { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,p2,op); }
<a name="l00667"></a>00667 <span class="comment">//static_for_each with three sources</span>
<a name="l00668"></a>00668 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00669"></a>00669 GIL_FORCEINLINE
<a name="l00670"></a>00670 Op static_for_each(P1&amp; p1,P2&amp; p2,P3&amp; p3,Op op) { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,p2,p3,op); }
<a name="l00671"></a>00671 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00672"></a>00672 GIL_FORCEINLINE
<a name="l00673"></a>00673 Op static_for_each(P1&amp; p1,P2&amp; p2,<span class="keyword">const</span> P3&amp; p3,Op op) { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,p2,p3,op); }
<a name="l00674"></a>00674 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00675"></a>00675 GIL_FORCEINLINE
<a name="l00676"></a>00676 Op static_for_each(P1&amp; p1,<span class="keyword">const</span> P2&amp; p2,P3&amp; p3,Op op) { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,p2,p3,op); }
<a name="l00677"></a>00677 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00678"></a>00678 GIL_FORCEINLINE
<a name="l00679"></a>00679 Op static_for_each(P1&amp; p1,<span class="keyword">const</span> P2&amp; p2,<span class="keyword">const</span> P3&amp; p3,Op op) { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,p2,p3,op); }
<a name="l00680"></a>00680 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00681"></a>00681 GIL_FORCEINLINE
<a name="l00682"></a>00682 Op static_for_each(<span class="keyword">const</span> P1&amp; p1,P2&amp; p2,P3&amp; p3,Op op) { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,p2,p3,op); }
<a name="l00683"></a>00683 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00684"></a>00684 GIL_FORCEINLINE
<a name="l00685"></a>00685 Op static_for_each(<span class="keyword">const</span> P1&amp; p1,P2&amp; p2,<span class="keyword">const</span> P3&amp; p3,Op op) { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,p2,p3,op); }
<a name="l00686"></a>00686 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00687"></a>00687 GIL_FORCEINLINE
<a name="l00688"></a>00688 Op static_for_each(<span class="keyword">const</span> P1&amp; p1,<span class="keyword">const</span> P2&amp; p2,P3&amp; p3,Op op) { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,p2,p3,op); }
<a name="l00689"></a>00689 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1,<span class="keyword">typename</span> P2,<span class="keyword">typename</span> P3,<span class="keyword">typename</span> Op&gt;
<a name="l00690"></a>00690 GIL_FORCEINLINE
<a name="l00691"></a>00691 Op static_for_each(<span class="keyword">const</span> P1&amp; p1,<span class="keyword">const</span> P2&amp; p2,<span class="keyword">const</span> P3&amp; p3,Op op) { <span class="keywordflow">return</span> detail::element_recursion&lt;size&lt;P1&gt;::value&gt;::static_for_each(p1,p2,p3,op); }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 } }  <span class="comment">// namespace boost::gil</span>
<a name="l00695"></a>00695 
<a name="l00696"></a>00696 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat May 2 13:50:13 2009 for Generic Image Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
