<!-- Copyright 2008 Lubomir Bourdev and Hailin Jin

     Distributed under the Boost Software License, Version 1.0.
     (See accompanying file LICENSE_1_0.txt or copy at
     http://www.boost.org/LICENSE_1_0.txt)
  -->

<!--
    Copyright 2005-2007 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
    <TITLE>Generic Image Library: Performance overloads of STL algorithms</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
</head>
<body>
<table border="0" cellspacing="0" cellpadding="0" style='width: 100%; margin: 0; padding: 0'><tr>
<td width="100%" valign="top" style='padding-left: 10px; padding-right: 10px; padding-bottom: 10px'>
<div class="qindex"><a class="qindex" href="index.html">Modules</a> 
                  | <a class="qindex" href="classes.html">Alphabetical List</a> 
                  | <a class="qindex" href="annotated.html">Class List</a> 
                  | <a class="qindex" href="dirs.html">Directories</a> 
                  | <a class="qindex" href="files.html">File List</a> 
                  | <a class="qindex" href="../index.html">GIL Home Page</a> 
</div>
<!-- End Header -->
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1>Performance overloads of STL algorithms<br>
<small>
[<a class="el" href="g_i_l_0138.html">Algorithms and Utility Functions</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
overloads of STL algorithms allowing more efficient implementation when used with GIL constructs 
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gc2faa90ab27d7fb0253d19839c75d341"></a><!-- doxytag: member="STLOptimizations::copy" ref="gc2faa90ab27d7fb0253d19839c75d341" args="(boost::gil::pixel&lt; T, Cs &gt; *first, boost::gil::pixel&lt; T, Cs &gt; *last, boost::gil::pixel&lt; T, Cs &gt; *dst)" -->
template&lt;typename T, typename Cs&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">GIL_FORCEINLINE <br>
<a class="el" href="g_i_l_0599.html">boost::gil::pixel</a>&lt; T, Cs &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0214.html#gc2faa90ab27d7fb0253d19839c75d341">copy</a> (<a class="el" href="g_i_l_0599.html">boost::gil::pixel</a>&lt; T, Cs &gt; *first, <a class="el" href="g_i_l_0599.html">boost::gil::pixel</a>&lt; T, Cs &gt; *last, <a class="el" href="g_i_l_0599.html">boost::gil::pixel</a>&lt; T, Cs &gt; *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy when both src and dst are interleaved and of the same type can be just memmove. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g85354afb86367e7d21162317463e8743"></a><!-- doxytag: member="STLOptimizations::copy" ref="g85354afb86367e7d21162317463e8743" args="(const boost::gil::pixel&lt; T, Cs &gt; *first, const boost::gil::pixel&lt; T, Cs &gt; *last, boost::gil::pixel&lt; T, Cs &gt; *dst)" -->
template&lt;typename T, typename Cs&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">GIL_FORCEINLINE <br>
<a class="el" href="g_i_l_0599.html">boost::gil::pixel</a>&lt; T, Cs &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0214.html#g85354afb86367e7d21162317463e8743">copy</a> (const <a class="el" href="g_i_l_0599.html">boost::gil::pixel</a>&lt; T, Cs &gt; *first, const <a class="el" href="g_i_l_0599.html">boost::gil::pixel</a>&lt; T, Cs &gt; *last, <a class="el" href="g_i_l_0599.html">boost::gil::pixel</a>&lt; T, Cs &gt; *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy when both src and dst are interleaved and of the same type can be just memmove. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g4e8a9e1bb08e76c93dc56a4626231ee1"></a><!-- doxytag: member="STLOptimizations::copy" ref="g4e8a9e1bb08e76c93dc56a4626231ee1" args="(boost::gil::planar_pixel_iterator&lt; IC1, Cs &gt; first, boost::gil::planar_pixel_iterator&lt; IC1, Cs &gt; last, boost::gil::planar_pixel_iterator&lt; IC2, Cs &gt; dst)" -->
template&lt;typename Cs, typename IC1, typename IC2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">GIL_FORCEINLINE <br>
<a class="el" href="g_i_l_0609.html">boost::gil::planar_pixel_iterator</a><br>
&lt; IC2, Cs &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0214.html#g4e8a9e1bb08e76c93dc56a4626231ee1">copy</a> (<a class="el" href="g_i_l_0609.html">boost::gil::planar_pixel_iterator</a>&lt; IC1, Cs &gt; first, <a class="el" href="g_i_l_0609.html">boost::gil::planar_pixel_iterator</a>&lt; IC1, Cs &gt; last, <a class="el" href="g_i_l_0609.html">boost::gil::planar_pixel_iterator</a>&lt; IC2, Cs &gt; dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy when both src and dst are planar pointers is copy for each channel. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g12594bf8bdb7b27c070987a3d30293ba"></a><!-- doxytag: member="STLOptimizations::copy1" ref="g12594bf8bdb7b27c070987a3d30293ba" args="(boost::gil::iterator_from_2d&lt; IL &gt; first, boost::gil::iterator_from_2d&lt; IL &gt; last, boost::gil::iterator_from_2d&lt; OL &gt; dst)" -->
template&lt;typename IL, typename OL&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">GIL_FORCEINLINE <br>
<a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a><br>
&lt; OL &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0214.html#g12594bf8bdb7b27c070987a3d30293ba">copy1</a> (<a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; IL &gt; first, <a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; IL &gt; last, <a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; OL &gt; dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">std::copy(I1,I1,I2) with I1 and I2 being a iterator_from_2d <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename IL, typename V&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0214.html#g718772a47188f4e2ecfce2f28fa3dc4f">fill</a> (<a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; IL &gt; first, <a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; IL &gt; last, const V &amp;val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">std::fill(I,I,V) with I being a iterator_from_2d  <a href="#g718772a47188f4e2ecfce2f28fa3dc4f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Loc1, typename Loc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">GIL_FORCEINLINE bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0214.html#g4ed3cf71cb0fbf435d1389df8567a4e5">equal</a> (<a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; Loc1 &gt; first, <a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; Loc1 &gt; last, <a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; Loc2 &gt; first2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">std::equal(I1,I1,I2) with I1 and I2 being a iterator_from_2d  <a href="#g4ed3cf71cb0fbf435d1389df8567a4e5"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g4ed3cf71cb0fbf435d1389df8567a4e5"></a><!-- doxytag: member="std::equal" ref="g4ed3cf71cb0fbf435d1389df8567a4e5" args="(boost::gil::iterator_from_2d&lt; Loc1 &gt; first, boost::gil::iterator_from_2d&lt; Loc1 &gt; last, boost::gil::iterator_from_2d&lt; Loc2 &gt; first2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GIL_FORCEINLINE bool std::equal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; Loc1 &gt;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; Loc1 &gt;&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; Loc2 &gt;&nbsp;</td>
          <td class="paramname"> <em>first2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
std::equal(I1,I1,I2) with I1 and I2 being a iterator_from_2d 
<p>
Invoked when one calls std::equal(I1,I1,I2) with I1 and I2 being a iterator_from_2d (which is a 1D iterator over the pixels in an image). Attempts to demote the source and destination iterators to simpler/faster types if the corresponding range is contiguous. For contiguous images (i.e. images that have no alignment gap at the end of each row) it is more efficient to use the underlying pixel iterator that does not check for the end of rows. If the underlying pixel iterator happens to be a fundamental planar/interleaved pointer, the call may further resolve to memcmp. Otherwise it resolves to copying each row using the underlying pixel iterator 
</div>
</div><p>
<a class="anchor" name="g718772a47188f4e2ecfce2f28fa3dc4f"></a><!-- doxytag: member="std::fill" ref="g718772a47188f4e2ecfce2f28fa3dc4f" args="(boost::gil::iterator_from_2d&lt; IL &gt; first, boost::gil::iterator_from_2d&lt; IL &gt; last, const V &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void std::fill           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; IL &gt;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; IL &gt;&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
std::fill(I,I,V) with I being a iterator_from_2d 
<p>
Invoked when one calls std::fill(I,I,V) with I being a iterator_from_2d (which is a 1D iterator over the pixels in an image). For contiguous images (i.e. images that have no alignment gap at the end of each row) it is more efficient to use the underlying pixel iterator that does not check for the end of rows. For non-contiguous images fill resolves to fill of each row using the underlying pixel iterator, which is still faster 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat May 2 13:50:16 2009 for Generic Image Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
