<!-- Copyright 2008 Lubomir Bourdev and Hailin Jin

     Distributed under the Boost Software License, Version 1.0.
     (See accompanying file LICENSE_1_0.txt or copy at
     http://www.boost.org/LICENSE_1_0.txt)
  -->

<!--
    Copyright 2005-2007 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
    <TITLE>Generic Image Library: Class List</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
</head>
<body>
<table border="0" cellspacing="0" cellpadding="0" style='width: 100%; margin: 0; padding: 0'><tr>
<td width="100%" valign="top" style='padding-left: 10px; padding-right: 10px; padding-bottom: 10px'>
<div class="qindex"><a class="qindex" href="index.html">Modules</a> 
                  | <a class="qindex" href="classes.html">Alphabetical List</a> 
                  | <a class="qindex" href="annotated.html">Class List</a> 
                  | <a class="qindex" href="dirs.html">Directories</a> 
                  | <a class="qindex" href="files.html">File List</a> 
                  | <a class="qindex" href="../index.html">GIL Home Page</a> 
</div>
<!-- End Header -->
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1>Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0385.html">alpha_t</a></td><td class="indexvalue">Alpha </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0018.html">any_image</a></td><td class="indexvalue">Represents a run-time specified <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a>. Note it does NOT model <a class="el" href="g_i_l_0306.html" title="2-dimensional image whose value type models PixelValueConcept">ImageConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0020.html">any_image_view</a></td><td class="indexvalue">Represents a run-time specified <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> view. Models <a class="el" href="g_i_l_0290.html" title="Concept for iterators, locators and views that can define a type just like the given...">HasDynamicXStepTypeConcept</a>, <a class="el" href="g_i_l_0292.html" title="Concept for locators and views that can define a type just like the given locator...">HasDynamicYStepTypeConcept</a>, Note that this class does NOT model <a class="el" href="g_i_l_0308.html" title="GIL&#39;s 2-dimensional view over immutable GIL pixels.">ImageViewConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0262.html">Assignable</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0387.html">binary_operation_obj</a></td><td class="indexvalue">A generic binary operation on views<p>
Use this class as a convenience superclass when defining an operation for any <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> views. Many operations have different behavior when the two views are compatible. This class checks for compatibility and invokes apply_compatible(V1,V2) or apply_incompatible(V1,V2) of the subclass. You must provide apply_compatible(V1,V2) method in your subclass, but apply_incompatible(V1,V2) is not required and the default throws std::bad_cast </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0389.html">bit_aligned_image1_type</a></td><td class="indexvalue">Returns the type of a single-channel bit-aligned <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> given the bit <a class="el" href="g_i_l_0621.html" title="Returns an MPL integral type specifying the number of elements in a color base.">size</a> of its channel and its <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0391.html">bit_aligned_image2_type</a></td><td class="indexvalue">Returns the type of a two channel bit-aligned <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> given the bit <a class="el" href="g_i_l_0621.html" title="Returns an MPL integral type specifying the number of elements in a color base.">size</a> of its channels and its <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0393.html">bit_aligned_image3_type</a></td><td class="indexvalue">Returns the type of a three channel bit-aligned <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> given the bit <a class="el" href="g_i_l_0621.html" title="Returns an MPL integral type specifying the number of elements in a color base.">size</a> of its channels and its <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0395.html">bit_aligned_image4_type</a></td><td class="indexvalue">Returns the type of a four channel bit-aligned <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> given the bit <a class="el" href="g_i_l_0621.html" title="Returns an MPL integral type specifying the number of elements in a color base.">size</a> of its channels and its <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0397.html">bit_aligned_image5_type</a></td><td class="indexvalue">Returns the type of a five channel bit-aligned <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> given the bit <a class="el" href="g_i_l_0621.html" title="Returns an MPL integral type specifying the number of elements in a color base.">size</a> of its channels and its <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0399.html">bit_aligned_image_type</a></td><td class="indexvalue">Returns the type of a packed <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> whose pixels may not be byte aligned. For example, an "rgb222" <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> is bit-aligned because its <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> spans six bits </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0401.html">bit_aligned_pixel_iterator</a></td><td class="indexvalue">An iterator over non-byte-aligned pixels. Models <a class="el" href="g_i_l_0352.html" title="An STL random access traversal iterator over a model of PixelConcept.">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0344.html" title="Concept for all pixel-based GIL constructs, such as pixels, iterators, locators,...">PixelBasedConcept</a>, <a class="el" href="g_i_l_0312.html" title="Concept of a random-access iterator that can be advanced in memory units (bytes or...">MemoryBasedIteratorConcept</a>, <a class="el" href="g_i_l_0290.html" title="Concept for iterators, locators and views that can define a type just like the given...">HasDynamicXStepTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0403.html">bit_aligned_pixel_reference</a></td><td class="indexvalue">Heterogeneous <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> reference corresponding to non-byte-aligned bit range. Models <a class="el" href="g_i_l_0274.html" title="A color base is a container of color elements (such as channels, channel references...">ColorBaseConcept</a>, <a class="el" href="g_i_l_0346.html" title="Pixel concept - A color base whose elements are channels.">PixelConcept</a>, <a class="el" href="g_i_l_0344.html" title="Concept for all pixel-based GIL constructs, such as pixels, iterators, locators,...">PixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0404.html">black_t</a></td><td class="indexvalue">Black </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0405.html">blue_t</a></td><td class="indexvalue">Blue </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0406.html">byte_to_memunit</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0408.html">channel_converter</a></td><td class="indexvalue">A unary function object converting between channel types </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0412.html">channel_converter_unsigned&lt; bits32, bits32f &gt;</a></td><td class="indexvalue">32 bit &lt;-&gt; float channel conversion </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0416.html">channel_converter_unsigned&lt; bits32f, bits32 &gt;</a></td><td class="indexvalue">32 bit &lt;-&gt; float channel conversion </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0414.html">channel_converter_unsigned&lt; bits32f, DstChannelV &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0410.html">channel_converter_unsigned&lt; T, T &gt;</a></td><td class="indexvalue">Converting a channel to itself - identity operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0477.html">channel_converter_unsigned_impl</a></td><td class="indexvalue">This is the default implementation. Performance specializatons are provided </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0418.html">channel_mapping_type&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue">Specifies the color space type of a planar <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> reference. Required by <a class="el" href="g_i_l_0344.html" title="Concept for all pixel-based GIL constructs, such as pixels, iterators, locators,...">PixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0420.html">channel_multiplier</a></td><td class="indexvalue">A function object to multiply two channels. result = a * b / max_value </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0422.html">channel_multiplier_unsigned</a></td><td class="indexvalue">This is the default implementation. Performance specializatons are provided </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0424.html">channel_multiplier_unsigned&lt; bits16 &gt;</a></td><td class="indexvalue">Specialization of channel_multiply for 16-bit unsigned channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0426.html">channel_multiplier_unsigned&lt; bits32f &gt;</a></td><td class="indexvalue">Specialization of channel_multiply for float 0..1 channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0428.html">channel_multiplier_unsigned&lt; bits8 &gt;</a></td><td class="indexvalue">Specialization of channel_multiply for 8-bit unsigned channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0429.html">channel_traits</a></td><td class="indexvalue">Traits for channels. Contains the following members: </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0431.html">channel_type&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue">Specifies the color space type of a planar <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> reference. Required by <a class="el" href="g_i_l_0300.html" title="Concept for homogeneous pixel-based GIL constructs.">HomogeneousPixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0264.html">ChannelConcept</a></td><td class="indexvalue">A channel is the building block of a color. Color is defined as a mixture of primary colors and a channel defines the degree to which each primary color is used in the mixture </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0266.html">ChannelConvertibleConcept</a></td><td class="indexvalue">A channel is convertible to another one if the <code>channel_convert</code> algorithm is defined for the two channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0268.html">ChannelMappingConcept</a></td><td class="indexvalue">Channel mapping concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0432.html">channels_are_compatible</a></td><td class="indexvalue">Predicate metafunction returning whether two channels are compatible<p>
Channels are considered compatible if their value types (ignoring constness and references) are the same </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0272.html">ChannelsCompatibleConcept</a></td><td class="indexvalue">Channels are compatible if their associated value types (ignoring constness and references) are the same </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0270.html">ChannelValueConcept</a></td><td class="indexvalue">A channel that supports default construction </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0022.html">color_convert_deref_fn</a></td><td class="indexvalue">Function object that given a source <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a>, returns it converted to a given color space and channel depth. Models: <a class="el" href="g_i_l_0350.html" title="Represents a unary function object that can be invoked upon dereferencing a pixel...">PixelDereferenceAdaptorConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0434.html">color_converted_view_type</a></td><td class="indexvalue">Returns the type of a view that does color conversion upon dereferencing its pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0438.html">color_converted_view_type&lt; any_image_view&lt; ViewTypes &gt;, DstP &gt;</a></td><td class="indexvalue">Returns the type of a runtime-specified view, color-converted to a given <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> type with the default coor converter </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0436.html">color_converted_view_type&lt; any_image_view&lt; ViewTypes &gt;, DstP, CC &gt;</a></td><td class="indexvalue">Returns the type of a runtime-specified view, color-converted to a given <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> type with user specified color converter </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0440.html">color_element_const_reference_type</a></td><td class="indexvalue">Specifies the return type of the constant element accessor by color name, get_color(color_base, Color()); </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0442.html">color_element_reference_type</a></td><td class="indexvalue">Specifies the return type of the mutable element accessor by color name, get_color(color_base, Color()); </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0444.html">color_element_type</a></td><td class="indexvalue">Specifies the type of the element associated with a given color tag </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0445.html">color_space_type&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue">Specifies the color space type of a planar <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> reference. Required by <a class="el" href="g_i_l_0344.html" title="Concept for all pixel-based GIL constructs, such as pixels, iterators, locators,...">PixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0274.html">ColorBaseConcept</a></td><td class="indexvalue">A color base is a container of color elements (such as channels, channel references or channel pointers) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0278.html">ColorBasesCompatibleConcept</a></td><td class="indexvalue">Two color bases are compatible if they have the same color space and their elements are compatible, semantic-pairwise </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0276.html">ColorBaseValueConcept</a></td><td class="indexvalue">Color base that also has a default-constructor. Refines <a class="el" href="g_i_l_0376.html">Regular</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0280.html">ColorSpaceConcept</a></td><td class="indexvalue">Color space type concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0282.html">ColorSpacesCompatibleConcept</a></td><td class="indexvalue">Two color spaces are compatible if they are the same </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0447.html">contains_color</a></td><td class="indexvalue">A predicate metafunction determining whether a given color base contains a given color </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0479.html">copier_n</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0481.html">copier_n&lt; I, iterator_from_2d&lt; OL &gt; &gt;</a></td><td class="indexvalue">Destination range is delimited by <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> iterators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0485.html">copier_n&lt; iterator_from_2d&lt; IL &gt;, iterator_from_2d&lt; OL &gt; &gt;</a></td><td class="indexvalue">Both source and destination ranges are delimited by <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> iterators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0483.html">copier_n&lt; iterator_from_2d&lt; IL &gt;, O &gt;</a></td><td class="indexvalue">Source range is delimited by <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> iterators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0284.html">CopyConstructible</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0448.html">cyan_t</a></td><td class="indexvalue">Cyan </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0487.html">dec</a></td><td class="indexvalue">Operator-- wrapped in a function object </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0450.html">default_channel_converter</a></td><td class="indexvalue">Same as <a class="el" href="g_i_l_0408.html" title="A unary function object converting between channel types.">channel_converter</a>, except it takes the destination channel by reference, which allows us to move the templates from the class level to the method level. This is important when invoking it on heterogeneous pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0452.html">default_color_converter</a></td><td class="indexvalue">Class for color-converting one <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> to another </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0453.html">default_color_converter_impl</a></td><td class="indexvalue">Color Convertion function object. To be specialized for every src/dst color space </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0457.html">default_color_converter_impl&lt; C, C &gt;</a></td><td class="indexvalue">When the color space is the same, color convertion performs channel depth conversion </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0455.html">default_color_converter_impl&lt; C1, rgba_t &gt;</a></td><td class="indexvalue">Converting any <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> type to RGBA. Note: Supports homogeneous pixels only </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0459.html">default_color_converter_impl&lt; cmyk_t, gray_t &gt;</a></td><td class="indexvalue">CMYK to Gray </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0461.html">default_color_converter_impl&lt; cmyk_t, rgb_t &gt;</a></td><td class="indexvalue">CMYK to RGB (not the fastest code in the world) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0463.html">default_color_converter_impl&lt; gray_t, cmyk_t &gt;</a></td><td class="indexvalue">Gray to CMYK </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0465.html">default_color_converter_impl&lt; gray_t, rgb_t &gt;</a></td><td class="indexvalue">Gray to RGB </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0467.html">default_color_converter_impl&lt; rgb_t, cmyk_t &gt;</a></td><td class="indexvalue">RGB to CMYK (not the fastest code in the world) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0469.html">default_color_converter_impl&lt; rgb_t, gray_t &gt;</a></td><td class="indexvalue">RGB to Gray </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0471.html">default_color_converter_impl&lt; rgba_t, C2 &gt;</a></td><td class="indexvalue">Converting RGBA to any <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> type. Note: Supports homogeneous pixels only </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0473.html">default_color_converter_impl&lt; rgba_t, rgba_t &gt;</a></td><td class="indexvalue">Unfortunately RGBA to RGBA must be explicitly provided - otherwise we get ambiguous specialization error </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0286.html">DefaultConstructible</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0475.html">deref_base</a></td><td class="indexvalue">Helper base class for <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> dereference adaptors </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0024.html">deref_compose</a></td><td class="indexvalue">Composes two dereference function objects. Similar to std::unary_compose but needs to pull some typedefs from the component types. Models: <a class="el" href="g_i_l_0350.html" title="Represents a unary function object that can be invoked upon dereferencing a pixel...">PixelDereferenceAdaptorConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0026.html">dereference_iterator_adaptor</a></td><td class="indexvalue">An adaptor over an existing iterator that provides for custom filter on dereferencing the object. Models: <a class="el" href="g_i_l_0310.html" title="Iterator adaptor is a forward iterator adapting another forward iterator.">IteratorAdaptorConcept</a>, <a class="el" href="g_i_l_0352.html" title="An STL random access traversal iterator over a model of PixelConcept.">PixelIteratorConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0028.html">derived_image_type</a></td><td class="indexvalue">Constructs a homogeneous <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> type from a source <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> type by changing some of the properties.<p>
Use use_default for the properties of the source <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> that you want to keep </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0030.html">derived_iterator_type</a></td><td class="indexvalue">Constructs a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> iterator type from a source <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> iterator type by changing some of the properties.<p>
Use use_default for the properties of the source view that you want to keep </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0032.html">derived_pixel_reference_type</a></td><td class="indexvalue">Constructs a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> reference type from a source <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> reference type by changing some of the properties.<p>
Use use_default for the properties of the source view that you want to keep </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0034.html">derived_view_type</a></td><td class="indexvalue">Constructs an <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> view type from a source view type by changing some of the properties.<p>
Use use_default for the properties of the source view that you want to keep </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0523.html">devicen_color_t</a></td><td class="indexvalue">Unnamed color </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0525.html">devicen_layout_t</a></td><td class="indexvalue">Unnamed color <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> of up to five channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0526.html">devicen_t&lt; 1 &gt;</a></td><td class="indexvalue">Unnamed color space of one channel </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0527.html">devicen_t&lt; 2 &gt;</a></td><td class="indexvalue">Unnamed color space of two channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0528.html">devicen_t&lt; 3 &gt;</a></td><td class="indexvalue">Unnamed color space of three channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0529.html">devicen_t&lt; 4 &gt;</a></td><td class="indexvalue">Unnamed color space of four channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0530.html">devicen_t&lt; 5 &gt;</a></td><td class="indexvalue">Unnamed color space of five channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0531.html">dynamic_xy_step_transposed_type</a></td><td class="indexvalue">Returns the type of a transposed view that has a dynamic step along both X and Y </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0532.html">dynamic_xy_step_type</a></td><td class="indexvalue">Returns the type of a view that has a dynamic step along both X and Y </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0533.html">element_const_reference_type</a></td><td class="indexvalue">Specifies the return type of the constant element accessor at_c of a homogeneous color base </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0534.html">element_reference_type</a></td><td class="indexvalue">Specifies the return type of the mutable element accessor at_c of a homogeneous color base </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0535.html">element_type</a></td><td class="indexvalue">Specifies the element type of a homogeneous color base </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0493.html">equal_n_fn&lt; boost::gil::iterator_from_2d&lt; Loc &gt;, I2 &gt;</a></td><td class="indexvalue">Source range is delimited by <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> iterators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0490.html">equal_n_fn&lt; boost::gil::iterator_from_2d&lt; Loc1 &gt;, boost::gil::iterator_from_2d&lt; Loc2 &gt; &gt;</a></td><td class="indexvalue">Both source and destination ranges are delimited by <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> iterators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0494.html">equal_n_fn&lt; const pixel&lt; T, Cs &gt; *, const pixel&lt; T, Cs &gt; * &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0489.html">equal_n_fn&lt; I1, boost::gil::iterator_from_2d&lt; Loc &gt; &gt;</a></td><td class="indexvalue">Destination range is delimited by <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> iterators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0496.html">equal_n_fn&lt; planar_pixel_iterator&lt; IC, Cs &gt;, planar_pixel_iterator&lt; IC, Cs &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0288.html">EqualityComparable</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0536.html">gray_color_t</a></td><td class="indexvalue">Gray </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0537.html">green_t</a></td><td class="indexvalue">Green </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0290.html">HasDynamicXStepTypeConcept</a></td><td class="indexvalue">Concept for iterators, locators and views that can define a type just like the given iterator/locator/view, except it supports runtime specified step along the X navigation </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0292.html">HasDynamicYStepTypeConcept</a></td><td class="indexvalue">Concept for locators and views that can define a type just like the given locator or view, except it supports runtime specified step along the Y navigation </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0294.html">HasTransposedTypeConcept</a></td><td class="indexvalue">Concept for locators and views that can define a type just like the given locator or view, except X and Y is swapped </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0499.html">homogeneous_color_base&lt; Element, Layout, 1 &gt;</a></td><td class="indexvalue">A homogeneous color base holding one color element. Models <a class="el" href="g_i_l_0296.html" title="Color base whose elements all have the same type.">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0298.html" title="Homogeneous color base that also has a default constructor. Refines Regular.">HomogeneousColorBaseValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0501.html">homogeneous_color_base&lt; Element, Layout, 2 &gt;</a></td><td class="indexvalue">A homogeneous color base holding two color elements. Models <a class="el" href="g_i_l_0296.html" title="Color base whose elements all have the same type.">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0298.html" title="Homogeneous color base that also has a default constructor. Refines Regular.">HomogeneousColorBaseValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0503.html">homogeneous_color_base&lt; Element, Layout, 3 &gt;</a></td><td class="indexvalue">A homogeneous color base holding three color elements. Models <a class="el" href="g_i_l_0296.html" title="Color base whose elements all have the same type.">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0298.html" title="Homogeneous color base that also has a default constructor. Refines Regular.">HomogeneousColorBaseValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0505.html">homogeneous_color_base&lt; Element, Layout, 4 &gt;</a></td><td class="indexvalue">A homogeneous color base holding four color elements. Models <a class="el" href="g_i_l_0296.html" title="Color base whose elements all have the same type.">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0298.html" title="Homogeneous color base that also has a default constructor. Refines Regular.">HomogeneousColorBaseValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0507.html">homogeneous_color_base&lt; Element, Layout, 5 &gt;</a></td><td class="indexvalue">A homogeneous color base holding five color elements. Models <a class="el" href="g_i_l_0296.html" title="Color base whose elements all have the same type.">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0298.html" title="Homogeneous color base that also has a default constructor. Refines Regular.">HomogeneousColorBaseValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0296.html">HomogeneousColorBaseConcept</a></td><td class="indexvalue">Color base whose elements all have the same type </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0298.html">HomogeneousColorBaseValueConcept</a></td><td class="indexvalue">Homogeneous color base that also has a default constructor. Refines <a class="el" href="g_i_l_0376.html">Regular</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0300.html">HomogeneousPixelBasedConcept</a></td><td class="indexvalue">Concept for homogeneous pixel-based GIL constructs </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0302.html">HomogeneousPixelConcept</a></td><td class="indexvalue">Homogeneous <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0304.html">HomogeneousPixelValueConcept</a></td><td class="indexvalue">Homogeneous <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> concept that is a <a class="el" href="g_i_l_0376.html">Regular</a> type </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0509.html">identity</a></td><td class="indexvalue">Identity taken from SGI STL </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0038.html">image</a></td><td class="indexvalue">Container interface over <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> view. Models <a class="el" href="g_i_l_0306.html" title="2-dimensional image whose value type models PixelValueConcept">ImageConcept</a>, <a class="el" href="g_i_l_0344.html" title="Concept for all pixel-based GIL constructs, such as pixels, iterators, locators,...">PixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0538.html">image_is_basic</a></td><td class="indexvalue">Basic images must use basic views and std::allocator of char </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0540.html">image_type</a></td><td class="indexvalue">Returns the type of a homogeneous <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> given the channel type, <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a>, and whether it operates on planar data </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0040.html">image_view</a></td><td class="indexvalue">A lightweight object that interprets memory as a 2D array of pixels. Models <a class="el" href="g_i_l_0308.html" title="GIL&#39;s 2-dimensional view over immutable GIL pixels.">ImageViewConcept</a>,<a class="el" href="g_i_l_0344.html" title="Concept for all pixel-based GIL constructs, such as pixels, iterators, locators,...">PixelBasedConcept</a>,<a class="el" href="g_i_l_0290.html" title="Concept for iterators, locators and views that can define a type just like the given...">HasDynamicXStepTypeConcept</a>,<a class="el" href="g_i_l_0292.html" title="Concept for locators and views that can define a type just like the given locator...">HasDynamicYStepTypeConcept</a>,<a class="el" href="g_i_l_0294.html" title="Concept for locators and views that can define a type just like the given locator...">HasTransposedTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0306.html">ImageConcept</a></td><td class="indexvalue">2-dimensional <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> whose value type models <a class="el" href="g_i_l_0356.html" title="Pixel concept that is a Regular type.">PixelValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0308.html">ImageViewConcept</a></td><td class="indexvalue">GIL's 2-dimensional view over immutable GIL pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0511.html">inc</a></td><td class="indexvalue">Operator++ wrapped in a function object </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0541.html">is_iterator_adaptor</a></td><td class="indexvalue"><a class="el" href="g_i_l_0314.html">Metafunction</a> predicate determining whether the given iterator is a plain one or an adaptor over another iterator. Examples of adaptors are the step iterator and the dereference iterator adaptor </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0542.html">is_pixel&lt; bit_aligned_pixel_reference&lt; B, C, L, M &gt; &gt;</a></td><td class="indexvalue"><a class="el" href="g_i_l_0314.html">Metafunction</a> predicate that flags <a class="el" href="g_i_l_0403.html" title="Heterogeneous pixel reference corresponding to non-byte-aligned bit range. Models...">bit_aligned_pixel_reference</a> as a model of <a class="el" href="g_i_l_0346.html" title="Pixel concept - A color base whose elements are channels.">PixelConcept</a>. Required by <a class="el" href="g_i_l_0346.html" title="Pixel concept - A color base whose elements are channels.">PixelConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0543.html">is_pixel&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue"><a class="el" href="g_i_l_0314.html">Metafunction</a> predicate that flags <a class="el" href="g_i_l_0611.html" title="A reference proxy to a planar pixel. Models: HomogeneousColorBaseConcept, HomogeneousPixelConcept...">planar_pixel_reference</a> as a model of <a class="el" href="g_i_l_0346.html" title="Pixel concept - A color base whose elements are channels.">PixelConcept</a>. Required by <a class="el" href="g_i_l_0346.html" title="Pixel concept - A color base whose elements are channels.">PixelConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0544.html">is_planar&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue">Specifies that <a class="el" href="g_i_l_0611.html" title="A reference proxy to a planar pixel. Models: HomogeneousColorBaseConcept, HomogeneousPixelConcept...">planar_pixel_reference</a> represents a planar construct. Required by <a class="el" href="g_i_l_0344.html" title="Concept for all pixel-based GIL constructs, such as pixels, iterators, locators,...">PixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0546.html">iterator_add_deref</a></td><td class="indexvalue">Returns the type (and creates an instance) of an iterator that invokes the given dereference adaptor upon dereferencing </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0547.html">iterator_add_deref&lt; dereference_iterator_adaptor&lt; Iterator, PREV_DEREF &gt;, Deref &gt;</a></td><td class="indexvalue">For dereference iterator adaptors, compose the new function object after the old one </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0042.html">iterator_from_2d</a></td><td class="indexvalue">Provides 1D random-access navigation to the pixels of the <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a>. Models: <a class="el" href="g_i_l_0352.html" title="An STL random access traversal iterator over a model of PixelConcept.">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0344.html" title="Concept for all pixel-based GIL constructs, such as pixels, iterators, locators,...">PixelBasedConcept</a>, <a class="el" href="g_i_l_0290.html" title="Concept for iterators, locators and views that can define a type just like the given...">HasDynamicXStepTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0549.html">iterator_is_basic</a></td><td class="indexvalue">Determines if a given <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> iterator is basic Basic iterators must use <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">gil::pixel</a> (if interleaved), <a class="el" href="g_i_l_0609.html" title="An iterator over planar pixels. Models HomogeneousColorBaseConcept, PixelIteratorConcept...">gil::planar_pixel_iterator</a> (if planar) and <a class="el" href="g_i_l_0046.html" title="Iterator with dynamically specified step in memory units (bytes or bits). Models...">gil::memory_based_step_iterator</a> (if step). They must use the standard constness rules </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0550.html">iterator_is_mutable</a></td><td class="indexvalue"><a class="el" href="g_i_l_0314.html">Metafunction</a> predicate returning whether the given iterator allows for changing its values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0551.html">iterator_is_step</a></td><td class="indexvalue">Determines if the given iterator has a step that could be set dynamically </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0552.html">iterator_type</a></td><td class="indexvalue">Returns the type of a homogeneous iterator given the channel type, <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a>, whether it operates on planar data, whether it is a step iterator, and whether it is mutable </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0553.html">iterator_type_from_pixel</a></td><td class="indexvalue">Returns the type of a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> iterator given the <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> type, whether it operates on planar data, whether it is a step iterator, and whether it is mutable </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0310.html">IteratorAdaptorConcept</a></td><td class="indexvalue">Iterator adaptor is a forward iterator adapting another forward iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0555.html">jpeg_read_support</a></td><td class="indexvalue">Determines whether the given view type is supported for reading </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0557.html">jpeg_write_support</a></td><td class="indexvalue">Determines whether the given view type is supported for writing </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0513.html">kth_channel_deref_fn</a></td><td class="indexvalue">Function object that returns a grayscale reference of the K-th channel (specified as a template parameter) of a given reference. Models: <a class="el" href="g_i_l_0350.html" title="Represents a unary function object that can be invoked upon dereferencing a pixel...">PixelDereferenceAdaptorConcept</a>.<p>
If the input is a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> value or constant reference, the function object is immutable. Otherwise it is mutable (and returns non-const reference to the k-th channel) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0559.html">kth_channel_view_type</a></td><td class="indexvalue">Given a source <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> view type View, returns the type of an <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> view over a given channel of View.<p>
If the channels in the source view are adjacent in memory (such as planar non-step view or single-channel view) then the return view is a single-channel non-step view. If the channels are non-adjacent (interleaved and/or step view) then the return view is a single-channel step view </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0561.html">kth_semantic_element_const_reference_type</a></td><td class="indexvalue">Specifies the return type of the constant semantic_at_c&lt;K&gt;(color_base); </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0563.html">kth_semantic_element_reference_type</a></td><td class="indexvalue">Specifies the return type of the mutable semantic_at_c&lt;K&gt;(color_base); </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0565.html">kth_semantic_element_type</a></td><td class="indexvalue">Specifies the type of the K-th semantic element of a color base </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0567.html">layout</a></td><td class="indexvalue">Represents a color space and ordering of channels in memory </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0568.html">locator_is_basic</a></td><td class="indexvalue">Determines if a given locator is basic. A basic locator is memory-based and has basic x_iterator and y_iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0569.html">locator_is_mutable</a></td><td class="indexvalue">Determines if the given locator is mutable (i.e. its pixels can be changed) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0570.html">locator_is_step_in_x</a></td><td class="indexvalue">Determines if the given locator has a horizontal step that could be set dynamically </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0571.html">locator_is_step_in_y</a></td><td class="indexvalue">Determines if the given locator has a vertical step that could be set dynamically </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0573.html">locator_type</a></td><td class="indexvalue">Returns the type of a homogeneous locator given the channel type, <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a>, whether it operates on planar data and whether it has a step horizontally </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0574.html">magenta_t</a></td><td class="indexvalue">Magenta </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0044.html">memory_based_2d_locator</a></td><td class="indexvalue">Memory-based <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> locator. Models: <a class="el" href="g_i_l_0354.html" title="GIL&#39;s 2-dimensional locator over immutable GIL pixels.">PixelLocatorConcept</a>,<a class="el" href="g_i_l_0290.html" title="Concept for iterators, locators and views that can define a type just like the given...">HasDynamicXStepTypeConcept</a>,<a class="el" href="g_i_l_0292.html" title="Concept for locators and views that can define a type just like the given locator...">HasDynamicYStepTypeConcept</a>,<a class="el" href="g_i_l_0294.html" title="Concept for locators and views that can define a type just like the given locator...">HasTransposedTypeConcept</a><p>
The class takes a step iterator as a parameter. The step iterator provides navigation along the vertical axis while its base iterator provides horizontal navigation </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0046.html">memory_based_step_iterator</a></td><td class="indexvalue">Iterator with dynamically specified step in memory units (bytes or bits). Models <a class="el" href="g_i_l_0380.html" title="Step iterator concept.">StepIteratorConcept</a>, <a class="el" href="g_i_l_0310.html" title="Iterator adaptor is a forward iterator adapting another forward iterator.">IteratorAdaptorConcept</a>, <a class="el" href="g_i_l_0312.html" title="Concept of a random-access iterator that can be advanced in memory units (bytes or...">MemoryBasedIteratorConcept</a>, <a class="el" href="g_i_l_0352.html" title="An STL random access traversal iterator over a model of PixelConcept.">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0290.html" title="Concept for iterators, locators and views that can define a type just like the given...">HasDynamicXStepTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0312.html">MemoryBasedIteratorConcept</a></td><td class="indexvalue">Concept of a random-access iterator that can be advanced in memory units (bytes or bits) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0576.html">memunit_step_fn</a></td><td class="indexvalue">Function object that returns the memory unit distance between two iterators and advances a given iterator a given number of mem units (bytes or bits) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0314.html">Metafunction</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0316.html">MutableChannelConcept</a></td><td class="indexvalue">A channel that allows for modifying its value </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0318.html">MutableColorBaseConcept</a></td><td class="indexvalue">Color base which allows for modifying its elements </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0320.html">MutableHomogeneousColorBaseConcept</a></td><td class="indexvalue">Homogeneous color base that allows for modifying its elements </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0322.html">MutableHomogeneousPixelConcept</a></td><td class="indexvalue">Homogeneous <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> concept that allows for changing its channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0324.html">MutableImageViewConcept</a></td><td class="indexvalue">GIL's 2-dimensional view over mutable GIL pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0326.html">MutableIteratorAdaptorConcept</a></td><td class="indexvalue">Iterator adaptor that is mutable </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0328.html">MutablePixelConcept</a></td><td class="indexvalue">Pixel concept that allows for changing its channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0330.html">MutablePixelIteratorConcept</a></td><td class="indexvalue">Pixel iterator that allows for changing its <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0332.html">MutablePixelLocatorConcept</a></td><td class="indexvalue">GIL's 2-dimensional locator over mutable GIL pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0334.html">MutableRandomAccess2DImageViewConcept</a></td><td class="indexvalue">2-dimensional view over mutable values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0336.html">MutableRandomAccess2DLocatorConcept</a></td><td class="indexvalue">2-dimensional locator over mutable pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0338.html">MutableRandomAccessNDImageViewConcept</a></td><td class="indexvalue">N-dimensional view over mutable values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0340.html">MutableRandomAccessNDLocatorConcept</a></td><td class="indexvalue">N-dimensional locator over mutable pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0342.html">MutableStepIteratorConcept</a></td><td class="indexvalue">Step iterator that allows for modifying its current value </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0515.html">nth_channel_deref_fn</a></td><td class="indexvalue">Function object that returns a grayscale reference of the N-th channel of a given reference. Models: <a class="el" href="g_i_l_0350.html" title="Represents a unary function object that can be invoked upon dereferencing a pixel...">PixelDereferenceAdaptorConcept</a>.<p>
If the input is a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> value or constant reference, the function object is immutable. Otherwise it is mutable (and returns non-const reference to the n-th channel) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0578.html">nth_channel_view_type</a></td><td class="indexvalue">Given a source <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> view type View, returns the type of an <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> view over a single channel of View<p>
If the channels in the source view are adjacent in memory (such as planar non-step view or single-channel view) then the return view is a single-channel non-step view. If the channels are non-adjacent (interleaved and/or step view) then the return view is a single-channel step view </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0580.html">nth_channel_view_type&lt; any_image_view&lt; ViewTypes &gt; &gt;</a></td><td class="indexvalue">Given a runtime source <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> view, returns the type of a runtime <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> view over a single channel of the source view </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0581.html">num_channels</a></td><td class="indexvalue">Returns the number of channels of a pixel-based GIL construct </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0048.html">packed_channel_reference&lt; BitField, FirstBit, NumBits, false &gt;</a></td><td class="indexvalue">A constant subbyte channel reference whose bit offset is fixed at compile time. Models <a class="el" href="g_i_l_0264.html" title="A channel is the building block of a color. Color is defined as a mixture of primary...">ChannelConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0050.html">packed_channel_reference&lt; BitField, FirstBit, NumBits, true &gt;</a></td><td class="indexvalue">A mutable subbyte channel reference whose bit offset is fixed at compile time. Models <a class="el" href="g_i_l_0264.html" title="A channel is the building block of a color. Color is defined as a mixture of primary...">ChannelConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0052.html">packed_channel_value</a></td><td class="indexvalue">The value of a subbyte channel. Models: <a class="el" href="g_i_l_0270.html" title="A channel that supports default construction.">ChannelValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0054.html">packed_dynamic_channel_reference&lt; BitField, NumBits, false &gt;</a></td><td class="indexvalue">Models a constant subbyte channel reference whose bit offset is a runtime parameter. Models <a class="el" href="g_i_l_0264.html" title="A channel is the building block of a color. Color is defined as a mixture of primary...">ChannelConcept</a> Same as packed_channel_reference, except that the offset is a runtime parameter </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0056.html">packed_dynamic_channel_reference&lt; BitField, NumBits, true &gt;</a></td><td class="indexvalue">Models a mutable subbyte channel reference whose bit offset is a runtime parameter. Models <a class="el" href="g_i_l_0264.html" title="A channel is the building block of a color. Color is defined as a mixture of primary...">ChannelConcept</a> Same as packed_channel_reference, except that the offset is a runtime parameter </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0583.html">packed_image1_type</a></td><td class="indexvalue">Returns the type of a single-channel <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> given its bitfield type, the bit <a class="el" href="g_i_l_0621.html" title="Returns an MPL integral type specifying the number of elements in a color base.">size</a> of its channel and its <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0585.html">packed_image2_type</a></td><td class="indexvalue">Returns the type of a two channel <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> given its bitfield type, the bit <a class="el" href="g_i_l_0621.html" title="Returns an MPL integral type specifying the number of elements in a color base.">size</a> of its channels and its <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0587.html">packed_image3_type</a></td><td class="indexvalue">Returns the type of a three channel <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> given its bitfield type, the bit <a class="el" href="g_i_l_0621.html" title="Returns an MPL integral type specifying the number of elements in a color base.">size</a> of its channels and its <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0589.html">packed_image4_type</a></td><td class="indexvalue">Returns the type of a four channel <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> given its bitfield type, the bit <a class="el" href="g_i_l_0621.html" title="Returns an MPL integral type specifying the number of elements in a color base.">size</a> of its channels and its <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0591.html">packed_image5_type</a></td><td class="indexvalue">Returns the type of a five channel <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> given its bitfield type, the bit <a class="el" href="g_i_l_0621.html" title="Returns an MPL integral type specifying the number of elements in a color base.">size</a> of its channels and its <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0593.html">packed_image_type</a></td><td class="indexvalue">Returns the type of an interleaved packed <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a>: an <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> whose channels may not be byte-aligned, but whose pixels are byte aligned </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0595.html">packed_pixel</a></td><td class="indexvalue">Heterogeneous <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> value whose channel references can be constructed from the <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> bitfield and their index. Models <a class="el" href="g_i_l_0276.html" title="Color base that also has a default-constructor. Refines Regular.">ColorBaseValueConcept</a>, <a class="el" href="g_i_l_0356.html" title="Pixel concept that is a Regular type.">PixelValueConcept</a>, <a class="el" href="g_i_l_0344.html" title="Concept for all pixel-based GIL constructs, such as pixels, iterators, locators,...">PixelBasedConcept</a> Typical use for this is a model of a packed <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> (like 565 RGB) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0597.html">packed_pixel_type</a></td><td class="indexvalue">Returns the type of a packed <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> given its bitfield type, the bit <a class="el" href="g_i_l_0621.html" title="Returns an MPL integral type specifying the number of elements in a color base.">size</a> of its channels and its <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0599.html">pixel</a></td><td class="indexvalue">Represents a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> value (a container of channels). Models: <a class="el" href="g_i_l_0298.html" title="Homogeneous color base that also has a default constructor. Refines Regular.">HomogeneousColorBaseValueConcept</a>, <a class="el" href="g_i_l_0356.html" title="Pixel concept that is a Regular type.">PixelValueConcept</a>, <a class="el" href="g_i_l_0300.html" title="Concept for homogeneous pixel-based GIL constructs.">HomogeneousPixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0058.html">pixel_2d_locator_base</a></td><td class="indexvalue">Base class for models of <a class="el" href="g_i_l_0354.html" title="GIL&#39;s 2-dimensional locator over immutable GIL pixels.">PixelLocatorConcept</a><p>
Pixel locator is similar to a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> iterator, but allows for 2D navigation of pixels within an <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> view. It has a 2D difference_type and supports random access operations like: </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0600.html">pixel_is_reference</a></td><td class="indexvalue">Given a model of a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a>, determines whether the model represents a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> reference (as opposed to <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> value) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0601.html">pixel_reference_is_basic</a></td><td class="indexvalue">Determines if a given <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> reference is basic Basic references must use <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">gil::pixel</a>&amp; (if interleaved), <a class="el" href="g_i_l_0611.html" title="A reference proxy to a planar pixel. Models: HomogeneousColorBaseConcept, HomogeneousPixelConcept...">gil::planar_pixel_reference</a> (if planar). They must use the standard constness rules </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0602.html">pixel_reference_is_mutable</a></td><td class="indexvalue">Determines if the given <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> reference is mutable (i.e. its channels can be changed) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0603.html">pixel_reference_is_proxy</a></td><td class="indexvalue">Determines whether the given <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> reference is a proxy class or a native C++ reference </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0604.html">pixel_reference_type</a></td><td class="indexvalue">Returns the type of a homogeneous <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> reference given the channel type, <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a>, whether it operates on planar data and whether it is mutable </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0606.html">pixel_value_type</a></td><td class="indexvalue">Returns the type of a homogeneous <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> given the channel type and <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0344.html">PixelBasedConcept</a></td><td class="indexvalue">Concept for all pixel-based GIL constructs, such as pixels, iterators, locators, views and images whose value type is a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0346.html">PixelConcept</a></td><td class="indexvalue">Pixel concept - A color base whose elements are channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0348.html">PixelConvertibleConcept</a></td><td class="indexvalue">Pixel convertible concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0350.html">PixelDereferenceAdaptorConcept</a></td><td class="indexvalue">Represents a unary function object that can be invoked upon dereferencing a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0352.html">PixelIteratorConcept</a></td><td class="indexvalue">An STL random access traversal iterator over a model of <a class="el" href="g_i_l_0346.html" title="Pixel concept - A color base whose elements are channels.">PixelConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0354.html">PixelLocatorConcept</a></td><td class="indexvalue">GIL's 2-dimensional locator over immutable GIL pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0607.html">pixels_are_compatible</a></td><td class="indexvalue">Returns whether two pixels are compatible </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0358.html">PixelsCompatibleConcept</a></td><td class="indexvalue">Concept for <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> compatibility Pixels are compatible if their channels and color space types are compatible. Compatible pixels can be assigned and copy constructed from one another </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0356.html">PixelValueConcept</a></td><td class="indexvalue">Pixel concept that is a <a class="el" href="g_i_l_0376.html">Regular</a> type </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0609.html">planar_pixel_iterator</a></td><td class="indexvalue">An iterator over planar pixels. Models <a class="el" href="g_i_l_0296.html" title="Color base whose elements all have the same type.">HomogeneousColorBaseConcept</a>, <a class="el" href="g_i_l_0352.html" title="An STL random access traversal iterator over a model of PixelConcept.">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0300.html" title="Concept for homogeneous pixel-based GIL constructs.">HomogeneousPixelBasedConcept</a>, <a class="el" href="g_i_l_0312.html" title="Concept of a random-access iterator that can be advanced in memory units (bytes or...">MemoryBasedIteratorConcept</a>, <a class="el" href="g_i_l_0290.html" title="Concept for iterators, locators and views that can define a type just like the given...">HasDynamicXStepTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0611.html">planar_pixel_reference</a></td><td class="indexvalue">A reference proxy to a planar <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a>. Models: <a class="el" href="g_i_l_0296.html" title="Color base whose elements all have the same type.">HomogeneousColorBaseConcept</a>, <a class="el" href="g_i_l_0302.html" title="Homogeneous pixel concept.">HomogeneousPixelConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0517.html">plus_asymmetric</a></td><td class="indexvalue">Plus function object whose arguments may be of different type </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0613.html">png_read_support</a></td><td class="indexvalue">Determines whether the given view type is supported for reading </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0615.html">png_write_support</a></td><td class="indexvalue">Determines whether the given view type is supported for writing </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0060.html">point2</a></td><td class="indexvalue">2D point both axes of which have the same dimension type<p>
Models: <a class="el" href="g_i_l_0360.html" title="2-dimensional point concept">Point2DConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0360.html">Point2DConcept</a></td><td class="indexvalue">2-dimensional point concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0362.html">PointNDConcept</a></td><td class="indexvalue">N-dimensional point concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0617.html">position_iterator</a></td><td class="indexvalue">An iterator that remembers its current X,Y position and invokes a function object with it upon dereferencing. Models <a class="el" href="g_i_l_0352.html" title="An STL random access traversal iterator over a model of PixelConcept.">PixelIteratorConcept</a>. Used to create virtual <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> views. Models: <a class="el" href="g_i_l_0380.html" title="Step iterator concept.">StepIteratorConcept</a>, <a class="el" href="g_i_l_0352.html" title="An STL random access traversal iterator over a model of PixelConcept.">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0344.html" title="Concept for all pixel-based GIL constructs, such as pixels, iterators, locators,...">PixelBasedConcept</a>, <a class="el" href="g_i_l_0290.html" title="Concept for iterators, locators and views that can define a type just like the given...">HasDynamicXStepTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0364.html">RandomAccess2DImageConcept</a></td><td class="indexvalue">2-dimensional container of values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0366.html">RandomAccess2DImageViewConcept</a></td><td class="indexvalue">2-dimensional view over immutable values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0368.html">RandomAccess2DLocatorConcept</a></td><td class="indexvalue">2-dimensional locator over immutable values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0370.html">RandomAccessNDImageConcept</a></td><td class="indexvalue">N-dimensional container of values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0372.html">RandomAccessNDImageViewConcept</a></td><td class="indexvalue">N-dimensional view over immutable values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0374.html">RandomAccessNDLocatorConcept</a></td><td class="indexvalue">N-dimensional locator over immutable values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0618.html">red_t</a></td><td class="indexvalue">Red </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0376.html">Regular</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0519.html">rgb_to_luminance_fn</a></td><td class="indexvalue">Red * .3 + green * .59 + blue * .11 + .5 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0378.html">SameType</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0620.html">scoped_channel_value</a></td><td class="indexvalue">A channel adaptor that modifies the range of the source channel. Models: <a class="el" href="g_i_l_0270.html" title="A channel that supports default construction.">ChannelValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0621.html">size</a></td><td class="indexvalue">Returns an MPL integral type specifying the number of elements in a color base </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0521.html">std_fill_t</a></td><td class="indexvalue">Struct to do std::fill </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0036.html">step_iterator_adaptor</a></td><td class="indexvalue">An adaptor over an existing iterator that changes the step unit </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0380.html">StepIteratorConcept</a></td><td class="indexvalue">Step iterator concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0382.html">Swappable</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0623.html">tiff_read_support</a></td><td class="indexvalue">Determines whether the given view type is supported for reading </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0625.html">tiff_write_support</a></td><td class="indexvalue">Determines whether the given view type is supported for writing </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0627.html">type_from_x_iterator</a></td><td class="indexvalue">Given a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> iterator defining access to pixels along a row, returns the types of the corresponding built-in step_iterator, xy_locator, <a class="el" href="g_i_l_0040.html" title="A lightweight object that interprets memory as a 2D array of pixels. Models ImageViewConcept...">image_view</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0522.html">type_to_index</a></td><td class="indexvalue">Returns the index corresponding to the first occurrance of a given given type in </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0062.html">variant</a></td><td class="indexvalue">Represents a concrete instance of a run-time specified type from a set of types<p>
A concept is typically modeled by a collection of different types. They may be instantiations of a templated type with different template parameters or even completely unrelated types </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0628.html">view_is_basic</a></td><td class="indexvalue">Basic views must be over basic locators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0629.html">view_is_mutable</a></td><td class="indexvalue">Determines if the given view is mutable (i.e. its pixels can be changed) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0630.html">view_is_step_in_x</a></td><td class="indexvalue">Determines if the given view has a horizontal step that could be set dynamically </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0631.html">view_is_step_in_y</a></td><td class="indexvalue">Determines if the given view has a vertical step that could be set dynamically </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0633.html">view_type</a></td><td class="indexvalue">Returns the type of a homogeneous view given the channel type, <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a>, whether it operates on planar data and whether it has a step horizontally </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0635.html">view_type_from_pixel</a></td><td class="indexvalue">Returns the type of a view the <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> type, whether it operates on planar data and whether it has a step horizontally </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0636.html">views_are_compatible</a></td><td class="indexvalue">Returns whether two views are compatible </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0384.html">ViewsCompatibleConcept</a></td><td class="indexvalue">Views are compatible if they have the same color spaces and compatible channel values. Constness and <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> are not important for compatibility </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0064.html">virtual_2d_locator</a></td><td class="indexvalue">A 2D locator over a virtual <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a>. Upon dereferencing, invokes a given function object passing it its coordinates. Models: <a class="el" href="g_i_l_0354.html" title="GIL&#39;s 2-dimensional locator over immutable GIL pixels.">PixelLocatorConcept</a>, <a class="el" href="g_i_l_0290.html" title="Concept for iterators, locators and views that can define a type just like the given...">HasDynamicXStepTypeConcept</a>, <a class="el" href="g_i_l_0292.html" title="Concept for locators and views that can define a type just like the given locator...">HasDynamicYStepTypeConcept</a>, <a class="el" href="g_i_l_0294.html" title="Concept for locators and views that can define a type just like the given locator...">HasTransposedTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0637.html">yellow_t</a></td><td class="indexvalue">Yellow </td></tr>
</table>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat May 2 13:50:17 2009 for Generic Image Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
