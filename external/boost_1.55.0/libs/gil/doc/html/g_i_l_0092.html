<!-- Copyright 2008 Lubomir Bourdev and Hailin Jin

     Distributed under the Boost Software License, Version 1.0.
     (See accompanying file LICENSE_1_0.txt or copy at
     http://www.boost.org/LICENSE_1_0.txt)
  -->

<!--
    Copyright 2005-2007 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
    <TITLE>Generic Image Library: gil_concept.hpp File Reference</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
</head>
<body>
<table border="0" cellspacing="0" cellpadding="0" style='width: 100%; margin: 0; padding: 0'><tr>
<td width="100%" valign="top" style='padding-left: 10px; padding-right: 10px; padding-bottom: 10px'>
<div class="qindex"><a class="qindex" href="index.html">Modules</a> 
                  | <a class="qindex" href="classes.html">Alphabetical List</a> 
                  | <a class="qindex" href="annotated.html">Class List</a> 
                  | <a class="qindex" href="dirs.html">Directories</a> 
                  | <a class="qindex" href="files.html">File List</a> 
                  | <a class="qindex" href="../index.html">GIL Home Page</a> 
</div>
<!-- End Header -->
<!-- Generated by Doxygen 1.5.6 -->
  <div class="navpath"><a class="el" href="g_i_l_0076.html">boost</a>&nbsp;&raquo&nbsp;<a class="el" href="g_i_l_0079.html">gil</a>
  </div>
<div class="contents">
<h1>gil_concept.hpp File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Concept check classes for GIL concepts. 
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Lubomir Bourdev and Hailin Jin <br>
 Adobe Systems Incorporated </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>2005-2007 <br>
 Last updated on February 12, 2007 </dd></dl>

<p>
<code>#include &lt;functional&gt;</code><br>
<code>#include &quot;<a class="el" href="g_i_l_0093.html">gil_config.hpp</a>&quot;</code><br>
<code>#include &lt;boost/type_traits.hpp&gt;</code><br>
<code>#include &lt;boost/utility/enable_if.hpp&gt;</code><br>
<code>#include &lt;boost/concept_check.hpp&gt;</code><br>
<code>#include &lt;boost/iterator/iterator_concepts.hpp&gt;</code><br>
<code>#include &lt;boost/mpl/and.hpp&gt;</code><br>
<code>#include &lt;boost/mpl/size.hpp&gt;</code><br>

<p>
<a href="g_i_l_0091.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost.html">boost</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><b>boost::gil</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><b>boost::gil::detail</b></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0286.html">DefaultConstructible</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0284.html">CopyConstructible</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0262.html">Assignable</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0288.html">EqualityComparable</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0378.html">SameType</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0382.html">Swappable</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0376.html">Regular</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0314.html">Metafunction</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0362.html">PointNDConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">N-dimensional point concept.  <a href="g_i_l_0362.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0360.html">Point2DConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional point concept  <a href="g_i_l_0360.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0280.html">ColorSpaceConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Color space type concept.  <a href="g_i_l_0280.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0282.html">ColorSpacesCompatibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two color spaces are compatible if they are the same.  <a href="g_i_l_0282.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0268.html">ChannelMappingConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Channel mapping concept.  <a href="g_i_l_0268.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0264.html">ChannelConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A channel is the building block of a color. Color is defined as a mixture of primary colors and a channel defines the degree to which each primary color is used in the mixture.  <a href="g_i_l_0264.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0316.html">MutableChannelConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A channel that allows for modifying its value.  <a href="g_i_l_0316.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0270.html">ChannelValueConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A channel that supports default construction.  <a href="g_i_l_0270.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0432.html">channels_are_compatible</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predicate metafunction returning whether two channels are compatible<p>
Channels are considered compatible if their value types (ignoring constness and references) are the same.  <a href="g_i_l_0432.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0272.html">ChannelsCompatibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Channels are compatible if their associated value types (ignoring constness and references) are the same.  <a href="g_i_l_0272.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0266.html">ChannelConvertibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A channel is convertible to another one if the <code>channel_convert</code> algorithm is defined for the two channels.  <a href="g_i_l_0266.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0274.html">ColorBaseConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A color base is a container of color elements (such as channels, channel references or channel pointers).  <a href="g_i_l_0274.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0318.html">MutableColorBaseConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Color base which allows for modifying its elements.  <a href="g_i_l_0318.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0276.html">ColorBaseValueConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Color base that also has a default-constructor. Refines <a class="el" href="g_i_l_0376.html">Regular</a>.  <a href="g_i_l_0276.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0296.html">HomogeneousColorBaseConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Color base whose elements all have the same type.  <a href="g_i_l_0296.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0320.html">MutableHomogeneousColorBaseConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Homogeneous color base that allows for modifying its elements.  <a href="g_i_l_0320.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0298.html">HomogeneousColorBaseValueConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Homogeneous color base that also has a default constructor. Refines <a class="el" href="g_i_l_0376.html">Regular</a>.  <a href="g_i_l_0298.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0278.html">ColorBasesCompatibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two color bases are compatible if they have the same color space and their elements are compatible, semantic-pairwise.  <a href="g_i_l_0278.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0344.html">PixelBasedConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept for all pixel-based GIL constructs, such as pixels, iterators, locators, views and images whose value type is a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a>.  <a href="g_i_l_0344.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0300.html">HomogeneousPixelBasedConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept for homogeneous pixel-based GIL constructs.  <a href="g_i_l_0300.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0346.html">PixelConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel concept - A color base whose elements are channels.  <a href="g_i_l_0346.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0328.html">MutablePixelConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel concept that allows for changing its channels.  <a href="g_i_l_0328.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0302.html">HomogeneousPixelConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Homogeneous <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> concept.  <a href="g_i_l_0302.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0322.html">MutableHomogeneousPixelConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Homogeneous <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> concept that allows for changing its channels.  <a href="g_i_l_0322.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0356.html">PixelValueConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel concept that is a <a class="el" href="g_i_l_0376.html">Regular</a> type.  <a href="g_i_l_0356.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0304.html">HomogeneousPixelValueConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Homogeneous <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> concept that is a <a class="el" href="g_i_l_0376.html">Regular</a> type.  <a href="g_i_l_0304.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0607.html">pixels_are_compatible</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether two pixels are compatible.  <a href="g_i_l_0607.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0358.html">PixelsCompatibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept for <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> compatibility Pixels are compatible if their channels and color space types are compatible. Compatible pixels can be assigned and copy constructed from one another.  <a href="g_i_l_0358.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0348.html">PixelConvertibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel convertible concept.  <a href="g_i_l_0348.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0350.html">PixelDereferenceAdaptorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a unary function object that can be invoked upon dereferencing a <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a> iterator.  <a href="g_i_l_0350.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0290.html">HasDynamicXStepTypeConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept for iterators, locators and views that can define a type just like the given iterator/locator/view, except it supports runtime specified step along the X navigation.  <a href="g_i_l_0290.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0292.html">HasDynamicYStepTypeConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept for locators and views that can define a type just like the given locator or view, except it supports runtime specified step along the Y navigation.  <a href="g_i_l_0292.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0294.html">HasTransposedTypeConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept for locators and views that can define a type just like the given locator or view, except X and Y is swapped.  <a href="g_i_l_0294.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0352.html">PixelIteratorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An STL random access traversal iterator over a model of <a class="el" href="g_i_l_0346.html" title="Pixel concept - A color base whose elements are channels.">PixelConcept</a>.  <a href="g_i_l_0352.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0330.html">MutablePixelIteratorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel iterator that allows for changing its <a class="el" href="g_i_l_0599.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept...">pixel</a>.  <a href="g_i_l_0330.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0312.html">MemoryBasedIteratorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concept of a random-access iterator that can be advanced in memory units (bytes or bits).  <a href="g_i_l_0312.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0380.html">StepIteratorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Step iterator concept.  <a href="g_i_l_0380.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0342.html">MutableStepIteratorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Step iterator that allows for modifying its current value.  <a href="g_i_l_0342.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0310.html">IteratorAdaptorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator adaptor is a forward iterator adapting another forward iterator.  <a href="g_i_l_0310.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0326.html">MutableIteratorAdaptorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator adaptor that is mutable.  <a href="g_i_l_0326.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0374.html">RandomAccessNDLocatorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">N-dimensional locator over immutable values.  <a href="g_i_l_0374.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0368.html">RandomAccess2DLocatorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional locator over immutable values  <a href="g_i_l_0368.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0354.html">PixelLocatorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GIL's 2-dimensional locator over immutable GIL pixels.  <a href="g_i_l_0354.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0340.html">MutableRandomAccessNDLocatorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">N-dimensional locator over mutable pixels.  <a href="g_i_l_0340.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0336.html">MutableRandomAccess2DLocatorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional locator over mutable pixels  <a href="g_i_l_0336.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0332.html">MutablePixelLocatorConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GIL's 2-dimensional locator over mutable GIL pixels.  <a href="g_i_l_0332.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0372.html">RandomAccessNDImageViewConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">N-dimensional view over immutable values.  <a href="g_i_l_0372.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0366.html">RandomAccess2DImageViewConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional view over immutable values  <a href="g_i_l_0366.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0308.html">ImageViewConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GIL's 2-dimensional view over immutable GIL pixels.  <a href="g_i_l_0308.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0338.html">MutableRandomAccessNDImageViewConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">N-dimensional view over mutable values.  <a href="g_i_l_0338.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0334.html">MutableRandomAccess2DImageViewConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional view over mutable values  <a href="g_i_l_0334.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0324.html">MutableImageViewConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GIL's 2-dimensional view over mutable GIL pixels.  <a href="g_i_l_0324.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0636.html">views_are_compatible</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether two views are compatible.  <a href="g_i_l_0636.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0384.html">ViewsCompatibleConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Views are compatible if they have the same color spaces and compatible channel values. Constness and <a class="el" href="g_i_l_0567.html" title="Represents a color space and ordering of channels in memory.">layout</a> are not important for compatibility.  <a href="g_i_l_0384.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0370.html">RandomAccessNDImageConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">N-dimensional container of values.  <a href="g_i_l_0370.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0364.html">RandomAccess2DImageConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional container of values  <a href="g_i_l_0364.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="g_i_l_0306.html">ImageConcept</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2-dimensional <a class="el" href="g_i_l_0038.html" title="container interface over image view. Models ImageConcept, PixelBasedConcept">image</a> whose value type models <a class="el" href="g_i_l_0356.html" title="Pixel concept that is a Regular type.">PixelValueConcept</a>  <a href="g_i_l_0306.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fde7c64632f1e43e38955f38882a9b11"></a><!-- doxytag: member="gil_concept.hpp::GIL_CLASS_REQUIRE" ref="fde7c64632f1e43e38955f38882a9b11" args="(T, NS, C)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GIL_CLASS_REQUIRE</b>(T, NS, C)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="081194872fc2371d614481fa87242c6a"></a><!-- doxytag: member="gil_concept.hpp::channel_convert" ref="081194872fc2371d614481fa87242c6a" args="(srcT val)" -->
template&lt;typename dstT, typename srcT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">channel_traits&lt; dstT &gt;::value_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>channel_convert</b> (srcT val)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2ce7e7c813ffa2b97d96c90240b7695d"></a><!-- doxytag: member="gil_concept.hpp::axis_value" ref="g2ce7e7c813ffa2b97d96c90240b7695d" args="(const point2&lt; T &gt; &amp;p)" -->
template&lt;std::size_t K, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const T &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>axis_value</b> (const point2&lt; T &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gdddff7a16462f93d3467c6b68bd21242"></a><!-- doxytag: member="gil_concept.hpp::axis_value" ref="gdddff7a16462f93d3467c6b68bd21242" args="(point2&lt; T &gt; &amp;p)" -->
template&lt;std::size_t K, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>axis_value</b> (point2&lt; T &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gd16b06024270e06a4e0ba5163da7ed15"></a><!-- doxytag: member="gil_concept.hpp::at_c" ref="gd16b06024270e06a4e0ba5163da7ed15" args="(detail::homogeneous_color_base&lt; E, L, N &gt; &amp;p)" -->
template&lt;int K, typename E, typename L, int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">add_reference&lt; E &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0119.html#gd16b06024270e06a4e0ba5163da7ed15">at_c</a> (detail::homogeneous_color_base&lt; E, L, N &gt; &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides mutable access to the K-th element, in physical order. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gd2561249354a1bea233ff2e53491583d"></a><!-- doxytag: member="gil_concept.hpp::at_c" ref="gd2561249354a1bea233ff2e53491583d" args="(const detail::homogeneous_color_base&lt; E, L, N &gt; &amp;p)" -->
template&lt;int K, typename E, typename L, int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">add_reference&lt; typename <br>
add_const&lt; E &gt;::type &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0119.html#gd2561249354a1bea233ff2e53491583d">at_c</a> (const detail::homogeneous_color_base&lt; E, L, N &gt; &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides constant access to the K-th element, in physical order. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ac4965de0ad306a2a07f01abd9100c51"></a><!-- doxytag: member="gil_concept.hpp::at_c" ref="ac4965de0ad306a2a07f01abd9100c51" args="(packed_pixel&lt; P, C, L &gt; &amp;p)" -->
template&lt;int K, typename P, typename C, typename L&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">kth_element_reference_type<br>
&lt; packed_pixel&lt; P, C, L &gt;, K &gt;<br>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>at_c</b> (packed_pixel&lt; P, C, L &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="cb73e6b145f73e1e2a61e4fff7eb7b79"></a><!-- doxytag: member="gil_concept.hpp::at_c" ref="cb73e6b145f73e1e2a61e4fff7eb7b79" args="(const packed_pixel&lt; P, C, L &gt; &amp;p)" -->
template&lt;int K, typename P, typename C, typename L&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">kth_element_const_reference_type<br>
&lt; packed_pixel&lt; P, C, L &gt;, K &gt;<br>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>at_c</b> (const packed_pixel&lt; P, C, L &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="62a77dc26fdd2dc363acf4cb0ba46c2f"></a><!-- doxytag: member="gil_concept.hpp::at_c" ref="62a77dc26fdd2dc363acf4cb0ba46c2f" args="(const bit_aligned_pixel_reference&lt; B, C, L, M &gt; &amp;p)" -->
template&lt;int K, typename B, typename C, typename L, bool M&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">kth_element_reference_type<br>
&lt; bit_aligned_pixel_reference<br>
&lt; B, C, L, M &gt;, K &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>at_c</b> (const bit_aligned_pixel_reference&lt; B, C, L, M &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2cdd9bfd1b27576659b8c79a3a0233de"></a><!-- doxytag: member="gil_concept.hpp::semantic_at_c" ref="g2cdd9bfd1b27576659b8c79a3a0233de" args="(ColorBase &amp;p)" -->
template&lt;int K, typename ColorBase&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">disable_if&lt; is_const<br>
&lt; ColorBase &gt;, typename <br>
kth_semantic_element_reference_type<br>
&lt; ColorBase, K &gt;::type &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0114.html#g2cdd9bfd1b27576659b8c79a3a0233de">semantic_at_c</a> (ColorBase &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A mutable accessor to the K-th semantic element of a color base. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gba9e03ce04fda71e2e840c10325b8b11"></a><!-- doxytag: member="gil_concept.hpp::semantic_at_c" ref="gba9e03ce04fda71e2e840c10325b8b11" args="(const ColorBase &amp;p)" -->
template&lt;int K, typename ColorBase&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">kth_semantic_element_const_reference_type<br>
&lt; ColorBase, K &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0114.html#gba9e03ce04fda71e2e840c10325b8b11">semantic_at_c</a> (const ColorBase &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constant accessor to the K-th semantic element of a color base. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="cd3c8198e06eaffedec17519fb938907"></a><!-- doxytag: member="gil_concept.hpp::initialize_it" ref="cd3c8198e06eaffedec17519fb938907" args="(T &amp;x)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>initialize_it</b> (T &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="35b67e27a26c72265186521b5648dcc8"></a><!-- doxytag: member="gil_concept.hpp::gil_function_requires" ref="35b67e27a26c72265186521b5648dcc8" args="()" -->
template&lt;typename C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>gil_function_requires</b> ()</td></tr>

</table>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat May 2 13:50:16 2009 for Generic Image Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
