/////
// Tests the driver API for correct tt field on AST terms
/////

var assert = require('assert');
var path = require('path');

// -- load rethinkdb from the proper location

var r = require(path.resolve(__dirname, '..', 'importRethinkDB.js')).r;
var protodef = require(path.resolve(__dirname, '..', 'importRethinkDB.js')).protodef;

var ttToExampleTerm = {
  MAKE_ARRAY:       r([]),
  MAKE_OBJ  :       r({}),
  VAR:              r(function(x){return x}).args[1],
  JAVASCRIPT:       r.js(''),
  UUID:             r.uuid(),
  HTTP:             r.http(''),
  ERROR:            r.error(),
  IMPLICIT_VAR:     r.row,
  DB:               r.db(''),
  TABLE:            r.table(''),
  GET:              r({}).get(''),
  GET_ALL:          r({}).getAll(''),
  EQ:               r.eq(),
  NE:               r.ne(),
  LT:               r.lt(),
  LE:               r.le(),
  GT:               r.gt(),
  GE:               r.ge(),
  NOT:              r.not(),
  ADD:              r.add(),
  SUB:              r.sub(),
  MUL:              r.mul(),
  DIV:              r.div(),
  MOD:              r.mod(),
  FLOOR:            r.floor(),
  CEIL:             r.ceil(),
  ROUND:            r.round(),
  APPEND:           r([]).append(),
  PREPEND:          r([]).prepend(),
  DIFFERENCE:       r([]).difference(),
  SET_INSERT:       r([]).setInsert(),
  SET_INTERSECTION: r([]).setIntersection(),
  SET_UNION:        r([]).setUnion(),
  SET_DIFFERENCE:   r([]).setDifference(),
  SLICE:            r([]).slice(0),
  SKIP:             r([]).skip(),
  LIMIT:            r([]).limit(),
  OFFSETS_OF:       r([]).offsetsOf(),
  CONTAINS:         r([]).contains(),
  GET_FIELD:        r({}).getField(),
  KEYS:             r({}).keys(),
  OBJECT:           r.object(),
  HAS_FIELDS:       r([]).hasFields(),
  WITH_FIELDS:      r([]).withFields(),
  PLUCK:            r([]).pluck(''),
  WITHOUT:          r([]).without(),
  MERGE:            r({}).merge(),
  BETWEEN:          r([]).between(0, 1),
  REDUCE:           r([]).reduce(),
  MAP:              r([]).map({}),
  FILTER:           r([]).filter({}),
  CONCAT_MAP:       r([]).concatMap({}),
  ORDER_BY:         r([]).orderBy(),
  DISTINCT:         r([]).distinct(),
  COUNT:            r([]).count(),
  IS_EMPTY:         r([]).isEmpty(),
  UNION:            r([]).union(),
  NTH:              r([]).nth(),
  BRACKET:          r([]).bracket(0),
  INNER_JOIN:       r([]).innerJoin(),
  OUTER_JOIN:       r([]).outerJoin(),
  EQ_JOIN:          r([]).eqJoin('', ''),
  ZIP:              r([]).zip(),
  RANGE:            r.range(),
  INSERT_AT:        r([]).insertAt(),
  DELETE_AT:        r([]).deleteAt(),
  CHANGE_AT:        r([]).changeAt(),
  SPLICE_AT:        r([]).spliceAt(),
  COERCE_TO:        r([]).coerceTo(),
  TYPE_OF:          r([]).typeOf(),
  UPDATE:           r([]).update({}),
  DELETE:           r([]).delete(),
  REPLACE:          r([]).replace({}),
  INSERT:           r([]).insert({}),
  DB_CREATE:        r.dbCreate(),
  DB_DROP:          r.dbDrop(),
  DB_LIST:          r.dbList(),
  TABLE_CREATE:     r.tableCreate(''),
  TABLE_DROP:       r.tableDrop(''),
  TABLE_LIST:       r.tableList(),
  CONFIG:           r([]).config(),
  STATUS:           r([]).status(),
  SYNC:             r([]).sync(),
  INDEX_CREATE:     r([]).indexCreate(''),
  INDEX_DROP:       r([]).indexDrop(''),
  INDEX_LIST:       r([]).indexList(),
  INDEX_STATUS:     r([]).indexStatus(),
  INDEX_WAIT:       r([]).indexWait(),
  INDEX_RENAME:     r([]).indexRename('', ''),
  FUNCALL:          r.do(function(){return 0}),
  BRANCH:           r.branch(0, 0, 0),
  OR:               r(0).or(0),
  AND:              r(0).and(0),
  FOR_EACH:         r([]).forEach(function(){return 0}),
  FUNC:             r(function(){return 0}),
  ASC:              r.asc(),
  DESC:             r.desc(),
  INFO:             r.info(),
  MATCH:            r('').match(''),
  UPCASE:           r('').upcase(),
  DOWNCASE:         r('').downcase(),
  SAMPLE:           r([]).sample(0),
  DEFAULT:          r({}).default(0),
  JSON:             r.json(''),
  TO_JSON_STRING:   r('').toJsonString(),
  ISO8601:          r.ISO8601(''),
  TO_ISO8601:       r.now().toISO8601(),
  EPOCH_TIME:       r.epochTime(0),
  TO_EPOCH_TIME:    r.now().toEpochTime(),
  NOW:              r.now(),
  IN_TIMEZONE:      r.now().inTimezone(''),
  DURING:           r('').during(r.now(), r.now()),
  DATE:             r.now().date(),
  TIME_OF_DAY:      r.now().timeOfDay(),
  TIMEZONE:         r.now().timezone(),
  YEAR:             r.now().year(),
  MONTH:            r.now().month(),
  DAY:              r.now().day(),
  DAY_OF_WEEK:      r.now().dayOfWeek(),
  DAY_OF_YEAR:      r.now().dayOfYear(),
  HOURS:            r.now().hours(),
  MINUTES:          r.now().minutes(),
  SECONDS:          r.now().seconds(),
  TIME:             r.time(),
  MONDAY:           r.monday,
  TUESDAY:          r.tuesday,
  WEDNESDAY:        r.wednesday,
  THURSDAY:         r.thursday,
  FRIDAY:           r.friday,
  SATURDAY:         r.saturday,
  SUNDAY:           r.sunday,
  JANUARY:          r.january,
  FEBRUARY:         r.february,
  MARCH:            r.march,
  APRIL:            r.april,
  MAY:              r.may,
  JUNE:             r.june,
  JULY:             r.july,
  AUGUST:           r.august,
  SEPTEMBER:        r.september,
  OCTOBER:          r.october,
  NOVEMBER:         r.november,
  DECEMBER:         r.december,
  LITERAL:          r.literal({}),
  GROUP:            r([]).group(''),
  SUM:              r([]).sum(),
  AVG:              r([]).avg(),
  MIN:              r([]).min(),
  MAX:              r([]).max(),
  SPLIT:            r([]).split(),
  UNGROUP:          r([]).ungroup(),
  RANDOM:           r.random(),
  CHANGES:          r([]).changes(),
  ARGS:             r.args([]),
  BINARY:           r.binary(new Buffer(0)),
  GEOJSON:          r.geojson({}),
  TO_GEOJSON:       r({}).toGeojson(),
  POINT:            r.point(0, 0),
  LINE:             r.line([], []),
  POLYGON:          r.polygon([], [], []),
  DISTANCE:         r.distance([], []),
  INTERSECTS:       r.intersects(),
  INCLUDES:         r([]).includes([]),
  CIRCLE:           r.circle([], 0),
  GET_INTERSECTING: r([]).getIntersecting([]),
  FILL:             r.line([], []).fill(),
  GET_NEAREST:      r([]).getNearest([]),
  POLYGON_SUB:      r.polygon([], [], []).polygonSub([]),
  MINVAL:           r.minval,
  MAXVAL:           r.maxval,
};

describe('Javascript AST tt field', function(){

    it('is defined correctly for all term types', function(){
        Object.keys(ttToExampleTerm).forEach(function(ttName){
            var term = ttToExampleTerm[ttName];
            var expectedTermType = protodef.Term.TermType[ttName];
            var actualTermType = term.tt;
            var msg = term.toString()
                    + ".tt is " + actualTermType
                    + ", expected " + expectedTermType
                    + " (" + ttName + ")";
            assert.deepEqual(actualTermType, expectedTermType, msg);
        });
    });

});

