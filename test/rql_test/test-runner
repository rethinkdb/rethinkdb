#!/usr/bin/env python

'''Tool to assemble and run the RQL language tests, including the polyglot yaml tests'''

from __future__ import print_function

import atexit, collections, copy, distutils.version, distutils.spawn, optparse, os, re, shutil, signal, stat, string, subprocess, sys, tempfile, time, traceback

try:
    import yaml
except ImportError:
    sys.exit('%s requires that PyYAML be installed: https://pypi.python.org/pypi/PyYAML' % os.path.basename(__file__))

sys.path.insert(0, os.path.join(os.path.dirname(os.path.realpath(__file__)), os.pardir, "common"))
import driver, test_exceptions, utils

try:
    unicode
except NameError:
    unicode = str

# -- settings

testGroupSeperator = '/'
testExtensions = ['test', 'yaml']

# --

# A test script src language
# This class attempts to abstract some of the details that
# separate our source languages.
class SrcLang(object):
    test_types = None
    display_name = None

    interpreter_name_exe_names = None
    interpreter_path = None
    interpreter_version = None
    interpreter_env_name = None
    
    driver_source_path = None
    driver_build_env_name = None
    driver_build_path = None
    
    instance_setup = False
    
    # -- class variables
    
    _singletons = {}
    
    def __new__(cls, version=''):
        singletonName = cls.__name__
        if version not in (None, ''):
            singletonName = "%s-%s" % (cls.__name__, str(version))
        if singletonName not in cls._singletons:
            cls._singletons[singletonName] = super(SrcLang, cls).__new__(cls)
        return cls._singletons[singletonName]
    
    def __init__(self):
        self.instance_setup = True
    
    # Returns the approriate line comment string
    def comment(self):
        return "#"

    # Converts input value into the appropriate string
    # representation for this language.
    def langrepr(self, val):
        return repr(str(val))

    # Translates names from canonical name representation
    # (underscores) to the convention for this language
    def nametranslate(self, name):
        return name

    # Translates dictionary (object) representation from cannonical
    # form (e.g. "{'a':1}") to the appropriate representation for this
    # language
    def dicttranslate(self, dic):
        return dic

    # Translates 'null' to langauge equivalents
    def nulltranslate(self, strng):
        return strng

    # Translate a generic code string using the rules defined by `self`
    def translate_query(self, src, encode=True):
        encoded = src
        if encode is True:
             encoded = self.langrepr(src)
        return self.dicttranslate(self.nametranslate(self.nulltranslate(encoded)))

    # Translate an expected value
    def translate_expected(self, src):
        return self.dicttranslate(self.nulltranslate(self.langrepr(src)))
    
    def get_interpreter_path(self):
        '''return the path to the interpreter on this system, respecting the given env variable'''
        
        if self.interpreter_path is not None:
            if not os.access(self.interpreter_path, os.X_OK):
                raise test_exceptions.TestingFrameworkException(detail='The interperter %s is not executable' % self.interpreter_path)
            return self.interpreter_path        
        
        if self.interpreter_name_exe_names is None or self.interpreter_name_exe_names == []:
            raise NotImplementedError('interpreter_name_exe_names is not implemented as required for the SrcLang subclass: %s' % self.__class__.__name__)
        if self.interpreter_env_name is None:
            raise NotImplementedError('interpreter_env_name is not implemented as required for the SrcLang subclass: %s' % self.__class__.__name__)
        
        executablePath = os.getenv(self.interpreter_env_name)
        if executablePath is None:
            for name in self.interpreter_name_exe_names:
                candidatePath = distutils.spawn.find_executable(name)
                if candidatePath is not None:
                    try:
                        self.interpreter_version = self.version_check(candidatePath)
                        executablePath = candidatePath
                        break
                    except Exception:
                        pass
        else:
            self.interpreter_version = self.version_check(executablePath) # execption on failure
            
        if executablePath is None:
            raise test_exceptions.TestingFrameworkException(detail='Unable to find interperter %s' % self.display_name)
        
        self.interpreter_path = executablePath
        return self.interpreter_path
    
    def get_interpreter_version(self, executablePath):
        '''Return the version string for this interpreter, this must be implimented by subclasses'''
        raise NotImplementedError('version_check is not implemented as required for the SrcLang subclass: %s' % self.__class__.__name__)
    
    def version_check(self, executablePath):
        '''Check that this is a supported version of this interpreter'''
        
        targetVersion = self.get_interpreter_version(executablePath)
        
        if self.minVersion is not None and targetVersion < self.minVersion:
            raise test_exceptions.TestingFrameworkException(detail='Version of %s (%s) was below the minuimum version %s' % (executablePath, targetVersion, self.minVersion))
        
        if self.maxVersion is not None and targetVersion > self.maxVersion:
            raise test_exceptions.TestingFrameworkException(detail='Version of %s (%s) was above the maximum version %s for python2' % (executablePath, targetVersion, self.maxVersion))
        
        return targetVersion

class PyLang(SrcLang):
    test_types = None
    display_name = 'python'
    
    interpreter_name_exe_names = None
    interpreter_env_name = None
    minVersion = None
    maxVersion = None
    
    driver_source_path = os.getenv('PYTHON_DRIVER_SRC_DIR') or os.path.join(utils.project_root_dir, 'drivers', 'python')
    driver_build_env_name = 'PYTHON_DRIVER_DIR'
    driver_build_path = os.getenv('PYTHON_DRIVER_DIR') or os.path.join(utils.project_root_dir, 'build', 'drivers', 'python')
    
    polyglot_language_header = os.path.join(os.path.dirname(__file__), 'drivers', 'driver.py')
    
    def __init__(self, version, interpreter_env_name='PYTHON'):
        if self.instance_setup is True:
            return
        
        super(PyLang, self).__init__()
        
        self.display_name = 'python ' + version
        self.test_types = []
        self.interpreter_name_exe_names = []
        
        if interpreter_env_name is not None:
            self.interpreter_env_name = interpreter_env_name
        
        self.minVersion = distutils.version.LooseVersion(version)
        self.maxVersion = distutils.version.LooseVersion(version + '.999')
        
        if version != '':
            lastVersion = None
            workingVersion = version
            while lastVersion != workingVersion:
                self.test_types.append('py' + workingVersion)
                self.interpreter_name_exe_names.append('python' + workingVersion)
                
                lastVersion = workingVersion
                workingVersion = os.path.splitext(workingVersion)[0]
        self.test_types.append('py')
        self.interpreter_name_exe_names.append('python')
    
    def langrepr(self, val):
        encoded = None
        if not isinstance(val, unicode):
            encoded = repr(str(val))
        else:
            encoded = repr(unicode(val))
        if distutils.version.LooseVersion('3.0') <= self.interpreter_version and self.interpreter_version < distutils.version.LooseVersion('3.3'):
            if len(encoded) > 2 and encoded[:2] in ('u"', "u'"):
                encoded = encoded[1:]
        return encoded
    
    def nulltranslate(self, strng):
        return re.sub("(?<!\"|')null(?!\"|')", 'None', strng)
    
    def get_interpreter_version(self, executablePath):
        versionCheckProcess = subprocess.Popen([executablePath, '--version'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, __ = versionCheckProcess.communicate()
        
        if versionCheckProcess.returncode != 0:
            raise test_exceptions.TestingFrameworkException(detail='Unable to determine the version of %s' % executablePath)
        
        versionNumbers = re.findall(r'\b([\d\.]+)\b', str(output.decode('utf-8')))
        if len(versionNumbers) != 1:
            raise test_exceptions.TestingFrameworkException(detail='Got multiple possible version numbers for %s' % executablePath)
        
        return distutils.version.LooseVersion(str(versionNumbers[0]))

class JsLang(SrcLang):
    test_types = ['js']
    display_name = 'javascript'
    
    interpreter_name_exe_names = ['node']
    interpreter_env_name = 'NODE'
    minVersion = None # no version requirements yet
    maxVersion = None
    
    driver_source_path = os.getenv('JAVASCRIPT_DRIVER_SRC_DIR') or os.path.join(utils.project_root_dir, 'drivers', 'javascript')
    driver_build_env_name = 'JAVASCRIPT_DRIVER_DIR'
    driver_build_path = os.getenv('JAVASCRIPT_DRIVER_DIR') or os.path.join(utils.project_root_dir, 'build', 'packages', 'js')
    
    polyglot_language_header = os.path.join(os.path.dirname(__file__), 'drivers', 'driver.js')
    
    def comment(self):
        return "//"

    def langrepr(self, val):
        if isinstance(val, str):
            return repr(val)
        elif isinstance(val, unicode):
            return repr(val)[1:] # Get rid of the 'u'
        elif isinstance(val, bool):
            return ("true" if val else "false")
        else:
            return repr(str(val))

    # Converts cannonical form (underscore separation) to camel case
    def nametranslate(self, name):
        if not re.search('__', name):
            return re.sub('_[a-z]', lambda m: m.group()[1].upper(), name)
        else:
            return re.sub('__', '_', name)
    
    def get_interpreter_version(self, executablePath):
        versionCheckProcess = subprocess.Popen([executablePath, '--version'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, __ = versionCheckProcess.communicate()
        
        if versionCheckProcess.returncode != 0:
            raise test_exceptions.TestingFrameworkException(detail='Unable to determine the version of %s' % executablePath)
        
        versionNumber = str(output.decode('utf-8')).lstrip('v').strip()
        return distutils.version.LooseVersion(versionNumber)

class RbLang(SrcLang):
    test_types = None
    display_name = 'ruby'
    
    interpreter_name_exe_names = None
    interpreter_env_name = None
    minVersion = None
    maxVersion = None
    
    driver_source_path = os.getenv('RUBY_DRIVER_SRC_DIR') or os.path.join(utils.project_root_dir, 'drivers', 'ruby')
    driver_build_env_name = 'RUBY_DRIVER_DIR'
    driver_build_path = os.getenv('RUBY_DRIVER_DIR') or os.path.join(utils.project_root_dir, 'drivers', 'ruby', 'lib')
    
    polyglot_language_header = os.path.join(os.path.dirname(__file__), 'drivers', 'driver.rb')
    
    def __init__(self, version, interpreter_env_name='RUBY'):
        if self.instance_setup is True:
            return
        
        super(RbLang, self).__init__()
        
        self.display_name = 'ruby ' + version
        self.test_types = []
        self.interpreter_name_exe_names = []
        
        if interpreter_env_name is not None:
            self.interpreter_env_name = interpreter_env_name
        
        self.minVersion = distutils.version.LooseVersion(version)
        self.maxVersion = distutils.version.LooseVersion(version + '.999')
        
        if version != '':
            lastVersion = None
            workingVersion = version
            while lastVersion != workingVersion:
                self.test_types.append('rb' + workingVersion)
                self.interpreter_name_exe_names.append('ruby' + workingVersion)
                
                lastVersion = workingVersion
                workingVersion = os.path.splitext(workingVersion)[0]
        self.test_types.append('rb')
        self.interpreter_name_exe_names.append('ruby')
    
    def rb_str_repr(self, string):
        return ('"' + re.sub("\"", "\\\"", re.sub("\\\\", "\\\\\\\\", string)) + '"')

    def langrepr(self, val):
        if isinstance(val, str):
            return self.rb_str_repr(val)
        elif isinstance(val, unicode):
            return re.sub("\\$", "\\$", repr(val)[1:]) # Get rid of the 'u'
        elif isinstance(val, bool):
            return ("true" if val else "false")
        else:
            return repr(str(val))

    def dicttranslate(self, dic):
        dicnew = re.sub("\\\\?'([^']*[^'\\\\])\\\\?':", ":\'\\1\'=>", dic)
        dicnew = re.sub("\\\\n$", "\n", dicnew)
        return dicnew

    def nulltranslate(self, strng):
        return re.sub('null', 'nil', strng)
    
    def get_interpreter_version(self, executablePath):
        '''Return the version string for this interpreter'''
        versionCheckProcess = subprocess.Popen([executablePath, '--version'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, __ = versionCheckProcess.communicate()
        
        if versionCheckProcess.returncode != 0:
            raise test_exceptions.TestingFrameworkException(detail='Unable to determine the version of %s' % executablePath)
        
        versionNumber = str(output.decode('utf-8').split()[1]).strip()
        return distutils.version.LooseVersion(versionNumber)

interpreters = {
    'js': [JsLang()],
    'py': [PyLang('2.6'), PyLang('2.7'), PyLang('3.0'), PyLang('3.1'), PyLang('3.2'), PyLang('3.3'), PyLang('3.4')],
    'rb': [RbLang('1.9'), RbLang('2.0'), RbLang('2.1')],
    
    'py2': [PyLang('2.6'), PyLang('2.7')],
    'py2.6': [PyLang('2.6')],
    'py2.7': [PyLang('2.7')],
    
    'py3': [PyLang('3.0'), PyLang('3.1'), PyLang('3.2'), PyLang('3.3'), PyLang('3.4')],
    'py3.0': [PyLang('3.0')],
    'py3.1': [PyLang('3.1')],
    'py3.2': [PyLang('3.2')],
    'py3.3': [PyLang('3.3')],
    'py3.4': [PyLang('3.4')],
    
    'rb1.9': [RbLang('1.9')],
    'rb1': [RbLang('1.9')],
    
    'rb2': [RbLang('2.0'), RbLang('2.1')],
    'rb2.0': [RbLang('2.0')],
    'rb2.1': [RbLang('2.1')]
}

# Abstracts a set of tests given in a single file
class TestGroup(object):
    
    testLanguageEntry = collections.namedtuple('testLanguageEntry', ['command', 'expected', 'definition', 'runopts', 'testopts'])
    variableRegex = re.compile('^\s*(?P<quoteString>[\'\"]*)\s*(?P<variableName>[a-zA-Z][\w\[\]\{\}\'\"]*)\s*=\s*(?P<expression>[^=].+)$')
    
    @classmethod
    def buildYamlTest(cls, testName, sourceFile, language, outputPath, shards=0,
                      useSpecificTable = False):
    
        # -- input validation
        
        # testName
        
        if testName is None:
            raise ValueError('buildYamlTest requires a testName, got None')
        testName = str(testName)
        
        # sourceFile
        
        if sourceFile is None:
            raise ValueError('buildYamlTest requires a sourceFile, got None')
        if not os.path.isfile(sourceFile):
            raise ValueError('buildYamlTest requires a sourceFile, got: %s' % str(sourceFile))
        
        # language
        
        if language is None:
            raise ValueError('buildYamlTest requires a language, got None')
        if not isinstance(language, SrcLang):
            raise ValueError('buildYamlTest requires a subclass of SrcLang, got %s' % language)
        
        # outputPath
        
        if outputPath is None:
            raise ValueError('buildYamlTest requires an outputPath, got None')
        if not os.path.isdir(os.path.dirname(outputPath)):
            if not os.path.exists(os.path.dirname(outputPath)):
                os.makedirs(os.path.dirname(outputPath))
            else:
                raise ValueError('buildYamlTest got an outputPath with a directory that was already a non-file: %s' % outputPath)
        if os.path.exists(outputPath) and not os.path.isfile(outputPath):
            raise ValueError('buildYamlTest got an outputPath that was already a non-file: %s' % outputPath)
        
        # -- create the file
        
        parsed_data = None
        try:
            parsed_data = yaml.load(open(sourceFile))
        except Exception as e:
            raise ValueError('buildYamlTest got a sourceFile (%s) that was unable to be parsed as Yaml: %s' % (sourceFile, str(e)))
        
        with open(outputPath, 'w') as outputFile:
            
            # - write the shebang line
            
            outputFile.write('#!%s\n' % language.get_interpreter_path())
            
            # - write in the encoding (mostly for Python2.6)
            
            outputFile.write('%s -*- coding: utf-8 -*-\n\n' % language.comment())
            
            # - mark start of the header/driver
            
            outputFile.write('%s ========== Start of common test functions ==========\n\n' % language.comment())
            
            # - insert a marker telling what test this is
            
            outputFile.write('%s Tests %s (%s): %s (%s)\n\n' % (language.comment(), testName, language.display_name, parsed_data['desc'], sourceFile))
            
            # - add the header/driver
            
            with open(language.polyglot_language_header) as headerFile:
                for chunk in iter((lambda: headerFile.read(1024)), ''):
                    outputFile.write(chunk)
            
            outputFile.write('\n\n')
            
            # - mark end of the header/driver
            
            outputFile.write('%s ========== End of common test functions ==========\n\n' % language.comment())
            
            # - set up table if necessary
            
            if "table_variable_name" in parsed_data:
                table_name = testName.replace(".","_").replace("/","_")
                table_name += "_"
                table_name += language.display_name.replace(" ","_").replace(".","_")
                outputFile.write("setup_table(%s, %s)\n\n" % (
                    language.langrepr(parsed_data["table_variable_name"]),
                    language.langrepr(table_name)))
            else:
                outputFile.write("check_no_table_specified()\n\n")
            
            # - add the body of the tests
            
            for testNumber, test in enumerate(parsed_data['tests'], start=0):
                cls.write_test(testName, outputFile, test, language, str(testNumber), shard=shards)
            
            outputFile.write('\n\n')
            
            # - add the footer
            
            outputFile.write('the_end()\n')
            
        # - make sure the file is executable
        
        os.chmod(outputPath, stat.S_IRWXU | stat.S_IRWXG | stat.S_IROTH | stat.S_IXOTH)
    
    @classmethod
    def write_test(cls, testName, out, test, lang, index, shard=0):
        
        testName = os.path.join(testName, str(index))

        # See if this test defines operations for our language
        try:
            testCode = cls.get_lang_entries(test, lang)
        except Exception as e:
            raise Exception("Error while processing test: %s\n%s" % (testName, str(e)))
        
        # Does this test define a variable?
        if testCode.definition:
            cls.write_def(out, testCode.definition)
        
        # Write the commands
        if testCode.command:
            for test_case in testCode.command:
                
                variableMatch = cls.variableRegex.match(test_case)
                if variableMatch:
                    testCode.testopts['variable'] = variableMatch.group('variableName')
                    test_case = variableMatch.group('quoteString') + variableMatch.group('expression')
                
                try:
                    out.write("test(%(code)s, %(expected)s, '%(name)s', %(driveropts)s, %(testopts)s)\n" % {
                        'code': test_case,
                        'expected': testCode.expected or '""',
                        'name': testName,
                        'driveropts': lang.translate_query(repr(testCode.runopts), encode=False),
                        'testopts': lang.translate_query(repr(testCode.testopts), encode=False)
                    })
                    
                    # We want to auto-shard tables that we create. There is stil no
                    # way to do this from rql so we have to hack the admin cli.
                    
                    if shard > 0:
                        pattern = 'table_create\\(\'(\\w+)\'\\)'
                        mo = re.search(pattern, test_case)
                        if mo:
                            table_name = mo.group(1)
                            out.write('shard("%s")\n' % table_name)
                except Exception as e:
                    raise Exception("Error while processing test: %s\n%s\n%s" % (testName, str(testCode.command), str(e)))

    @staticmethod
    def write_def(out, defs):
        for definition in defs:
            out.write('define(%s)\n' % definition)
    
    # Tests may specify generic test strings valid for all languages or language specific versions
    @classmethod
    def get_lang_entries(cls, source, lang, default='command'):
        assert default in ('command', 'expected', 'definition'), 'get_lang_entries requires that default be one of : command, expected, or definition'
        
        results = { 'command': None, 'definition': None, 'expected': None, 'runopts': {}, 'testopts':{} }
        
        if source is None:
            pass
        
        elif default in ('runopts', 'testopts'):
            results[default] = source
        
        elif not hasattr(source, 'get'):
            # leaf, replace appropriate item
            langcode = (lang.test_types[0] if isinstance(lang.test_types, list) else lang.test_types).replace('.', '')
            
            if default != 'expected' and hasattr(source, '__iter__') and not hasattr(source, 'capitalize'):
                results[default] = []
                for item in source:
                    results[default].append(string.Template(lang.translate_query(item)).safe_substitute({'langcode': langcode}))
            else:
                if default == 'expected':
                    results['expected'] = string.Template(lang.translate_expected(source)).safe_substitute({'langcode': langcode})
                else:
                    results[default] = [string.Template(lang.translate_query(source)).safe_substitute({'langcode': langcode})]
        else:
            if default == 'command':
                
                # runopts and testopts
                if 'runopts' in source:
                    results['runopts'].update(source['runopts'])
                if 'testopts' in source:
                    results['testopts'].update(source['testopts'])
                
                # command
                
                for langCode in lang.test_types + ['cd']:
                    if langCode in source:
                        results = cls.combineLangEntries(results, cls.get_lang_entries(source[langCode], lang, 'command'))
                        break
                
                # def and ot
                if 'def' in source:
                    results = cls.combineLangEntries(results, cls.get_lang_entries(source['def'], lang, 'definition'))
                if 'ot' in source:
                    results = cls.combineLangEntries(results, cls.get_lang_entries(source['ot'], lang, 'expected'))
                    
            elif default == 'expected':
                for langCode in lang.test_types + ['cd']:
                    if langCode in source:
                        results['expected'] = cls.get_lang_entries(source[langCode], lang, 'expected').expected
                        break
            
            elif default == 'definition':
                for langCode in lang.test_types + ['cd']:
                    if langCode in source:
                        results['definition'] = cls.get_lang_entries(source[langCode], lang, 'definition').definition
                        break
            
            else:
                sys.stderr.write('Warning! Unknown default type: %s\n' % str(default))
        
        return cls.testLanguageEntry(command=results['command'], expected=results['expected'], definition=results['definition'], runopts=results['runopts'], testopts=results['testopts'])
    
    @classmethod
    def combineLangEntries(cls, left, right):
        
        # - convert both to dicts
        
        if isinstance(left, cls.testLanguageEntry):
            left = dict(left._asdict())
        elif not isinstance(left, dict):
            raise ValueError('combineLangEntries given a left that is not useable: %s' % str(left))
        
        if isinstance(right, cls.testLanguageEntry):
            right = dict(right._asdict())
        elif not isinstance(right, dict):
            raise ValueError('combineLangEntries given a right that is not useable: %s' % str(right))
        
        # combine them, keeping any non-None entries from right
        returnDict = {}
        for key in set(right.keys() + left.keys()): # should be the same, but...
            if key in ('runopts', 'testopts') and any([left.get(key), right.get(key)]):
                returnValue = left.get(key) or {}
                returnValue.update(right.get(key) or {})
                returnDict[key] = returnValue
            else:
                returnDict[key] = right.get(key) or left.get(key)
        return returnDict

class RethinkDBRunningServer(object):
    
    __driver_port = None
    __cluster_port = None
    
    def __init__(self, driver_port, cluster_port):
        self.__driver_port = driver_port
        self.__cluster_port = cluster_port
    
    @property
    def host(self):
        return 'localhost'
    
    @property
    def driver_port(self):
        return self.__driver_port
    
    @property
    def cluster_port(self):
        return self.__cluster_port
    
    @property
    def executable_path(self):
        return 'NOT_AVALIBLE_FOR_RUNNING_SERVERS'

# ==== Main

def check_language(option, opt_str, value, parser):
    if value not in option.choices:
        raise optparse.OptionValueError('Invalid language: %s' % value) 
    
    if not hasattr(parser.values, option.dest):
        setattr(parser.values, option.dest, [])
    selectedValues = getattr(parser.values, option.dest)
    if selectedValues == None:
        selectedValues = []
    
    foundAny = False
    for language in interpreters[value]:
        try:
            language.get_interpreter_path()
            foundAny = True
            if language not in selectedValues:
                selectedValues.append(language)
                break # default is to only take one language from a group
        except Exception:
            continue
    
    if foundAny is False:
        raise optparse.OptionValueError('Unable to find a valid interpreter for language: %s' % value)
    
    setattr(parser.values, option.dest, selectedValues)

TestListing = collections.namedtuple('TestListing', ['name', 'path', 'language', 'type', 'interpreter'])
def getTestList(rootPath, languages, testFilters=None):
    '''Get a list of TestListing objects for tests found in the given folder'''
    
    # -- input validation
    
    # rootPath
    
    if rootPath is None:
        raise ValueError('getTestList got None for rootPath')
    if not os.path.isdir(str(rootPath)):
        raise ValueError('getTestList got a non-directory as rootpath: %s' % str(rootPath))
    rootPath = os.path.realpath(rootPath)
    
    # testFilters
    
    if testFilters is not None:
        if not hasattr(testFilters, '__iter__'):
            testFilters = [testFilters]
        for testFilter in testFilters:
            if not hasattr(testFilter, 'match'):
                raise ValueError('getTestList got a non-regex value as a fiter: %s' % str(testFilter))
    
    # languages
    
    if languages is None:
        raise ValueError('getTestList requires one or more languages to look for')
    
    if not hasattr(languages, '__iter__'):
        languages = [languages]
    
    for language in languages:
        if not isinstance(language, SrcLang):
            raise ValueError('getTestList got a language that it does not know how to process: %s' % language)
        
    # -- find items in the directory
    
    foundTests = []
    
    for root, dirs, files in os.walk(rootPath):
        
        groupName = os.path.relpath(root, rootPath)
        if groupName in ('.', './'):
            groupName = ''
        if groupName == 'src' or groupName.startswith('src/'):
            groupName = 'polyglot' + groupName.lstrip('src')
        
        for fileName in [x for x in files if x.count('.') > 0]:
            
            testName, extension = os.path.splitext(fileName)
            extension = extension.lstrip('.').lower()
            
            testName, testLanguages = os.path.splitext(testName)
            testLanguages = testLanguages.lstrip('.').lower().split(',')
            
            testName = os.path.join(groupName, testName)
            
            if extension not in testExtensions:
                continue
            
            for language in languages:
                
                # - check that this test supports this language
                
                if extension == 'yaml':
                    pass # implicitly all languages
                elif not any([x in language.test_types for x in testLanguages]):
                    continue
                
                subTestName = '%s.%s' % (testName, language.test_types[0])
            
                # - run the filters

                if testFilters is not None and len(testFilters) > 0:
                    foundMatch = False
                    for testFilter in testFilters:
                        if testFilter.match(subTestName) is not None:
                            foundMatch = True
                            break
                    if foundMatch is False:
                        continue
                
                # - add the test
                
                interpreter = None
                if extension == 'yaml':
                    interpreter = language.get_interpreter_path()
                
                foundTests.append(TestListing(name=subTestName, path=os.path.join(root, fileName), language=language, type=extension, interpreter=interpreter))
    
    # --
    
    foundTests.sort(key=lambda x: (x.name, x.type))
    return foundTests

runningProcessGroupsIds = []
def cleanup(*args):
    '''fired by atexit or a signal handler, this should make sure we don't leave processes running'''
    
    for processGroupId in runningProcessGroupsIds:
        try:
            utils.kill_process_group(processGroupId)
        except Exception as e:
            raise Warning('Unable to shut down server: %s' % str(e))
    
    if len(args) == 2 and args[0] == signal.SIGINT:
        sys.exit(130) # standard signal.SIGINT exit code
atexit.register(cleanup)
signal.signal(signal.SIGINT, cleanup) # TODO: cover all relevent signals

def main():
    
    testFilters = []
    testList = []
    rethinkdb_exe_path = None
    
    server = None
    serverOutput = None
    
    # -- parse command line options
    
    parser = optparse.OptionParser(usage='usage: %prog [options] [patterns]')
    
    parser.add_option('-l', '--list', dest='list_mode', default=False, action='store_true', help='list the tests and exit')
    
    parser.add_option('-b', '--server-binary', dest='rethinkdb_exe_path', default=None, help='path to RethinkDB server binary to test')
    parser.add_option(      '--clean', dest='clean_run_directory', default=False, action='store_true', help='clean the run directory before running')
    
    parser.add_option('-i', '--interpreter', dest='languages', action='callback', callback=check_language, choices=list(interpreters.keys()), type='choice', default=None, help='the language to test')
    parser.add_option('-s', '--shards', dest='shards', type='int', default=1, help='number of shards to run (default 1)')
    
    parser.add_option('-c', '--cluster-port', dest='cluster_port', default=None, type='int', help='cluster port of an already-running rethinkdb instance')
    parser.add_option('-d', '--driver-port', dest='driver_port', default=None, type='int', help='driver port of an already-running rethinkdb instance')
    parser.add_option('-t', '--table', dest='table', default=None, type='string', help='name of pre-existing table to run queries against.')
    
    parser.add_option('-v', '--verbose', dest='verbose', default=False, action='store_true', help='show in-progress messages from tests')
    
    options, args = parser.parse_args()
    
    # - options validation
    
    # cluster_port/driver_port
    
    if (options.cluster_port is not None or options.driver_port is not None) and None in (options.cluster_port, options.driver_port):
        parser.error('If either of the following options are used, both must be specifed: -c/--cluster-port, -d/--driver-port')
    if options.driver_port is not None:
        server = RethinkDBRunningServer(options.driver_port, options.cluster_port)
        # TODO: validate that this is actually a running server
        
        if options.shards != 1:
            parser.error('The -c/--cluster-port and -d/--driver-port options can not be used with -s/--shards')
    elif options.table:
        parser.error('If you specify -t/--table, you must also specify -c/--cluster-port and -d/--driver-port')
    
    if options.table and options.table.count(".") != 1:
        parser.error('Parameter to -t/--table should be of the form db.table')
    
    # - add filters
    
    for newFilter in args:
        try:
            testFilters.append(re.compile(newFilter))
        except Exception:
            parser.error('Invalid filter (regex) entry: %s' % newFilter)
    
    # - pull in environmental variables
    
    if len(testFilters) == 0:
        if os.getenv('RQL_TEST'):
            try:
                testFilters.append(re.compile(os.getenv('RQL_TEST')))
            except re.error:
                parser.error("'Invalid filter from ENV: %s" % os.getenv('RQL_TEST'))
        if os.getenv('TEST'):
            try:
                testFilters.append(re.compile(os.getenv('TEST')))
            except re.error:
                parser.error("'Invalid filter from ENV: %s" % os.getenv('TEST'))
    
    # - default options
    
    if options.languages is None:
        options.languages = []
        for languageGroup in (interpreters['js'], interpreters['py'], interpreters['rb']):
            for language in languageGroup:
                try:
                    language.get_interpreter_path()
                    options.languages.append(language)
                    break
                except Exception: pass
        if len(options.languages) == 0:
            parser.error('Unable to find interperters for any of the default languages')
    
    # -- get the list of tests
    
    testList = getTestList(os.path.realpath(os.path.dirname(__file__)), languages=options.languages, testFilters=testFilters)
    
    # -- clean run dir if requested
    
    if options.clean_run_directory is True:
        runDirPath = os.path.join(os.path.realpath(os.path.dirname(__file__)), 'run')
        if os.path.exists(runDirPath) and not os.path.islink(runDirPath):
            if os.path.isdir(runDirPath):
                shutil.rmtree(runDirPath)
            else:
                os.unlink(runDirPath)
    
    # -- short-circut if there are no tests
    
    if len(testList) == 0:
        languagesString = 'for the language: '
        if len(options.languages) > 1:
            languagesString = 'for the languages: '
        languagesString += ', '.join([lang.display_name for lang in options.languages])
        if len(args) == 1:
            sys.stderr.write('There are no tests that match the filter: %s %s\n' % (args[0], languagesString))
        elif len(args) > 1:
            sys.stderr.write('There are no tests that match any of the filters: %s %s\n' % (args, languagesString))
        else:
            sys.stderr.write('There are no tests %s\n' % languagesString)
        sys.exit()
    
    # -- print list if requested
    
    if options.list_mode is True:
        for test in testList:
            print(test.name)
        sys.exit()
    
    # -- reduce the langauges to only ones we have tests selected for
    
    for language in options.languages[:]:
        foundLangauge = False
        for test in testList:
            if test.language == language:
                foundLangauge = True
                break
        if not foundLangauge:
            options.languages.remove(language)
            sys.stderr.write('Warning: did not find any tests for %s\n' % language.display_name)
    
    # -- check the rethinkdb_exe_path
    
    if options.rethinkdb_exe_path is None:
        try:
            rethinkdb_exe_path = utils.find_rethinkdb_executable()
        except test_exceptions.TestingFrameworkException as e:
            sys.exit(str(e))
    else:
        rethinkdb_exe_path = options.rethinkdb_exe_path
    
    if not os.access(rethinkdb_exe_path, os.X_OK):
        sys.exit('Error: selected RethiinkDB server binary does not look valid: %s' % rethinkdb_exe_path)
    
    # -- set ENV settings for child processes
    
    os.environ['JAVASCRIPT_DRIVER_DIR'] = utils.driverPaths['javascript']['driverPath']
    os.environ['PYTHON_DRIVER_DIR'] = utils.driverPaths['python']['driverPath']
    os.environ['RUBY_DRIVER_DIR'] = utils.driverPaths['ruby']['driverPath']
    
    os.environ['RDB_EXE_PATH'] = rethinkdb_exe_path
    
    if options.table:
        os.environ['TEST_DB_AND_TABLE_NAME'] = options.table
    
    # -- make sure the drivers are built
    
    for language in options.languages:
        outputFile = tempfile.NamedTemporaryFile(mode='w+')
        notificationDeadline = time.time() + 3
        makeProcess = subprocess.Popen(['make', '-C', language.driver_source_path], stdout=outputFile, stderr=subprocess.STDOUT)
        while makeProcess.poll() is None and time.time() < notificationDeadline:
            time.sleep(.1)
        if time.time() > notificationDeadline:
            print('Building the %s drivers. This make take a few moments.' % language.display_name)
        if makeProcess.wait() != 0:
            sys.stderr.write('Error making %s driver. Make output follows:\n\n' % os.path.basename(__file__))
            outputFile.seek(0)
            print(outputFile.read().decode('utf-8'))
            sys.exit(1)
        
        os.environ[language.driver_build_env_name] = language.driver_build_path
    
    # -- run the testing
    
    if len(testList) == 0:
        sys.exit()
    
    print('Using rethinkdb binary %s' % rethinkdb_exe_path)
    for thisLanguage in options.languages:
        print('\t%s interpreter: %s, driver: %s' % (thisLanguage.display_name, thisLanguage.get_interpreter_path(), thisLanguage.driver_source_path))
    startTime = time.time()
    
    failedTests = []
    
    srcPath = os.path.join(os.path.realpath(os.path.dirname(__file__)), 'src')
    buildPath = os.path.join(os.path.realpath(os.path.dirname(__file__)), 'build')
    
    for test in testList:
        
        executablePath = test.path
        
        # - type-specific setup
        
        if test.type == 'yaml':
            
            # - build the runable test
            
            if not os.path.isdir(srcPath):
                os.makedirs(srcPath)
            executablePath = os.path.join(buildPath, test.name.replace('/', '.'))
            
            try:
                TestGroup.buildYamlTest(test.name, test.path, test.language, executablePath, shards=options.shards-1)
            except Exception as e:
                failedTests.append("%s (%s)" % (test.name, test.language.display_name))
                sys.stderr.write("Setup Failure: unable to create test executable for Yaml test %s:\n" % test.name)
                traceback.print_exc()
                continue
            
        # - start the server
        
        if server is None:
            if options.cluster_port is not None:
                sys.exit('Internal failure: we somehow lost track of the already running server!')
            serverOutput = tempfile.NamedTemporaryFile(mode='w+')
            try:
                server = driver.Process(executable_path=rethinkdb_exe_path, console_output=serverOutput, wait_until_ready=True)
            except Exception as e:
                serverOutput.seek(0)
                sys.stderr.write('Unable to start a managed server. The servers output was:\n%s\n' % serverOutput.read())
                sys.exit(str(e))
            
        # - run the test
        
        outputChannel = None
        if options.verbose is False:
            outputChannel = tempfile.NamedTemporaryFile(mode='w+')
        
        testProcessGroupId = None
        print("\n== Running %s (%s)" % (test.name, test.language.display_name))
        try:
            
            if not os.path.isfile(executablePath):
                failedTests.append("%s (%s)" % (test.name, test.language.display_name))
                sys.stderr.write("== Failed %s test as it could not be located %s\n" % (test.name, executablePath))
                continue
            
            testExecutable = [executablePath]
            if test.interpreter is not None:
                testExecutable = [test.interpreter] + testExecutable
            
            envVariables = copy.copy(os.environ)
            envVariables.update({
                'RDB_DRIVER_PORT':str(server.driver_port),
                'RDB_CLUSTER_PORT':str(server.cluster_port),
                'RDB_SERVER_HOST':server.host
            })
            if test.language:
                envVariables['INTERPRETER_PATH'] = test.language.interpreter_path
            
            testProcess = subprocess.Popen(testExecutable, stdout=outputChannel, stderr=outputChannel, preexec_fn=os.setpgrp, env=envVariables)
            
            # - kill off the process group
            
            try:
                testProcessGroupId = os.getpgid(testProcess.pid)
                runningProcessGroupsIds.append(testProcessGroupId)
            except OSError:
                pass
            
            if testProcess.wait() != 0:
                if server is not None and hasattr(server, 'check_and_stop'):
                    try:
                        server.check_and_stop()
                    except Exception as e:
                        serverLog = ''
                        if serverOutput:
                            serverOutput.seek(0)
                            serverLog = '\nServer log:\n%s' % serverOutput.read()
                        sys.stderr.write('RethinkDB server failed: %s%s' % (str(e), serverLog))
                    server = None
                    serverOutput = None
                
                failedTests.append("%s (%s)" % (test.name, test.language.display_name))
                sys.stderr.write("== Failed %s test with result code %s (%s)" % (test.name, str(testProcess.returncode), test.path))
                if outputChannel is not None and os.path.getsize(outputChannel.name) > 0:
                    outputChannel.seek(0)
                    sys.stderr.write(' Output:\n')
                    sys.stderr.write(outputChannel.read())
                sys.stderr.write('\n')
            else:
                print("== Successfully passed %s test" % test.name)
        finally:
            outputChannel = None
            if testProcessGroupId is not None:
                try:
                    os.killpg(testProcessGroupId, signal.SIGINT) # TODO: police this
                except Exception:
                    pass
            if testProcessGroupId in runningProcessGroupsIds:
                runningProcessGroupsIds.remove(testProcessGroupId)
            testProcessGroupId = None
            sys.stderr.flush()
            sys.stdout.flush()
    
    if len(failedTests) == 0:
        testNumberMessage = 'the 1 test'
        if len(testList) > 1:
            testNumberMessage = 'all %s tests' % len(testList)
        print('\n== Sucessfully passed %s in %.2f seconds!' % (testNumberMessage, time.time() - startTime))
        sys.exit()
    else:
        plural = ''
        if len(failedTests) > 1:
            plural = 's'
        sys.exit('\n== Failed %d test%s (of %d) in %.2f seconds!\n\t%s\n\n' % (len(failedTests), plural, len(testList), time.time() - startTime, '\n\t'.join(failedTests)))
        
if __name__ == '__main__':
    main()
