desc: Test ReQL interface to geo indexes
table_variable_name: tbl
tests:
  - def: rows = [{'id':0, 'g':r.point(10,10), 'm':[r.point(0,0),r.point(1,0),r.point(2,0)]},
                 {'id':1, 'g':r.polygon([0,0], [0,1], [1,1], [1,0])},
                 {'id':2, 'g':r.line([0.000002,-1], [-0.000001,1])}]

  - cd: tbl.insert(rows)
    ot: ({'deleted':0,'inserted':3,'skipped':0,'errors':0,'replaced':0,'unchanged':0})

  - rb: tbl.index_create('g', :geo=>true)
    py: tbl.index_create('g', geo=true)
    js: tbl.indexCreate('g', {'geo':true})
    ot: {'created':1}
  - rb: tbl.index_create('m', :geo=>true, :multi=>true)
    py: tbl.index_create('m', geo=true, multi=true)
    js: tbl.indexCreate('m', {'geo':true, 'multi':true})
    ot: {'created':1}
  - cd: tbl.index_create('other')
    ot: {'created':1}
  # r.point is deterministic and can be used in an index function
  - rb: tbl.index_create('point_det'){ |x| r.point(x, x) }
    py: tbl.index_create('point_det', lambda x: r.point(x, x) )
    js: tbl.indexCreate('point_det', function(x) {return r.point(x, x);} )
    ot: {'created':1}

  - cd: tbl.index_wait()

  # r.line (and friends) are non-deterministic across servers and should be disallowed
  # in index functions
  - rb: tbl.index_create('point_det'){ |x| r.line(x, x) }
    py: tbl.index_create('point_det', lambda x: r.line(x, x) )
    js: tbl.indexCreate('point_det', function(x) {return r.line(x, x);} )
    ot: err('ReqlQueryLogicError', 'Could not prove function deterministic.  Index functions must be deterministic.')

  - js: tbl.get_intersecting(r.point(0,0), {'index':'other'}).count()
    py: tbl.get_intersecting(r.point(0,0), index='other').count()
    rb: tbl.get_intersecting(r.point(0,0), :index=>'other').count()
    ot: err('ReqlQueryLogicError', 'Index `other` is not a geospatial index.  get_intersecting can only be used with a geospatial index.', [0])
  - js: tbl.get_intersecting(r.point(0,0), {'index':'missing'}).count()
    py: tbl.get_intersecting(r.point(0,0), index='missing').count()
    rb: tbl.get_intersecting(r.point(0,0), :index=>'missing').count()
    ot: err_regex('ReqlOpFailedError', 'Index `missing` was not found on table `[a-zA-Z0-9_]+.[a-zA-Z0-9_]+`[.]', [0])
  - cd: tbl.get_intersecting(r.point(0,0)).count()
    ot: err('ReqlQueryLogicError', 'get_intersecting requires an index argument.', [0])
  - js: tbl.get_all(0, {'index':'g'}).count()
    py: tbl.get_all(0, index='g').count()
    rb: tbl.get_all(0, :index=>'g').count()
    ot: err('ReqlQueryLogicError', 'Index `g` is a geospatial index.  Only get_nearest and get_intersecting can use a geospatial index.', [0])
  - js: tbl.between(0, 1, {'index':'g'}).count()
    py: tbl.between(0, 1, index='g').count()
    rb: tbl.between(0, 1, :index=>'g').count()
    ot: err('ReqlQueryLogicError', 'Index `g` is a geospatial index.  Only get_nearest and get_intersecting can use a geospatial index.', [0])
  - js: tbl.order_by({'index':'g'}).count()
    py: tbl.order_by(index='g').count()
    rb: tbl.order_by(:index=>'g').count()
    ot: err('ReqlQueryLogicError', 'Index `g` is a geospatial index.  Only get_nearest and get_intersecting can use a geospatial index.', [0])
  - js: tbl.between(0, 1).get_intersecting(r.point(0,0), {'index':'g'}).count()
    py: tbl.between(0, 1).get_intersecting(r.point(0,0), index='g').count()
    rb: tbl.between(0, 1).get_intersecting(r.point(0,0), :index=>'g').count()
    ot:
      cd: err('ReqlQueryLogicError', 'Expected type TABLE but found TABLE_SLICE:', [0])
      py: err('AttributeError', "'Between' object has no attribute 'get_intersecting'")
  - js: tbl.get_all(0).get_intersecting(r.point(0,0), {'index':'g'}).count()
    py: tbl.get_all(0).get_intersecting(r.point(0,0), index='g').count()
    rb: tbl.get_all(0).get_intersecting(r.point(0,0), :index=>'g').count()
    ot:
      cd: err('ReqlQueryLogicError', 'Expected type TABLE but found SELECTION:', [0])
      py: err('AttributeError', "'GetAll' object has no attribute 'get_intersecting'")    
  - js: tbl.order_by({'index':'id'}).get_intersecting(r.point(0,0), {'index':'g'}).count()
    py: tbl.order_by(index='id').get_intersecting(r.point(0,0), index='g').count()
    rb: tbl.order_by(:index=>'id').get_intersecting(r.point(0,0), :index=>'g').count()
    ot:
      cd: err('ReqlQueryLogicError', 'Expected type TABLE but found TABLE_SLICE:', [0])
      py: err('AttributeError', "'OrderBy' object has no attribute 'get_intersecting'")
  - js: tbl.get_intersecting(r.point(0,0), {'index':'id'}).count()
    py: tbl.get_intersecting(r.point(0,0), index='id').count()
    rb: tbl.get_intersecting(r.point(0,0), :index=>'id').count()
    ot: err('ReqlQueryLogicError', 'get_intersecting cannot use the primary index.', [0])

  - js: tbl.get_intersecting(r.point(0,0), {'index':'g'}).count()
    py: tbl.get_intersecting(r.point(0,0), index='g').count()
    rb: tbl.get_intersecting(r.point(0,0), :index=>'g').count()
    ot: 1
  - js: tbl.get_intersecting(r.point(10,10), {'index':'g'}).count()
    py: tbl.get_intersecting(r.point(10,10), index='g').count()
    rb: tbl.get_intersecting(r.point(10,10), :index=>'g').count()
    ot: 1
  - js: tbl.get_intersecting(r.point(0.5,0.5), {'index':'g'}).count()
    py: tbl.get_intersecting(r.point(0.5,0.5), index='g').count()
    rb: tbl.get_intersecting(r.point(0.5,0.5), :index=>'g').count()
    ot: 1
  - js: tbl.get_intersecting(r.point(20,20), {'index':'g'}).count()
    py: tbl.get_intersecting(r.point(20,20), index='g').count()
    rb: tbl.get_intersecting(r.point(20,20), :index=>'g').count()
    ot: 0
  - js: tbl.get_intersecting(r.polygon([0,0], [1,0], [1,1], [0,1]), {'index':'g'}).count()
    py: tbl.get_intersecting(r.polygon([0,0], [1,0], [1,1], [0,1]), index='g').count()
    rb: tbl.get_intersecting(r.polygon([0,0], [1,0], [1,1], [0,1]), :index=>'g').count()
    ot: 2
  - js: tbl.get_intersecting(r.line([0,0], [10,10]), {'index':'g'}).count()
    py: tbl.get_intersecting(r.line([0,0], [10,10]), index='g').count()
    rb: tbl.get_intersecting(r.line([0,0], [10,10]), :index=>'g').count()
    ot: 3
  - js: tbl.get_intersecting(r.point(0,0), {'index':'g'}).type_of()
    py: tbl.get_intersecting(r.point(0,0), index='g').type_of()
    rb: tbl.get_intersecting(r.point(0,0), :index=>'g').type_of()
    ot: ("SELECTION<STREAM>")
  - js: tbl.get_intersecting(r.point(0,0), {'index':'g'}).filter(true).type_of()
    py: tbl.get_intersecting(r.point(0,0), index='g').filter(true).type_of()
    rb: tbl.get_intersecting(r.point(0,0), :index=>'g').filter(true).type_of()
    ot: ("SELECTION<STREAM>")
  - js: tbl.get_intersecting(r.point(0,0), {'index':'g'}).map(r.row).type_of()
    py: tbl.get_intersecting(r.point(0,0), index='g').map(r.row).type_of()
    rb: tbl.get_intersecting(r.point(0,0), :index=>'g').map{|x|x}.type_of()
    ot: ("STREAM")

  - js: tbl.get_intersecting(r.point(0,0), {'index':'m'}).count()
    py: tbl.get_intersecting(r.point(0,0), index='m').count()
    rb: tbl.get_intersecting(r.point(0,0), :index=>'m').count()
    ot: 1
  - js: tbl.get_intersecting(r.point(1,0), {'index':'m'}).count()
    py: tbl.get_intersecting(r.point(1,0), index='m').count()
    rb: tbl.get_intersecting(r.point(1,0), :index=>'m').count()
    ot: 1
  - js: tbl.get_intersecting(r.point(2,0), {'index':'m'}).count()
    py: tbl.get_intersecting(r.point(2,0), index='m').count()
    rb: tbl.get_intersecting(r.point(2,0), :index=>'m').count()
    ot: 1
  - js: tbl.get_intersecting(r.point(3,0), {'index':'m'}).count()
    py: tbl.get_intersecting(r.point(3,0), index='m').count()
    rb: tbl.get_intersecting(r.point(3,0), :index=>'m').count()
    ot: 0
  # The document is emitted once for each match.
  - js: tbl.get_intersecting(r.polygon([0,0], [0,1], [1,1], [1,0]), {'index':'m'}).count()
    py: tbl.get_intersecting(r.polygon([0,0], [0,1], [1,1], [1,0]), index='m').count()
    rb: tbl.get_intersecting(r.polygon([0,0], [0,1], [1,1], [1,0]), :index=>'m').count()
    ot: 2


  - js: tbl.get_nearest(r.point(0,0), {'index':'other'})
    py: tbl.get_nearest(r.point(0,0), index='other')
    rb: tbl.get_nearest(r.point(0,0), :index=>'other')
    ot: err('ReqlQueryLogicError', 'Index `other` is not a geospatial index.  get_nearest can only be used with a geospatial index.', [0])
  - js: tbl.get_nearest(r.point(0,0), {'index':'missing'})
    py: tbl.get_nearest(r.point(0,0), index='missing')
    rb: tbl.get_nearest(r.point(0,0), :index=>'missing')
    ot: err_regex('ReqlOpFailedError', 'Index `missing` was not found on table `[a-zA-Z0-9_]+.[a-zA-Z0-9_]+`[.]', [0])
  - cd: tbl.get_nearest(r.point(0,0))
    ot: err('ReqlQueryLogicError', 'get_nearest requires an index argument.', [0])
  - js: tbl.between(0, 1).get_nearest(r.point(0,0), {'index':'g'}).count()
    py: tbl.between(0, 1).get_nearest(r.point(0,0), index='g').count()
    rb: tbl.between(0, 1).get_nearest(r.point(0,0), :index=>'g').count()
    ot:
      cd: err('ReqlQueryLogicError', 'Expected type TABLE but found TABLE_SLICE:', [0])
      py: err('AttributeError', "'Between' object has no attribute 'get_nearest'")
  - js: tbl.get_all(0).get_nearest(r.point(0,0), {'index':'g'}).count()
    py: tbl.get_all(0).get_nearest(r.point(0,0), index='g').count()
    rb: tbl.get_all(0).get_nearest(r.point(0,0), :index=>'g').count()
    ot:
      cd: err('ReqlQueryLogicError', 'Expected type TABLE but found SELECTION:', [0])
      py: err('AttributeError', "'GetAll' object has no attribute 'get_nearest'")
  - js: tbl.order_by({'index':'id'}).get_nearest(r.point(0,0), {'index':'g'}).count()
    py: tbl.order_by(index='id').get_nearest(r.point(0,0), index='g').count()
    rb: tbl.order_by(:index=>'id').get_nearest(r.point(0,0), :index=>'g').count()
    ot:
      cd: err('ReqlQueryLogicError', 'Expected type TABLE but found TABLE_SLICE:', [0])
      py: err('AttributeError', "'OrderBy' object has no attribute 'get_nearest'")
  - js: tbl.get_nearest(r.point(0,0), {'index':'id'}).count()
    py: tbl.get_nearest(r.point(0,0), index='id').count()
    rb: tbl.get_nearest(r.point(0,0), :index=>'id').count()
    ot: err('ReqlQueryLogicError', 'get_nearest cannot use the primary index.', [0])

  - js: tbl.get_nearest(r.point(0,0), {'index':'g'}).pluck('dist', {'doc':'id'})
    py: tbl.get_nearest(r.point(0,0), index='g').pluck('dist', {'doc':'id'})
    rb: tbl.get_nearest(r.point(0,0), :index=>'g').pluck('dist', {'doc':'id'})
    ot: ([{'dist':0,'doc':{'id':1}},{'dist':0.055659745396754216,'doc':{'id':2}}])
  - js: tbl.get_nearest(r.point(-0.000001,1), {'index':'g'}).pluck('dist', {'doc':'id'})
    py: tbl.get_nearest(r.point(-0.000001,1), index='g').pluck('dist', {'doc':'id'})
    rb: tbl.get_nearest(r.point(-0.000001,1), :index=>'g').pluck('dist', {'doc':'id'})
    ot: ([{'dist':0,'doc':{'id':2}},{'dist':0.11130264976984369,'doc':{'id':1}}])
  - js: tbl.get_nearest(r.point(0,0), {'index':'g', 'max_dist':1565110}).pluck('dist', {'doc':'id'})
    py: tbl.get_nearest(r.point(0,0), index='g', max_dist=1565110).pluck('dist', {'doc':'id'})
    rb: tbl.get_nearest(r.point(0,0), :index=>'g', :max_dist=>1565110).pluck('dist', {'doc':'id'})
    ot: ([{'dist':0,'doc':{'id':1}},{'dist':0.055659745396754216,'doc':{'id':2}},{'dist':1565109.0992178896,'doc':{'id':0}}])
  - js: tbl.get_nearest(r.point(0,0), {'index':'g', 'max_dist':1565110, 'max_results':2}).pluck('dist', {'doc':'id'})
    py: tbl.get_nearest(r.point(0,0), index='g', max_dist=1565110, max_results=2).pluck('dist', {'doc':'id'})
    rb: tbl.get_nearest(r.point(0,0), :index=>'g', :max_dist=>1565110, :max_results=>2).pluck('dist', {'doc':'id'})
    ot: ([{'dist':0,'doc':{'id':1}},{'dist':0.055659745396754216,'doc':{'id':2}}])
  - js: tbl.get_nearest(r.point(0,0), {'index':'g', 'max_dist':10000000}).pluck('dist', {'doc':'id'})
    py: tbl.get_nearest(r.point(0,0), index='g', max_dist=10000000).pluck('dist', {'doc':'id'})
    rb: tbl.get_nearest(r.point(0,0), :index=>'g', :max_dist=>10000000).pluck('dist', {'doc':'id'})
    ot: err('ReqlQueryLogicError', 'The distance has become too large for continuing the indexed nearest traversal.  Consider specifying a smaller `max_dist` parameter.  (Radius must be smaller than a quarter of the circumference along the minor axis of the reference ellipsoid.  Got 10968937.995244588703m, but must be smaller than 9985163.1855612862855m.)', [0])
  - js: tbl.get_nearest(r.point(0,0), {'index':'g', 'max_dist':1566, 'unit':'km'}).pluck('dist', {'doc':'id'})
    py: tbl.get_nearest(r.point(0,0), index='g', max_dist=1566, unit='km').pluck('dist', {'doc':'id'})
    rb: tbl.get_nearest(r.point(0,0), :index=>'g', :max_dist=>1566, :unit=>'km').pluck('dist', {'doc':'id'})
    ot: ([{'dist':0,'doc':{'id':1}},{'dist':0.00005565974539675422,'doc':{'id':2}},{'dist':1565.1090992178897,'doc':{'id':0}}])
  - py: tbl.get_nearest(r.point(0,0), index='g', max_dist=1, geo_system='unit_sphere').pluck('dist', {'doc':'id'})
    rb: tbl.get_nearest(r.point(0,0), :index=>'g', :max_dist=>1, :geo_system=>'unit_sphere').pluck('dist', {'doc':'id'})
    ot: ([{'dist':0, 'doc':{'id':1}}, {'dist':8.726646259990191e-09, 'doc':{'id':2}}, {'dist':0.24619691677893205, 'doc':{'id':0}}])
  - js: tbl.get_nearest(r.point(0,0), {'index':'g'}).type_of()
    py: tbl.get_nearest(r.point(0,0), index='g').type_of()
    rb: tbl.get_nearest(r.point(0,0), :index=>'g').type_of()
    ot: ("ARRAY")
  - js: tbl.get_nearest(r.point(0,0), {'index':'g'}).map(r.row).type_of()
    py: tbl.get_nearest(r.point(0,0), index='g').map(r.row).type_of()
    rb: tbl.get_nearest(r.point(0,0), :index=>'g').map{|x|x}.type_of()
    ot: ("ARRAY")
